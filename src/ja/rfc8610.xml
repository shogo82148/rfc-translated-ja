<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" docName="draft-ietf-cbor-cddl-08" indexInclude="true" number="8610" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-cbor-cddl-08" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8610" rel="alternate"/>
  <front>
    <title>Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures</title>
    <seriesInfo name="RFC" value="8610" stream="IETF"/>
    <date year="2019" month="June"/>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">この文書では、CBOR（Concise Binary Object Representation）データ構造（RFC 7049）を表現するための表記法の提案を行っています。その主な目的は、CBORまたはJSONを使用するプロトコルメッセージおよびデータ形式の構造を簡単かつ明確に表現する方法を提供することです。</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1.1">これはインターネット標準化トラックの文書です。</t>
        <t indent="0" pn="section-boilerplate.1.2">このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の成果物です。IETFコミュニティのコンセンサスを代表しています。公開レビューを受け、インターネットエンジニアリング指導グループ（IESG）による出版承認を得ています。インターネット標準に関する詳細情報は、RFC 7841のセクション2に利用可能です。</t>
        <t indent="0" pn="section-boilerplate.1.3">Information about the current status of this document, any errata,
and how to provide feedback on it may be obtained at
https://www.rfc-editor.org/info/rfc8610.</t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">著作権（c）2019 IETF Trustと文書の著者として識別された個人。全著作権は保護されています。</t>
        <t indent="0" pn="section-boilerplate.2-2">この文書は、BCP 78およびIETF文書に関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）に従います。この文書の発行日に有効なこれらの規定については、注意深く確認してください。この文書に含まれるコードコンポーネントは、Trust Legal Provisionsのセクション4.eで説明されている通り、Simplified BSD Licenseのテキストを含まなければなりません。Simplified BSD Licenseで説明されているように、これらのコンポーネントは保証なしで提供されます。</t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">はじめに</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-notation">要件表記</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">用語</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1">
<xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-the-style-of-data-structure-specification">データ構造仕様のスタイル</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-groups-and-composition-in-cddl">CDDLにおけるグループと組成</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.1.2">
                  <li pn="section-toc.1-1.2.1.1">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1.1.1"><xref derivedContent="2.1.1" format="counter" sectionFormat="of" target="section-2.1.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-usage">使用法</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.1.2">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1.2.1"><xref derivedContent="2.1.2" format="counter" sectionFormat="of" target="section-2.1.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-syntax">構文</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-types">型</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.2">
                  <li pn="section-toc.1-1.2.2.1">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.2.1" format="counter" sectionFormat="of" target="section-2.2.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-values">値</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.2">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2.2" format="counter" sectionFormat="of" target="section-2.2.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-choices">選択肢</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.2.2">
                      <li pn="section-toc.1-1.2.2.2.1">
                        <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.2.1.1"><xref derivedContent="2.2.2.1" format="counter" sectionFormat="of" target="section-2.2.2.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-ranges">範囲</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.2.2">
                        <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.2.2.1"><xref derivedContent="2.2.2.2" format="counter" sectionFormat="of" target="section-2.2.2.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-turning-a-group-into-a-choice">グループを選択肢に変換する</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.2.2.3">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.2.3" format="counter" sectionFormat="of" target="section-2.2.3"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-representation-types">表現型</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.4.1"><xref derivedContent="2.2.4" format="counter" sectionFormat="of" target="section-2.2.4"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-root-type">ルートタイプ</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-syntax">Syntax</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-general-conventions">General Conventions</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-occurrence">Occurrence</xref></t>
              </li>
              <li pn="section-toc.1-1.3.3">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-predefined-names-for-types">Predefined Names for Types</xref></t>
              </li>
              <li pn="section-toc.1-1.3.4">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-arrays">Arrays</xref></t>
              </li>
              <li pn="section-toc.1-1.3.5">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.5.1"><xref derivedContent="3.5" format="counter" sectionFormat="of" target="section-3.5"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-maps">Maps</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.5.2">
                  <li pn="section-toc.1-1.3.5.1">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.5.1.1"><xref derivedContent="3.5.1" format="counter" sectionFormat="of" target="section-3.5.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-structs">Structs</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.5.2">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.5.2.1"><xref derivedContent="3.5.2" format="counter" sectionFormat="of" target="section-3.5.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-tables">Tables</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.5.3">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.5.3.1"><xref derivedContent="3.5.3" format="counter" sectionFormat="of" target="section-3.5.3"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-non-deterministic-order">Non-deterministic Order</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.5.4">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.5.4.1"><xref derivedContent="3.5.4" format="counter" sectionFormat="of" target="section-3.5.4"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-cuts-in-maps">Cuts in Maps</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.6">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.6.1"><xref derivedContent="3.6" format="counter" sectionFormat="of" target="section-3.6"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-tags">Tags</xref></t>
              </li>
              <li pn="section-toc.1-1.3.7">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.7.1"><xref derivedContent="3.7" format="counter" sectionFormat="of" target="section-3.7"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-unwrapping">Unwrapping</xref></t>
              </li>
              <li pn="section-toc.1-1.3.8">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.8.1"><xref derivedContent="3.8" format="counter" sectionFormat="of" target="section-3.8"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-controls">Controls</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.8.2">
                  <li pn="section-toc.1-1.3.8.1">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.8.1.1"><xref derivedContent="3.8.1" format="counter" sectionFormat="of" target="section-3.8.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-control-operator-.size">Control Operator .size</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.8.2">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.8.2.1"><xref derivedContent="3.8.2" format="counter" sectionFormat="of" target="section-3.8.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-control-operator-.bits">Control Operator .bits</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.8.3">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.8.3.1"><xref derivedContent="3.8.3" format="counter" sectionFormat="of" target="section-3.8.3"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-control-operator-.regexp">Control Operator .regexp</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.8.3.2">
                      <li pn="section-toc.1-1.3.8.3.1">
                        <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.8.3.1.1"><xref derivedContent="3.8.3.1" format="counter" sectionFormat="of" target="section-3.8.3.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-usage-considerations">Usage Considerations</xref></t>
                      </li>
                      <li pn="section-toc.1-1.3.8.3.2">
                        <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.8.3.2.1"><xref derivedContent="3.8.3.2" format="counter" sectionFormat="of" target="section-3.8.3.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-discussion">Discussion</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.3.8.4">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.8.4.1"><xref derivedContent="3.8.4" format="counter" sectionFormat="of" target="section-3.8.4"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-control-operators-.cbor-and-.cborseq">Control Operators .cbor and .cborseq</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.8.5">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.8.5.1"><xref derivedContent="3.8.5" format="counter" sectionFormat="of" target="section-3.8.5"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-control-operators-.within-and-.and">Control Operators .within and .and</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.8.6">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.8.6.1"><xref derivedContent="3.8.6" format="counter" sectionFormat="of" target="section-3.8.6"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-control-operators-.lt,-.le,-.gt,-.ge,-.eq,-.ne,-and-.default">Control Operators .lt, .le, .gt, .ge, .eq, .ne, and .default</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.9">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.9.1"><xref derivedContent="3.9" format="counter" sectionFormat="of" target="section-3.9"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-socket/plug">Socket/Plug</xref></t>
              </li>
              <li pn="section-toc.1-1.3.10">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.10.1"><xref derivedContent="3.10" format="counter" sectionFormat="of" target="section-3.10"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-generics">Generics</xref></t>
              </li>
              <li pn="section-toc.1-1.3.11">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.11.1"><xref derivedContent="3.11" format="counter" sectionFormat="of" target="section-3.11"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-operator-precedence">Operator Precedence</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-making-use-of-cddl">CDDLの活用</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.4.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-as-a-guide-for-a-human-user">人間ユーザーのためのガイドとして</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.4.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-for-automated-checking-of-cbor-data-structures">CBORデータ構造の自動チェックのための</xref></t>
              </li>
              <li pn="section-toc.1-1.4.3">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.4.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-for-data-analysis-tools">データ分析ツールのための</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <section>
              <t indent="0" keepWithNext="true" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">セキュリティの考慮事項</xref></t>
            </section>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANAの考慮事項</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.6.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-cddl-control-operators-registry">CDDL制御演算子レジストリ</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-references">参考文献</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.7.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">規範的参考文献</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.7.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">参考情報</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.A">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.A.1"><xref derivedContent="A" format="counter" sectionFormat="of" target="section-appendix.a"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-expression-grammars-(pegs)">パーシング表現文法（PEG）</xref></t>
          </li>
          <li pn="section-toc.1-1.B">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.B.1"><xref derivedContent="B" format="counter" sectionFormat="of" target="section-appendix.b"/>.&nbsp;&nbsp;
<xref derivedContent="" format="title" sectionFormat="of" target="name-abnf-grammar">ABNF文法</xref></t>
          </li>
          <li pn="section-toc.1-1.C">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.C.1"><xref derivedContent="C" format="counter" sectionFormat="of" target="section-appendix.c"/>.&nbsp;&nbsp; <xref derivedContent="" format="title" sectionFormat="of" target="name-matching-rules">一致ルール</xref></t>
          </li>
          <li pn="section-toc.1-1.D">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.D.1"><xref derivedContent="D" format="counter" sectionFormat="of" target="section-appendix.d"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-standard-prelude">標準的な前文</xref></t>
          </li>
          <li pn="section-toc.1-1.E">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.E.1"><xref derivedContent="E" format="counter" sectionFormat="of" target="section-appendix.e"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-use-with-json">JSONとの使用方法</xref></t>
          </li>
          <li pn="section-toc.1-1.F">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.F.1"><xref derivedContent="F" format="counter" sectionFormat="of" target="section-appendix.f"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-a-cddl-tool">A CDDL Tool</xref></t>
          </li>
          <li pn="section-toc.1-1.G">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.G.1"><xref derivedContent="G" format="counter" sectionFormat="of" target="section-appendix.g"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-extended-diagnostic-notation">Extended Diagnostic Notation</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.G.2">
              <li pn="section-toc.1-1.G.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.G.1.1"><xref derivedContent="G.1" format="counter" sectionFormat="of" target="section-g.1"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-whitespace-in-byte-string-notation">Whitespace in Byte String Notation</xref></t>
              </li>
              <li pn="section-toc.1-1.G.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.G.2.1"><xref derivedContent="G.2" format="counter" sectionFormat="of" target="section-g.2"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-text-in-byte-string-notation">Text in Byte String Notation</xref></t>
              </li>
              <li pn="section-toc.1-1.G.3">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.G.3.1"><xref derivedContent="G.3" format="counter" sectionFormat="of" target="section-g.3"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-embedded-cbor-and-cbor-sequences-in-byte-strings">Embedded CBOR and CBOR Sequences in Byte Strings</xref></t>
              </li>
              <li pn="section-toc.1-1.G.4">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.G.4.1"><xref derivedContent="G.4" format="counter" sectionFormat="of" target="section-g.4"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-concatenated-strings">Concatenated Strings</xref></t>
              </li>
              <li pn="section-toc.1-1.G.5">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.G.5.1"><xref derivedContent="G.5" format="counter" sectionFormat="of" target="section-g.5"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-hexadecimal,-octal,-and-binary-numbers">Hexadecimal, Octal, and Binary Numbers</xref></t>
              </li>
              <li pn="section-toc.1-1.G.6">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.G.6.1"><xref derivedContent="G.6" format="counter" sectionFormat="of" target="section-g.6"/>.&nbsp;&nbsp;<xref derivedContent="" format="title" sectionFormat="of" target="name-comments">Comments</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.H">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.H.1"><xref derivedContent="H" format="counter" sectionFormat="of" target="section-appendix.h"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-examples">例</xref></t>
          </li>
          <li pn="section-toc.1-1.i">
            <bcp14>しなければなりません（MUST）</bcp14>、<bcp14>しなければいけません（MUST NOT）</bcp14>、<bcp14>要求されています（REQUIRED）</bcp14>、<bcp14>することになります（SHALL）</bcp14>、<bcp14>することはありません（SHALL NOT）</bcp14>、<bcp14>すべきです（SHOULD）</bcp14>、<bcp14>すべきではありません（SHOULD NOT）</bcp14>、<bcp14>推奨されます（RECOMMENDED）</bcp14>、<bcp14>推奨されません（NOT RECOMMENDED）</bcp14>、<bcp14>してもよいです（MAY）</bcp14>、そして<bcp14>選択できます（OPTIONAL）</bcp14>。

 <t indent="0" pn="section-toc.1-1.i.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.i"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">謝辞</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">このドキュメントでは、Concise Binary Object Representation (CBOR)データ構造を表現するための表記法が定義されています。</t>
      <t indent="0" pn="section-1-2">コンベンションの主な目標は、CBORを使用するプロトコルの定義時に使用できる統一された表記法を提供することです。私たちはこの規約を「Concise Data Definition Language（CDDL）」と呼んでいます。</t>
      <t indent="0" pn="section-1-3">CBORの表記規約には、以下の目標があります：<bcp14>しなければなりません（MUST）</bcp14>、<bcp14>することになります（SHALL）</bcp14>、<bcp14>推奨されます（RECOMMENDED）</bcp14>：</t>
      <t indent="0" pn="section-1-4">(G1)  Provide an unambiguous description of the overall structure of
      a CBOR data item.</t>
      <t indent="0" pn="section-1-5">（G2）CBORデータ形式でデータが表現される複数の方法を柔軟に表現すること。</t>
      <t indent="0" pn="section-1-6">(G3)  Be able to express common CBOR datatypes and structures.</t>
      <t indent="0" pn="section-1-7">(G4) 人間が読み書き可能であり、機械も処理可能な単一の形式を提供します。</t>
      <t indent="0" pn="section-1-8">（G5）CBORデータ項目のデータ形式の適合性を自動的にチェックするようにします。</t>
      <t indent="0" pn="section-1-9">（G6）CBORデータから特定の要素を抽出してさらなる処理を可能にする。</t>
      <t indent="0" pn="section-1-10">Rough translation:

JSON汎用データモデルがCBOR汎用データモデルのサブセットであるという便利な副次的効果から生じるものではありませんが、CDDLはJSONデータ構造を記述するためにも使用できます（詳細は付録Eを参照してください）。</t>
      <t indent="0" pn="section-1-11">このドキュメントは以下の構造を持っています：</t>
      <t indent="0" pn="section-1-12">CDDLの構文は、セクション3で定義されています。CDDLの例や関連するCBORデータ項目（「インスタンス」と呼ばれるもの）のいくつかは、JSON形式を使用して説明されており、それについては付録Hで説明されています。セクション4では、CDDLの使用方法について説明しています。コンセプトの定義をより具体的に説明するために、テキスト全体にわたって例が提供されています。ABNF文法<xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>を使用したCDDLの形式的な定義は、付録Bで提供されています。最後に、すべてのCDDL仕様で自動的に先行するため、またそのために利用可能な、標準CDDL定義のプレリュードが付録Dにリストされています。</t>
      <section anchor="requirements-notation" numbered="true" removeInRFC="false" toc="include" pn="section-1.1">
        <name slugifiedName="name-requirements-notation">Requirements Notation</name>
        <t indent="0" pn="section-1.1-1">XMLテキストでは、「<bcp14>しなければなりません（MUST）</bcp14>」、「<bcp14>してはなりません（MUST NOT）</bcp14>」、「<bcp14>要求されています（REQUIRED）</bcp14>」、「<bcp14>することになります（SHALL）</bcp14>」、「<bcp14>することはありません（SHALL NOT）</bcp14>」、「<bcp14>すべきです（SHOULD）</bcp14>」、「<bcp14>すべきではありません（SHOULD NOT）</bcp14>」、「<bcp14>推奨されます（RECOMMENDED）</bcp14>」、「<bcp14>推奨されません（NOT RECOMMENDED）</bcp14>」、「<bcp14>してもよいです（MAY）</bcp14>」、「<bcp14>選択できます（OPTIONAL）</bcp14>」のキーワードは、この文書では大文字で表示される場合に限り、BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/>に記載されているように解釈されるものとします。</t>
      </section>
      <section anchor="terminology" numbered="true" removeInRFC="false" toc="include" pn="section-1.2">
        <name slugifiedName="name-terminology">Terminology</name>
        <t indent="0" pn="section-1.2-1">新しい用語は _斜体_ で導入され、通常のテキストでは新しい用語をアンダースコアで囲んで表示します。逐次実行テキスト内のCDDLテキストは ''タイプライター'' であり、通常のテキストではCDDLテキストを二重引用符で囲んで表示します（二重引用符は通常の英語の意味でも使用されますが、読者は文脈によってこれを曖昧にすることが期待されています）。</t>
        <t indent="0" pn="section-1.2-2">この仕様書では、「バイト」という用語は、その今日の通例的な意味である「オクテット」という同義語として使用されています。</t>
      </section>
    </section>
    <section anchor="the-style-of-data-structure-specification" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-the-style-of-data-structure-specification">The Style of Data Structure Specification</name>
      <t indent="0" pn="section-2-1">CDDLは、JSONで先駆けられ、CBORで現在改良されているデータモデルを使用するコミュニティで使用されている仕様のスタイルに焦点を当てています。</t>
      <t indent="0" pn="section-2-2">CBORデータモデルには、数値、単純値（false、true、nil）、テキスト文字列、バイト文字列など、いくつかのよりまたは少ない原子要素があります。CDDLは、これらの構造を指定することには焦点を当てていません。もちろん、CDDLはデータアイテムにCBORタグを追加することも許可しています。</t>
      <t indent="0" pn="section-2-3">これらの原子要素に加えて、データ構造定義言語のさらなる要素として、組み立てに使用されるデータ型があります。CBORでは、配列とマップ（JSONでは「配列」と「オブジェクト」と呼ばれる）が使用されます。これらは、表現形式は2つだけですが、4つの異なるスタイルの組み立てを指定するために使用されます。</t>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2-4">
        <li pn="section-2-4.1">ベクター：ほとんど同じ意味を持つ要素の配列。署名付きデータアイテムに関連する署名のセットは、ベクターの典型的な応用例です。</li>
      </ul>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2-5">
        <li pn="section-2-5.1">
          <bcp14>レコード</bcp14>: データ構造定義に詳細に記載されているように、要素が異なる位置で定義された意味を持つ配列。x座標（最初に来る）とy座標（2番目に来る）の配列として指定された2Dポイントは、レコードの例です。また、CBOR10進数の指数（最初）と仮数（次）のペアもレコードです。</li>
      </ul>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2-6">
        <li pn="section-2-6.1">
          <bcp14>テーブル</bcp14>: ほぼ同じ意味を持つマップキーのドメインからマップ値のドメインへのマップ。特定の言語に翻訳されたテキスト文字列にマップされた言語タグのセットは、テーブルの例です。キードメインは通常、仕様によって特定のセットに制限されることはありませんが、アプリケーションにオープンです。例えば、IPアドレスをメディアアクセス制御（MAC）アドレスにマッピングするテーブルでは、仕様ではすべての可能なIPアドレスを予測しようとしません。JavaScriptのような言語では、キードメインの一般性を達成するために、通常「オブジェクト」ではなく「マップ」が使用されることがあります。</li>
      </ul>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2-7">
        <li pn="section-2-7.1">_struct_: 仕様で定義されたマップキーのドメインから、特定のマップキーにバインドされた各マップ値のドメインへのマップです。これは、多くの人がJSONオブジェクトについて考えるときに想定しているものです。CBORは、単なるテキスト文字列でないマップキーの使用を可能にします。structは、レコードの使用と類似した問題を解決するために使用することができます。明示的なマップキーの使用は、オプション性と拡張性を容易にします。</li>
      </ul>
      <t indent="0" pn="section-2-8">CDDLの基礎となる2つの重要な概念があります。</t>
      <t indent="0" pn="section-2-9">1. CDDLでは、個別にすべての４つの組み合わせタイプを定義するのではなく、または配列の種類（ベクトルとレコード）とマップの種類（テーブルと構造体）を定義するのでもなく、CDDLには組み合わせの一種類「_group_（セクション2.1）」のみが存在します。</t>
      <t indent="0" pn="section-2-10">2. もう一つの重要な概念は「タイプ」です。CDDLの仕様全体は、この仕様の「インスタンス」として受け入れ可能なCBORデータアイテムのセット（最初の「ルール」によって定義されるもの）を形式的に定義します。CDDLは、「uint」（符号なし整数）や「tstr」（テキスト文字列）などのいくつかの基本的なタイプを事前に定義しており、しばしばCBORデータアイテムのための単純な形式的記法を使用します。CBORデータアイテムとして表現できる各値はそれ自体でもタイプであり、「1」などです。タイプは他のタイプの「選択」として構築することもできます。例えば、「int」は「uint」と「nint」（負の整数）のどちらかであることがあります。最後に、タイプはグループからの配列やマップとして構築することもできます。</t>
      <t indent="0" pn="section-2-11">このセクションの残りでは、CDDLのいくつかの基本的な概念について説明し、セクション3では追加の文法を定義しています。付録Cでは、CDDLの意味論の簡潔なまとめが提供されています。</t>
      <section anchor="groups-and-composition-in-cddl" numbered="true" removeInRFC="false" toc="include" pn="section-2.1">
        <name slugifiedName="name-groups-and-composition-in-cddl">Groups and Composition in CDDL</name>
        <t indent="0" pn="section-2.1-1">CDDLグループは、<bcp14>グループエントリ</bcp14>のリストであり、それぞれが名前/値のペアまたはより複雑なグループ式（その場合は名前/値のペアのシーケンスを表す）であることができます。 CDDLグループは、特定の名前/値のペアのシーケンスに一致するが、他のシーケンスには一致しない文法内のプロダクションです。この文法は、Parsing Expression Grammars（PEGs）の概念に基づいています（詳細は付録Aを参照）。</t>
        <t indent="0" pn="section-2.1-2">配列コンテキストでは、名前/値のペアの値のみが表されます。名前は注釈のみです（必要な場合はグループ仕様から省略することもできます）。マップコンテキストでは、名前がマップキー（"メンバーキー"）になります。</t>
        <t indent="0" pn="section-2.1-3">配列のコンテキストでは、グループ内の要素の実際のシーケンスが重要です。なぜなら、そのシーケンスが実際の配列要素をグループのエントリと関連付けるための情報であるからです。マップのコンテキストでは、グループ内のエントリのシーケンスは関係ありません（しかし、グループのエントリをシーケンスで記述する必要が依然としてあります）。</t>
        <t indent="0" pn="section-2.1-4">配列は、グループとして与えられた仕様に一致する場合、そのグループは、値部分が配列の要素と完全に一致する名前/値のペアのシーケンスと一致します。</t>
        <t indent="0" pn="section-2.1-5">マップは、グループとして指定された仕様と一致する場合、グループがマップ内に存在するすべての名前/値のペアと一致するシーケンスであるときに一致します。また、マップにはグループでカバーされていない名前/値のペアが存在しないことが必要です。</t>
        <t indent="0" pn="section-2.1-6">グループをマップ定義で直接使用する簡単な例は次のとおりです：</t>
        <t indent="0" pn="section-2.1-7"><artwork name="" type="" align="left" alt="">
                          person = {
                            age: int,
                            name: tstr,
                            employer: tstr,
                          }
</artwork>
          <artwork name="" type="" align="left" alt="">
                          person = {
                            age: int,
                            name: tstr,
                            employer: tstr,
                          }
</artwork>
        </t>
        <t indent="0" pn="section-2.1-8"><figure anchor="fig-1" align="left" suppress-title="false" pn="figure-1">
            <name slugifiedName="name-figure-1">Using a Group Directly in a Map</name>
            <artwork name="" type="" align="left" alt="">

</artwork>
          </figure>
        </t>
        <t indent="0" pn="section-2.1-9">グループの3つのエントリは、マップを生成する波括弧の間に書かれます。ここでは、「age」、「name」、「employer」は、マップのキーテキスト文字列になる名前です。また、「int」と「tstr」（テキストストリング）は、これらのキーの下にあるマップの値の型です。</t>
        <t indent="0" pn="section-2.1-10">グループ自体（その周りにマップを作らずに）は、（丸括弧の中に）置かれ、ルールで使用することで名前を付けることができます。</t>
        <t indent="0" pn="section-2.1-11"><artwork name="" type="" align="left" alt="">
                          pii = (
                            age: int,
                            name: tstr,
                            employer: tstr,
                          )
</artwork>
          <絵 name="" type="" align="left" alt="">
                          pii = (
                            age: int,
                            name: tstr,
                            employer: tstr,
                          )
</絵>
        </t>
        <t indent="0" pn="section-2.1-12"><figure anchor="fig-2" align="left" suppress-title="false" pn="figure-2">
            <name slugifiedName="name-figure-2">A Basic Group</name>
            <artwork name="" type="" align="left" alt="">

</artwork>
          </figure>
        </t>
        <t indent="0" pn="section-2.1-13">この個別で名前付きのグループ定義により、図1を以下のように言い換えることができます。</t>
        <t indent="0" pn="section-2.1-14"><artwork name="" type="" align="left" alt="">
                             person = {
                               pii
                             }
</artwork>
        </t>
        <t indent="0" pn="section-2.1-15"><figure anchor="fig-3" align="left" suppress-title="false" pn="figure-3">
            <name slugifiedName="name-figure-3">名前でグループ化する</name>
            <artwork name="" type="" align="left" alt="">

</artwork>
          </figure>
        </t>
        <t indent="0" pn="section-2.1-16">（波かっこ）はマップの作成を示します。グループ自体は、マップまたは配列で使用されるかどうかに関して中立です。</t>
        <t indent="0" pn="section-2.1-17">図1に示されているように、グループの括弧は、他のセットのかっこが存在する場合はオプションです。ただし、それらは引き続き使用することができるため、次の非現実的ですが完全に有効な例につながります。</t>
        <t indent="0" pn="section-2.1-18"><artwork name="" type="" align="left" alt="">
                          person = {(
                            age: int,
                            name: tstr,
                            employer: tstr,
                          )}
</artwork>
          <artwork name="" type="" align="left" alt="">
                          person = {(
                            年齢: int,
                            名前: tstr,
                            雇用主: tstr,
                          )}
</artwork>
        </t>
        <t indent="0" pn="section-2.1-19"><figure anchor="fig-4" align="left" suppress-title="false" pn="figure-4">
            <name slugifiedName="name-figure-4">括弧グループを使用したマップ</name>
            <artwork name="" type="" align="left" alt="">

</artwork>
          </figure>
        </t>
        <t indent="0" pn="section-2.1-20">グループは、構造体の共通部分を分離するために使用できます。例えば、図5のようなコピー＆ペーストスタイルで仕様を記述する代わりに、共通のサブグループを分離し、それに名前を付けて個々のマップには特定の部分だけを記述することができます（図6参照）。</t>
        <t indent="0" pn="section-2.1-21"><artwork name="" type="" align="left" alt="">
                       person = {
                         age: <tstr>整数</tstr>,
                         name: <tstr>文字列</tstr>,
                         employer: <tstr>文字列</tstr>,
                       }
</artwork>
        </t>
        <t indent="0" pn="section-2.1-22"><artwork name="" type="" align="left" alt="">
                        dog = {
                          age: int,
                          name: tstr,
                          leash-length: float,
                        }
</artwork>
          <artwork name="" type="" align="left" alt="">
                        dog = {
                          年齢: int,
                          名前: tstr,
                          リーシュの長さ: float,
                        }
</artwork>
        </t>
        <t indent="0" pn="section-2.1-23"><figure anchor="fig-5" align="left" suppress-title="false" pn="figure-5">
            <name slugifiedName="name-figure-5"><bcp14>コピー/ペーストによる地図</bcp14></name>
            <artwork name="" type="" align="left" alt="">

</artwork>
          </figure>
        </t>
        <t indent="0" pn="section-2.1-24"><artwork name="" type="" align="left" alt="">
                       person = {
                         identity,
                         employer: tstr,
                       }
</artwork>
          <artwork name="" type="" align="left" alt="">
                       person = {
                         identity,
                         employer: tstr,
                       }
</artwork>
        </t>
        <t indent="0" pn="section-2.1-25"><artwork name="" type="" align="left" alt="">
                       犬 = {
                         identity,
                         首輪の長さ: float,
                       }
</artwork>
        </t>
        <t indent="0" pn="section-2.1-26"><artwork name="" type="" align="left" alt="">
                       identity = (
                         age: int,
                         name: tstr,
                       )
</artwork>
        </t>
        <t indent="0" pn="section-2.1-27"><figure anchor="fig-6" align="left" suppress-title="false" pn="figure-6">
            <name slugifiedName="name-figure-6">要因分解のためのグループの使用方法</name>
            <artwork name="" type="" align="left" alt="">

</artwork>
          </figure>
        </t>
        <t indent="0" pn="section-2.1-28">上記の定義内の中括弧内のリストは（匿名の）グループを構成しますが、「identity」は名前付きのグループであり、その後他のグループの一部として含めることができます（前述の例のように匿名であるか、それ自体が名前付きであるか）。</t>
        <section anchor="usage" numbered="true" removeInRFC="false" toc="include" pn="section-2.1.1">
          <name slugifiedName="name-usage">Usage</name>
          <t indent="0" pn="section-2.1.1-1">グループはCDDLを使用してデータ構造を構築するための仕組みです。これらの構造を定義する際に、そのコンテキスト内でグループを（匿名で）直接定義するか、それらを別のルールで定義し、関連する名前で参照するか（複数回行う場合もあるかもしれません）はスタイルの問題です。</t>
          <t indent="0" pn="section-2.1.1-2">これにより、データ構造のすべての小さな部分を定義し、それらを組み合わせて大きなプロトコルデータユニットを作成したり、必要な場所で定義を完全に行った1つの大きなプロトコルデータユニットだけを持つことが許可されます。</t>
        </section>
        <section anchor="syntax" numbered="true" removeInRFC="false" toc="include" pn="section-2.1.2">
          <name slugifiedName="name-syntax">Syntax</name>
          <t indent="0" pn="section-2.1.2-1">構成文法は簡潔で読みやすいことを意図されています。</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2.1.2-2">
            <li pn="section-2.1.2-2.1">グループの始まりと終わりは"("と")"でマークされることができます。</li>
          </ul>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2.1.2-3">
            <li pn="section-2.1.2-3.1">グループ内のエントリの定義は、次のように記述されます：_keytype =&gt; valuetype,_ （この場合、「keytypeはvaluetypeにマップされる」と読みます）。コンマは実際にはオプションです（最後のエントリの場合だけでなく）、しかし設定することが好ましいスタイルとされています。直接テキスト文字列や整数リテラルをキーとして使用する場合、ダブルアローをコロンで置き換えることもできます。詳細は3.5.1節を参照してください。これは、配列の要素をドキュメント化するための一般的な方法でもあります。3.4節を参照してください。</li>
          </ul>
          <t indent="0" pn="section-2.1.2-4">基本エントリは_keytype_と_valuetype_の両方のタイプで構成されています（セクション2.2）。このエントリは、名前がkeytypeに含まれ、値がvaluetypeに含まれる名前/値のペアに一致します。</t>
          <t indent="0" pn="section-2.1.2-5"><bcp14>MUST</bcp14>: <bcp14>しなければなりません（MUST）</bcp14>
            <bcp14>MUST NOT</bcp14>: <bcp14>してはなりません（MUST NOT）</bcp14>
            <bcp14>REQUIRED</bcp14>: <bcp14>要求されています（REQUIRED）</bcp14>
            <bcp14>SHALL</bcp14>: <bcp14>することになります（SHALL）</bcp14>
            <bcp14>SHALL NOT</bcp14>: <bcp14>することはありません（SHALL NOT）</bcp14>
            <bcp14>SHOULD</bcp14>: <bcp14>すべきです（SHOULD）</bcp14>
            <bcp14>SHOULD NOT</bcp14>: <bcp14>すべきではありません（SHOULD NOT）</bcp14>
            <bcp14>RECOMMENDED</bcp14>: <bcp14>推奨されます（RECOMMENDED）</bcp14>
            <bcp14>NOT RECOMMENDED</bcp14>: <bcp14>推奨されません（NOT RECOMMENDED）</bcp14>
            <bcp14>MAY</bcp14>: <bcp14>してもよいです（MAY）</bcp14>
            <bcp14>OPTIONAL</bcp14>: <bcp14>選択できます（OPTIONAL）</bcp14>

The given English text translated to Japanese:
グループとは、グループエントリのシーケンスとして定義され、エントリが一致する順序に従って連結された名前/値のシーケンスに一致します。</t>
          <t indent="0" pn="section-2.1.2-6">グループ定義には、グループ間の選択肢も含めることもできます。セクション2.2.2を参照してください。</t>
        </section>
      </section>
      <section anchor="types" numbered="true" removeInRFC="false" toc="include" pn="section-2.2">
        <name slugifiedName="name-types">Types</name>
        <section anchor="values" numbered="true" removeInRFC="false" toc="include" pn="section-2.2.1">
          <name slugifiedName="name-values">Values</name>
          <t indent="0" pn="section-2.2.1-1">値、例えば数値や文字列などは、型の代わりに使用することができます。（たとえば、キーの型に関しては、これが非常に一般的なことであり、CDDLはこれに関して追加の便利な構文を提供しています。）</t>
          <t indent="0" pn="section-2.2.1-2">値の表記法はC言語に基づいていますが、すべての構文的なバリエーションを提供していません（詳細については付録Bを参照してください）。値の表記方法には、整数値（小数部や指数がない- NR1 <xref target="ISO6093" format="default" sectionFormat="of" derivedContent="ISO6093"/>。"NR"は"numerical representation"の略です）と浮動小数点値（小数部、指数、またはその両方が存在する- NR2またはNR3）の区別があります。したがって、タイプ"1"には浮動小数点数は含まれませんが、タイプ"1e3"と"1.5"は浮動小数点数であり、整数数を含みません。</t>
        </section>
        <section anchor="choices" numbered="true" removeInRFC="false" toc="include" pn="section-2.2.2">
          <name slugifiedName="name-choices">Choices</name>
          <t indent="0" pn="section-2.2.2-1">多くの場所では、タイプを許可すると同時に、タイプ間の選択が可能であり、"/"（スラッシュ）で区切られています。選択構造全体は、構造を明確にするために必要な場合は括弧で囲むことができます（CDDL文法の詳細については付録Bを参照してください）。</t>
          <t indent="0" pn="section-2.2.2-2">値の選択肢を使用して列挙を表現することができます。</t>
          <t indent="0" pn="section-2.2.2-3"><artwork name="" type="" align="left" alt="">
         attire = "ボウタイ" / "ネクタイ" / "インターネットの服装"
         protocol = 6 / 17
</artwork>
          </t>
          <t indent="0" pn="section-2.2.2-4">タイプに対応するように、CDDLはグループ間の選択も許可しており、グループは"//"（二重スラッシュ）で区切られます。なお、"//"演算子は他のCDDLの演算子よりも弱くバインドされるため、以下の例で「delivery」内の各行は、グループ選択の個々の代替となります。</t>
          <t indent="0" pn="section-2.2.2-5"><artworks name="" type="" align="left" alt="">
    address = { delivery }
</artworks>
            <artworks name="" type="" align="left" alt="">
    アドレス = { 配送 }
</artworks>
          </t>
          <t indent="0" pn="section-2.2.2-6"><artwork name="" type="" align="left" alt="">
                delivery = (
                street: tstr, ? number: uint, city //
                po-box: uint, city //
                per-pickup: true )
</artwork>
          </t>
          <t indent="0" pn="section-2.2.2-7"><artwork name="" type="" align="left" alt="">
                city = (
                name: <bcp14>tstr</bcp14>, zip-code: <bcp14>uint</bcp14>
                )
</artwork>
            <artwork name="" type="" align="left" alt="">
                city = (
                name: <bcp14>tstr</bcp14>, zip-code: <bcp14>uint</bcp14>
                )
</artwork> 

Translated to Japanese:

<artwork name="" type="" align="left" alt="">
                city = (
                name: <bcp14>文字列（tstr）</bcp14>、zipコード: <bcp14>符号なし整数（uint）</bcp14>
                )
</artwork>
          </t>
          <t indent="0" pn="section-2.2.2-8">グループ選択は、選択の中の選択肢ができる名前/値ペアのシーケンスの集合の和集合に一致する。</t>
          <t indent="0" pn="section-2.2.2-9">両方のタイプの選択肢とグループの選択肢について、追加の選択肢は、"="の代わりに"/="（タイプの選択肢）および"//="（グループの選択肢）を使用して、後で別のルールに追加することができます。</t>
          <t indent="0" pn="section-2.2.2-10"><artwork name="" type="" align="left" alt="">
              <xi:bcp14>「水着」以外の衣服</xi:bcp14>
            </artwork>
          </t>
          <t indent="0" pn="section-2.2.2-11"><artwork name="" type="" align="left" alt="">
              delivery //= (
              lat: float, long: float, drone-type: tstr
              )
</artwork>
            <artwork name="" type="" align="left" alt="">
              配達 //= (
              lat: float, long: float, drone-type: tstr
              )
</artwork>
          </t>
          <t indent="0" pn="section-2.2.2-12">名前が最初に"/="または"//="と共に使用された場合、それを"="で「作成する」必要はありません。</t>
          <section anchor="ranges" numbered="true" removeInRFC="false" toc="include" pn="section-2.2.2.1">
            <name slugifiedName="name-ranges">Ranges</name>
            <t indent="0" pn="section-2.2.2.1-1">選択肢を構成するすべての値を列挙する代わりに、CDDLでは順序関係にある2つの値からなる「範囲（range）」を構築することができます。範囲は、両方の境界を含む場合（2つの値を「..」で結合することで表示されます）、または下限を含み上限を除外する場合（代わりに「...」を使用することで表示されます）があります。下限が上限を超える場合、結果的な型は空の集合になります（この動作は、ジェネリック（セクション3.10）を使用している場合に望ましい場合があります）。</t>
            <t indent="0" pn="section-2.2.2.1-2"><artwork name="" type="" align="left" alt="">
      <bcp14>MUST</bcp14>のdevice-address = byte
      <bcp14>MUST</bcp14>のmax-byte = 255
      <bcp14>MUST</bcp14>のbyte = 0..max-byte ; inclusiveな範囲
      <bcp14>MUST</bcp14>ではないfirst-non-byte = 256
      <bcp14>MUST</bcp14>のbyte1 = 0...first-non-byte ; byte1はbyteと同等
</artwork>
            </t>
            <t indent="0" pn="section-2.2.2.1-3">CDDLは現在、整数間の範囲（整数値に一致する）または浮動小数点値間の範囲（浮動小数点値に一致する）のみを許可しています。もしタイプ内で両方が必要な場合、二種類の範囲の間でタイプの選択を（不器用にも）使用することができます。</t>
            <t indent="0" pn="section-2.2.2.1-4"><artwork name="" type="" align="left" alt="">
             int-range = 0..10 ; ただし整数にマッチ
             float-range = 0.0..10.0 ; ただし浮動小数点数にマッチ
             BAD-range1 = 0..10.0 ; 未定義
             BAD-range2 = 0.0..10 ; 未定義
             numeric-range = int-range / float-range
</artwork>
            </t>
            <t indent="0" pn="section-2.2.2.1-5">(See also the control operators .lt/.ge and .le/.gt in
Section 3.8.6.)
Note that the dot is a valid name continuation character in CDDL, so</t>
            <t indent="0" pn="section-2.2.2.1-6"><artwork name="" type="" align="left" alt="">
   最小..最大
</artwork>
            </t>
            <t indent="0" pn="section-2.2.2.1-7">範囲式ではなく、単一の名前です。範囲演算子の左辺として名前を使用する場合は、以下のようにスペースを使用してください。</t>
            <t indent="0" pn="section-2.2.2.1-8"><artwork name="" type="" align="left" alt="">
   最小 .. 最大
</artwork>
            </t>
            <t indent="0" pn="section-2.2.2.1-9">範囲演算子を分割します。</t>
          </section>
          <section anchor="turning-a-group-into-a-choice" numbered="true" removeInRFC="false" toc="include" pn="section-2.2.2.2">
            <name slugifiedName="name-turning-a-group-into-a-choice">Turning a Group into a Choice</name>
            <t indent="0" pn="section-2.2.2.2-1">Some choices are built out of large numbers of values, often
integers, each of which is best given a semantic name in the
specification.  Instead of naming each of these integers and then
accumulating them into a choice, CDDL allows building a choice from a
group by prefixing it with an "&amp;" character:</t>
            <t indent="0" pn="section-2.2.2.2-2"><artwork name="" type="" align="left" alt="">
           terminal-color = &amp;basecolors
           basecolors = (
             black: 0,  red: 1,  green: 2,  yellow: 3,
             blue: 4,  magenta: 5,  cyan: 6,  white: 7,
           )
           extended-color = &amp;(
             basecolors,
             orange: 8,  pink: 9,  purple: 10,  brown: 11,
           )
</artwork>
              <artwork name="" type="" align="left" alt="">
           terminal-color = &amp;basecolors
           basecolors = (
             black: 0,  red: 1,  green: 2,  yellow: 3,
             blue: 4,  magenta: 5,  cyan: 6,  white: 7,
           )
           extended-color = &amp;(
             basecolors,
             orange: 8,  pink: 9,  purple: 10,  brown: 11,
           )
</artwork>
            </t>
            <t indent="0" pn="section-2.2.2.2-3">配列内でのグループの使用についても（セクション3.4）、メンバー名はただの文書的な値です（特に、その選択肢から取られた整数を表示するツールで使用される可能性があります）。</t>
          </section>
        </section>
        <section anchor="representation-types" numbered="true" removeInRFC="false" toc="include" pn="section-2.2.3">
          <name slugifiedName="name-representation-types">Representation Types</name>
          <t indent="0" pn="section-2.2.3-1">CDDLでは、データ項目のタイプをCBOR表現（具体的には主要なタイプと追加情報を参照すること）によって指定することができます（詳細は<xref target="RFC7049" section="2" format="default" sectionFormat="of" derivedLink="https://www.rfc-editor.org/rfc/rfc7049#section-2" derivedContent="RFC7049"/>を参照）。これがどのように使用されるかについては、序文（付録D）から明らかになるはずです：ハッシュマーク（"#"）の後に、主なタイプを識別する0から7の番号（オプション）が続き、その後にドットと追加情報を指定する番号が続きます。この構造は、与えられた主なタイプがあれば、または与えられた主なタイプと追加情報があれば、CBORに直列化できる値のセットを指定します（つまり、「任意の値」）。主なタイプが6（タグ）の場合、タグ付けされたアイテムのタイプは、括弧内に追加で指定できます。</t>
          <t indent="0" pn="section-2.2.3-2">CBORシリアライズに基づくこの表記法は、データモデルレベルの値の集合について言及しています。例えば、"#7.25"は半精度浮動小数点数として表現できる値の集合を指定していますが、これらの値が半精度浮動小数点数としてシリアライズされる必要があるわけではありません。CDDLは、シリアライズのバリアントの選択を制約するための言語手段を提供していません。これにより、CDDLはJSONとも組み合わせて使用することができます。JSONは同じ値を（一部）異なる方法でシリアライズする基本的に異なる方法を使用しています。</t>
          <t indent="0" pn="section-2.2.3-3">事前文書以外の表現タイプを利用する必要がある場合があります。例えば、仕様書は、既存のタグをより具体的な方法で使用したり、事前文書で定義されていない新しいタグを定義したりすることがあります。</t>
          <t indent="0" pn="section-2.2.3-4"><artwork name="" type="" align="left" alt="">
   my_breakfast = #6.55799(breakfast)   ; cbor-any is too general!
   breakfast = cereal / porridge
   cereal = #6.998(tstr)
   porridge = #6.999([liquid, solid])
   liquid = milk / water
   milk = 0
   water = 1
   solid = tstr
</artwork>
          </t>
        </section>
        <section anchor="root-type" numbered="true" removeInRFC="false" toc="include" pn="section-2.2.4">
          <name slugifiedName="name-root-type">Root Type</name>
          <t indent="0" pn="section-2.2.4-1">特定の構文を使用してCDDLデータ構造の定義のルートを識別する特別な方法はありません。「ルート」という役割は単純にファイルで最初に定義されたルールが担当します。</t>
          <t indent="0" pn="section-2.2.4-2">This is motivated by the usual top-down approach for defining data
structures, decomposing a big data structure unit into smaller parts;
however, except for the root type, there is no need to strictly
follow this sequence.</t>
          <t indent="0" pn="section-2.2.4-3">（グループをルートとして使用する方法はないことに注意してください - タイプである必要があります。）</t>
        </section>
      </section>
    </section>
    <section anchor="syntax" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-syntax">Syntax</name>
      <t indent="0" pn="section-3-1">このセクションでは、CDDLの全体的な構文が示され、構文を説明するいくつかの例も示されます。（この定義は過度に正式を目指すものではありません。詳細については、付録Bを参照してください。）</t>
      <section anchor="general-conventions" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-general-conventions">General Conventions</name>
        <t indent="0" pn="section-3.1-1">基本の構文はABNFに触発されており、以下のものを持っています：<xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>という規則による。</t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.1-2">
          <li pn="section-3.1-2.1">ルールは、グループまたはタイプを定義するかどうかに関係なく、名前で定義され、イコール記号「=」とその定義に対する実際の定義が続きます。定義は、それに対応する構文規則に従って行われます。</li>
        </ul>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.1-3">
          <li pn="section-3.1-3.1">名前は、アルファベット文字（"@", "_", "$"を含む）で始まり、アルファベット文字または数字で終わることができます。使用可能な文字は、セット{"A"から"Z"、"a"から"z"、"0"から"9"、"_", "-", "@", ".", "$"}です。</li>
        </ul>
        <t indent="0" pn="section-3.1-4"><artwork name="" type="" align="left" alt="">
   *  Names are case sensitive.
</artwork>
        </t>
        <t indent="0" pn="section-3.1-5"><artwork name="" type="" align="left" alt="">
   *  名前は小文字で始めることが推奨されます。
</artwork>
        </t>
        <t indent="0" pn="section-3.1-6"><artwork name="" type="" align="left" alt="">
  - アンダースコアよりハイフンが好まれます（ただし、「基本語」（セクション3.5.1）では、意味によっては実際にアンダースコアが必要になる場合もあります）。
</artwork>
        </t>
        <t indent="0" pn="section-3.1-7"><artwork name="" type="" align="left" alt="">
*  期間は、より大規模な仕様において、モジュールの構造（例：「tcp.throughput」と「udp.throughput」）を表現するために使用できます。
</artwork>
        </t>
        <t indent="0" pn="section-3.1-8"><artwork name="" type="" align="left" alt="">
   *  数多くの名前がCDDLプレリュードで予め定義されており、
      Appendix Dにリストされています。
</artwork>
        </t>
        <t indent="0" pn="section-3.1-9"><artwork name="" type="" align="left" alt="">
   *  ルールの名称（タイプまたはグループ）は、実際のCBORエンコーディングには表示されませんが、メンバーキーとして使用される「裸の単語」には表示されます。
</artwork>
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.1-10">
          <li pn="section-3.1-10.1">コメントは";"（セミコロン）文字で始まり、行の最後（LFまたはCRLF）で終了します。</li>
        </ul>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.1-11">
          <li pn="section-3.1-11.1">文字列以外では、可読性のため（および互いに続く識別子、範囲演算子、または数値を区別するため）、空白（スペース、改行、コメント）は構文要素を区切るために使用されます。その他の場合、空白は完全にオプションです。</li>
        </ul>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.1-12">
          <li pn="section-3.1-12.1">16進数の数字は、クォーテーションなしで "0x" で始まり、大文字小文字を区別しません。同様に、2進数の数字は "0b" で始まります。</li>
        </ul>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.1-13">
          <li pn="section-3.1-13.1">テキスト文字列は、二重引用符「"」で囲まれています。これらは[RFC8259]のセクション7で定義されている文字列の規則に従います。（ABNFのユーザーは、テキスト文字列の大文字小文字の概念に対するCDDLのサポートがないことに注意するかもしれません。必要な場合は、正規表現を使用できます（セクション3.8.3）。）</li>
        </ul>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.1-14">
          <li pn="section-3.1-14.1">バイト文字列は単一引用符 "'" で囲まれ、"h" または "b64" で接頭辞が付けられる場合があります。接頭辞がない場合、文字列はテキスト文字列として解釈されますが、シングルクォートはエスケープする必要があり、結果として得られるUTF-8バイトはバイト文字列（メジャータイプ2）としてマークされます。"h" または "b64" として接頭辞が付けられる場合、文字列はスクリプト16進数のペアのシーケンス（基数16; [RFC4648] のセクション8を参照）またはbase64(url)文字列（[RFC4648] のセクション4またはセクション5）として解釈されます（[RFC7049] のセクション6の診断表記と同様；付録G.2を参照）。接頭辞の場合、文字列内の空白（コメントを含む）は無視されます。</li>
        </ul>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.1-15">
          <li pn="section-3.1-15.1">CDDLは、エンコーディングにUTF-8[RFC3629]を使用します。CDDLの処理には、Unicodeの正規化プロセスは関与しません。</li>
        </ul>
        <t indent="0" pn="section-3.1-16"><bcp14>MUST</bcp14> applies to the sender's action that the specification requires to be performed in order to correctly implement the protocol. The term <bcp14>MUST NOT</bcp14> applies to the sender's action that the specification prohibits in order to correctly implement the protocol. The term <bcp14>REQUIRED</bcp14> means that the specification uses the term <bcp14>MUST</bcp14> and enforces its usage. Similarly, the terms <bcp14>SHALL</bcp14> and <bcp14>SHALL NOT</bcp14> are used in the same way.</t>
        <t indent="0" pn="section-3.1-17"><artwork name="" type="" align="left" alt="">
                 ; This is a comment
                 person = { g }
</artwork>
        </t>
        <t indent="0" pn="section-3.1-18"><artwork name="" type="" align="left" alt="">
                 g = (
                   "name": tstr,
                   age: int,  ; "age" is a bareword
                 )
</artwork>
          <artwork name="" type="" align="left" alt="">
                 g = (
                   "name": tstr,
                   age: int,  ; "age" is a bareword
                 )
</artwork>
        </t>
      </section>
      <section anchor="occurrence" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-occurrence">Occurrence</name>
        <t indent="0" pn="section-3.2-1">グループエントリの前に<bcp14>オプションの発生</bcp14>インジケータを指定することができます。それは、(1) オプションの場合は "?" (オプションあり)、"*" (0回以上)、または "+" (1回以上) のいずれかであるか、(2) n*m の形式であり、n と m はオプションの符号なし整数であり、n が下限 (デフォルト 0) であり、m が上限 (デフォルト 制限なし) であります。</t>
        <t indent="0" pn="section-3.2-2">もし発生インジケータが指定されていない場合、グループエントリは正確に1回発生する必要があります（1*1 が指定されたかのように）。発生インジケータに許可された数によって、基本グループエントリが一致する一連の名前/値ペアのシーケンスを結合して構成されるグループエントリが一致します。</t>
        <t indent="0" pn="section-3.2-3">CDDLは、定義される可能性のあるいかなる指示/注釈の外部でも、配列またはマップが明示的な長さの符号化または非明示的な長さの符号化を使用するかどうかについて何ら規定しません。つまり、仕様で配列のサイズを「開いた」状態にしたことと、それが明示的な長さまたは非明示的な長さで交換されるという事実との間には、相関関係がありません。</t>
        <t indent="0" pn="section-3.2-4">以下の情報も注意してください。CDDLは、対象表現のデータモデルには存在しない柔軟性を記述することができます。これはJSONにとっては明らかですが、CBORにも関連しています。</t>
        <t indent="0" pn="section-3.2-5"><artwork name="" type="" align="left" alt="">
                        apartment = {
                          kitchen: size,
                          * bedroom: size,
                        }
                        size = float ; in m2
</artwork>
        </t>
        <t indent="0" pn="section-3.2-6">以前の仕様では、「bedroom」というキーを複数回使用することを許可するためにCBORが変更されるわけではありません。言い換えると、データモデルによって課される制約のため、3行目はほとんど以下のようになります:</t>
        <t indent="0" pn="section-3.2-7"><artwork name="" type="" align="left" alt="">
                          ? ベッドルーム：広さ、
</artwork>
        </t>
        <t indent="0" pn="section-3.2-8">（複数の発生指標は、さまざまなキーを許容するグループのマップにおいて依然として有用です。）</t>
      </section>
      <section anchor="predefined-names-for-types" numbered="true" removeInRFC="false" toc="include" pn="section-3.3">
        <name slugifiedName="name-predefined-names-for-types">Predefined Names for Types</name>
        <t indent="0" pn="section-3.3-1">CDDLはいくつかの名前を予め定義しています。この節ではこれらの名前をまとめていますが、詳細な定義については付録Dを参照してください。</t>
        <t indent="0" pn="section-3.3-2">以下のプリミティブデータ型に対するキーワードが定義されています：</t>
        <t indent="0" pn="section-3.3-3">「bool」はブール値です（メジャータイプ7、追加情報20または21）。</t>
        <t indent="0" pn="section-3.3-4">「uint」とは、符号なし整数（メジャータイプ0）を表すものです。</t>
        <t indent="0" pn="section-3.3-5">「nint」とは、負の整数を表すためのタグ（主要タイプ1）です。</t>
        <t indent="0" pn="section-3.3-6">「int」は符号なし整数または負の整数です。</t>
        <t indent="0" pn="section-3.3-7">「float16」とは、半精度浮動小数点数 <xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/>（主要型7、追加情報25）で表すことができる数字です。</t>
        <t indent="0" pn="section-3.3-8">"float32"  A number representable as a single-precision float
   <xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/> (major type 7, additional information 26).</t>
        <t indent="0" pn="section-3.3-9">「float64」は、IEEE754に準拠した倍精度浮動小数点数で表される数値です（主要タイプ7、追加情報27）。</t>
        <t indent="0" pn="section-3.3-10">「float」は、float16、float32、またはfloat64のいずれかです。</t>
        <t indent="0" pn="section-3.3-11">「bstr」または「バイト」は、バイト文字列です（メジャータイプ2）。</t>
        <t indent="0" pn="section-3.3-12">「tstr」または「text」は、テキスト文字列（メジャータイプ3）です。</t>
        <t indent="0" pn="section-3.3-13">（配列やマップのための予め定義された名前はないことに注意してください。これらは以下の構文で定義されます。）</t>
        <t indent="0" pn="section-3.3-14">さらに、"tdate"、"bigint"、"regexp"などのCBORタグに関連付けられたいくつかの型がプレリュードで定義されています。</t>
      </section>
      <section anchor="arrays" numbered="true" removeInRFC="false" toc="include" pn="section-3.4">
        <name slugifiedName="name-arrays">Arrays</name>
        <t indent="0" pn="section-3.4-1">配列の定義は、グループを角かっこで囲みます。</t>
        <t indent="0" pn="section-3.4-2">それぞれのエントリについて、セクション3.2で指定されている出現指示子を許可します。</t>
        <t indent="0" pn="section-3.4-3">例えば:</t>
        <t indent="0" pn="section-3.4-4"><artwork name="" type="" align="left" alt="">
                  unlimited-people = [* person]
                  one-or-two-people = [1*2 person]
                  at-least-two-people = [2* person]
                  person = (
                      name: tstr,
                      age: uint,
                  )
</artwork>
          <artwork name="" type="" align="left" alt="">
                  unlimited-people = [* person]
                  one-or-two-people = [1*2 person]
                  at-least-two-people = [2* person]
                  person = (
                      name: tstr,
                      age: uint,
                  )
</artwork>
        </t>
        <t indent="0" pn="section-3.4-5">「person」というグループは、配列内で繰り返し使用することで交互に名前と年齢が生成されるように定義されています。したがって、「unlimited-people」というデータ項目のタイプには、以下の4つの有効な値があります。</t>
        <t indent="0" pn="section-3.4-6"><artwork name="" type="" align="left" alt="">
   ["roundlet", 1047, "psychurgy", 2204, "extrarhythmical", 2231]
   []
   ["aluminize", 212, "climograph", 4124]
   ["penintime", 1513, "endocarditis", 4084, "impermeator", 1669,
    "coextension", 865]
</artwork>
        </t>
      </section>
      <section anchor="maps" numbered="true" removeInRFC="false" toc="include" pn="section-3.5">
        <name slugifiedName="name-maps">Maps</name>
        <t indent="0" pn="section-3.5-1">マップを指定するための構文は特別な注意が必要であり、CDDLを使用する多くの仕様の焦点となる可能性があるため、最適化と利便性の数も重要です。構文は厳密にはマップの構造体とテーブルの使用を区別しませんが、それぞれに特化しています。</t>
        <t indent="0" pn="section-3.5-2">しかし、まず、JSONから引き継がれたCBORの特徴を再確認しましょう。CBORマップ内のキー/値ペアは固定の順序を持ちません（オーダーメイキングされません）。（注：順序を固定することが有用な状況を想像することができます。例えば、デコーダは整数キー1、3、および7に関連する値を探し出すことができます。もし順序が固定されており、デコーダがキー3に遭遇する前にキー4がエンカウントされる場合、より複雑なブックキーピングを行うことなくキー3が利用できないことが判断できます。残念ながら、JSONもCBORもこれをサポートしていないため、CDDLでもこれをサポートする試みは行われませんでした。）</t>
        <section anchor="structs" numbered="true" removeInRFC="false" toc="include" pn="section-3.5.1">
          <name slugifiedName="name-structs">Structs</name>
          <t indent="0" pn="section-3.5.1-1">「struct」のマップの使用方法は、多くのJSONアプリケーションでJSONオブジェクトが使用される方法に類似しています。</t>
          <t indent="0" pn="section-3.5.1-2"><Section>3.4</Section>で定義する配列と同じ方法で、マップは定義されますが、角括弧 "[]" の代わりに波括弧 "{}" を使用します。</t>
          <t indent="0" pn="section-3.5.1-3">An occurrence indicator as specified in Section 3.2 is permitted for
each group entry.</t>
          <t indent="0" pn="section-3.5.1-4">以下は、構造が埋め込まれたレコードの例です。</t>
          <t indent="0" pn="section-3.5.1-5"><artwork name="" type="" align="left" alt="">
    Geography = [
      city           : tstr,
      gpsCoordinates : GpsCoordinates,
    ]
</artwork>
          </t>
          <t indent="0" pn="section-3.5.1-6"><artwork name="" type="" align="left" alt="">
    GpsCoordinates = {
      longitude      : uint,            ; degrees, scaled by 10^7
      latitude       : uint,            ; degrees, scaled by 10^7
    }
</artwork>
            <artwork name="" type="" align="left" alt="">
    GpsCoordinates = {
      longitude      : uint,            ; degrees, scaled by 10^7
      latitude       : uint,            ; degrees, scaled by 10^7
    }
</artwork>
          </t>
          <t indent="0" pn="section-3.5.1-7">エンコード時に、ジオグラフィーレコードは、2つのメンバー（グループエントリのキーは無視されます）を持つCBOR配列としてエンコードされます。一方、GpsCoordinates構造体は、2つのキー/値ペアを持つCBORマップとしてエンコードされます。</t>
          <t indent="0" pn="section-3.5.1-8">Types used in a structure can be defined in separate rules or just in
place (potentially placed inside parentheses, such as for choices).
For example:</t>
          <t indent="0" pn="section-3.5.1-9"><artwork name="" type="" align="left" alt="">
                        located-samples = {
                          sample-point: int,
                          samples: [+ float],
                        }
</artwork>
          </t>
          <t indent="0" pn="section-3.5.1-10">「located-samples」というデータ型は、struct を参照する際に使用されるべきであり、「sample-point」と「samples」というキーを使用する必要があります。これは実際に完全な例です：コロンに続く識別子は、メンバーキーのテキスト文字列として直接使用することができます（「bareword」メンバーキーと呼びます）、ダブルクォーテーションで囲まれた文字列や数値も同様です。（他のタイプ、特に複数の値を含むタイプがキーのタイプとして使用される場合、ダブルアローに続きます；詳細は以下を参照してください。）</t>
          <t indent="0" pn="section-3.5.1-11">テキスト文字列キーが識別子の構文と一致しない場合（または仕様者が二重引用符を使用することを好む場合）、テキスト文字列構文はメンバーキーの位置にも使用でき、その後にコロンを続けます。したがって、上記の例は、メンバーキーの位置に引用符で囲まれた文字列を使用しても書くことができました。</t>
          <t indent="0" pn="section-3.5.1-12">一般的に、上記のケースで述べられているもの以外の方法で指定された型は、それらに続けて二重矢印を使用することで、キーの型の位置で使用することができます。特に、型が識別子によって名前付けられている場合（コロンに続いて使用されると、「裸のワード」と解釈されてテキスト文字列に変換されることがある）は、二重矢印が必要です。リテラルテキスト文字列もまた、型を生成します（与えられた文字列のみを含む型です）。したがって、この例の別の形式は次のようになります：</t>
          <t indent="0" pn="section-3.5.1-13"><artwork name="" type="" align="left" alt="">
                      located-samples = {
                        "sample-point" =&gt; int,
                        "samples" =&gt; [+ float],
                      }
</artwork>
            <作品 name="" type="" align="left" alt="">
                      located-samples = {
                        "sample-point" =&gt; int,
                        "samples" =&gt; [+ float],
                      }
</作品>
          </t>
          <t indent="0" pn="section-3.5.1-14">ここで説明されているコロン（":"）のショートカットによっても一部の暗黙的な意味が追加される方法については、以下のセクション3.5.4を参照してください。</t>
          <t indent="0" pn="section-3.5.1-15">ダブルアローの使用方法をよりよく示す方法は、次のようなものかもしれません：</t>
          <t indent="0" pn="section-3.5.1-16"><artwork name="" type="" align="left" alt="">
          located-samples = {
            sample-point: int,
            samples: [+ float],
            * equipment-type =&gt; equipment-tolerances,
          }
          equipment-type = [name: tstr, manufacturer: tstr]
          equipment-tolerances = [+ [float, float]]
</artwork>
            <artwork name="" type="" align="left" alt="">
          located-samples = {
            sample-point: int,
            samples: [+ float],
            * equipment-type =&gt; equipment-tolerances,
          }
          equipment-type = [name: tstr, manufacturer: tstr]
          equipment-tolerances = [+ [float, float]]
</artwork>
          </t>
          <t indent="0" pn="section-3.5.1-17">以下の例では、オプションのエントリを持つ構造体が定義されています。表示名（テキスト文字列）、名前の構成要素である名（テキスト文字列）、および年齢情報（符号なし整数）です。</t>
          <t indent="0" pn="section-3.5.1-18"><artwork name="" type="" align="left" alt="">
                       PersonalData = {
                         ? displayName: tstr,
                         NameComponents,
                         ? age: uint,
                       }
</artwork>
            <artwork name="" type="" align="left" alt="">
                       PersonalData = {
                         ? displayName: tstr,
                         NameComponents,
                         ? age: uint,
                       }
</artwork>
          </t>
          <t indent="0" pn="section-3.5.1-19"><artwork name="" type="" align="left" alt="">
                       NameComponents = (
                         ? firstName: tstr,
                         ? familyName: tstr,
                       )
</artwork>
            <artwork name="" type="" align="left" alt="">
                       NameComponents = (
                         ? firstName: tstr,
                         ? familyName: tstr,
                       )
</artwork>
          </t>
          <t indent="0" pn="section-3.5.1-20">NameComponentsのグループ定義では、別のマップを生成しません。代わりに、すべての4つのキーはPersonalDataによって作成された構造体に直接格納されます。</t>
          <t indent="0" pn="section-3.5.1-21">この例では、CDDLの観点から見て、すべてのキー/値のペアはオプションです。発生指示子がない場合、エントリーは必須です。</t>
          <t indent="0" pn="section-3.5.1-22">現在の仕様で指定されていないさらなるエントリの追加が必要な場合、この可能性を明示的に追加することができます。</t>
          <t indent="0" pn="section-3.5.1-23"><artwork name="" type="" align="left" alt="">
                      PersonalData = {
                        ? displayName: tstr,
                        NameComponents,
                        ? age: uint,
                        * tstr =&gt; any
                      }
</artwork>
            <artwork name="" type="" align="left" alt="">
                      PersonalData = {
                        ? displayName: tstr,
                        NameComponents,
                        ? age: uint,
                        * tstr =&gt; any
                      }
</artwork>
          </t>
          <t indent="0" pn="section-3.5.1-24"><artwork name="" type="" align="left" alt="">
                       NameComponents = (
                         ? firstName: tstr,
                         ? familyName: tstr,
                       )
</artwork>
            <artwork name="" type="" align="left" alt="">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NameComponents = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? firstName: tstr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? familyName: tstr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
</artwork>
          </t>
          <t indent="0" pn="section-3.5.1-25"><figure anchor="fig-7" align="left" suppress-title="false" pn="figure-7">
              <name slugifiedName="name-figure-7">個人データ：拡張性の例</name>
              <artwork name="" type="" align="left" alt="">

</artwork>
            </figure>
          </t>
          <t indent="0" pn="section-3.5.1-26">付録Fで説明されたCDDLツールは、この仕様に対して受け入れ可能な1つのインスタンスを生成しました。</t>
          <t indent="0" pn="section-3.5.1-27"><artwork name="" type="" align="left" alt="">
      {"familyName": "agust", "antiforeignism": "pretzel",
       "springbuck": "illuminatingly", "exuviae": "ephemeris",
       "kilometrage": "frogfish"}
</artwork>

＜artwork xmlns:xi="http://www.w3.org/2001/XInclude" name="" type="" align="left" alt=""&gt;
      {"familyName": "agust", "antiforeignism": "pretzel",
       "springbuck": "illuminatingly", "exuviae": "ephemeris",
       "kilometrage": "frogfish"}
＜/artwork＞</t>
          <t indent="0" pn="section-3.5.1-28">（エクステンションポイントを明示的に識別する方法の一つについては、セクション3.9を参照してください。）</t>
        </section>
        <section anchor="tables" numbered="true" removeInRFC="false" toc="include" pn="section-3.5.2">
          <name slugifiedName="name-tables">Tables</name>
          <t indent="0" pn="section-3.5.2-1">テーブルは、キーのタイプが単一の値だけでなく複数の値を許容する場合、エントリーを持つマップを定義することで指定することができます。例えば：</t>
          <t indent="0" pn="section-3.5.2-2"><artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
            <artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
            <artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
            <artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
            <artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
            <artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
            <artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
            <artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
            <artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
            <artwork name="" type="" align="left" alt="">
                      square-roots = {* x =&gt; y}
                      x = int
                      y = float
</artwork>
          </t>
          <t indent="0" pn="section-3.5.2-3">ここでは、各キー/値のペアのキーはデータ型x（整数として定義）であり、値はデータ型y（浮動小数点数として定義）です。</t>
          <t indent="0" pn="section-3.5.2-4">仕様書がxまたはyのいずれかを制限する必要がない場合（つまり、アプリケーションはエントリごとに自由に選択できる）、事前定義済みの名前「any」で置き換えることができます。</t>
          <t indent="0" pn="section-3.5.2-5">別の例として、整数または浮動小数点数から文字列に変換するための変換テーブルとして、次のものが使用される可能性があります。</t>
          <t indent="0" pn="section-3.5.2-6"><artwork name="" type="" align="left" alt="">
                   tostring = {* mynumber =&gt; tstr}
                   mynumber = int / float
</artwork>
            <artwork name="" type="" align="left" alt="">
                   tostring = {* mynumber =&gt; tstr}
                   mynumber = int / float
</artwork>
          </t>
        </section>
        <section anchor="non-deterministic-order" numbered="true" removeInRFC="false" toc="include" pn="section-3.5.3">
          <name slugifiedName="name-non-deterministic-order">Non-deterministic Order</name>
          <t indent="0" pn="section-3.5.3-1">PEG形式（付録Aを参照）によって配列がどのようにマッチされるかは完全に決定されますが、マップのマッチングはより複雑です。マップには固有の順序がないためです。 PEGアルゴリズムが試す候補の名前/値ペアごとに、マップ全体からマッチするメンバーが選択されます。グループ式では、マップ内の複数のメンバーがマッチする場合があります。ほとんどの場合、これは重要ではありませんが、グループ式は通常、すべてのマッチを消費します。</t>
          <t indent="0" pn="section-3.5.3-2"><artwork name="" type="" align="left" alt="">
                         labeled-values = {
                           ? fritz: number,
                           * label =&gt; value
                         }
                         label = text
                         value = number
</artwork>
            <artwork name="" type="" align="left" alt="">
                         labeled-values = {
                           ? fritz: number,
                           * label =&gt; value
                         }
                         label = テキスト
                         value = 数字
</artwork>
          </t>
          <t indent="0" pn="section-3.5.3-3">ここでは、キーが「fritz」のメンバーが存在する場合、これはグループの最初のエントリによって選択されます。残りのテキスト/数値メンバーは2番目のエントリによって選択されます（そして何かが選択されないままであれば、マップは一致しません）。</t>
          <t indent="0" pn="section-3.5.3-4">However, it is possible to construct group expressions where what is
actually picked is indeterminate, but does matter:</t>
          <t indent="0" pn="section-3.5.3-5"><artwork name="" type="" align="left" alt="">
                         do-not-do-this = {
                           int =&gt; int,
                           int =&gt; 6,
                         }
</artwork>
            <artwork name="" type="" align="left" alt="">
                         以下は行ってはならない = {
                           int =&gt; int,
                           int =&gt; 6,
                         }
</artwork>
          </t>
          <t indent="0" pn="section-3.5.3-6">この式が"{3: 5, 4: 6}"と一致するとき、最初のグループエントリは「3: 5」を選択し、「4: 6」は2番目のエントリと一致するために残されるかもしれません。または、最初のエントリは「4: 6」を選択し、2番目のエントリには何も残りません。このような病理的な非決定性は、「より一般的」な部分が「より具体的」な部分よりも前に指定されていること、または一般規則が、それが一致できるマップのキー/値のサブセットのみを消費するという一般的なルールによって引き起こされます。「より一般的」な部分が「より具体的」な部分よりも前に指定されることや、マップのキー/値のサブセットのみを一致させるように求められるこの一般的なルールは、実際の仕様ではあまり発生しない傾向があります。本文作成時点では、CDDLツールはこのようなケースを自動的に検出することができません。したがって、現在のCDDL仕様では、仕様の筆者に対して病理的な非決定的な仕様を記述しないように要請されています。</t>
          <t indent="0" pn="section-3.5.3-7">(The astute reader will be reminded of what was called "ambiguous
content models" in the Standard Generalized Markup Language (SGML)
and "non-deterministic content models" in XML.  That problem is
related to the one described here, but the problem here is
specifically caused by the lack of order in maps, something that the
XML schema languages do not have to contend with.  Note that
RELAX NG's "interleave" pattern handles lack of order explicitly on
the specification side, while the instances in XML always have
determinate order.)</t>
        </section>
        <section anchor="cuts-in-maps" numbered="true" removeInRFC="false" toc="include" pn="section-3.5.4">
          <name slugifiedName="name-cuts-in-maps">Cuts in Maps</name>
          <t indent="0" pn="section-3.5.4-1">上記の構造体に関する拡張性のイディオムには1つの問題があります：</t>
          <t indent="0" pn="section-3.5.4-2"><artwork name="" type="" align="left" alt="">
                     extensible-map-example = {
                       ? 「選択できます（OPTIONAL）-キー」 =&gt; int,
                       * tstr =&gt; any
                     }
</artwork>
          </t>
          <t indent="0" pn="section-3.5.4-3">この例では、オプションのキー「optional-key」が1つあります。存在する場合、整数にマップされます。また、将来の追加のためのワイルドカードも存在します。</t>
          <t indent="0" pn="section-3.5.4-4"><code>MUST</code> not be null.
<code>SHOULD</code> be validated before processing.
<code>NOT RECOMMENDED</code> to use outdated encryption algorithms.
Please provide the <code>OPTIONAL</code> parameter if available.
</t>
          <t indent="0" pn="section-3.5.4-5"><artwork name="" type="" align="left" alt="">
                   { "optional-key": "nonsense" }
</artwork>
            <artwork name="" type="" align="left" alt="">
                   { "optional-key": "nonsense" }
</artwork>
          </t>
          <t indent="0" pn="section-3.5.4-6">この仕様と一致します：グループの最初のエントリが一致しない間、2番目のエントリ（ワイルドカード）が一致します。これは望ましい場合もあります（例：将来の拡張で「オプションキー」のタイプを拡張できるようにする場合など）、しかし多くの場合そうではありません。</t>
          <t indent="0" pn="section-3.5.4-7">"カット"というより一般的な潜在的な機能を見越して、CDDLはマップエントリの定義に「^」を挿入することを許可しています。</t>
          <t indent="0" pn="section-3.5.4-8"><artwork name="" type="" align="left" alt="">
                    extensible-map-example = {
                      ? "<bcp14>選択できます（OPTIONAL）</bcp14>-key" ^ =&gt; int,
                      * tstr =&gt; any
                    }
</artwork>
          </t>
          <t indent="0" pn="section-3.5.4-9">この位置でのカットは、メンバーキーがカットを持つエントリーの名前部分と一致すると、マップのグループ内の後のエントリーでのメンバーのキーの他の潜在的な一致が許可されなくなることを意味します。つまり、グループエントリーがマッチングキーに基づいてキー/値ペアを選択する場合、その選択は「固定」されます。このルールは、値の一致有無に関係なく適用され、一致しない場合は、マップ全体が一致しなくなります。要約すると、前述の例は、カットで変更された仕様と一致しなくなります。</t>
          <t indent="0" pn="section-3.5.4-10">このような排他的なマッチングの要求が非常に頻繁であるため、「:」のショートカットは実際にはカットのセマンティクスを含むように定義されています。したがって、前述の例（カットを含む）は次のようにより簡潔に記述することができます。</t>
          <t indent="0" pn="section-3.5.4-11"><artwork name="" type="" align="left" alt="">
                     extensible-map-example = {
                       ? "optional-key": int,
                       * tstr =&gt; any
                     }
</artwork>
            <artwork name="" type="" align="left" alt="">
                     extensible-map-example = {
                       ? "optional-key": int,
                       * tstr =&gt; any
                     }
</artwork>
          </t>
          <t indent="0" pn="section-3.5.4-12">または、キーに対して裸の単語を使用してさらに短くすることもできます。</t>
          <t indent="0" pn="section-3.5.4-13"><artwork name="" type="" align="left" alt="">
                     extensible-map-example = {
                       ? optional-key: int,
                       * tstr =&gt; any
                     }
</artwork>
            <artwork name="" type="" align="left" alt="">
                     extensible-map-example = {
                       ? optional-key: int,
                       * tstr =&gt; any
                     }
</artwork>
          </t>
        </section>
      </section>
      <section anchor="tags" numbered="true" removeInRFC="false" toc="include" pn="section-3.6">
        <name slugifiedName="name-tags">Tags</name>
        <t indent="0" pn="section-3.6-1">A type can make use of a CBOR tag (major type 6) by using the
representation type notation, giving #6.nnn(type) where nnn is an
unsigned integer giving the tag number and "type" is the type of the
data item being tagged.</t>
        <t indent="0" pn="section-3.6-2">たとえば、CDDLの序文（付録D）からの次の行は、符号なしの大きな数Nの型名として「biguint」を定義しています。</t>
        <t indent="0" pn="section-3.6-3"><artwork name="" type="" align="left" alt="">
                        biguint = #6.2(bstr)
</artwork>
          <artwork name="" type="" align="left" alt="">
                        biguint = #6.2(bstr)
</artwork>
        </t>
        <t indent="0" pn="section-3.6-4">The tags defined by <xref target="RFC7049" format="default" sectionFormat="of" derivedContent="RFC7049"/> are included in the prelude.
Additional tags registered since <xref target="RFC7049" format="default" sectionFormat="of" derivedContent="RFC7049"/> was written need to be
added to a CDDL specification as needed; e.g., a binary Universally
Unique Identifier (UUID) tag could be referenced as "buuid" in a
specification after defining</t>
        <t indent="0" pn="section-3.6-5"><artwork name="" type="" align="left" alt="">
                         buuid = #6.37(bstr)
</artwork>
          <artwork name="" type="" align="left" alt="">
                         buuid = #6.37(bstr)
</artwork>
        </t>
        <t indent="0" pn="section-3.6-6">In the following example, usage of tag 32 for URIs is optional:</t>
        <t indent="0" pn="section-3.6-7"><artwork name="" type="" align="left" alt="">
                     my_uri = #6.32(tstr) / tstr
</artwork>
          <artwork name="" type="" align="left" alt="">
                     my_uri = #6.32(tstr) / tstr
</artwork>
        </t>
      </section>
      <section anchor="unwrapping" numbered="true" removeInRFC="false" toc="include" pn="section-3.7">
        <name slugifiedName="name-unwrapping">Unwrapping</name>
        <t indent="0" pn="section-3.7-1">マップまたは配列を定義するために使用されるグループは、多くの場合、別のマップまたは配列の定義に再利用されます。同様に、タグとして定義された型は、参照したい内部データアイテムを持っています。これらの場合、単にマップ、配列、またはタグ型の名前を、それ自体の定義されたグループまたは型のハンドルとして使用することが便利です。</t>
        <t indent="0" pn="section-3.7-2">The "unwrap" operator (written by preceding a name by a tilde
character "~") can be used to strip the type defined for a name by
one layer, exposing the underlying group (for maps and arrays) or
type (for tags).</t>
        <t indent="0" pn="section-3.7-3">For example, an application might want to define a basic header and
an advanced header.  Without unwrapping, this might be done as
follows:</t>
        <t indent="0" pn="section-3.7-4"><artwork name="" type="" align="left" alt="">
          basic-header-group = (
            field1: int,
            field2: text,
          )
</artwork>
          <artwork name="" type="" align="left" alt="">
          基本ヘッダーグループ = (
            field1: int,
            field2: text,
          )
</artwork>
        </t>
        <t indent="0" pn="section-3.7-5"><artwork name="" type="" align="left" alt="">
          basic-header = [ basic-header-group ]
</artwork>
          <artwork name="" type="" align="left" alt="">
          basic-header = [ basic-header-group ]
</artwork>
        </t>
        <t indent="0" pn="section-3.7-6"><artwork name="" type="" align="left" alt="">
          advanced-header = [
            basic-header-group,
            field3: bytes,
            field4: number, ; as in the tagged type "time"
          ]
</artwork>
          <artwork name="" type="" align="left" alt="">
          advanced-header = [
            basic-header-group,
            field3: bytes,
            field4: number; タグ付けされた型「time」と同じく
          ]
</artwork>
        </t>
        <t indent="0" pn="section-3.7-7">アンラップすることで、これは簡略化されます。</t>
        <t indent="0" pn="section-3.7-8"><artwork name="" type="" align="left" alt="">
                         basic-header = [
                           field1: int,
                           field2: text,
                         ]
</artwork>
          <artwork name="" type="" align="left" alt="">
                         基本ヘッダー = [
                           フィールド1: int,
                           フィールド2: text,
                         ]
</artwork>
        </t>
        <t indent="0" pn="section-3.7-9"><artwork name="" type="" align="left" alt="">
                         advanced-header = [
                           ~basic-header,
                           field3: bytes,
                           field4: ~time,
                         ]
</artwork>
        </t>
        <t indent="0" pn="section-3.7-10">（後者の例では最初のunwrap演算子を省略すると、basic-headerがadvanced-header内の独自の配列にネストされることになりますが、unwrapped basic-headerを使用すると、basic-header内のグループの定義がadvanced-header内でも基本的に繰り返され、単一の配列が生成されます。これは、プログラミング言語での継承によって解決されることが多いさまざまなアプリケーションに使用されることがあります。unwrapの効果は、参照されたタイプ内のグループやタイプの"スレッドイン"としても表現できます。これは、スレッドのような"~"文字を示唆しています。）</t>
      </section>
      <section anchor="controls" numbered="true" removeInRFC="false" toc="include" pn="section-3.8">
        <name slugifiedName="name-controls">Controls</name>
        <t indent="0" pn="section-3.8-1"><bcp14>制御は、制御演算子を介してターゲット型とコントローラー型を関連付けることを可能にします。</bcp14></t>
        <t indent="0" pn="section-3.8-2">The syntax for a control type is "target .control-operator
controller", where control operators are special identifiers prefixed
by a dot.  (Note that _target_ or _controller_ might need to be
parenthesized.)</t>
        <t indent="0" pn="section-3.8-3">この時点で、いくつかの制御演算子が定義されています。さらなる制御演算子は、本仕様の新しいバージョンによって定義されるか、セクション6.1の手順に従って登録される場合があります。</t>
        <section anchor="control-operator-.size" numbered="true" removeInRFC="false" toc="include" pn="section-3.8.1">
          <name slugifiedName="name-control-operator-.size">Control Operator .size</name>
          <t indent="0" pn="section-3.8.1-1">A ".size" control controls the size of the target in bytes by the
control type.  The control is defined for text and byte strings,
where it directly controls the number of bytes in the string.  It is
also defined for unsigned integers (see below).  Figure 8 shows
example usage for byte strings.</t>
          <t indent="0" pn="section-3.8.1-2"><artwork name="" type="" align="left" alt="">
                full-address = [[+ label], ip4, ip6]
                ip4 = bstr .size 4
                ip6 = bstr .size 16
                label = bstr .size (1..63)
</artwork>
            <artwork name="" type="" align="left" alt="">
                full-address = [[+ label], ip4, ip6]
                ip4 = bstr .size 4
                ip6 = bstr .size 16
                label = bstr .size (1..63)
</artwork>
          </t>
          <t indent="0" pn="section-3.8.1-3"><figure anchor="fig-8" align="left" suppress-title="false" pn="figure-8">
              <name slugifiedName="name-figure-8">バイトサイズの制御</name>
              <artwork name="" type="" align="left" alt="">

</artwork>
            </figure>
          </t>
          <t indent="0" pn="section-3.8.1-4">非符号整数に適用される場合、".size"制御は、その整数の範囲を制限します。これは、その非符号整数のコンピュータ表現に必要な最大バイト数を指定することによって行われます。言い換えれば、"uint .size N" は "0...BYTES_N" と等価であり、ここで BYTES_N は 256**N です。</t>
          <t indent="0" pn="section-3.8.1-5"><artwork name="" type="" align="left" alt="">
  audio_sample = uint .size 3 ; 24-bit, equivalent to 0...16777216
</artwork>
            <artwork name="" type="" align="left" alt="">
  audio_sample = uint .size 3 ; 24 ビットであり、0...16777216 に相当します。
</artwork>
          </t>
          <t indent="0" pn="section-3.8.1-6"><figure anchor="fig-9" align="left" suppress-title="false" pn="figure-9">
              <name slugifiedName="name-figure-9">整数のバイトサイズに対する制御</name>
              <artwork name="" type="" align="left" alt="">

</artwork>
            </figure>
          </t>
          <t indent="0" pn="section-3.8.1-7">注意してください。CDDLの値制約と同様に、この制御は表現制約ではありません。より少ないバイトに収まる数値でもその形式で表現することができ、効率の悪い実装でもより長い形式を使用することができます（ただし、それがCDDL以外の形式制約によって制約されていない場合、例えば、<xref target="RFC7049" section="3.9" format="default" sectionFormat="of" derivedLink="https://www.rfc-editor.org/rfc/rfc7049#section-3.9" derivedContent="RFC7049"/>のルールなど）。</t>
        </section>
        <section anchor="control-operator-.bits" numbered="true" removeInRFC="false" toc="include" pn="section-3.8.2">
          <name slugifiedName="name-control-operator-.bits">Control Operator .bits</name>
          <t indent="0" pn="section-3.8.2-1">A ".bits" control on a byte string indicates that, in the target,
only the bits numbered by a number in the control type are allowed to
be set.  (Bits are counted the usual way, bit number "n" being set in
"str" meaning that "(str[n &gt;&gt; 3] &amp; (1 &lt;&lt; (n &amp; 7))) != 0".)
Similarly, a ".bits" control on an unsigned integer "i" indicates
that for all unsigned integers "n" where "(i &amp; (1 &lt;&lt; n)) != 0", "n"
must be in the control type.</t>
          <t indent="0" pn="section-3.8.2-2"><artwork name="" type="" align="left" alt="">
                   tcpflagbytes = bstr .bits flags
                   flags = &amp;(
                     fin: 8, 　
                     syn: 9, 　
                     rst: 10, 　
                     psh: 11, 　
                     ack: 12, 　
                     urg: 13, 　
                     ece: 14, 　
                     cwr: 15, 　
                     ns: 0, 　
                   ) / (4..7) ; data offset bits
</artwork>
            <artwork name="" type="" align="left" alt="">
                   tcpflagbytes = bstr .bits flags
                   flags = &amp;(
                     fin: 8, 　
                     syn: 9, 　
                     rst: 10, 　
                     psh: 11, 　
                     ack: 12, 　
                     urg: 13, 　
                     ece: 14, 　
                     cwr: 15, 　
                     ns: 0, 　
                   ) / (4..7) ; データオフセットビット
</artwork>
          </t>
          <t indent="0" pn="section-3.8.2-3"><artwork name="" type="" align="left" alt="">
                   rwxbits = uint .bits rwx
                   rwx = &amp;(r: 2, w: 1, x: 0)
</artwork>
            <artwork name="" type="" align="left" alt="">
                   rwxbits = uint .bits rwx
                   rwx = &amp;(r: 2, w: 1, x: 0)
</artwork>
            <artwork name="" type="" align="left" alt="">
                   rwxbits = uint .bits rwx
                   rwx = &amp;(r: 2, w: 1, x: 0)
</artwork>
          </t>
          <t indent="0" pn="section-3.8.2-4"><figure anchor="fig-10" align="left" suppress-title="false" pn="figure-10">
              <name slugifiedName="name-figure-10"><bcp14>ビットの設定に対する制御</bcp14></name>
              <artwork name="" type="" align="left" alt="">

</artwork>
            </figure>
          </t>
          <t indent="0" pn="section-3.8.2-5">Appendix Fで述べられているCDDLツールは、「tcpflagbytes」のために以下の10個の例を生成します。</t>
          <t indent="0" pn="section-3.8.2-6"><artwork name="" type="" align="left" alt="">
   h'906d' h'01fc' h'8145' h'01b7' h'013d' h'409f' h'018e' h'c05f'
   h'01fa' h'01fe'
</artwork>
            <artwork name="" type="" align="left" alt="">
   h'906d' h'01fc' h'8145' h'01b7' h'013d' h'409f' h'018e' h'c05f'
   h'01fa' h'01fe'
</artwork>
          </t>
          <t indent="0" pn="section-3.8.2-7">これらの例は、上記の CDDL 仕様に明示的に 2 バイトのサイズが指定されていないことを示していません。フラグバイトの有効な完全な例としては、"h''" や "h'00'"、そして "h'000000'" などがあります。</t>
        </section>
        <section anchor="control-operator-.regexp" numbered="true" removeInRFC="false" toc="include" pn="section-3.8.3">
          <name slugifiedName="name-control-operator-.regexp">Control Operator .regexp</name>
          <t indent="0" pn="section-3.8.3-1">「<bcp14>.regexp</bcp14>」コントロールは、ターゲットとして与えられたテキスト文字列が、コントロールタイプの値として与えられたXML Schema Definition（XSD）正規表現と一致する必要があることを示します。XSD正規表現は、<xref target="W3C.REC-xmlschema-2-20041028" format="default" sectionFormat="of" derivedContent="W3C.REC-xmlschema-2-20041028"/>の付録Fで定義されています。</t>
          <t indent="0" pn="section-3.8.3-2"><artwork name="" type="" align="left" alt="">
  nai = tstr .regexp "[A-Za-z0-9]+@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)+"
</artwork>
            <artwork name="" type="" align="left" alt="">
  nai = tstr .regexp "[A-Za-z0-9]+@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)+"
</artwork>
          </t>
          <t indent="0" pn="section-3.8.3-3"><figure anchor="fig-11" align="left" suppress-title="false" pn="figure-11">
              <name slugifiedName="name-figure-11">XSD正規表現で制御する</name>
              <artwork name="" type="" align="left" alt="">

</artwork>
            </figure>
          </t>
          <t indent="0" pn="section-3.8.3-4">この正規表現に一致する例です：</t>
          <t indent="0" pn="section-3.8.3-5"><artwork name="" type="" align="left" alt="">
                    "N1@CH57HF.4Znqe0.dYJRN.igjf"
</artwork>
          </t>
          <section anchor="usage-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-3.8.3.1">
            <name slugifiedName="name-usage-considerations">Usage Considerations</name>
            <t indent="0" pn="section-3.8.3.1-1">注意してください。XSD正規表現は、通常の\xや\uエスケープをサポートしていません。ただし、CDDLではXSD正規表現がテキスト文字列に含まれており、リテラル表記では\uエスケープが提供されています。これにより、テキスト文字列に正規表現を使用するほとんどのアプリケーションには十分です。（なお、これはXSDのエスケープ規則が適用される前に、1つのレベルの文字列エスケープがあることを意味します。）</t>
            <t indent="0" pn="section-3.8.3.1-2">XSDの正規表現は文字クラスの差し引きをサポートしており、これは一般的な正規表現ライブラリではよく見られない機能です。仕様文書の作成者は、この機能を節約的に使用することを望むかもしれません。Unicode文字クラスにも同様の考慮が適用されます。これらが使用される場合、CDDLを使用する仕様書は対象となるUnicodeバージョンを特定する必要があります。</t>
            <t indent="0" pn="section-3.8.3.1-3">他の頻繁でないXSD正規表現の使用者にとっての予想外の事柄には、以下のものが含まれる場合があります。</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.8.3.1-4">
              <li pn="section-3.8.3.1-4.1">大文字と小文字を区別しない（case insensitivity）に対する直接のサポートはありません。プロトコルの設計では、大文字と小文字を区別しないことはほとんど流行していませんが、時には必要となり、その場合は手動で「[Cc][Aa][Ss][Ee]」のように明示する必要があります。</li>
            </ul>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.8.3.1-5">
              <li pn="section-3.8.3.1-5.1">人気のある文字クラス（\wや\dなど）のサポートは、Unicodeの文字プロパティに基づいています。これはしばしばASCIIベースのプロトコルでは望ましい動作ではないため、予期しない結果になる可能性があります（\sと\Sは従来の意味を持っており、"."は改行文字\rまたは\n以外の任意の文字にマッチします）。</li>
            </ul>
          </section>
          <section anchor="discussion" numbered="true" removeInRFC="false" toc="include" pn="section-3.8.3.2">
            <name slugifiedName="name-discussion">Discussion</name>
            <t indent="0" pn="section-3.8.3.2-1">プログラミングコミュニティでは、さまざまな種類の正規表現が使用されています。たとえば、Perl-Compatible Regular Expressions（PCRE）は広く使用されており、XSDの正規表現よりも便利かもしれません。ただし、現在のドキュメントで使用できるPCREの規範的な参照はありません。その代わり、現時点ではXSDの正規表現を選択します。IETFにはその選択の前例があります。たとえば、YANG <xref target="RFC7950" format="default" sectionFormat="of" derivedContent="RFC7950"/>で使用されています。</t>
            <t indent="0" pn="section-3.8.3.2-2">CDDLでは、制御を主な拡張ポイントとして使用していることに注意してください。これにより、望む場合には、ここで参照されているものに加えて、さらなる正規表現形式を追加する機会が生まれます。例えば、".pcre"制御の提案は、<xref target="CDDL-Freezer" format="default" sectionFormat="of" derivedContent="CDDL-Freezer"/>で定義されています。</t>
          </section>
        </section>
        <section anchor="control-operators-.cbor-and-.cborseq" numbered="true" removeInRFC="false" toc="include" pn="section-3.8.4">
          <name slugifiedName="name-control-operators-.cbor-and-.cborseq">Control Operators .cbor and .cborseq</name>
          <t indent="0" pn="section-3.8.4-1">エレメントが右辺引数（以下の例ではtype1）と一致するデータアイテムであることを示すバイト文字列である".cbor"が、CBORエンコードされたデータアイテムを含んでいます。</t>
          <t indent="0" pn="section-3.8.4-2"><artwork name="" type="" align="left" alt="">
   "バイト .cbor 型1"
</artwork>
          </t>
          <t indent="0" pn="section-3.8.4-3">同様に、バイト文字列上の「.cborseq」制御は、バイト文字列がCBORエンコードされたデータアイテムのシーケンスを含んでいることを示します。データアイテムが配列として取られる場合、配列は右辺の引数（以下の例ではtype2）と一致します。</t>
          <t indent="0" pn="section-3.8.4-4"><artwork name="" type="" align="left" alt="">
   "bytes .cborseq type2"
</artwork>
            <artwork name="" type="" align="left" alt="">
   "bytes .cborseq type2"（バイト数 .cborseq タイプ2）
</artwork>
          </t>
          <t indent="0" pn="section-3.8.4-5">（エンコードされたシーケンスを配列に変換するために、たとえばバイト文字列をバイト0x9fと0xffで挟み込んで、挟み込まれたバイト文字列をCBORエンコードされたデータ項目としてデコードすることで、実施できます。）</t>
        </section>
        <section anchor="control-operators-.within-and-.and" numbered="true" removeInRFC="false" toc="include" pn="section-3.8.5">
          <name slugifiedName="name-control-operators-.within-and-.and">Control Operators .within and .and</name>
          <t indent="0" pn="section-3.8.5-1"><bcp14>「.and」</bcp14>コントロールは、タイプに対して左辺のタイプと右辺として指定されたタイプの両方と一致することを示します。 （形式的には、結果のタイプは、指定された2つのタイプの共通部分です。）</t>
          <t indent="0" pn="section-3.8.5-2"><artwork name="" type="" align="left" alt="">
   "type1 .and type2"
</artwork>
            <artwork name="" type="" align="left" alt="">
   "type1 .および type2"
</artwork>
          </t>
          <t indent="0" pn="section-3.8.5-3">A variant of the ".and" control is the ".within" control, which
expresses an additional intent: the left-hand-side type is meant to
be a subset of the right-hand-side type.</t>
          <t indent="0" pn="section-3.8.5-4"><artwork name="" type="" align="left" alt="">
   "type1 .within type2"
</artwork>
            <artwork name="" type="" align="left" alt="">
   "type1 .type2内にある"
</artwork>
          </t>
          <t indent="0" pn="section-3.8.5-5">両方の形式は形式的な意味（交差）が同じですが、".within" 形式の意図は、右側が左側に許可されるタイプに関するガイダンスを提供することです。左側は通常、ソケットであることが想定されています（セクション3.9）。</t>
          <t indent="0" pn="section-3.8.5-6"><artwork name="" type="" align="left" alt="">
     message = $message .within message-structure
     message-structure = [message_type, *message_option]
     message_type = 0..255
     message_option = any
</artwork>
            <artwork name="" type="" align="left" alt="">
     message = $message .within message-structure
     message-structure = [message_type, *message_option]
     message_type = 0..255
     message_option = 任意
</artwork>
          </t>
          <t indent="0" pn="section-3.8.5-7"><artwork name="" type="" align="left" alt="">
     $message /= [3, dough: text, topping: [* text]]
     $message /= [4, noodles: text, sauce: text, parmesan: bool]
</artwork>
            <artwork name="" type="" align="left" alt="">
     $message /= [3、dough: text、topping: [* text]]
     $message /= [4、noodles: text、sauce: text、parmesan: bool]
</artwork>
          </t>
          <t indent="0" pn="section-3.8.5-8">「.within」の場合、type1がtype2で許可されていないデータ項目を許可している場合、ツールはエラーを検出する可能性があります。一方、「.and」の場合、type1が既にtype2のサブセットであることを期待する必要はありません。</t>
        </section>
        <section anchor="control-operators-.lt,-.le,-.gt,-.ge,-.eq,-.ne,-and-.default" numbered="true" removeInRFC="false" toc="include" pn="section-3.8.6">
          <name slugifiedName="name-control-operators-.lt,-.le,-.gt,-.ge,-.eq,-.ne,-and-.default">Control Operators .lt, .le, .gt, .ge, .eq, .ne, and .default</name>
          <t indent="0" pn="section-3.8.6-1">左辺の型が右辺の型（単一の値のみを含む）より小さい、小さいか等しい、大きい、大きいか等しい、等しい、等しくない値であるという制約を示すコントロール ".lt, .le, .gt, .ge, .eq, .ne" 。現在の仕様では、最初の4つのコントロール（.lt, .le, .gt, .ge）は数値型にのみ定義されており、これらは自然な順序関係を持っています。</t>
          <t indent="0" pn="section-3.8.6-2"><artwork name="" type="" align="left" alt="">
                  speed = number .ge 0  ; 単位： m/s
</artwork>
          </t>
          <t indent="0" pn="section-3.8.6-3"><bcp14>.ne</bcp14>と<bcp14>.eq</bcp14>は、数値または他のタイプの値の両方に対して定義されています。値のいずれかが数値型ではない場合、等価性は次のように決定されます：テキスト文字列はバイト単位で同一である場合に等しい（<bcp14>.eq</bcp14>を満たす/ <bcp14>.ne</bcp14>を満たさない）；バイト文字列についても同様です。配列は、要素の数が同じであり、配列間で順番にペアごとに等しい場合に等しいです。マップは、キーと値のペアの数が同じであり、2つのマップ間のキーと値のペアの間に等しさがある場合に等しいです。タグ付き値は、タグが同じで値が等しい場合に等しいです。単純なタイプの値は、同じ値であれば一致します。配列、マップ、またはタグ付き値内にある数値型は、数値の値が等しく、両方が整数または浮動小数点値である場合に等しいです。その他の場合は等しくありません（例：テキスト文字列とバイト文字列の比較）。</t>
          <t indent="0" pn="section-3.8.6-4">「.ne」制御のバリエーションは、".default" 制御であり、追加の意図を表します。右側のタイプで指定された値は、左側のタイプに対してデフォルト値として意図されており、暗黙の .ne 制御はこの値が送信されないようにするために存在しています。この制御は、制御タイプがオプションのコンテキストで使用される場合にのみ意味を持ちます。そうでない場合は、デフォルト値を利用する方法が存在しないためです。</t>
          <t indent="0" pn="section-3.8.6-5"><artwork name="" type="" align="left" alt="">
            timer = {
              time: uint,
              ? displayed-step: (number .gt 0) .default 1
            }
</artwork>
          </t>
        </section>
      </section>
      <section anchor="socket/plug" numbered="true" removeInRFC="false" toc="include" pn="section-3.9">
        <name slugifiedName="name-socket/plug">Socket/Plug</name>
        <t indent="0" pn="section-3.9-1">両方のタイプの選択肢とグループの選択肢において、空の選択肢から始めて、後でそれらを組み立てるメカニズムが定義されています。これにより、完全な仕様を構築するために連結される可能性のある別々のファイルで選択肢を組み立てることが容易になります。</t>
        <t indent="0" pn="section-3.9-2">従来の慣行により、CDDL拡張ポイントは先行するドル記号（types）または二つの先行するドル記号（groups）で示されます。ツールは、そのような型またはグループがまったく定義されていない場合、エラーを発生させずにこの慣行を尊重します。その場合、記号は空の型の選択肢（グループの選択肢）とみなされ、つまり選択肢は利用できません。</t>
        <t indent="0" pn="section-3.9-3"><artwork name="" type="" align="left" alt="">
         tcp-header = {seq: uint, ack: uint, * $$tcp-option}
</artwork>
          <artwork name="" type="" align="left" alt="">
         tcp-header = {seq: uint, ack: uint, * $$tcp-option}
</artwork>
        </t>
        <t indent="0" pn="section-3.9-4"><artwork name="" type="" align="left" alt="">
         ; 後で、別のファイルで
</artwork>
        </t>
        <t indent="0" pn="section-3.9-5"><artwork name="" type="" align="left" alt="">
         $$tcp-option //= (
         sack: [+(left: uint, right: uint)]
         )
</artwork>
          <artwork name="" type="" align="left" alt="">
         $$tcp-option //= (
         sack: [+(left: uint, right: uint)]
         )
</artwork>
        </t>
        <t indent="0" pn="section-3.9-6"><artwork name="" type="" align="left" alt="">
         ; および、別のファイルにあるかもしれません
</artwork>
        </t>
        <t indent="0" pn="section-3.9-7"><artwork name="" type="" align="left" alt="">
         $$tcp-option //= (
         sack-permitted: true
         )
</artwork>
          <artwork name="" type="" align="left" alt="">
         $$tcp-option //= (
         sack-permitted: true
         )
</artwork>
        </t>
        <t indent="0" pn="section-3.9-8"><bcp14>「$」で始まる名前は「タイプソケット」と呼ばれ、空のタイプとして始まり、「/ =」を介して拡張されることを意図しています。 「$$」で始まる名前は「グループソケット」と呼ばれ、空のグループ選択として始まり、「// =」を介して拡張されることを意図しています。 いずれの場合も、ソケットの定義が存在しない場合はエラーではありません。その場合、ルールを満たす方法がないことを意味します（つまり、選択肢は空です）。 </bcp14></t>
        <t indent="0" pn="section-3.9-9">以下のように訳されます。

慣例として、ソケット名のすべての定義（プラグ）は、「/ =」および「//=」を使用してオーグメンテーションする必要があります。</t>
        <t indent="0" pn="section-3.9-10">図7に示されている例を取り上げると、ソケット/プラグ機構は図12に示すように使用することができます。</t>
        <t indent="0" pn="section-3.9-11"><artwork name="" type="" align="left" alt="">
                  PersonalData = {
                    ? displayName: tstr,
                    名前の構成要素,
                    ? age: uint,
                    * $$personaldata-extensions
                  }
</artwork>
        </t>
        <t indent="0" pn="section-3.9-12"><artwork name="" type="" align="left" alt="">
                  NameComponents = (
                    ? firstName: tstr,
                    ? familyName: tstr,
                  )
</artwork>
          <artwork name="" type="" align="left" alt="">
                  NameComponents = (
                    ? firstName: tstr,
                    ? familyName: tstr,
                  )
</artwork>
        </t>
        <t indent="0" pn="section-3.9-13"><artwork name="" type="" align="left" alt="">
                  ; 上記はそのまま機能します。
                  ; しかしその後に、次のように追加することができます:
</artwork>
        </t>
        <t indent="0" pn="section-3.9-14"><artwork name="" type="" align="left" alt="">
                  $$personaldata-extensions //= (
                    favorite-salsa: tstr,
                  )
</artwork>
          <artwork name="" type="" align="left" alt="">
                  $$personaldata-extensions //= (
                    favorite-salsa: tstr,
                  )
</artwork>
        </t>
        <t indent="0" pn="section-3.9-15"><artwork name="" type="" align="left" alt="">
; そして再度、別の場所で：
</artwork>
        </t>
        <t indent="0" pn="section-3.9-16"><artwork name="" type="" align="left" alt="">
                  $$personaldata-extensions //= (
                    shoesize: uint,
                  )
</artwork>
          <artwork name="" type="" align="left" alt="">
                  $$personaldata-extensions //= (
                    shoesize: uint,
                  )
</artwork>
        </t>
        <t indent="0" pn="section-3.9-17"><figure anchor="fig-12" align="left" suppress-title="false" pn="figure-12">
            <name slugifiedName="name-figure-12">Personal Data Example: Using Socket/Plug Extensibility</name>
            <artwork name="" type="" align="left" alt="">

</artwork>
          </figure>
        </t>
      </section>
      <section anchor="generics" numbered="true" removeInRFC="false" toc="include" pn="section-3.10">
        <name slugifiedName="name-generics">Generics</name>
        <t indent="0" pn="section-3.10-1">アングルブラケットを使用して、ルールの左側に、定義される名前の後にフォーマルパラメータを追加することができます。例:</t>
        <t indent="0" pn="section-3.10-2"><artwork name="" type="" align="left" alt="">
   messages = message&lt;"reboot", "now"&gt; / message&lt;"sleep", 1..100&gt;
   message&lt;t, v&gt; = {type: t, value: v}
</artwork>
          <artwork name="" type="" align="left" alt="">
   messages = message&lt;"reboot", "now"&gt; / message&lt;"sleep", 1..100&gt;
   message&lt;t, v&gt; = {type: t, value: v}
</artwork>
        </t>
        <t indent="0" pn="section-3.10-3">一般的な規則を使用する場合、仮パラメータは、実引数（角括弧も使用）に束縛されます。束縛は、一般的な規則のスコープ内で行われます（あたかも「parameter = argument」という形式の規則が存在するかのように）。</t>
        <t indent="0" pn="section-3.10-4">一般的なルールは、タイプとグループの両方の名前を確立するために使用することができます。</t>
        <t indent="0" pn="section-3.10-5">（現時点では、付録Fに記載されているCDDLツールのジェネリックスのネストにいくつかの制限があります。）</t>
      </section>
      <section anchor="operator-precedence" numbered="true" removeInRFC="false" toc="include" pn="section-3.11">
        <name slugifiedName="name-operator-precedence">Operator Precedence</name>
        <t indent="0" pn="section-3.11-1">複数の構文的特徴（接頭辞および中置演算子など）を持つ任意の言語と同様に、CDDLには他の演算子よりも強く束縛する演算子が存在します。これは、例えばABNFと比較して、CDDLには型とグループの両方があり、それぞれに固有の演算子が存在するため、より複雑になります。型演算子（例えば型の選択に使用される「/」）は型に作用し、グループ演算子（例えばグループの選択に使用される「//」）はグループに作用します。型は単純にグループで使用することができますが、グループは型として使用するために（配列やマップなどとして）括弧で囲む必要があります。そのため、型演算子は自然にグループ演算子よりも緊密に結び付きます。</t>
        <t indent="0" pn="section-3.11-2">例えば、以下のような場合、</t>
        <t indent="0" pn="section-3.11-3"><artwork name="" type="" align="left" alt="">
   t = [group1]
   group1 = (a / b // c / d)
   a = 1 b = 2 c = 3 d = 4
</artwork>
          <artwork name="" type="" align="left" alt="">
   t = [group1]
   group1 = (a / b // c / d)
   a = 1 b = 2 c = 3 d = 4
</artwork>
        </t>
        <t indent="0" pn="section-3.11-4">group1は、aとbのタイプ選択とcとdのタイプ選択の間のグループ選択です。これは、メンバーキーと/または出現回数が追加された場合により関連性が増します。</t>
        <t indent="0" pn="section-3.11-5"><artwork name="" type="" align="left" alt="">
   <bcp14>t</bcp14> = {<bcp14>group2</bcp14>}
   <bcp14>group2</bcp14> = (? ab: <bcp14>a</bcp14> / <bcp14>b</bcp14> // cd: <bcp14>c</bcp14> / <bcp14>d</bcp14>)
   <bcp14>a</bcp14> = <bcp14>1</bcp14> <bcp14>b</bcp14> = <bcp14>2</bcp14> <bcp14>c</bcp14> = <bcp14>3</bcp14> <bcp14>d</bcp14> = <bcp14>4</bcp14>
          </artwork>
        </t>
        <t indent="0" pn="section-3.11-6">ビット・フィールドgroovChoiceには、タイプaまたはbのオプショナルメンバー「ab」と、タイプcまたはdのメンバー「cd」の間で選択することができます。オプションは2番目の選択肢ではなく、最初の選択肢「ab」に付けられていることに注意してください。</t>
        <t indent="0" pn="section-3.11-7">同様に、</t>
        <t indent="0" pn="section-3.11-8"><artwork name="" type="" align="left" alt="">
   t = [group3]
   group3 = (+ a / b / c)
   a = 1 b = 2 c = 3
</artwork>
          <artwork name="" type="" align="left" alt="">
   t = [group3]
   group3 = (+ a / b / c)
   a = 1 b = 2 c = 3
</artwork>
        </t>
        <t indent="0" pn="section-3.11-9"><bcp14>MUST</bcp14>、<bcp14>MUST NOT</bcp14>、<bcp14>REQUIRED</bcp14>、<bcp14>SHALL</bcp14>、<bcp14>SHALL NOT</bcp14>、<bcp14>SHOULD</bcp14>、<bcp14>SHOULD NOT</bcp14>、<bcp14>RECOMMENDED</bcp14>、<bcp14>NOT RECOMMENDED</bcp14>、<bcp14>MAY</bcp14>、および<bcp14>OPTIONAL</bcp14>というキーワードをそれぞれ
「<bcp14>しなければなりません（MUST）</bcp14>」、「<bcp14>してはなりません（MUST NOT）</bcp14>」、「<bcp14>要求されています（REQUIRED）</bcp14>」、「<bcp14>することになります（SHALL）</bcp14>」、「<bcp14>することはありません（SHALL NOT）</bcp14>」、「<bcp14>すべきです（SHOULD）</bcp14>」、「<bcp14>すべきではありません（SHOULD NOT）</bcp14>」、「<bcp14>推奨されます（RECOMMENDED）</bcp14>」、「<bcp14>推奨されません（NOT RECOMMENDED）</bcp14>」、「<bcp14>してもよいです（MAY）</bcp14>」、「<bcp14>選択できます（OPTIONAL）</bcp14>」と翻訳してください。以下の英文を日本語に翻訳します：

グループ3は、a、b、cの間のタイプの選択の繰り返しであり、単にaを繰り返し可能にする場合、出現に焦点を合わせるためにグループの選択が必要です。</t>
        <t indent="0" pn="section-3.11-10"><artwork name="" type="" align="left" alt="">
   t = [group4]
   group4 = (+ a // b / c)
   a = 1 b = 2 c = 3
</artwork>
          <artwork name="" type="" align="left" alt="">
   t = [group4]
   group4 = (+ a // b / c)
   a = 1 b = 2 c = 3
</artwork>
        </t>
        <t indent="0" pn="section-3.11-11">group4は、繰り返し可能なaと単一のbまたはcの間で選択するグループです。</t>
        <t indent="0" pn="section-3.11-12"><bcp14>group3</bcp14> の意味論は直感に反する可能性があるというコメントがありました。一般的に、演算子の優先順位ルールを持つ他の多くの言語と同様に、仕様書の作成者はそれに依存せず、CDDLの優先順位ルールに慣れていない読者をガイドするために括弧を自由に挿入することが推奨されています。</t>
        <t indent="0" pn="section-3.11-13"><artwork name="" type="" align="left" alt="">
   t = [group4a]
   group4a = ((+ a) // (b / c))
   a = 1 b = 2 c = 3
</artwork>
          <artwork name="" type="" align="left" alt="">
   t = [group4a]
   group4a = ((+ a) // (b / c))
   a = 1 b = 2 c = 3
</artwork>
        </t>
        <t indent="0" pn="section-3.11-14">演算子の優先順位は、緩い結合から厳密な結合へと順番に定義されており、付録Bで詳細に説明されています。また、この優先順位は表1にまとめられています。（与えられたアリティは、単項接頭辞演算子に対しては1であり、二項中置演算子に対しては2です。）</t>
        <t indent="0" pn="section-3.11-15"><table align="center">
            <thead>
              <tr>
                <tr>
                  <td align="left">演算子</td>
                  <td align="left">n個の引数をもつ</td>
                  <td align="left">作用するもの</td>
                  <td align="left">優先順位</td>
                </tr>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">    =</td>
                <td align="left">2</td>
                <td align="left">name = type, name = group</td>
                <td align="left">1      </td>
              </tr>
              <tr>
                <td align="left">    /=</td>
                <td align="left">2</td>
                <td align="left">name /= type</td>
                <td align="left">1      </td>
              </tr>
              <tr>
                <td align="left">   //=</td>
                <td align="left">2</td>
                <td align="left">name //= group</td>
                <td align="left">1      </td>
              </tr>
              <tr>
                <td align="left">    //</td>
                <td align="left">2</td>
                <td align="left">group // group</td>
                <td align="left">2      </td>
              </tr>
              <tr>
                <td align="left">    ,</td>
                <td align="left">2</td>
                <td align="left">group, group</td>
                <td align="left">3      </td>
              </tr>
              <tr>
                <td align="left">    *</td>
                <td align="left">1</td>
                <td align="left">* group</td>
                <td align="left">4      </td>
              </tr>
              <tr>
                <td align="left">   n*m</td>
                <td align="left">1</td>
                <td align="left">n*m group</td>
                <td align="left">4      </td>
              </tr>
              <tr>
                <td align="left">    +</td>
                <td align="left">1</td>
                <td align="left">+ group</td>
                <td align="left">4      </td>
              </tr>
              <tr>
                <td align="left">    ?</td>
                <td align="left">1</td>
                <td align="left">? group</td>
                <td align="left">4      </td>
              </tr>
              <tr>
                <td align="left">    =&gt;</td>
                <td align="left">2</td>
                <td align="left">type =&gt; type</td>
                <td align="left">5      </td>
              </tr>
              <tr>
                <td align="left">    :</td>
                <td align="left">2</td>
                <td align="left">name: type</td>
                <td align="left">5      </td>
              </tr>
              <tr>
                <td align="left">    /</td>
                <td align="left">2</td>
                <td align="left">type / type</td>
                <td align="left">6      </td>
              </tr>
              <tr>
                <td align="left">    ..</td>
                <td align="left">2</td>
                <td align="left">type..type</td>
                <td align="left">7      </td>
              </tr>
              <tr>
                <td align="left">   ...</td>
                <td align="left">2</td>
                <td align="left">type...type</td>
                <td align="left">7      </td>
              </tr>
              <tr>
                <td align="left">  .ctrl</td>
                <td align="left">2</td>
                <td align="left">type .ctrl type</td>
                <td align="left">7      </td>
              </tr>
              <tr>
                <td align="left">    &amp;</td>
                <td align="left">1</td>
                <td align="left">&amp;group</td>
                <td align="left">8      </td>
              </tr>
              <tr>
                <td align="left">    ~</td>
                <td align="left">1</td>
                <td align="left">~type</td>
                <td align="left">8      </td>
              </tr>
            </tbody>
          </table>
        </t>
        <t indent="0" pn="section-3.11-16"><artwork name="" type="" align="left" alt="">
              Table 1: 演算子の優先順位の要約
</artwork>
        </t>
      </section>
    </section>
    <section anchor="making-use-of-cddl" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-making-use-of-cddl">Making Use of CDDL</name>
      <t indent="0" pn="section-4-1">このセクションでは、CDDLを利用するためのいくつかの潜在的な方法について説明します。</t>
      <section anchor="as-a-guide-for-a-human-user" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-as-a-guide-for-a-human-user">As a Guide for a Human User</name>
        <t indent="0" pn="section-4.1-1">CDDLはCBORデータのレイアウトを効率的に定義するために使用することができます。これにより、人間の実装者はデータがどのようにエンコードされるべきかを簡単に理解することができます。</t>
        <t indent="0" pn="section-4.1-2">CDDLはCBORデータの一部を人間が読みやすい名前にマッピングするため、CDDLを使用してCBORデータの人間にやさしい表現を提供し、CDDLの定義に準拠しながらそのようなデータを編集するためのツールが作成される可能性があります。</t>
      </section>
      <section anchor="for-automated-checking-of-cbor-data-structures" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-for-automated-checking-of-cbor-data-structures">For Automated Checking of CBOR Data Structures</name>
        <t indent="0" pn="section-4.2-1">CDDLは、機械がCDDLの定義と関連するCBORデータ（そしてJSONデータも同様）を処理できるように指定されています。例えば、機械はCDDLを使用して、CBORデータがその定義と一致しているかどうかをチェックすることができます。</t>
        <t indent="0" pn="section-4.2-2">そのようなコンプライアンスチェックの徹底性の必要性は、アプリケーションによって異なります。 例えば、アプリケーションはデータ構造を全くチェックせず、CDDLの定義を単にデータの構造をプログラマーに示す手段として使用することを選択する場合もあります。</t>
        <t indent="0" pn="section-4.2-3">逆に、アプリケーションは、すべての必須のマップメンバーが利用可能であるかどうかまでチェックするチェックメカニズムを実装することもあります。</t>
        <t indent="0" pn="section-4.2-4">データの説明がアプリケーションによってどの程度強制されるかは、そのアプリケーションの設計者や実装者に委ねられており、関連するセキュリティ上の考慮事項を念頭に置いています。</t>
        <t indent="0" pn="section-4.2-5">どの場合でも、CDDLツールが実装のために「コードを作成」することを意図しているわけではありません。</t>
      </section>
      <section anchor="for-data-analysis-tools" numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-for-data-analysis-tools">For Data Analysis Tools</name>
        <t indent="0" pn="section-4.3-1">将来的には、CBORデータ形式を使用してより多くのデータが保存されることが予想されます。</t>
        <t indent="0" pn="section-4.3-2">データがある場所には、データ分析があり、そのようなデータを自動的に処理する必要があります。CDDLは、このような自動化されたデータ処理に使用することができ、ツールがデータを検証し、クリーンにし、興味のある特定の部分を抽出することができます。</t>
        <t indent="0" pn="section-4.3-3">CBORは制約のあるデバイスを想定して設計されているため、それの可能な利用は小さなセンサーです。興味深い利用例として、センサーデータの自動分析が挙げられます。</t>
      </section>
    </section>
    <section anchor="security-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-5-1">このドキュメントは、CBORデータ構造を表現するためのコンテンツルール言語を提案しています。そのため、CBORを使用するプロトコルの仕様には、その定義時にセキュリティ分析が必要ですが、そのセキュリティ上の問題はこのドキュメント自体にはありません。セキュリティ考慮事項の書き方に関する一般的なガイドラインは、<xref target="RFC3552" format="default" sectionFormat="of" derivedContent="RFC3552"/>（BCP 72）で定義されています。CDDLを使用してプロトコルでCBOR構造を定義する仕様は、これらのガイドラインに従う必要があります。CDDLを使用してCBOR構造を定義する仕様のセキュリティ考慮事項セクションで考慮すべき追加のトピックは、以下の通りです。</t>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-5-2">
        <li pn="section-5-2.1">言語がセキュリティ上の問題を引き起こす可能性がある箇所は、どのようなところですか？</li>
      </ul>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-5-3">
        <li pn="section-5-3.1">システムの実装の一部としてCDDLマッチャーが含まれている場合、システムのセキュリティは、CDDL仕様やCDDL実装の正確性に依存せず、さらなる防御策を採る必要があります。</li>
      </ul>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-5-4">
        <li pn="section-5-4.1">CDDL仕様に拡張ポイントが含まれている場合、システムのセキュリティへの拡張の影響を慎重に考慮する必要があります。</li>
      </ul>
      <t indent="0" pn="section-5-5">CDDL仕様の執筆者は、仕様の優雅さよりも明確さと透明性を重視するよう強く推奨されます。必要なデータモデルを表現しつつ、できるだけシンプルに保つことです。</t>
      <t indent="0" pn="section-5-6">CDDL仕様のライターが心に留めておくことを<strong><bcp14>強く推奨します</bcp14></strong>：CDDLが仕様で複雑さを扱いやすくするからといって、それによってその複雑さが何らかの意味で少なくなるわけではありません（おそらく、仕様を読む際に複雑な構造を把握する人間レベルでは少なくなるかもしれませんが）。</t>
    </section>
    <section anchor="iana-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <section anchor="cddl-control-operators-registry" numbered="true" removeInRFC="false" toc="include" pn="section-6.1">
        <name slugifiedName="name-cddl-control-operators-registry">CDDL Control Operators Registry</name>
        <t indent="0" pn="section-6.1-1">IANAは、制御オペレータ（セクション3.8）のためのレジストリを作成しました。 "CDDL制御オペレータ"のレジストリは、"簡潔なデータ定義言語（CDDL）"のレジストリ内に作成されました。</t>
        <t indent="0" pn="section-6.1-2">サブレジストリ内の各エントリは、制御演算子の名前（先頭のドットで指定される通例）とそのドキュメントへの参照を含める必要があります。名前は、付録Bの「id」で定義されるテキスト文字列に従った先頭のドットで構成されている必要があります。</t>
        <t indent="0" pn="section-6.1-3">このレジストリの最初のエントリは以下の通りです：</t>
        <t indent="0" pn="section-6.1-4"><table align="center">
            <thead>
              <tr>
                <tr>
                  <td align="left"> 名前</td>
                  <td align="left">ドキュメント</td>
                </tr>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left"> .size</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .bits</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .regexp</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .cbor</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .cborseq</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .within</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .and</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .lt</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .le</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .gt</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .ge</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .eq</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .ne</td>
                <td align="left">RFC 8610</td>
              </tr>
              <tr>
                <td align="left"> .default</td>
                <td align="left">RFC 8610</td>
              </tr>
            </tbody>
          </table>
        </t>
        <t indent="0" pn="section-6.1-5">他のすべての制御演算子名は未割り当てです。</t>
        <t indent="0" pn="section-6.1-6">このレジストリへの追加のためのIANA方針は、内部ドットを含まない名前に対しては「Specification Required」と定義された<xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>（専門家によるレビューを含む）とし、「内部ドットを含む名前に対しては「IETF Review」とします。レビューアに対しては、他の標準化団体（SDO）が特定の領域に固有の制御演算子を定義する可能性があること（たとえば、SDOで既に使用されているバイナリ構文に基づいて）を明示的に指示します。レビュー手続きは、そのような取り組みを促進するよう努めるべきです。</t>
      </section>
    </section>
  </middle>
  <back>
    <references pn="section-7">
      <name slugifiedName="name-references">References</name>
      <references pn="section-7.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="ISO6093" quoteTitle="true" derivedAnchor="ISO6093">
          <front>
            <title>Information processing -- Representation of numerical values in character strings for information interchange</title>
            <date year="1985"/>
          </front>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <date year="1997" month="March"/>
          </front>
          <seriesInfo name="BCP">14</seriesInfo>
          <seriesInfo name="RFC">2119</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC2119</seriesInfo>
        </reference>
        <reference anchor="RFC3552" target="https://www.rfc-editor.org/info/rfc3552" quoteTitle="true" derivedAnchor="RFC3552">
          <front>
            <title>Guidelines for Writing RFC Text on Security Considerations</title>
            <date year="2003" month="July"/>
          </front>
          <seriesInfo name="BCP">72</seriesInfo>
          <seriesInfo name="RFC">3552</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC3552</seriesInfo>
        </reference>
        <reference anchor="RFC3629" target="https://www.rfc-editor.org/info/rfc3629" quoteTitle="true" derivedAnchor="RFC3629">
          <front>
            <title>UTF-8, a transformation format of ISO 10646</title>
            <date year="2003" month="November"/>
          </front>
          <seriesInfo name="STD">63</seriesInfo>
          <seriesInfo name="RFC">3629</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC3629</seriesInfo>
        </reference>
        <reference anchor="RFC4648" target="https://www.rfc-editor.org/info/rfc4648" quoteTitle="true" derivedAnchor="RFC4648">
          <front>
            <title>The Base16, Base32, and Base64 Data Encodings</title>
            <date year="2006" month="October"/>
          </front>
          <seriesInfo name="RFC">4648</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC4648</seriesInfo>
        </reference>
        <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234" quoteTitle="true" derivedAnchor="RFC5234">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <date year="2008" month="January"/>
          </front>
          <seriesInfo name="STD">68</seriesInfo>
          <seriesInfo name="RFC">5234</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC5234</seriesInfo>
        </reference>
        <reference anchor="RFC7049" target="https://www.rfc-editor.org/info/rfc7049" quoteTitle="true" derivedAnchor="RFC7049">
          <front>
            <title>Concise Binary Object Representation (CBOR)</title>
            <date year="2013" month="October"/>
          </front>
          <seriesInfo name="RFC">7049</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC7049</seriesInfo>
        </reference>
        <reference anchor="RFC7493" target="https://www.rfc-editor.org/info/rfc7493" quoteTitle="true" derivedAnchor="RFC7493">
          <front>
            <title>The I-JSON Message Format</title>
            <date year="2015" month="March"/>
          </front>
          <seriesInfo name="RFC">7493</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC7493</seriesInfo>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <date year="2017" month="June"/>
          </front>
          <seriesInfo name="BCP">26</seriesInfo>
          <seriesInfo name="RFC">8126</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC8126</seriesInfo>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <date year="2017" month="May"/>
          </front>
          <seriesInfo name="BCP">14</seriesInfo>
          <seriesInfo name="RFC">8174</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC8174</seriesInfo>
        </reference>
        <reference anchor="RFC8259" target="https://www.rfc-editor.org/info/rfc8259" quoteTitle="true" derivedAnchor="RFC8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <date year="2017" month="December"/>
          </front>
          <seriesInfo name="STD">90</seriesInfo>
          <seriesInfo name="RFC">8259</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC8259</seriesInfo>
        </reference>
        <reference anchor="W3C.REC-xmlschema-2-20041028" target="https://www.w3.org/TR/2004/REC-xmlschema-2-20041028" quoteTitle="true" derivedAnchor="W3C.REC-xmlschema-2-20041028">
          <front>
            <title>XML Schema Part 2: Datatypes Second Edition</title>
            <date year="2004" month="October"/>
          </front>
        </reference>
      </references>
      <references pn="section-7.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="CDDL-Freezer" quoteTitle="true" derivedAnchor="CDDL-Freezer">
          <front>
            <title>A feature freezer for the Concise Data Definition Language (CDDL)</title>
            <date year="2018" month="August"/>
          </front>
        </reference>
        <reference anchor="GRASP" quoteTitle="true" derivedAnchor="GRASP">
          <front>
            <title>A Generic Autonomic Signaling Protocol (GRASP)</title>
            <date year="2017" month="July"/>
          </front>
        </reference>
        <reference anchor="IEEE754" quoteTitle="true" derivedAnchor="IEEE754">
          <front>
            <title>IEEE Standard for Floating-Point Arithmetic</title>
          </front>
          <seriesInfo name="IEEE">Std 754-2008</seriesInfo>
        </reference>
        <reference anchor="JCR" quoteTitle="true" derivedAnchor="JCR">
          <front>
            <title>A Language for Rules Describing JSON Content</title>
            <date year="2017" month="September"/>
          </front>
        </reference>
        <reference anchor="PEG" quoteTitle="true" derivedAnchor="PEG">
          <front>
            <title>Parsing expression grammars: a recognition- based syntactic foundation</title>
            <date year="2004" month="January"/>
          </front>
          <seriesInfo name="DOI">10.1145/964001.964011</seriesInfo>
        </reference>
        <reference anchor="RELAXNG" quoteTitle="true" derivedAnchor="RELAXNG">
          <front>
            <title>Information technology -- Document Schema Definition Language (DSDL) -- Part 2: Regular-grammar- based validation -- RELAX NG</title>
            <date year="2008" month="December"/>
          </front>
          <seriesInfo name="ISO/IEC">19757-2</seriesInfo>
        </reference>
        <reference anchor="RFC7071" target="https://www.rfc-editor.org/info/rfc7071" quoteTitle="true" derivedAnchor="RFC7071">
          <front>
            <title>A Media Type for Reputation Interchange</title>
            <date year="2013" month="November"/>
          </front>
          <seriesInfo name="RFC">7071</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC7071</seriesInfo>
        </reference>
        <reference anchor="RFC7950" target="https://www.rfc-editor.org/info/rfc7950" quoteTitle="true" derivedAnchor="RFC7950">
          <front>
            <title>The YANG 1.1 Data Modeling Language</title>
            <date year="2016" month="August"/>
          </front>
          <seriesInfo name="RFC">7950</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC7950</seriesInfo>
        </reference>
        <reference anchor="RFC8007" target="https://www.rfc-editor.org/info/rfc8007" quoteTitle="true" derivedAnchor="RFC8007">
          <front>
            <title>Content Delivery Network Interconnection (CDNI) Control Interface / Triggers</title>
            <date year="2016" month="December"/>
          </front>
          <seriesInfo name="RFC">8007</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC8007</seriesInfo>
        </reference>
        <reference anchor="RFC8152" target="https://www.rfc-editor.org/info/rfc8152" quoteTitle="true" derivedAnchor="RFC8152">
          <front>
            <title>CBOR Object Signing and Encryption (COSE)</title>
            <date year="2017" month="July"/>
          </front>
          <seriesInfo name="RFC">8152</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC8152</seriesInfo>
        </reference>
        <reference anchor="RFC8428" target="https://www.rfc-editor.org/info/rfc8428" quoteTitle="true" derivedAnchor="RFC8428">
          <front>
            <title>Sensor Measurement Lists (SenML)</title>
            <date year="2018" month="August"/>
          </front>
          <seriesInfo name="RFC">8428</seriesInfo>
          <seriesInfo name="DOI">10.17487/RFC8428</seriesInfo>
        </reference>
        <reference anchor="YAML" target="https://yaml.org/spec/1.2/spec.html" quoteTitle="true" derivedAnchor="YAML">
          <front>
            <title>YAML Ain't Markup Language (YAML[TM]) Version 1.2</title>
            <date year="2009" month="October"/>
          </front>
        </reference>
      </references>
    </references>
    <section anchor="parsing-expression-grammars-(pegs)" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-parsing-expression-grammars-(pegs)">Parsing Expression Grammars (PEGs)</name>
      <t indent="0" pn="section-appendix.a-1">この付録は規範的です。</t>
      <t indent="0" pn="section-appendix.a-2">1950年代以来、多くの文法表記は、文脈自由文法（CFG）のための表記法であるバッカス・ナウア形式（BNF）に基づいています。拡張バッカス・ナウア形式（ABNF）<xi:xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>は、IETFの仕様に広く使用され、またCDDLの構文にも影響を与えています。</t>
      <t indent="0" pn="section-appendix.a-3">生成文法は曖昧さをうまく表現することができますが、この特性が認識システムでの使用を困難にすることがあります。その結果、生成文法の制約をパーサージェネレータとの使用に課すいくつかの副方言が生まれることがあります。このシナリオは、仕様の作成者にとって管理が困難な場合があります。</t>
      <t indent="0" pn="section-appendix.a-4">PEG（<xref target="PEG" format="default" sectionFormat="of" derivedContent="PEG"/>）は、生成よりも認識を重視し、「優先度付き選択」という概念を導入することで、生成システムでは曖昧になっていたものを解決するための文法の形式的な基盤を提供します。</t>
      <t indent="0" pn="section-appendix.a-5">PEGの表記法はBNFに非常に近く、通常の「Extended BNF」の特徴である繰り返しのような要素が追加されています。ただし、BNFが無順序（対称）の選択演算子「|」（偶然にもABNFでは「/」と表記）を使用するのに対して、PEGは優先度の付いた選択演算子「/」を提供します。リストアップされた2つの代替案は、左から右の順にテストされ、最初に成功したマッチが確定し、選択肢内の他の潜在的なマッチは無視されます（ただし、この選択肢を含む選択肢内の代替案は無効にされません）。</t>
      <t indent="0" pn="section-appendix.a-6">たとえば、ABNF式</t>
      <t indent="0" pn="section-appendix.a-7"><artwork name="" type="" align="left" alt="">
   A = "a" "b" / "a"    (1)
</artwork>
        <artwork name="" type="" align="left" alt="">
   A = "a" "b" / "a"    (1)
</artwork>
      </t>
      <t indent="0" pn="section-appendix.a-8">そして</t>
      <t indent="0" pn="section-appendix.a-9"><artwork name="" type="" align="left" alt="">
   A = "a" / "a" "b"    (2)
</artwork>
        <artwork name="" type="" align="left" alt="">
   A = "a" / "a" "b"    (2)
</artwork>
      </t>
      <t indent="0" pn="section-appendix.a-10">ABNFの元の生成フレームワークでは等価ですが、PEGでは非常に異なります。 （2）では、2番目の選択肢は一致しないことがありません。なぜなら、「a」で始まる任意の入力文字列はすでに最初の選択肢で成功するため、マッチが確定しているからです。</t>
      <t indent="0" pn="section-appendix.a-11">同様に、出現インジケーター（「?」、「*」、「+」）はPEGでは「貪欲」であり、一致するだけの入力を消費します（その結果、「a* a」（PEG形式）または「*a a」（CDDL構文）は何も一致しない可能性がありません。なぜなら、最初の「a*」によってすべての「a」を一致させるために必要な入力が既に消費されているため、二番目の「a」に何も一致するものが残っていないからです）。</t>
      <t indent="0" pn="section-appendix.a-12">ついでに、付録Bに記載されているABNFで書かれたCDDL自体の文法は、（1）RFC 5234がもとになっている生成フレームワークで、または（2）PEGとして解釈することができます。これは、文法の選択肢を順序立てて並べることにより、左側の"/"演算子によって成功したマッチは常に意図したマッチであるため、対称的な選択肢のパワーに頼るのではなく実現されました（たとえば、"uint"のルールの選択肢の順序に注目してください。ゼロで始まるよりも長いマッチの選択肢の後ろにゼロだけがあります）。</t>
      <t indent="0" pn="section-appendix.a-13">CDDLのPEGコンポーネントを表現するために使用される構文は、PEGのセマンティクスをもって明らかな方法で解釈されるABNFに基づいています。制御された主要な要素の前に発生指示子を示すABNFの規約、および"*"の記号を周囲の最小および最大発生回数に数値値を許可する規約がコピーされています。PEGは文字に関するものであり、CDDLは型やグループといったより豊富な要素のセットを持っています。具体的には、以下の構成要素がマッピングされます。</t>
      <t indent="0" pn="section-appendix.a-14"><table align="center">
          <thead>
            <tr>
              <tr>
                <td align="left">CDDL</td>
                <td align="left">PEG</td>
                <td align="left">備考                                    </td>
              </tr>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">"="<bcp14>することになります</bcp14></td>
              <td align="left">"&lt;-"</td>
              <td align="left">"/="および"/=/"は省略形です              </td>
            </tr>
            <tr>
              <td align="left">"//"</td>
              <td align="left">"/"</td>
              <td align="left">優先順位付きの選択                        </td>
            </tr>
            <tr>
              <td align="left">"/"</td>
              <td align="left">"/"</td>
              <td align="left">優先順位付きの選択、型のみに制限される </td>
            </tr>
            <tr>
              <td align="left">"?" P</td>
              <td align="left">P "?"</td>
              <td align="left">0個または1個                               </td>
            </tr>
            <tr>
              <td align="left">"*" P</td>
              <td align="left">P "*"</td>
              <td align="left">0個以上                              </td>
            </tr>
            <tr>
              <td align="left">"+" P</td>
              <td align="left">P "+"</td>
              <td align="left">1個以上                               </td>
            </tr>
            <tr>
              <td align="left">A B</td>
              <td align="left">A B</td>
              <td align="left">順序                                  </td>
            </tr>
            <tr>
              <td align="left">A, B</td>
              <td align="left">A B</td>
              <td align="left">順序、カンマは装飾のみ        </td>
            </tr>
          </tbody>
        </table>
      </t>
      <t indent="0" pn="section-appendix.a-15">The literal notation and the use of square brackets, curly braces,
tildes, ampersands, and hash marks are specific to CDDL and unrelated
to the conventional PEG notation.  The DOT (".") from PEG is replaced
by the unadorned "#" or its alias "any".  Also, CDDL does not provide
the syntactic predicate operators NOT ("!") or AND ("&amp;") from PEG,
reducing expressiveness as well as complexity.</t>
      <t indent="0" pn="section-appendix.a-16">PEGの理論的な基礎や、結びつき方や配布性などの演算子の興味深い特性についての詳細については、<xref target="PEG" format="default" sectionFormat="of" derivedContent="PEG"/>を参照してください。</t>
    </section>
    <section anchor="abnf-grammar" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-abnf-grammar">ABNF Grammar</name>
      <t indent="0" pn="section-appendix.b-1">この付録は規範的です。</t>
      <t indent="0" pn="section-appendix.b-2">以下は、CDDL構文のABNFによる形式的な定義です。ABNFに定義されている通り、以下の引用符で囲まれた文字列は大文字小文字を区別しません（CDDLでは文字列の値と名前は大文字小文字を区別します）。「<xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>」。</t>
      <t indent="0" pn="section-appendix.b-3"><artwork name="" type="" align="left" alt="">
  cddl = S 1*(rule S)
  rule = typename [genericparm] S assignt S type
       / groupname [genericparm] S assigng S grpent
</artwork>
        <artwork name="" type="" align="left" alt="">
  cddl = S 1*(rule S)
  rule = typename [genericparm] S assignt S type
       / groupname [genericparm] S assigng S grpent
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-4"><artwork name="" type="" align="left" alt="">
  typename = id
  groupname = id
</artwork>
以下のように翻訳されます：

<artwork name="" type="" align="left" alt="">
  typename = id
  groupname = id
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-5"><artwork name="" type="" align="left" alt="">
  assignt = "=" / "/="
  assigng = "=" / "//="
</artwork>
        <artwork name="" type="" align="left" alt="">
  assignt = "=" / "/="
  assigng = "=" / "//="
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-6">【記事】
<artwork name="" type="" align="left" alt="">
  genericparm = "&lt;" S id S *("," S id S ) "&gt;"
  genericarg = "&lt;" S type1 S *("," S type1 S ) "&gt;"
</artwork>

【翻訳】
<artwork name="" type="" align="left" alt="">
  genericparm = "&lt;" S id S *("," S id S ) "&gt;"
  genericarg = "&lt;" S type1 S *("," S type1 S ) "&gt;"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-7"><artwork name="" type="" align="left" alt="">
  type = type1 *(S "/" S type1)
</artwork>
        <artwork name="" type="" align="left" alt="">
  type = type1 *(S "/" S type1)
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-8"><artwork name="" type="" align="left" alt="">
  type1 = type2 [S (rangeop / ctlop) S type2]
  ; もし type2 が名前で終わるならば、演算子の前にスペースを入れる必要がある場合もあります
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-9"><artwork name="" type="" align="left" alt="">
  type2 = value
        / typename [genericarg]
        / "(" S type S ")"
        / "{" S group S "}"
        / "[" S group S "]"
        / "~" S typename [genericarg]
        / "&amp;" S "(" S group S ")"
        / "&amp;" S groupname [genericarg]
        / "#" "6" ["." uint] "(" S type S ")"
        / "#" DIGIT ["." uint]                ; major/ai
        / "#"                                 ; any
</artwork>
        <artwork name="" type="" align="left" alt="">
type2 = value
/ typename [genericarg]
/ "（" S type S "）"
/ "｛" S group S "｝"
/ "［" S group S "］"
/ "〜" S typename [genericarg]
/ "&amp;" S "（" S group S "）"
/ "&amp;" S groupname [genericarg]
/ "#" "6" ["." uint] "（" S type S "）"
/ "#" DIGIT ["." uint]                ; major/ai
/ "#"                                 ; any
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-10"><artwork name="" type="" align="left" alt="">
  rangeop = "..." / ".."
</artwork>
        <artwork name="" type="" align="left" alt="">
  rangeop = "..." / ".."
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-11"><artwork name="" type="" align="left" alt="">
  ctlop = "." id
</artwork>
        <artwork name="" type="" align="left" alt="">
  ctlop = "." id
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-12"><artwork name="" type="" align="left" alt="">
  グループ = grpchoice *(S "//" S grpchoice)
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-13"><artwork name="" type="" align="left" alt="">
  grpchoice = *(grpent optcom)
  grpent = [occur S] [memberkey S] type
         / [occur S] groupname [genericarg]  ; preempted by above
         / [occur S] "(" S group S ")"
</artwork>
        <artwork name="" type="" align="left" alt="">
  grpchoice = *(grpent optcom)
  grpent = [occur S] [memberkey S] type
         / [occur S] groupname [genericarg]  ; 上記により優先
         / [occur S] "(" S group S ")"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-14"><artwork name="" type="" align="left" alt="">
  memberkey = type1 S ["^" S] "=&gt;"
            / bareword S ":"
            / value S ":"
</artwork>
        <artwork name="" type="" align="left" alt="">
  memberkey = type1 S ["^" S] "=&gt;"
            / bareword S ":"
            / value S ":"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-15"><artwork name="" type="" align="left" alt="">
  bareword = id
</artwork>
        <artwork name="" type="" align="left" alt="">
  裸の単語 = 識別子
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-16"><artwork name="" type="" align="left" alt="">
  optcom = S ["," S]
</artwork>
        <artwork name="" type="" align="left" alt="">
  optcom = S ["," S]
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-17"><artwork name="" type="" align="left" alt="">
  occur = [uint] "*" [uint]
        / "+"
        / "?"
</artwork>
        <artwork name="" type="" align="left" alt="">
  occur = [uint] "*" [uint]
        / "+"
        / "?"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-18"><artwork name="" type="" align="left" alt="">
  uint = DIGIT1 *DIGIT
       / "0x" 1*HEXDIG
       / "0b" 1*BINDIG
       / "0"
</artwork>
        <artwork name="" type="" align="left" alt="">
  uint = DIGIT1 *DIGIT
       / "0x" 1*HEXDIG
       / "0b" 1*BINDIG
       / "0"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-19"><artwork name="" type="" align="left" alt="">
  value = 数値
        / テキスト
        / バイト
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-20"><artwork name="" type="" align="left" alt="">
  int = ["-"] uint
</artwork>
        <artwork name="" type="" align="left" alt="">
  int = ["-"] uint
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-21"><artwork name="" type="" align="left" alt="">
  ; 小数部や指数部を持つ場合は浮動小数点数です；それ以外の場合は整数です
  number = hexfloat / (int [ "." fraction ] [ "e" exponent ])
  hexfloat = ["-"] "0x" 1*HEXDIG [ "." 1*HEXDIG ] "p" exponent
  fraction = 1*DIGIT
  exponent = [ "+" / "-" ] 1*DIGIT
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-22"><artwork name="" type="" align="left" alt="">
  text = %x22 *SCHAR %x22
  SCHAR = %x20-21 / %x23-5B / %x5D-7E / %x80-10FFFD / SESC
  SESC = "\" (%x20-7E / %x80-10FFFD)
</artwork>
        <artwork name="" type="" align="left" alt="">
  text = %x22 *SCHAR %x22
  SCHAR = %x20-21 / %x23-5B / %x5D-7E / %x80-10FFFD / SESC
  SESC = "\" (%x20-7E / %x80-10FFFD)
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-23"><artwork name="" type="" align="left" alt="">
  bytes = [bsqual] %x27 *BCHAR %x27
  BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF
  bsqual = "h" / "b64"
  id = EALPHA *(*("-" / ".") (EALPHA / DIGIT))
  ALPHA = %x41-5A / %x61-7A
  EALPHA = ALPHA / "@" / "_" / "$"
  DIGIT = %x30-39
  DIGIT1 = %x31-39
  HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
  BINDIG = %x30-31
</artwork>
        <artwork name="" type="" align="left" alt="">
  bytes = [bsqual] %x27 *BCHAR %x27
  BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF
  bsqual = "h" / "b64"
  id = EALPHA *(*("-" / ".") (EALPHA / DIGIT))
  ALPHA = %x41-5A / %x61-7A
  EALPHA = ALPHA / "@" / "_" / "$"
  DIGIT = %x30-39
  DIGIT1 = %x31-39
  HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
  BINDIG = %x30-31
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-24"><artwork name="" type="" align="left" alt="">
  S = *WS
  WS = SP / NL
  SP = %x20
  NL = COMMENT / CRLF
  COMMENT = ";" *PCHAR CRLF
  PCHAR = %x20-7E / %x80-10FFFD
  CRLF = %x0A / %x0D.0A
</artwork>
        <artwork name="" type="" align="left" alt="">
  S = *WS
  WS = SP / NL
  SP = %x20
  NL = COMMENT / CRLF
  COMMENT = ";" *PCHAR CRLF
  PCHAR = %x20-7E / %x80-10FFFD
  CRLF = %x0A / %x0D.0A
</artwork>
      </t>
      <t indent="0" pn="section-appendix.b-25"><figure anchor="fig-13" align="left" suppress-title="false" pn="figure-13">
          <name slugifiedName="name-figure-13">CDDL ABNF</name>
          <artwork name="" type="" align="left" alt="">

</artwork>
        </figure>
        <fig-13 anchor="fig-13" align="left" suppress-title="false" pn="figure-13">
          <name slugifiedName="name-figure-13">CDDL ABNF</name>
          <artwork name="" type="" align="left" alt="">

</artwork>
        </fig-13>
      </t>
      <t indent="0" pn="section-appendix.b-26">注意：このABNFは、接頭辞付きバイト文字列に含まれる詳細なルールを反映しようとはしていません。</t>
    </section>
    <section anchor="matching-rules" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-matching-rules">Matching Rules</name>
      <t indent="0" pn="section-appendix.c-1">この付録は規範的です。</t>
      <t indent="0" pn="section-appendix.c-2">この付録では、付録Bで定義されたABNF構文規則を確認し、各構文的機能の一致する意味論を簡単に説明します。この文脈では、CDDL仕様によって許可される場合、インスタンス（データアイテム）はCDDL仕様に「一致」します。これは、仕様の一部（型およびグループ式）とインスタンスの一部（データアイテム）に分割されます。</t>
      <t indent="0" pn="section-appendix.c-3"><cddl>はS1*(rule S)である必要があります（MUST）</cddl>
      </t>
      <t indent="0" pn="section-appendix.c-4">A CDDL specification is a sequence of one or more rules. Each rule gives a name to a right-hand-side expression, either a CDDL type or a CDDL group. Rule names can be used in the rule itself and/or other rules (and tools can output warnings if that is not the case). The order of the rules is significant only in two cases:

CDDL仕様は1つ以上のルールのシーケンスです。各ルールは、CDDLの型またはCDDLグループのどちらかを右辺式に名前を付けます。ルール名は、そのルール自体および/または他のルールで使用できます（ツールは、そうでない場合に警告を出力できます）。ルールの順序は、2つの場合にのみ重要です：</t>
      <t indent="0" pn="section-appendix.c-5">最初のルールは仕様の意味を定義します。したがって、そのルートルールに特別な名前や特別な構文を与える必要はありません（例えば、RELAX NGの「start」のように）。その名前は、説明的なものに選択することができます。（初期ルールの名前は他のルール内またはそれ自体で使用することも可能ですが、他のルール名と同様です。）</t>
      <t indent="0" pn="section-appendix.c-6">2. ルールが型またはグループの選択肢に貢献する場合（「/ =」または「// =」を使用する場合）、その選択肢はルールが与えられた順序で選択されます。以下を参照してください。</t>
      <t indent="0" pn="section-appendix.c-7">ルール = タイプ名[ジェネリックパラメータ] S assignt S タイプ/ グループ名[ジェネリックパラメータ] S assigng S grpent</t>
      <t indent="0" pn="section-appendix.c-8">typename = 識別子 groupname = 識別子</t>
      <t indent="0" pn="section-appendix.c-9">ルールは、タイプ式（「type」プロダクション）またはグループ式（「grpent」プロダクション）に対して名前を定義します。この名前が、（必要に応じて括弧で囲まれた）定義に置き換えられた際に、意味が変わらないように意図されています。なお、ルールによって定義される名前がタイプを表すのか、グループを表すのかは、常に構文だけで判断されるわけではありません。たとえば、「a = b」は、「b」がタイプであれば「a」をタイプにすることができますし、もし「b」がグループであれば「a」をグループにすることもできます。さらに、"a = (b)"の場合では、もし「b」がタイプであれば「a」はタイプとして使用されるかもしれませんし、もし「b」がグループであっても、また「b」がタイプであっても「a」はグループとして使用されるかもしれません（後者の場合を人間の読者に明確にするための良い規約としては、"a = (b,)"と書くことです）。なお（式内でのかっこの二重の意味についても同様ですが、しばしばかっこの文脈から解決できることがあります）、一般的なポイントとしては、即座に「b」がグループを表すのか、タイプを表すのかは明確ではない場合があります。このような意味処理は、判断が下されるまでにいくつかのレベルのルール定義をまたいで行われることがあります。</t>
      <t indent="0" pn="section-appendix.c-10">assignt = "=" / "/="
assigng = "=" / "//="

assignt = "=" / "/="
assigng = "=" / "//="</t>
      <t indent="0" pn="section-appendix.c-11"><bcp14>単純な等号記号は、右側の式と同等のルール名を定義します。既に異なる式で名前が定義されている場合、エラーになります。"/="または"//="は、追加の選択肢によって名前付きタイプまたはグループを拡張します。これらのいくつかは、すべての右辺を収集し、与えられた規則の順序で右辺から作成されたタイプの選択またはグループの選択から単一のルールが作成されることによって置き換えることができます。（まだ定義されていないルール名を拡張することはエラーではありません。これにより、右辺が作成中の選択の最初のエントリになります。）</bcp14></t>
      <t indent="0" pn="section-appendix.c-12">genericparm = "&lt;" S id S *("," S id S ) "&gt;"
genericarg = "&lt;" S type1 S *("," S type1 S ) "&gt;"</t>
      <t indent="0" pn="section-appendix.c-13">ルール名にはジェネリックパラメータを持つことができます。これにより、ルール名を引用する際に指定された引数から、右辺に一時的な割り当てが行われます。</t>
      <t indent="0" pn="section-appendix.c-14">type = type1 *(S "/" S type1) A type can be given as a choice between one or more types. The choice matches a data item if the data item matches any one of the types given in the choice. The choice uses PEG semantics as discussed in Appendix A: the first choice that matches wins. (As a result, the order of rules that contribute to a single rule name can very well matter.)

type = type1 *(S "/" S type1) 型は1つ以上の型の選択肢として指定できます。選択肢は、データアイテムが選択肢で指定されたいずれかの型と一致する場合、データアイテムと一致します。選択肢は、付録Aで議論されているPEGセマンティクスを使用します。最初に一致する選択肢が勝利します。（その結果、単一のルール名に寄与するルールの順序は非常に重要です。）</t>
      <t indent="0" pn="section-appendix.c-15">type1 = type2 [S（rangeop / ctlop）S type2]</t>
      <t indent="0" pn="section-appendix.c-16">2つのタイプは、範囲演算子（以下参照）または制御演算子（セクション3.8を参照）と組み合わせることができます。</t>
      <t indent="0" pn="section-appendix.c-17">type2 = 値</t>
      <t indent="0" pn="section-appendix.c-18">一つのタイプは単一の値（例えば1や "アイスクリーム"や h'0815'）であり、それは特定の値に一致するデータアイテムにのみ対応します（変換は定義されていません）。</t>
      <t indent="0" pn="section-appendix.c-19"><artwork name="" type="" align="left" alt="">
   / typename [genericarg]
</artwork>
        <artwork name="" type="" align="left" alt="">
   / typename [genericarg]
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-20">または、名前に意味を与える規則によって定義される場合もあります（ジェネリックパラメータが必要な場合、必要に応じて一般的な引数を提供した後で）。</t>
      <t indent="0" pn="section-appendix.c-21"><artwork name="" type="" align="left" alt="">
   / "(" S type S ")"
</artwork>
        <artwork name="" type="" align="left" alt="">
   / "(" S タイプ S ")"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-22">または、括弧で囲まれた型式の表現で定義される場合もあります（一部の演算子の優先順位を上書きするためには括弧が必要です）。</t>
      <t indent="0" pn="section-appendix.c-23"><artwork name="" type="" align="left" alt="">
   / "{" S group S "}"
</artwork>
        <artwork name="" type="" align="left" alt="">
   / "{" S グループ S "}"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-24">「<bcp14>MUST</bcp14>」、「<bcp14>MUST NOT</bcp14>」、「<bcp14>REQUIRED</bcp14>」、「<bcp14>SHALL</bcp14>」、「<bcp14>SHALL NOT</bcp14>」、「<bcp14>SHOULD</bcp14>」、「<bcp14>SHOULD NOT</bcp14>」、「<bcp14>RECOMMENDED</bcp14>」、「<bcp14>NOT RECOMMENDED</bcp14>」、「<bcp14>MAY</bcp14>」、および「<bcp14>OPTIONAL</bcp14>」キーワードは、「<bcp14>しなければなりません（MUST）</bcp14>」、「<bcp14>してはなりません（MUST NOT）</bcp14>」、「<bcp14>要求されています（REQUIRED）</bcp14>」、「<bcp14>することになります（SHALL）</bcp14>」、「<bcp14>することはありません（SHALL NOT）</bcp14>」、「<bcp14>すべきです（SHOULD）</bcp14>」、「<bcp14>すべきではありません（SHOULD NOT）</bcp14>」、「<bcp14>推奨されます（RECOMMENDED）</bcp14>」、「<bcp14>推奨されません（NOT RECOMMENDED）</bcp14>」、「<bcp14>してもよいです（MAY）</bcp14>」、「<bcp14>選択できます（OPTIONAL）</bcp14>」と翻訳されます。

「a map expression, which matches a valid CBOR map the key/value pairs of which can be ordered in such a way that the resulting sequence matches the group expression, or」は日本語に翻訳すると、「結果のシーケンスがグループ式に一致するように、キー/値のペアを順序付けることができる有効なCBORマップと一致するマップ式、または」になります。</t>
      <t indent="0" pn="section-appendix.c-25"><artwork name="仮" type="仮" align="左" alt="">
   / "[" S group S "]"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-26">配列式は、各要素がグループと一致する場合に、値とワイルドカード（任意のものと一致する）キーとの補足を受けているCBOR配列と一致します。</t>
      <t indent="0" pn="section-appendix.c-27"><artwork name="" type="" align="left" alt="">
   / "~" S typename [genericarg]
</artwork>
        <artwork name="" type="" align="left" alt="">
   / "~" S typename [genericarg]
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-28">「アンラップされた」グループ（セクション3.7を参照）は、グループを包むことで定義された型内のグループに一致する。</t>
      <t indent="0" pn="section-appendix.c-29"><artwork name="" type="" align="left" alt="">
   / "<bcp14>そして</bcp14>" S "<bcp14>（</bcp14>" S group S "<bcp14>）</bcp14>"
   / "<bcp14>そして</bcp14>" S groupname [genericarg]
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-30">列挙式は、与えられたグループの値を取ることができる値の集合内の任意の値と一致するものとして扱われます。</t>
      <t indent="0" pn="section-appendix.c-31"><artwork name="" type="" align="left" alt="">
   / "#" "6" ["." uint] "(" S type S ")"
</artwork>
        <artwork name="" type="" align="left" alt="">
   / "#" "6" ["." uint] "(" S type S ")"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-32">タグ付きのデータ項目で、与えられた「uint」でタグ付けされ、タグ付きの値として与えられたタイプを含んでいます。または</t>
      <t indent="0" pn="section-appendix.c-33"><artwork name="" type="" align="left" alt="">
   / "#" DIGIT ["." uint]                ; major/ai
</artwork>
        <artwork name="" type="" align="left" alt="">
   / "#" DIGIT ["." uint]                ; major/ai
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-34">デジットによって与えられた主要なタイプ（データ項目）は、必要に応じてuintによって与えられた追加情報に制約される場合があります。</t>
      <t indent="0" pn="section-appendix.c-35"><artwork name="" type="" align="left" alt="">
   / "#"                                 ; 任意の文字
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-36">任意のデータ項目。</t>
      <t indent="0" pn="section-appendix.c-37">rangeop = "..." / ".."
rangeop =「...」/「..」</t>
      <t indent="0" pn="section-appendix.c-38">範囲演算子は、2つの整数値または2つの浮動小数点値を表す2つの型式を結合するために使用できます。その演算子は、2つの値の間にある任意の値にマッチし、最初の値は常にマッチングセットに含まれ、2番目の値は「..」の場合は含まれ、「...」の場合は除外されます。</t>
      <t indent="0" pn="section-appendix.c-39">ctlop = "." ID</t>
      <t indent="0" pn="section-appendix.c-40">制御演算子は、セクション3.8で定義された「_target_」タイプを「_controller_」タイプに関連付けます。制御演算子はCDDLの拡張ポイントであることに注意してください。追加のドキュメントでは、追加の制御演算子を定義することも可能です。</t>
      <t indent="0" pn="section-appendix.c-41">グループ = grpchoice *(S "//" S grpchoice)</t>
      <t indent="0" pn="section-appendix.c-42">与えられた選択肢のいずれかに一致するキー/値のシーケンスに一致するグループ（再びPEGセマンティクスを使用して）</t>
      <t indent="0" pn="section-appendix.c-43">grpchoice = *(grpent optcom)

grpchoice = *(grpent optcom)</t>
      <t indent="0" pn="section-appendix.c-44">各コンポーネントグループは、グループエントリのシーケンスとして与えられます。一致するためには、与えられたシーケンスのキー/値ペアのシーケンスが、与えられたシーケンスのグループエントリのシーケンスと一致する必要があります。</t>
      <t indent="0" pn="section-appendix.c-45">grpent = [occur S] [memberkey S] type

grpent = [occur S] [memberkey S] タイプ</t>
      <t indent="0" pn="section-appendix.c-46">グループエントリは、値型によって指定されることがあります。この値型は、単一要素の値部分と一致する必要があります。また、メンバーキーが指定されている場合は、メンバーキー型も指定することができます。メンバーキーが指定されていない場合、エントリはマップではなく配列の一致にのみ使用できます。（発生指示子によってどのように変更されるかについては、以下を参照してください。）</t>
      <t indent="0" pn="section-appendix.c-47"><アートワーク name="" type="" align="left" alt="">
    / [occur S] groupname [genericarg]  ; 上記によって妨害されます
</アートワーク>
      </t>
      <t indent="0" pn="section-appendix.c-48">グループエントリは、名前付きグループから構築することができます。または</t>
      <t indent="0" pn="section-appendix.c-49"><artwork name="" type="" align="left" alt="">
    / [occur S] "(" S group S ")"
</artwork>
      </t>
      <t indent="0" pn="section-appendix.c-50">カッコで囲まれたグループから、再度、可能な出現指示子と共に。</t>
      <t indent="0" pn="section-appendix.c-51">memberkey = type1 S ["^" S] "=&gt;" / bareword S ":" / value S ":"

memberkey = type1 S ["^" S] "=&gt;" / bareword S ":" / value S ":"
メンバーキー = タイプ1 S ["^" S] "=&gt;" / ベアワード S ":" / 値 S ":"</t>
      <t indent="0" pn="section-appendix.c-52">キータイプは、タイプ式、ベアワード（このベアワードから作成された文字列の値を含むタイプを表す）、または値（この値を含むタイプを表す）で指定することができます。キーの値は、そのキータイプのメンバーである場合、前のエントリで "^" または ":" で示されるカットの存在がマップマッチングに影響を与えることがない限り、キーのタイプに一致します（カットの影響については、セクション 3.5.4 を参照してください）。</t>
      <t indent="0" pn="section-appendix.c-53">bareword = id</t>
      <t indent="0" pn="section-appendix.c-54"><bcp14>A bareword is an alternative way to write a type with a single text string value; it can only be used in the syntactic context given above.</bcp14> → 「<bcp14>bareword</bcp14> は単一のテキスト文字列値で型を表すための代替的な方法です。これは上記の構文的な文脈でのみ使用できます。」</t>
      <t indent="0" pn="section-appendix.c-55">optcom = S ["," S]

optcom = S ["," S]</t>
      <t indent="0" pn="section-appendix.c-56">（オプションのカンマは、マッチングに影響を与えません。）</t>
      <t indent="0" pn="section-appendix.c-57">発生 = [uint] "*" [uint] / "+" / "?"</t>
      <t indent="0" pn="section-appendix.c-58">発生指示子は、一定回数（セクション3.2を参照）連続して一致するように、その右側に与えられたグループを修正します。つまり、（無限かもしれない）グループ選択として機能し、各発生回数ごとにグループを繰り返します。</t>
      <t indent="0" pn="section-appendix.c-59">ABNFの残りは、値表記の構文を説明しており、プログラミング言語の読者には馴染みのあるものです。ただし、h'..'とb64'..'のようなバイト文字列や、コメントや行末のような構文要素は除きます。</t>
    </section>
    <section anchor="standard-prelude" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.d">
      <name slugifiedName="name-standard-prelude">Standard Prelude</name>
      <t indent="0" pn="section-appendix.d-1">この付録は正式なものです。<bcp14>MUST</bcp14></t>
      <t indent="0" pn="section-appendix.d-2">次の序文は、各CDDLファイルに自動的に追加されます。（技術的には、これは事実上の後記であるため、定義のルートとして最初の規則の選択を妨げるものではありません。）</t>
      <t indent="0" pn="section-appendix.d-3"><artwork name="" type="" align="left" alt="">
               任意 = #
</artwork>
      </t>
      <t indent="0" pn="section-appendix.d-4"><artwork name="" type="" align="left" alt="">
               uint = #0
               nint = #1
               int = uint / nint
</artwork>
        <artwork name="" type="" align="left" alt="">
               uint = #0
               nint = #1
               int = uint / nint
</artwork>
      </t>
      <t indent="0" pn="section-appendix.d-5"><artwork name="" type="" align="left" alt="">
               bstr = #2
               bytes = bstr
               tstr = #3
               text = tstr
</artwork>
        <artwork name="" type="" align="left" alt="">
               bstr = #2
               bytes = bstr
               tstr = #3
               text = tstr
</artwork>
      </t>
      <t indent="0" pn="section-appendix.d-6"><bcp14>しなければなりません（MUST）</bcp14>
        <artwork name="" type="" align="left" alt="">
               tdate = #6.0(tstr)
               time = #6.1(number)
               number = int / float
               biguint = #6.2(bstr)
               bignint = #6.3(bstr)
               bigint = biguint / bignint
               integer = int / bigint
               unsigned = uint / biguint
               decfrac = #6.4([e10: int, m: integer])
               bigfloat = #6.5([e2: int, m: integer])
               eb64url = #6.21(any)
               eb64legacy = #6.22(any)
               eb16 = #6.23(any)
               encoded-cbor = #6.24(bstr)
               uri = #6.32(tstr)
               b64url = #6.33(tstr)
               b64legacy = #6.34(tstr)
               regexp = #6.35(tstr)
               mime-message = #6.36(tstr)
               cbor-any = #6.55799(any)
               float16 = #7.25
               float32 = #7.26
               float64 = #7.27
               float16-32 = float16 / float32
               float32-64 = float32 / float64
               float = float16-32 / float64
</artwork>
      </t>
      <t indent="0" pn="section-appendix.d-7"><artwork name="" type="" align="left" alt="">
               false = #7.20
               true = #7.21
               bool = false / true
               nil = #7.22
               null = nil
               undefined = #7.23
</artwork>
        <artwork name="" type="" align="left" alt="">
               false = #7.20
               true = #7.21
               bool = false / true
               nil = #7.22
               null = nil
               undefined = #7.23
</artwork>
      </t>
      <t indent="0" pn="section-appendix.d-8"><figure anchor="fig-14" align="left" suppress-title="false" pn="figure-14">
          <name slugifiedName="name-figure-14">CDDL Prelude</name>
          <artwork name="" type="" align="left" alt="">

</artwork>
        </figure>
      </t>
      <t indent="0" pn="section-appendix.d-9">前文は固定されていると見なされます。つまり、例えば、<xref target="RFC7049" format="default" sectionFormat="of" derivedContent="RFC7049"/>に定義されている以外の追加のタグは、それらを使用している各CDDLファイルで定義する必要があります。</t>
      <t indent="0" pn="section-appendix.d-10"><pre>よくある落とし穴は、プレリュードが "string" という型を定義していないことです。CBOR にはバイト文字列（プレリュードでは "bytes"）とテキスト文字列（"text"）があり、単に "string" と呼ばれる型はあいまいです。</pre>
      </t>
    </section>
    <section anchor="use-with-json" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.e">
      <name slugifiedName="name-use-with-json">Use with JSON</name>
      <t indent="0" pn="section-appendix.e-1">この付録は規範的です。</t>
      <t indent="0" pn="section-appendix.e-2">JSONの一般的なデータモデル（<xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/>で暗黙的に表されます）は、CBORの一般的なデータモデルのサブセットです。そのため、JSONでCDDLを使用する場合は、JSONで表現できるものに自分自身を制限することができます。大まかに言えば、これはバイト文字列、タグ、および「false」、「true」、「null」以外の単純な値を除外することを意味し、以下の限定的な前文が得られます。</t>
      <t indent="0" pn="section-appendix.e-3"><artwork name="" type="" align="left" alt="">
                   any = #
</artwork>
        <artwork name="" type="" align="left" alt="">
                   任意 = #
</artwork>
      </t>
      <t indent="0" pn="section-appendix.e-4"><artwork name="" type="" align="left" alt="">
                   uint = #0
                   nint = #1
                   int = uint / nint
</artwork>
        <artwork name="" type="" align="left" alt="">
                   uint = #0
                   nint = #1
                   int = uint / nint
</artwork>
      </t>
      <t indent="0" pn="section-appendix.e-5"><artwork name="" type="" align="left" alt="">
     tstr = #3
     text = tstr
</artwork>
        <artwork name="" type="" align="left" alt="">
     tstr = #3
     text = tstr
</artwork>
      </t>
      <t indent="0" pn="section-appendix.e-6"><artwork name="" type="" align="left" alt="">
                  number = int / float
</artwork>
        <artwork name="" type="" align="left" alt="">
                  number = 整数 / 浮動小数点数
</artwork>
      </t>
      <t indent="0" pn="section-appendix.e-7"><artwork name="" type="" align="left" alt="">
                   float16 = #7.25
                   float32 = #7.26
                   float64 = #7.27
                   float16-32 = float16 / float32
                   float32-64 = float32 / float64
                   float = float16-32 / float64
</artwork>
        <artwork name="" type="" align="left" alt="">
                   float16 = #7.25
                   float32 = #7.26
                   float64 = #7.27
                   float16-32 = float16 / float32
                   float32-64 = float32 / float64
                   float = float16-32 / float64
</artwork>
      </t>
      <t indent="0" pn="section-appendix.e-8"><artwork name="" type="" align="left" alt="">
                   false = #7.20
                   true = #7.21
                   bool = false / true
                   nil = #7.22
                   null = nil
</artwork>
        <artwork name="" type="" align="left" alt="">
                   false = #7.20
                   true = #7.21
                   bool = false / true
                   nil = #7.22
                   null = nil
</artwork>
      </t>
      <t indent="0" pn="section-appendix.e-9"><figure anchor="fig-15" align="left" suppress-title="false" pn="figure-15">
          <name slugifiedName="name-figure-15">JSON-Compatible Subset of CDDL Prelude</name>
          <artwork name="" type="" align="left" alt="">

</artwork>
        </figure>
        <figure anchor="fig-15" align="left" suppress-title="false" pn="figure-15">
          <name slugifiedName="name-figure-15">JSON-Compatible Subset of CDDL Prelude（あらすじ）</name>
          <artwork name="" type="" align="left" alt="">

</artwork>
        </figure>
      </t>
      <t indent="0" pn="section-appendix.e-10">ここで示されている主要なタイプは、JSONに直接の意味を持っていませんが、CBORの主要なタイプとして解釈することができます。これは、<xref target="RFC7049" section="4" format="default" sectionFormat="of" derivedLink="https://www.rfc-editor.org/rfc/rfc7049#section-4" derivedContent="RFC7049"/>を通じて変換されます。</t>
      <t indent="0" pn="section-appendix.e-11">JSONを使用する際には、いくつかの細かいポイントがあります。まず、JSONでは整数と浮動小数点数を区別しません。数値にはただ一種類の数値（整数になることもある）しかありません。この文脈では、「uint」、「nint」、または「int」という型を指定することは、数値が整数であることを条件とする述語となります。例えば、次のJSONの数値はすべて「uint」と一致します。</t>
      <t indent="0" pn="section-appendix.e-12"><artwork name="" type="" align="left" alt="">
   10 10.0 1e1 1.0e1 100e-1
</artwork>
        <artwork name="" type="" align="left" alt="">
   10 10.0 1e1 1.0e1 100e-1
</artwork>
      </t>
      <t indent="0" pn="section-appendix.e-13">これらがすべて整数であるという事実は、プログラミング言語の長い伝統で小数点や指数を使用して浮動小数点数リテラルを表すことに慣れているユーザーには驚くかもしれません。</t>
      <t indent="0" pn="section-appendix.e-14">CDDLは、さまざまなCBORの数値型を区別しますが、JSONには1つの数値型しかありません。浮動小数点精度（float16/float32/float64）を指定する効果は、許容値のセットをbinary16/binary32/binary64で表現可能なものに制限することだけです。これは、JSONデータ構造を指定するためにCDDLを使用する際にはあまり役に立たないでしょう。</t>
      <t indent="0" pn="section-appendix.e-15">基本的に、JSON自体の数値システムは10進数と10進小数点に基づいており、精度や範囲に制限はありません。実際には、JSONの数値はしばしばここで「float64」と呼ばれる数値型に解析され、一般的なデータモデル<xref target="RFC7493" format="default" sectionFormat="of" derivedContent="RFC7493"/>に制約が生じます。特に、これは整数が相互運用性を持つ厳密さで表現できる範囲が[-(2**53)+1, (2**53)-1]という範囲に制限されることを意味します。これはCDDLの「int」がカバーしている範囲よりも狭いです。</t>
      <t indent="0" pn="section-appendix.e-16">I-JSON（「Internet JSON」：詳細は<xref target="RFC7493" format="default" sectionFormat="of" derivedContent="RFC7493"/>を参照）と互換性を維持したいJSONアプリケーションでは、図16のような範囲が制限された整数型を定義することを検討する必要があります。なお、ここで提供されている型は予備の一部ではないため、必要な場合はCDDL仕様にコピーする必要があります。</t>
      <t indent="0" pn="section-appendix.e-17"><artwork name="" type="" align="left" alt="">
            ij-uint = 0..9007199254740991
            ij-nint = -9007199254740991..-1
            ij-int = -9007199254740991..9007199254740991
</artwork>
        <artwork name="" type="" align="left" alt="">
            ij-uint = 0..9007199254740991
            ij-nint = -9007199254740991..-1
            ij-int = -9007199254740991..9007199254740991
</artwork>
      </t>
      <t indent="0" pn="section-appendix.e-18"><figure anchor="fig-16" align="left" suppress-title="false" pn="figure-16">
          <name slugifiedName="name-figure-16">I-JSON Types for CDDL (Not Part of Prelude)</name>
          <artwork name="" type="" align="left" alt="">

</artwork>
        </figure>
        <figure anchor="fig-16" align="left" suppress-title="false" pn="figure-16">
          <name slugifiedName="name-figure-16">I-JSONのためのCDDL型（プレリュードの一部ではありません）</name>
          <artwork name="" type="" align="left" alt="">

</artwork>
        </figure>
      </t>
      <t indent="0" pn="section-appendix.e-19">I-JSONとの互換性を保持する必要のないJSONアプリケーションで、「int」（=「uint」/「nint」）がサポートする64ビット未満の符号なし整数および負の整数を超える必要がある場合は、以下の標準前提条件から以下の追加の型を使用することができます。これらの型はタグに基づいて表現されますが、JSON（ただしI-JSONではありません）の数値に直接マッピングすることができます。</t>
      <t indent="0" pn="section-appendix.e-20"><artwork name="" type="" align="left" alt="">
   biguint = #6.2(bstr)
   bignint = #6.3(bstr)
   bigint = biguint / bignint
   integer = int / bigint
   unsigned = uint / biguint
</artwork>
        <artwork name="" type="" align="left" alt="">
   biguint = #6.2(bstr)
   bignint = #6.3(bstr)
   bigint = biguint / bignint
   integer = int / bigint
   unsigned = uint / biguint
</artwork>
      </t>
      <t indent="0" pn="section-appendix.e-21">CDDL at this point does not have a way to express the unlimited floating-point precision that is theoretically possible with JSON; at the time of writing, this is rarely used in protocols in practice.
この時点のCDDLでは、JSONで理論上可能な無制限の浮動小数点精度を表現する方法はありません。執筆時点では、これは実際のプロトコルでほとんど使用されていません。</t>
      <t indent="0" pn="section-appendix.e-22">CDDLで説明されるデータモデルは、シリアライズで表現可能な内容に常に制約があります。たとえば、NaN（数ではない）や無限大などの浮動小数点値は、CDDLの一般的なデータモデルでは許可されていても、JSONで表現することはできません。</t>
    </section>
    <section anchor="a-cddl-tool" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.f">
      <name slugifiedName="name-a-cddl-tool">A CDDL Tool</name>
      <t indent="0" pn="section-appendix.f-1">この付録は情報提供のみです。</t>
      <t indent="0" pn="section-appendix.f-2">簡易なCDDLツールが利用可能です。CDDLの仕様に対して、構文をチェックすることができ、1つ以上のインスタンス（CBOR診断用記法または整形されたJSONで表現されます）を生成し、既存のインスタンスを仕様に対して検証することもできます。</t>
      <t indent="0" pn="section-appendix.f-3"><artwork name="" type="" align="left" alt="">
                使用法:
                cddl spec.cddl generate [n]
                cddl spec.cddl json-generate [n]
                cddl spec.cddl validate instance.cbor
                cddl spec.cddl validate instance.json
</artwork>
      </t>
      <t indent="0" pn="section-appendix.f-4"><figure anchor="fig-17" align="left" suppress-title="false" pn="figure-17">
          <name slugifiedName="name-figure-17">CDDLツールの使用方法</name>
          <artwork name="" type="" align="left" alt="">

</artwork>
        </figure>
      </t>
      <t indent="0" pn="section-appendix.f-5">現代のRubyを使用したシステムにインストールしてください。以下のコマンドを使用します。</t>
      <t indent="0" pn="section-appendix.f-6"><artwork name="" type="" align="left" alt="">
                          gemのインストール方法は以下の通りです：cddlをインストールします。
</artwork>
      </t>
      <t indent="0" pn="section-appendix.f-7"><figure anchor="fig-18" align="left" suppress-title="false" pn="figure-18">
          <name slugifiedName="name-figure-18">CDDL ツールのインストール</name>
          <artwork name="" type="" align="left" alt="">

</artwork>
        </figure>
      </t>
      <t indent="0" pn="section-appendix.f-8">The accompanying CBOR diagnostic tools (which are automatically
installed by the above) are described in &lt;https://github.com/cabo/
cbor-diag&gt;; they can be used to convert between binary CBOR, a
pretty-printed hexadecimal form of binary CBOR, CBOR diagnostic
notation, JSON, and YAML <xref target="YAML" format="default" sectionFormat="of" derivedContent="YAML"/>.</t>
    </section>
    <section anchor="extended-diagnostic-notation" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.g">
      <name slugifiedName="name-extended-diagnostic-notation">拡張診断表記</name>
      <t indent="0" pn="section-appendix.g-1">この付録は規範です。</t>
      <t indent="0" pn="section-appendix.g-2"><xref target="RFC7049" section="6" format="default" sectionFormat="of" derivedLink="https://www.rfc-editor.org/rfc/rfc7049#section-6" derivedContent="RFC7049"/> は、バイナリデータに頼らずにCBORデータ項目について会話するための「診断表示法」を定義しています。診断表示法はJSONを基にしており、バイナリデータやタグなどのCBOR構造を表現するための拡張機能を持っています。</t>
      <t indent="0" pn="section-appendix.g-3">（実際のやり取り形式と一緒にこれを標準化することは、別のやり取り形式を作成するためではなく、CBORについてのツールや文書で共有される診断表記の使用を可能にします。）</t>
      <t indent="0" pn="section-appendix.g-4">この付録では、RFC 7049 の作成以降に有用であることがわかった診断表記のいくつかの拡張について説明します。この結果を拡張診断表記 (EDN) と呼びます。</t>
      <section anchor="whitespace-in-byte-string-notation" numbered="true" removeInRFC="false" toc="include" pn="section-g.1">
        <name slugifiedName="name-whitespace-in-byte-string-notation">バイト文字列表記のホワイトスペース</name>
        <t indent="0" pn="section-g.1-1">例は、バイト文字列にいくつかのホワイトスペース（スペース、改行）を入れることでしばしば利益を得ます。EDNでは、プレフィックス付きバイト文字列では空白は無視されます。例えば、次のものは同等です。</t>
        <t indent="0" pn="section-g.1-2"><artwork name="" type="" align="left" alt=""><![CDATA[
   h'48656c6c6f20776f726c64'
   h'48 65 6c 6c 6f 20 77 6f 72 6c 64'
   h'4 86 56c 6c6f
     20776 f726c64'
]]></artwork>
</t>
      </section>
      <section anchor="text-in-byte-string-notation" numbered="true" removeInRFC="false" toc="include" pn="section-g.2">
        <name slugifiedName="name-text-in-byte-string-notation">バイト文字列表記のテキスト</name>
        <t indent="0" pn="section-g.2-1">診断表記法は、バイト文字列を<xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/>のいずれかの基底エンコーディングで表記し、シングルクォートで囲み、&gt;h&lt;をbase16のプレフィックスとして、&gt;b32&lt;をbase32のプレフィックスとして、&gt;h32&lt;をbase32hexのプレフィックスとして、または&gt;b64&lt;をbase64またはbase64urlのプレフィックスとして使用します。よくあることですが、バイト文字列はUTF-8テキストとして意味を持つバイトを携行します。EDNは、UTF-8テキストを持つバイト文字列を表現するために、プレフィックスなしのシングルクォートの使用を許可します。例えば、以下の表記は等価です:</t>
        <t indent="0" pn="section-g.2-2"><artwork name="" type="" align="left" alt=""><![CDATA[
   'hello world'
   h'68656c6c6f20776f726c64'
]]></artwork>
</t>
        <t indent="0" pn="section-g.2-3">JSON文字列のエスケープルールは、テキストベースのバイト文字列にも同様に適用されます。たとえば、"\"は単一のバックスラッシュを表し、"'"は単一のクオートを表します。空白は文字通り含まれるため、前のセクションはテキストベースのバイト文字列には適用されません。</t>
      </section>
      <section anchor="embedded-cbor-and-cbor-sequences-in-byte-strings" numbered="true" removeInRFC="false" toc="include" pn="section-g.3">
        <name slugifiedName="name-embedded-cbor-and-cbor-sequences-in-byte-strings">バイト文字列内の埋め込みCBORとCBORシーケンス</name>
        <t indent="0" pn="section-g.3-1">バイト文字列が埋め込みCBORエンコードアイテム、または一般的にはそのようなアイテムの0個以上のシーケンスを携行する場合、これらの0個以上のCBORデータアイテムの診断表記法は、コンマで区切られ、&lt;&lt;と&gt;&gt;で囲まれて、データアイテムをエンコードし、結果を連結した結果となるバイト文字列を表記します。例えば、以下の各列のペアは等価です:</t>
        <t indent="0" pn="section-g.3-2"><artwork name="" type="" align="left" alt=""><![CDATA[
   <<1>>              h'01'
   <<1, 2>>           h'0102'
   <<"foo", null>>    h'63666F6FF6'
   <<>>               h''
]]></artwork>
</t>
      </section>
      <section anchor="concatenated-strings" numbered="true" removeInRFC="false" toc="include" pn="section-g.4">
        <name slugifiedName="name-concatenated-strings">連結された文字列</name>
        <t indent="0" pn="section-g.4-1">エンコードされたバイト文字列にホワイトスペースを含めることで改行が可能になります。一方で、テキスト文字列とバイト文字列を直接のUTF-8表現で行ベースのドキュメント（RFCやソースコードなど）に含めるためのメカニズムが必要です。</t>
        <t indent="0" pn="section-g.4-2">診断表記法を拡張し、テキスト文字列またはバイト文字列をホワイトスペースで区切って示すことを許可します。これらはそれぞれ一つのテキスト文字列またはバイト文字列に連結されます。ただし、テキスト文字列とバイト文字列は、そのような連結の中で混在しませんが、より適切に表現できる文字をエンコードするために、エンコードされた形式でバイト文字列表記をテキスト文字列表記の連結の中に使用することができます。以下の4つの値は同等です。</t>
        <t indent="0" pn="section-g.4-3"><artwork name="" type="" align="left" alt=""><![CDATA[
   "Hello world"
   "Hello " "world"
   "Hello" h'20' "world"
   "" h'48656c6c6f20776f726c64' ""
]]></artwork>
</t>
        <t indent="0" pn="section-g.4-4">同様に、次のバイトストリングの値は等価です：</t>
        <t indent="0" pn="section-g.4-5"><artwork name="" type="" align="left" alt=""><![CDATA[
   'Hello world'
   'Hello ' 'world'
   'Hello ' h'776f726c64'
   'Hello' h'20' 'world'
   '' h'48656c6c6f20776f726c64' '' b64''
   h'4 86 56c 6c6f' h' 20776 f726c64'
]]></artwork>
</t>
        <t indent="0" pn="section-g.4-6">（C言語でよく見られる方法である空白文字での区切りの手法に注意してください。ここでは、単一のカンマが大きな違いを生じます。）</t>
      </section>
      <section anchor="hexadecimal,-octal,-and-binary-numbers" numbered="true" removeInRFC="false" toc="include" pn="section-g.5">
        <name slugifiedName="name-hexadecimal,-octal,-and-binary-numbers">16進数、8進数、および2進数</name>
        <t indent="0" pn="section-g.5-1">JSONの10進数に加えて、EDNは通常のC言語表記（8進数は0o接頭辞に限ります）で16進数、8進数、および2進数を提供します。</t>
        <t indent="0" pn="section-g.5-2">以下の表記は等価です：</t>
        <t indent="0" pn="section-g.5-3"><artwork name="" type="" align="left" alt=""><![CDATA[
   4711
   0x1267
   0o11147
   0b1001001100111
]]></artwork>
</t>
        <t indent="0" pn="section-g.5-4">同様に、以下の表記は等価です。</t>
        <t indent="0" pn="section-g.5-5"><artwork name="" type="" align="left" alt=""><![CDATA[
   1.5
   0x1.8p0
   0x18p-4
]]></artwork>
</t>
      </section>
      <section anchor="comments" numbered="true" removeInRFC="false" toc="include" pn="section-g.6">
        <name slugifiedName="name-comments">コメント</name>
        <t indent="0" pn="section-g.6-1">長い診断表記にはコメントが役立つ場合があります。JSONはコメントを提供しないことで有名であり、RFC 7049の基本的な診断表記もこの特性を継承しています。</t>
        <t indent="0" pn="section-g.6-2">EDNでは、コメントを含むことができます。コメントはスラッシュ("/")で区切られます。スラッシュのペア内にあるテキストはコメントとして扱われます。</t>
        <t indent="0" pn="section-g.6-3">コメントは空白として扱われます。したがって、プレフィックス付きバイト列でも許可されます。たとえば、以下は同等です。</t>
        <t indent="0" pn="section-g.6-4"><artwork name="" type="" align="left" alt=""><![CDATA[
   h'68656c6c6f20776f726c64'
   h'68 65 6c /doubled l!/ 6c 6f /hello/
     20 /space/
     77 6f 72 6c 64' /world/
]]></artwork>
</t>
        <t indent="0" pn="section-g.6-5">これはCBOR構造に注釈を付けるために使用することができます。</t>
        <t indent="0" pn="section-g.6-6"><artwork name="" type="" align="left" alt=""><![CDATA[
   /grasp-message/ [/M_DISCOVERY/ 1, /session-id/ 10584416,
                    /objective/ [/objective-name/ "opsonize",
                                 /D, N, S/ 7, /loop-count/ 105]]
]]></artwork>
</t>
        <t indent="0" pn="section-g.6-7">（現在、行末コメントはありません。追加する場合は、「//」はコメント用のスラッシュを既に使用しているため、理にかなっているようですが、例えば「#」を選択することもできます。</t>
      </section>
    </section>
    <section anchor="examples" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.h">
      <name slugifiedName="name-examples">Examples</name>
      <t indent="0" pn="section-appendix.h-1">この付録は情報提供のみです。</t>
      <t indent="0" pn="section-appendix.h-2">この付録には、CDDLを使用して定義されたいくつかの構造の例がいくつか含まれています。これらの例のテーマは、英語で定義されたあるJSON構造を定義している<xref target="RFC7071" format="default" sectionFormat="of" derivedContent="RFC7071"/>から取られています。同様の例として、<xref target="RFC8007" format="default" sectionFormat="of" derivedContent="RFC8007"/>の付録Aを調べることも興味深いかもしれません。付録Aには、そのRFCの本文で定義されたJSON構造のCDDL定義が含まれています。</t>
      <t indent="0" pn="section-appendix.h-3">これらの例はすべて、JSONで交換されるデータを説明しています。CBORで交換されるデータのCDDL定義の例は、<xref target="RFC8152" format="default" sectionFormat="of" derivedContent="RFC8152"/>、<xref target="GRASP" format="default" sectionFormat="of" derivedContent="GRASP"/>、および<xref target="RFC8428" format="default" sectionFormat="of" derivedContent="RFC8428"/>で見つけることができます。</t>
      <t indent="0" pn="section-appendix.h-4"><xref target="RFC7071" format="default" sectionFormat="of" derivedContent="RFC7071"/>は、「reputon」構造体について、いくぶん形式化された英文テキストを使用したJSONを定義しています。以下は、同じ用語を使用しているがCDDLで表記された（やや冗長な）同等の定義です。</t>
      <t indent="0" pn="section-appendix.h-5"><artwork name="" type="" align="left" alt="">
              reputation-object = {
                reputation-context,
                reputon-list
              }
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputation-object = {
                reputation-context,
                reputon-list
              }
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputation-object = {
                reputation-context,
                reputon-list
              }
</artwork>
      </t>
      <t indent="0" pn="section-appendix.h-6"><artwork name="" type="" align="left" alt="">
              reputation-context = (
                application: text
              )
</artwork>
        <artwork name="" type="" align="left" alt="">
              <bcp14>reputation-context</bcp14> = (
                <bcp14>application:</bcp14> <bcp14>text</bcp14>
              )
</artwork>
      </t>
      <t indent="0" pn="section-appendix.h-7"><artwork name="" type="" align="left" alt="">
              reputon-list = (
                reputons: reputon-array
              )
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-list = (
                reputons: reputon-array
              )
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-list = (
                reputons: reputon-array
              )
</artwork>
      </t>
      <t indent="0" pn="section-appendix.h-8"><artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon-array = [* reputon]
</artwork>
      </t>
      <t indent="0" pn="section-appendix.h-9"><artwork name="" type="" align="left" alt="">
              reputon = {
                rater-value,
                assertion-value,
                rated-value,
                rating-value,
                ? conf-value,
                ? normal-value,
                ? sample-value,
                ? gen-value,
                ? expire-value,
                * ext-value,
              }
              rater-value = ( rater: text )
              assertion-value = ( assertion: text )
              rated-value = ( rated: text )
              rating-value = ( rating: float16 )
              conf-value = ( confidence: float16 )
              normal-value = ( normal-rating: float16 )
              sample-value = ( sample-size: uint )
              gen-value = ( generated: uint )
              expire-value = ( expires: uint )
              ext-value = ( text =&gt; any )
</artwork>
        <artwork name="" type="" align="left" alt="">
              reputon = {
                rater-value,
                assertion-value,
                rated-value,
                rating-value,
                ? conf-value,
                ? normal-value,
                ? sample-value,
                ? gen-value,
                ? expire-value,
                * ext-value,
              }
              rater-value = ( rater: text )
              assertion-value = ( assertion: text )
              rated-value = ( rated: text )
              rating-value = ( rating: float16 )
              conf-value = ( confidence: float16 )
              normal-value = ( normal-rating: float16 )
              sample-value = ( sample-size: uint )
              gen-value = ( generated: uint )
              expire-value = ( expires: uint )
              ext-value = ( text =&gt; any )
</artwork>
      </t>
      <t indent="0" pn="section-appendix.h-10">この例の同等かつより縮小された形式は以下の通りです：</t>
      <t indent="0" pn="section-appendix.h-11"><artwork name="" type="" align="left" alt="">
                     reputation-object = {
                       application: text
                       reputons: [* reputon]
                     }
</artwork>
        <artwork name="" type="" align="left" alt="">
                     reputation-object = {
                       application: text
                       reputons: [* reputon]
                     }
</artwork>
      </t>
      <t indent="0" pn="section-appendix.h-12"><artwork name="" type="" align="left" alt="">
                     reputon = {
                       rater: text
                       assertion: text
                       rated: text
                       rating: float16
                       ? confidence: float16
                       ? normal-rating: float16
                       ? sample-size: uint
                       ? generated: uint
                       ? expires: uint
                       * text =&gt; any
                     }
</artwork>
        <artwork name="" type="" align="left" alt="">
                     reputon = {
                       rater: text
                       assertion: text
                       rated: text
                       rating: float16
                       ? confidence: float16
                       ? normal-rating: float16
                       ? sample-size: uint
                       ? generated: uint
                       ? expires: uint
                       * text =&gt; any
                     }
</artwork>
      </t>
      <t indent="0" pn="section-appendix.h-13">Note how this rather clearly delineates the structure somewhat
shrouded by so many words in <xref target="RFC7071" section="6.2.2" format="default" sectionFormat="of" derivedLink="https://www.rfc-editor.org/rfc/rfc7071#section-6.2.2" derivedContent="RFC7071"/>.  Also, this
definition makes it clear that several ext-values are allowed (by
definition with different member names); RFC 7071 could be read to
forbid the repetition of ext-value ("A specific reputon-element
<bcp14>MUST NOT</bcp14> appear more than once" is ambiguous).</t>
      <t indent="0" pn="section-appendix.h-14">付録Fで説明されているCDDLツールは、以下の例のように生成します：</t>
      <t indent="0" pn="section-appendix.h-15"><artwork name="" type="" align="left" alt="">
               {
                 "application": "conchometry",
                 "reputons": [
                   {
                     "rater": "Ephthianura",
                     "assertion": "codding",
                     "rated": "sphaerolitic",
                     "rating": 0.34133473256800795,
                     "confidence": 0.9481983064298332,
                     "expires": 1568,
                     "unplaster": "grassy"
                   },
                   {
                     "rater": "nonchargeable",
                     "assertion": "raglan",
                     "rated": "alienage",
                     "rating": 0.5724646875815566,
                     "sample-size": 3514,
                     "Aldebaran": "unchurched",
                     "puruloid": "impersonable",
                     "uninfracted": "pericarpoidal",
                     "schorl": "Caro"
                   },
                   {
                     "rater": "precollectable",
                     "assertion": "Merat",
                     "rated": "thermonatrite",
                     "rating": 0.19164006323936977,
                     "confidence": 0.6065252103391268,
                     "normal-rating": 0.5187773690879303,
                     "generated": 899,
                     "speedy": "solidungular",
                     "noviceship": "medicine",
                     "checkrow": "epidictic"
                   }
                 ]
               }
</artwork>
        <artwork name="" type="" align="left" alt="">
               {
                 "application": "conchometry",
                 "reputons": [
                   {
                     "rater": "Ephthianura",
                     "assertion": "codding",
                     "rated": "sphaerolitic",
                     "rating": 0.34133473256800795,
                     "confidence": 0.9481983064298332,
                     "expires": 1568,
                     "unplaster": "grassy"
                   },
                   {
                     "rater": "nonchargeable",
                     "assertion": "raglan",
                     "rated": "alienage",
                     "rating": 0.5724646875815566,
                     "sample-size": 3514,
                     "Aldebaran": "unchurched",
                     "puruloid": "impersonable",
                     "uninfracted": "pericarpoidal",
                     "schorl": "Caro"
                   },
                   {
                     "rater": "precollectable",
                     "assertion": "Merat",
                     "rated": "thermonatrite",
                     "rating": 0.19164006323936977,
                     "confidence": 0.6065252103391268,
                     "normal-rating": 0.5187773690879303,
                     "generated": 899,
                     "speedy": "solidungular",
                     "noviceship": "medicine",
                     "checkrow": "epidictic"
                   }
                 ]
               }
</artwork>
      </t>
    </section>
    <section anchor="acknowledgements" numbered="false" removeInRFC="false" toc="exclude" pn="section-appendix.i">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t indent="0" pn="section-appendix.i-1">Inspiration was taken from the C and Pascal languages, MPEG's conventions for describing structures in the ISO base media file format, RELAX NG and its compact syntax <xref target="RELAXNG" format="default" sectionFormat="of" derivedContent="RELAXNG"/>, and, in particular, Andrew Lee Newton's early proposals on JSON Content Rules (JCR) as found in draft version four (-04) of <xref target="JCR" format="default" sectionFormat="of" derivedContent="JCR"/>.

Inspiration was taken from the C and Pascal languages, MPEG's conventions for describing structures in the ISO base media file format, RELAX NG (Resource Description Framework for XML Next Generation)とそれの簡潔な構文<xref target="RELAXNG" format="default" sectionFormat="of" derivedContent="RELAXNG"/>、そして特にAndrew Lee Newtonが提案したJSON Content Rules (JCR) found in draft version four (-04)の<xref target="JCR" format="default" sectionFormat="of" derivedContent="JCR"/>を元にしています。</t>
      <t indent="0" pn="section-appendix.i-2">IETFのCBORワーキンググループのメンバーから、非常に有益なフィードバックがたくさん寄せられました。特に、アリ・ケラネン、ブライアン・カーペンター、バート・ハリス、ジェフリー・ヤスキン、ジム・ヘーグ、ジム・シャード、ジョー・ヒルデブランド、マックス・プリティキン、マイケル・リチャードソン、ピート・コーデル、ショーン・レナード、ヤロン・シェファーからのフィードバックがありました。また、フランチェスカ・パロンビーニとジョーがワーキンググループの議長を志 volunteersdersし、このフィードバックの生成と処理のための枠組みを提供しました。その後、バリー・ライバがジョーの後を引き継いでいます。Chris LonvickとInes RoblesはIESGの処理中に追加のレビューを提供し、Alexey Melnikovは責任あるエリアディレクターとしてプロセスを指導しました。</t>
      <t indent="0" pn="section-appendix.i-3"><bcp14>付録 F で説明されている CDDL ツールは、Carsten Bormann によって書かれ、Troy Heninger と Tom Lord の先行作業を基にしています。</bcp14></t>
    </section>
  </back>
</rfc>
