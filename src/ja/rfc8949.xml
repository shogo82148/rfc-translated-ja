<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-cbor-7049bis-16" indexInclude="true" ipr="trust200902" number="8949" obsoletes="7049" prepTime="2020-12-04T16:27:22" scripts="Common,Greek,Han,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="4" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-cbor-7049bis-16" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8949" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="CBOR">コンパクトなバイナリーオブジェクト表現（CBOR：Concise Binary Object Representation）</title>
    <seriesInfo name="RFC" value="8949" stream="IETF"/>
    <seriesInfo name="STD" value="94" stream="IETF"/>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization showOnFrontPage="true">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>
    <author initials="P." surname="Hoffman" fullname="Paul Hoffman">
      <organization showOnFrontPage="true">ICANN</organization>
      <address>
        <email>paul.hoffman@icann.org</email>
      </address>
    </author>
    <date month="12" year="2020"/>
    <area>Internet</area>
    <keyword>parser</keyword>
    <keyword>decoder</keyword>
    <keyword>encoder</keyword>
    <keyword>binary format</keyword>
    <keyword>data interchange format</keyword>
    <keyword>JSON</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">コンパクトなバイナリーオブジェクト表現（CBOR：Concise Binary Object Representation）は、非常に小さなコードサイズ、かなり小さなメッセージサイズ、およびバージョンネゴシエーションの必要性がない拡張性を可能にするデータ形式です。これらの設計目標により、ASN.1やMessagePackなどの以前のバイナリーシリアル化とは異なります。</t>
      <t indent="0" pn="section-abstract-2">この文書はRFC 7049を廃止し、編集上の改善、新しい詳細、および勘定訂正を提供しながら、RFC 7049の交換形式と完全な互換性を維持します。この文書は、フォーマットの新しいバージョンを作成するものではありません。</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">このメモのステータス</name>
        <t indent="0" pn="section-boilerplate.1-1">
            これは、インターネット標準トラック文書です。
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            この文書は、インターネット技術標準化委員会（IETF）の成果物です。IETFコミュニティの合意を表しており、公開レビューを受け、インターネット技術指導委員会（IESG）によって公開が承認されました。インターネット標準に関する詳細は、RFC 7841のセクション2を参照してください。
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            この文書の現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、<eref target="https://www.rfc-editor.org/info/rfc8949" brackets="none"/>で入手できます。
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">著作権表示</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            この文書は、BCP 78およびIETFドキュメントに関するIETFトラストの法的規定（<eref target="https://trustee.ietf.org/license-info" brackets="none"/>）にしたがう必要があります。これらの文書をよく確認し、この文書に関するあなたの権利と制限を説明しています。この文書から抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">目次</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">はじめに</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-objectives">目的</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">用語</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cbor-data-models">CBORデータモデル</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-extended-generic-data-model">拡張ジェネリックデータモデル</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-specific-data-models">特定データモデル</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-specification-of-the-cbor-e">CBORエンコーディングの仕様</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-major-types">Major Types</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-indefinite-lengths-for-some">Indefinite Lengths for Some Major Types</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.2.2">
                  <li pn="section-toc.1-1.3.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.1.1"><xref derivedContent="3.2.1" format="counter" sectionFormat="of" target="section-3.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-the-break-stop-code">The "break" Stop Code</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.2.1"><xref derivedContent="3.2.2" format="counter" sectionFormat="of" target="section-3.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-indefinite-length-arrays-an">Indefinite-Length Arrays and Maps</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.3.1"><xref derivedContent="3.2.3" format="counter" sectionFormat="of" target="section-3.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-indefinite-length-byte-stri">Indefinite-Length Byte Strings and Text Strings</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.2.2.4">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.4.1"><xref derivedContent="3.2.4" format="counter" sectionFormat="of" target="section-3.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-summary-of-indefinite-lengt">Summary of Indefinite-Length Use of Major Types</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-floating-point-numbers-and-">Floating-Point Numbers and Values with No Content</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tagging-of-items">Tagging of Items</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.4.2">
                  <li pn="section-toc.1-1.3.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.4.2.1.1"><xref derivedContent="3.4.1" format="counter" sectionFormat="of" target="section-3.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-standard-date-time-string">Standard Date/Time String</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.4.2.2.1"><xref derivedContent="3.4.2" format="counter" sectionFormat="of" target="section-3.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-epoch-based-date-time">Epoch-Based Date/Time</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.3.2.4.2.3.1"><xref derivedContent="3.4.3" format="counter" sectionFormat="of" target="section-3.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-bignums">Bignums</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.4.2.4">
                    <t indent="0" pn="section-toc.1-1.3.2.4.2.4.1"><xref derivedContent="3.4.4" format="counter" sectionFormat="of" target="section-3.4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-decimal-fractions-and-bigfl">Decimal Fractions and Bigfloats</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.4.2.5">
                    <t indent="0" pn="section-toc.1-1.3.2.4.2.5.1"><xref derivedContent="3.4.5" format="counter" sectionFormat="of" target="section-3.4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-hints">Content Hints</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.4.2.5.2">
                      <li pn="section-toc.1-1.3.2.4.2.5.2.1">
                        <t indent="0" pn="section-toc.1-1.3.2.4.2.5.2.1.1"><xref derivedContent="3.4.5.1" format="counter" sectionFormat="of" target="section-3.4.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-encoded-cbor-data-item">Encoded CBOR Data Item</xref></t>
                      </li>
                      <li pn="section-toc.1-1.3.2.4.2.5.2.2">
                        <t indent="0" pn="section-toc.1-1.3.2.4.2.5.2.2.1"><xref derivedContent="3.4.5.2" format="counter" sectionFormat="of" target="section-3.4.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-expected-later-encoding-for">Expected Later Encoding for CBOR-to-JSON Converters</xref></t>
                      </li>
                      <li pn="section-toc.1-1.3.2.4.2.5.2.3">
                        <t indent="0" pn="section-toc.1-1.3.2.4.2.5.2.3.1"><xref derivedContent="3.4.5.3" format="counter" sectionFormat="of" target="section-3.4.5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-encoded-text">Encoded Text</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.3.2.4.2.6">
                    <t indent="0" pn="section-toc.1-1.3.2.4.2.6.1"><xref derivedContent="3.4.6" format="counter" sectionFormat="of" target="section-3.4.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-self-described-cbor">Self-Described CBOR</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serialization-consideration">Serialization Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-preferred-serialization">Preferred Serialization</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-deterministically-encoded-c">Deterministically Encoded CBOR</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.2.2">
                  <li pn="section-toc.1-1.4.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.1.1"><xref derivedContent="4.2.1" format="counter" sectionFormat="of" target="section-4.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-core-deterministic-encoding">Core Deterministic Encoding Requirements</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.2.1"><xref derivedContent="4.2.2" format="counter" sectionFormat="of" target="section-4.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-additional-deterministic-en">Additional Deterministic Encoding Considerations</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.3.1"><xref derivedContent="4.2.3" format="counter" sectionFormat="of" target="section-4.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-length-first-map-key-orderi">Length-First Map Key Ordering</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-creating-cbor-based-protoco">Creating CBOR-Based Protocols</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cbor-in-streaming-applicati">CBOR in Streaming Applications</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-generic-encoders-and-decode">Generic Encoders and Decoders</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.3">
                <t indent="0" pn="section-toc.1-1.5.2.3.1"><xref derivedContent="5.3" format="counter" sectionFormat="of" target="section-5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-validity-of-items">Validity of Items</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.3.2">
                  <li pn="section-toc.1-1.5.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.5.2.3.2.1.1"><xref derivedContent="5.3.1" format="counter" sectionFormat="of" target="section-5.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-basic-validity">Basic validity</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.5.2.3.2.2.1"><xref derivedContent="5.3.2" format="counter" sectionFormat="of" target="section-5.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tag-validity">Tag validity</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.5.2.4">
                <t indent="0" pn="section-toc.1-1.5.2.4.1"><xref derivedContent="5.4" format="counter" sectionFormat="of" target="section-5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-validity-and-evolution">Validity and Evolution</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.5">
                <t indent="0" pn="section-toc.1-1.5.2.5.1"><xref derivedContent="5.5" format="counter" sectionFormat="of" target="section-5.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-numbers">Numbers</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.6">
                <t indent="0" pn="section-toc.1-1.5.2.6.1"><xref derivedContent="5.6" format="counter" sectionFormat="of" target="section-5.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-specifying-keys-for-maps">Specifying Keys for Maps</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.6.2">
                  <li pn="section-toc.1-1.5.2.6.2.1">
                    <t indent="0" pn="section-toc.1-1.5.2.6.2.1.1"><xref derivedContent="5.6.1" format="counter" sectionFormat="of" target="section-5.6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-equivalence-of-keys">Equivalence of Keys</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.5.2.7">
                <t indent="0" pn="section-toc.1-1.5.2.7.1"><xref derivedContent="5.7" format="counter" sectionFormat="of" target="section-5.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-undefined-values">Undefined Values</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-converting-data-between-cbo">Converting Data between CBOR and JSON</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-converting-from-cbor-to-jso">Converting from CBOR to JSON</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-converting-from-json-to-cbo">Converting from JSON to CBOR</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-future-evolution-of-cbor">Future Evolution of CBOR</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-extension-points">Extension Points</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-curating-the-additional-inf">Curating the Additional Information Space</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-diagnostic-notation">Diagnostic Notation</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-encoding-indicators">Encoding Indicators</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cbor-simple-values-registry">CBOR Simple Values Registry</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cbor-tags-registry">CBOR Tags Registry</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.3">
                <t indent="0" pn="section-toc.1-1.9.2.3.1"><xref derivedContent="9.3" format="counter" sectionFormat="of" target="section-9.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-media-types-registry">Media Types Registry</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.4">
                <t indent="0" pn="section-toc.1-1.9.2.4.1"><xref derivedContent="9.4" format="counter" sectionFormat="of" target="section-9.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-coap-content-format-registr">CoAP Content-Format Registry</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.5">
                <t indent="0" pn="section-toc.1-1.9.2.5.1"><xref derivedContent="9.5" format="counter" sectionFormat="of" target="section-9.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-structured-syntax-suffix-re">Structured Syntax Suffix Registry</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.11.2">
              <li pn="section-toc.1-1.11.2.1">
                <t indent="0" pn="section-toc.1-1.11.2.1.1"><xref derivedContent="11.1" format="counter" sectionFormat="of" target="section-11.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.2">
                <t indent="0" pn="section-toc.1-1.11.2.2.1"><xref derivedContent="11.2" format="counter" sectionFormat="of" target="section-11.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-of-encoded-cbor-da">Examples of Encoded CBOR Data Items</xref></t>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-jump-table-for-initial-byte">Jump Table for Initial Byte</xref></t>
          </li>
          <li pn="section-toc.1-1.14">
            <t indent="0" pn="section-toc.1-1.14.1"><xref derivedContent="Appendix C" format="default" sectionFormat="of" target="section-appendix.c"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-pseudocode">Pseudocode</xref></t>
          </li>
          <li pn="section-toc.1-1.15">
            <t indent="0" pn="section-toc.1-1.15.1"><xref derivedContent="Appendix D" format="default" sectionFormat="of" target="section-appendix.d"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-half-precision">Half-Precision</xref></t>
          </li>
          <li pn="section-toc.1-1.16">
            <t indent="0" pn="section-toc.1-1.16.1"><xref derivedContent="Appendix E" format="default" sectionFormat="of" target="section-appendix.e"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-comparison-of-other-binary-">Comparison of Other Binary Formats to CBOR's Design Objectives</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2">
              <li pn="section-toc.1-1.16.2.1">
                <t indent="0" pn="section-toc.1-1.16.2.1.1"><xref derivedContent="E.1" format="counter" sectionFormat="of" target="section-e.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-asn1-der-ber-and-per">ASN.1 DER, BER, and PER</xref></t>
              </li>
              <li pn="section-toc.1-1.16.2.2">
                <t indent="0" pn="section-toc.1-1.16.2.2.1"><xref derivedContent="E.2" format="counter" sectionFormat="of" target="section-e.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-messagepack">MessagePack</xref></t>
              </li>
              <li pn="section-toc.1-1.16.2.3">
                <t indent="0" pn="section-toc.1-1.16.2.3.1"><xref derivedContent="E.3" format="counter" sectionFormat="of" target="section-e.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-bson">BSON</xref></t>
              </li>
              <li pn="section-toc.1-1.16.2.4">
                <t indent="0" pn="section-toc.1-1.16.2.4.1"><xref derivedContent="E.4" format="counter" sectionFormat="of" target="section-e.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-msdtp-rfc-713">MSDTP: RFC 713</xref></t>
              </li>
              <li pn="section-toc.1-1.16.2.5">
                <t indent="0" pn="section-toc.1-1.16.2.5.1"><xref derivedContent="E.5" format="counter" sectionFormat="of" target="section-e.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-conciseness-on-the-wire">Conciseness on the Wire</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.17">
            <t indent="0" pn="section-toc.1-1.17.1"><xref derivedContent="Appendix F" format="default" sectionFormat="of" target="section-appendix.f"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-well-formedness-errors-and-">Well-Formedness Errors and Examples</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.17.2">
              <li pn="section-toc.1-1.17.2.1">
                <t indent="0" pn="section-toc.1-1.17.2.1.1"><xref derivedContent="F.1" format="counter" sectionFormat="of" target="section-f.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-of-cbor-data-items">Examples of CBOR Data Items That Are Not Well-Formed</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.18">
            <t indent="0" pn="section-toc.1-1.18.1"><xref derivedContent="Appendix G" format="default" sectionFormat="of" target="section-appendix.g"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7049">Changes from RFC 7049</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.18.2">
              <li pn="section-toc.1-1.18.2.1">
                <t indent="0" pn="section-toc.1-1.18.2.1.1"><xref derivedContent="G.1" format="counter" sectionFormat="of" target="section-g.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-errata-processing-and-cleri">Errata Processing and Clerical Changes</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.2">
                <t indent="0" pn="section-toc.1-1.18.2.2.1"><xref derivedContent="G.2" format="counter" sectionFormat="of" target="section-g.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-in-iana-considerati">Changes in IANA Considerations</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.3">
                <t indent="0" pn="section-toc.1-1.18.2.3.1"><xref derivedContent="G.3" format="counter" sectionFormat="of" target="section-g.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-in-suggestions-and-">Changes in Suggestions and Other Informational Components</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.19">
            <t indent="0" pn="section-toc.1-1.19.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.h"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.20">
            <t indent="0" pn="section-toc.1-1.20.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.i"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" toc="include" numbered="true" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">はじめに</name>
      <t indent="0" pn="section-1-1">構造化データのバイナリー表現のための標準化されたフォーマットは数百あります（バイナリーシリアル化フォーマットとも呼ばれます）。そのうち、いくつかは特定の情報ドメイン向けであり、他のものは任意のデータに対して一般化されています。IETFでは、後者のカテゴリーでもっともよく知られているフォーマットは、ASN.1のBERおよびDER<xref target="ASN.1" format="default" sectionFormat="of" derivedContent="ASN.1"/>です。</t>
      <t indent="0" pn="section-1-2">ここで定義されたフォーマットは、現在のフォーマットでは十分に満たされていないいくつかの特定の設計目標にしたがっています。基礎となるデータモデルは、JSONデータモデルの拡張版です<xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/>。RFC 8259の文法を一般的に拡張することを提案するものではないことに注意することが重要です。なぜなら、すでに展開されているJSONドキュメントとの間で重大な後方互換性の問題が発生するためです。代わりに、この文書はJSONから始まる独自のデータモデルを定義するだけです。</t>
      <t indent="0" pn="section-1-3"><xref target="comparison-app" format="default" sectionFormat="of" derivedContent="Appendix E"/>では、既存のバイナリーフォーマットをいくつかリストし、コンパクトなバイナリーオブジェクト表現（CBOR）の設計目標にどの程度適合しているかについて説明しています。</t>
      <t indent="0" pn="section-1-4">この文書は、RFC 7049を廃止します。編集上の改善、新しい詳細、および勘定訂正を提供しながら、RFC 7049の交換形式と完全な互換性を維持します。この文書は、フォーマットの新しいバージョンを作成するものではありません。</t>
      <section anchor="objectives" toc="include" numbered="true" removeInRFC="false" pn="section-1.1">
        <name slugifiedName="name-objectives">目的</name>
        <t indent="0" pn="section-1.1-1">CBORの目的は、おおよそ重要度の低い順に以下のとおりです。</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-1.1-2"><li pn="section-1.1-2.1" derivedCounter="1.">
            <t indent="0" pn="section-1.1-2.1.1">表現は、インターネット標準で使用される一般的なデータ形式のほとんどを明確に符号化できる必要があります。</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.1-2.1.2">
              <li pn="section-1.1-2.1.2.1">バイナリーエンコーディングを使用して、合理的な基本データ型と構造のセットを表現する必要があります。ここでの「合理的」とは、主にJSONの機能に大きく影響を受け、バイナリーバイトストリングの主要な追加を含みます。サポートされる構造は、配列とツリーに限定されており、ループや格子状のグラフはサポートされていません。</li>
              <li pn="section-1.1-2.1.2.2">すべてのデータ形式が一意にエンコードされる必要はありません。つまり、数字の「7」が複数の異なる方法でエンコードされることが許容されます。</li>
            </ul>
          </li>
          <li pn="section-1.1-2.2" derivedCounter="2.">
            <t indent="0" pn="section-1.1-2.2.1">エンコーダーまたはデコーダーのコードは、非常に限られたメモリ、プロセッサのパワー、および命令セットを持つシステムをサポートするためにコンパクトである必要があります。</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.1-2.2.2">
              <li pn="section-1.1-2.2.2.1">エンコーダーまたはデコーダーは、非常に小さなコードで実装できる必要があります（たとえば、<xref target="RFC7228" format="default" sectionFormat="of" derivedContent="RFC7228"/>で定義されたクラス1制約ノードで）。</li>
              <li pn="section-1.1-2.2.2.2">フォーマットは、データの現代的なマシン表現を使用する必要があります（たとえば、バイナリーから10進数への変換を必要としない）。</li>
            </ul>
          </li>
          <li pn="section-1.1-2.3" derivedCounter="3.">
            <t indent="0" pn="section-1.1-2.3.1">スキーマの説明なしでデータをデコードできる必要があります。</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.1-2.3.2">
              <li pn="section-1.1-2.3.2.1">JSONと同様に、エンコードされたデータは自己記述的である必要があり、汎用デコーダーを記述できるようにする必要があります。</li>
            </ul>
          </li>
          <li pn="section-1.1-2.4" derivedCounter="4.">
            <t indent="0" pn="section-1.1-2.4.1">シリアル化は、比較的コンパクトである必要がありますが、エンコーダーとデコーダーのコードのコンパクトさが優先されます。</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.1-2.4.2">
              <li pn="section-1.1-2.4.2.1">ここでの「合理的」とは、JSONを上限としたサイズであり、実装の複雑さによっても制限されます。コンパクトさを実現するために投入できる労力が制限されるため、一般的な圧縮スキームや広範なビット操作を使用することは、複雑性の目標に反します。</li>
            </ul>
          </li>
          <li pn="section-1.1-2.5" derivedCounter="5.">
            <t indent="0" pn="section-1.1-2.5.1">フォーマットは、制約ノードと高容量アプリケーションの両方に適用できる必要があります。</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.1-2.5.2">
              <li pn="section-1.1-2.5.2.1">つまり、エンコードとデコードの両方でCPU使用量が比較的少なくなければなりません。これは、制約ノードと非常に高いデータ量のアプリケーションでの使用に関連しています。</li>
            </ul>
          </li>
          <li pn="section-1.1-2.6" derivedCounter="6.">
            <t indent="0" pn="section-1.1-2.6.1">フォーマットは、JSONデータ型をすべてサポートし、JSONからの変換およびJSONへの変換を行う必要があります。</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.1-2.6.2">
              <li pn="section-1.1-2.6.2.1">JSONの機能に大きく影響を受け、表現されたデータがJSONの機能範囲内である限り、合理的な変換レベルをサポートする必要があります。すべてのデータ型に対してJSONへの単方向マッピングを定義することができる必要があります。</li>
            </ul>
          </li>
          <li pn="section-1.1-2.7" derivedCounter="7.">
            <t indent="0" pn="section-1.1-2.7.1">フォーマットは拡張可能であり、拡張されたデータは以前のデコーダーでデコードできる必要があります。</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.1-2.7.2">
              <li pn="section-1.1-2.7.2.1">このフォーマットは、数十年にわたる使用を想定しています。</li>
              <li pn="section-1.1-2.7.2.2">フォーマットは、拡張機能をサポートする必要があり、拡張機能を理解できないデコーダーでもメッセージをデコードできるようにフォールバックすることができる形式をサポートする必要があります。</li>
              <li pn="section-1.1-2.7.2.3">フォーマットは、将来のIETF標準によって拡張できる必要があります。</li>
            </ul>
          </li>
        </ol>
      </section>
      <section anchor="terminology" toc="include" numbered="true" removeInRFC="false" pn="section-1.2">
        <name slugifiedName="name-terminology">用語</name>
        <t indent="0" pn="section-1.2-1">キーワード「<bcp14>しなければなりません（MUST）</bcp14>」、「<bcp14>してはなりません（MUST NOT）</bcp14>」、
「<bcp14>要求されています（REQUIRED）</bcp14>」、
「<bcp14>することになります（SHALL）</bcp14>」、「<bcp14>することはありません（SHALL NOT）</bcp14>」、
「<bcp14>すべきです（SHOULD）</bcp14>」、「<bcp14>すべきではありません（SHOULD NOT）</bcp14>」、
「<bcp14>推奨されます（RECOMMENDED）</bcp14>」、「<bcp14>推奨されません（NOT RECOMMENDED）</bcp14>」、
「<bcp14>してもよいです（MAY）</bcp14>」、「<bcp14>選択できます（OPTIONAL）</bcp14>」は、
BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/>に記載されているとおりに解釈されるものとします。
ただし、ここに示すようにすべて大文字で表示される場合に限ります。
        </t>
        <t indent="0" pn="section-1.2-2">「バイト（byte）」という用語は、現在の慣習的な意味で「オクテット（octet）」の同義語として使用されます。すべてのマルチバイト値は、ネットワークバイトオーダー（つまり、最上位バイトが先に来る「ビッグエンディアン」とも呼ばれる）でエンコードされます。</t>
        <t indent="0" pn="section-1.2-3">This specification makes use of the following terminology:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-1.2-4">
          <dt pn="section-1.2-4.1">データアイテム（Data Item）：</dt>
          <dd pn="section-1.2-4.2">
  単一のCBORデータ。データアイテムの構造には、ゼロ、1つ、または複数のネストされたデータアイテムが含まれる場合があります。この用語は、表現形式のデータアイテムと、デコーダーによって得られる抽象的なアイデアの両方に使用されます。前者は「エンコードされたデータアイテム」という用語を使用して特定できます。</dd>
          <dt pn="section-1.2-4.3">デコーダー（Decoder）：</dt>
          <dd pn="section-1.2-4.4">
  ウェルフォームされたエンコードされたCBORデータアイテムをデコードし、アプリケーションで使用できるようにします。形式的には、デコーダーには、CBORの構文規則を使用して入力を分割するパーサーと、アプリケーションに適した形式でデータを準備する意味処理器が含まれます。</dd>
          <dt pn="section-1.2-4.5">エンコーダー（Encoder）：</dt>
          <dd pn="section-1.2-4.6">
  アプリケーション情報からCBORデータアイテムの（ウェルフォームされた）表現形式を生成するプロセス。</dd>
          <dt pn="section-1.2-4.7">データストリーム（Data Stream）：</dt>
          <dd pn="section-1.2-4.8">
  より大きな含まれるデータアイテムにさらに組み立てられていない、ゼロ個以上のデータアイテムのシーケンス（1つのアプリケーションについては、<xref target="RFC8742" format="default" sectionFormat="of" derivedContent="RFC8742"/>を参照）。データストリームを構成する独立したデータアイテムは、時に「トップレベルのデータアイテム」とも呼ばれます。</dd>
          <dt pn="section-1.2-4.9">ウェルフォーム（Well-formed）:</dt>
          <dd pn="section-1.2-4.10">
  CBORの構文構造にしたがうデータアイテム。ウェルフォームなデータアイテムは、CBORで定義された初期バイトと、その値によって暗示されるバイト文字列および/またはデータアイテムを使用し、その後の余分なデータを含みません。CBORデコーダーは、定義上、ウェルフォームなデータアイテムからのコンテンツのみを返します。</dd>
          <dt pn="section-1.2-4.11">有効（Valid）：</dt>
          <dd pn="section-1.2-4.12">
  CBORデータアイテムに適用される意味的制限にしたがう、ウェルフォームであるデータアイテム (<xref target="semantic-errors" format="default" sectionFormat="of" derivedContent="Section 5.3"/>を参照)。</dd>
          <dt pn="section-1.2-4.13">期待される（Expected）：</dt>
          <dd pn="section-1.2-4.14">
  通常の英語の意味に加えて、「期待される」という用語は、アプリケーションが入力データに対して持つCBORの有効性を超えた要件を説明するために使用されます。ウェルフォーム（処理可能）、有効（有効性チェックを行う汎用デコーダーによってチェックされる）、期待される（アプリケーションによってチェックされる）は、受け入れ可能性のレイヤーの階層を形成します (<xref target="semantic-errors" format="default" sectionFormat="of" derivedContent="Section 5.3"/>を参照)。</dd>
          <dt pn="section-1.2-4.15">ストリームデコーダー：</dt>
          <dd pn="section-1.2-4.16">
  データストリームをデコードし、データアイテムが受信されるたびにアプリケーションで利用可能にします。</dd>
        </dl>
        <t indent="0" pn="section-1.2-5">無限大、NaN（非数）、負のゼロ、および非正規化数などの浮動小数点値に関する用語や概念は、<xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/>で定義されています。</t>
        <t indent="0" pn="section-1.2-6">ビット演算やデータ型の説明において、本文書ではCプログラミング言語でお馴染みの表記法を使用しています (<xref target="C" format="default" sectionFormat="of" derivedContent="C"/>)。ただし、".."は両端を含む範囲を表し、上付き文字は累乗を表します。たとえば、2の64乗は2<sup>64</sup>と表記されます。
この仕様書のプレーンテキスト版では、上付き文字は使用できないため、代替表記でレンダリングされます。この表記法はRFCに最適化されておらず、Cの排他的論理和と曖昧になることがあります（これは付録でのみ使用され、さらに累乗は使用されません）。プレーンテキスト版の読者は注意が必要です。</t>
        <t indent="0" pn="section-1.2-7">例と疑似コード
符号付き整数が2の補数表現を使用し、符号付き整数の右シフトが符号拡張することを前提とします。これらの前提条件は、C++の2020年版のセクション6.8.1（basic.fundamental）および7.6.7（expr.shift）でも指定されています（現在、最終ドラフトとして<xref target="Cplusplus20" format="default" sectionFormat="of" derivedContent="Cplusplus20"/>が利用可能です）。</t>
        <t indent="0" pn="section-1.2-8">16進数の"0x"表記法にならって、"0b"接頭辞を2進数の表記法として使用します。可読性を向上させるために、数字にアンダースコアを追加することがあります。たとえば、0b00100001 (0x21) は、バイト内のビットの解釈を強調するために、0b001_00001 のように書くことがあります。この場合、3ビットと5ビットに分割されます。エンコードされたCBORデータアイテムは、ときには"0x"または"0b"表記法で与えられます。これらの値は、まずC言語の数値として解釈され、次にネットワークバイトオーダーでバイト文字列として解釈されます。表記法で表される先頭のゼロバイトも含まれます。</t>
        <t indent="0" pn="section-1.2-9">強調するために、単語を<em>斜体</em>にすることがあります。この仕様書のプレーンテキスト版では、これは単語をアンダースコアで囲むことで示されます。プログラミング言語の名前などの原文のままのテキストは、<tt>等幅フォント</tt>で表示されることがあります。プレーンテキストでは、テキストを二重引用符で囲むことで、やや曖昧に近似されます（二重引用符は通常の意味も保持します）。</t>
      </section>
    </section>
    <section anchor="cbor-data-models" toc="include" numbered="true" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-cbor-data-models">CBORデータモデル</name>
      <t indent="0" pn="section-2-1">CBORは、CBORで表現できるすべてのデータアイテムのセットを定義するジェネリックデータモデルについて明示的に述べています。基本ジェネリックデータモデルは、「シンプルな値」とタグの登録によって拡張可能です。アプリケーションは、その結果の拡張されたジェネリックデータモデルのサブセットを作成して、特定データモデルを構築できます。</t>
      <t indent="0" pn="section-2-2">ジェネリックデータモデルでデータアイテムを表現できる環境では、一般的なCBORエンコーダーとデコーダーを実装できます（通常、環境に自然な表現がないデータアイテムに対して追加の実装データ型を定義する必要があります）。一般的なエンコーダーとデコーダーを提供することは、CBORの明示的な設計目標の1つです。ただし、多くのアプリケーションでは、独自のアプリケーション固有のエンコーダーやデコーダーを提供します。</t>
      <t indent="0" pn="section-2-3">拡張されていないジェネリックデータモデルでは、<xref target="encoding" format="default" sectionFormat="of" derivedContent="Section 3"/>で定義されているように、データアイテムは次のいずれかです。</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2-4">
        <li pn="section-2-4.1">-2<sup>64</sup>から2<sup>64</sup>-1までの範囲の整数</li>
        <li pn="section-2-4.2">単純な値。0から255までの数値で識別されますが、その数値自体とは異なります</li>
        <li pn="section-2-4.3">浮動小数点値。整数とは区別されます。IEEE 754 binary64 <xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/> で表現できない要素を含みます（非有限数を含む）</li>
        <li pn="section-2-4.4">0バイト以上のバイトのシーケンス（「バイト文字列」）</li>
        <li pn="section-2-4.5">0個以上のUnicodeコードポイントのシーケンス（「テキスト文字列」）</li>
        <li pn="section-2-4.6">0個以上のデータアイテムのシーケンス（「配列」）</li>
        <li pn="section-2-4.7">0個以上のデータアイテム（「キー」）から各々1つのデータアイテム（「値」）への写像（数学的関数）（「マップ」）</li>
        <li pn="section-2-4.8">タグ付きデータアイテム（「タグ」）。タグ番号（0から2<sup>64</sup>-1の範囲の整数）とタグコンテンツ（データアイテム）から構成されます</li>
      </ul>
      <t indent="0" pn="section-2-5">このモデルでは、整数値と浮動小数点値は異なることに注意してください。たとえ数値が同じであっても、それらは別々のデータアイテムとして扱われます。</t>
      <t indent="0" pn="section-2-6">また、シリアル化のバリアントは、ジェネリックデータモデルレベルでは見えません。この意図的な不在には、符号付き浮動小数点値のエンコードされたバイト数も含まれます。整数のエンコード、テキストまたはバイト文字列の長さのエンコード、配列内の要素数またはマップ内のペア数のエンコード、またはタグ番号のエンコードなどの「引数」（<xref target="encoding" format="default" sectionFormat="of" derivedContent="Section 3"/>を参照）のエンコードの選択肢も含まれます。</t>
      <section anchor="extended-generic-data-models" toc="include" numbered="true" removeInRFC="false" pn="section-2.1">
        <name slugifiedName="name-extended-generic-data-model">拡張ジェネリックデータモデル</name>
        <t indent="0" pn="section-2.1-1">基本ジェネリックデータモデルは、このドキュメントによって、次のようなシンプルな値とタグ番号の登録によって拡張されています。</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.1-2">
          <li pn="section-2.1-2.1">
            <tt>false</tt>、<tt>true</tt>、<tt>null</tt>、および<tt>undefined</tt>（20..23で識別されるシンプルな値、<xref target="fpnocont" format="default" sectionFormat="of" derivedContent="Section 3.3"/>）</li>
          <li pn="section-2.1-2.2">上記よりも大きな範囲と精度を持つ整数値および浮動小数点値
（タグ番号2から5、<xref target="tags" format="default" sectionFormat="of" derivedContent="Section 3.4"/>）</li>
          <li pn="section-2.1-2.3">RFC 3339で定義された時刻または日付/時刻文字列などのアプリケーションデータ型
（タグ番号1および0、<xref target="tags" format="default" sectionFormat="of" derivedContent="Section 3.4"/>）</li>
        </ul>
        <t indent="0" pn="section-2.1-3">拡張ジェネリックデータモデルの追加要素は、CBORのために作成されたIANAレジストリを介して定義されることができます（実際に定義されています）。このような拡張が一般的なエンコーダーやデコーダーには不明でも、その拡張を使用するデータアイテムは、基本ジェネリックデータモデル内のジェネリックなシンプルな値またはジェネリックなタグとして、アプリケーションインタフェース内で表現することによって、アプリケーションによって受け渡すことができます。</t>
        <t indent="0" pn="section-2.1-4">つまり、基本ジェネリックデータモデルは、このドキュメントで定義されたものとして安定しています。一方、拡張ジェネリックデータモデルは、新しいシンプルな値またはタグ番号の登録によって拡張されますが、縮小することはありません。</t>
        <t indent="0" pn="section-2.1-5">ジェネリックなエンコーダーやデコーダーが、プログラミング環境に適した形式で<tt>false</tt>、<tt>true</tt>、および<tt>null</tt>（<tt>undefined</tt>は意図的に省略されています）を表現できることが強く期待されていますが、タグによって作成されたデータモデルの拡張の実装は本当にオプションであり、実装品質の問題です。</t>
      </section>
      <section anchor="specific-data-models" toc="include" numbered="true" removeInRFC="false" pn="section-2.2">
        <name slugifiedName="name-specific-data-models">特定データモデル</name>
        <t indent="0" pn="section-2.2-1">CBORベースのプロトコルの特定データモデルは、通常、拡張ジェネリックデータモデルのサブセットを取り、このサブセットとそのコンポーネント内のデータアイテムにアプリケーションの意味を割り当てます。
   このような特定データモデルを文書化し、データアイテムのタイプを指定する場合、CBOR表現の側面（「メジャータイプ1」、「メジャータイプ4」）ではなく、ジェネリックデータモデルの名前（「負の整数」、「配列」）でタイプを識別することが望ましいです。</t>
        <t indent="0" pn="section-2.2-2">特定データモデルでは、マップキーとエンコーダーの自由度のために、値の等価性（異なる型の値を含む）を指定できます。たとえば、ジェネリックデータモデルでは、有効なマップには<tt>0</tt>と<tt>0.0</tt>の両方がキーとして含まれる<bcp14>場合があります（MAY）</bcp14>。エンコーダーは<tt>0.0</tt>を整数（メジャータイプ0、<xref target="majortypes" format="default" sectionFormat="of" derivedContent="Section 3.1"/>）としてエンコード<bcp14>してはなりません（MUST NOT）</bcp14>。<br/>
ただし、特定データモデルが整数値の浮動小数点表現と整数表現を等価と宣言する場合、単一のマップ内で両方のマップキー<tt>0</tt>と<tt>0.0</tt>を使用することは、重複とみなされます。異なるメジャータイプとしてエンコードされていても無効になります。なぜなら、エンコードされたバイトを節約するために、エンコーダーは整数値を持つ浮動小数点数を整数としてエンコードできるためです。その逆を行うこともできます。</t>
      </section>
    </section>
    <section anchor="encoding" toc="include" numbered="true" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-specification-of-the-cbor-e">CBORエンコーディングの仕様</name>
      <t indent="0" pn="section-3-1">このセクションでは、CBORデータアイテム（<xref target="cbor-data-models" format="default" sectionFormat="of" derivedContent="Section 2"/>）をウェルフォームなバイト文字列へエンコード、もしくはバイト文字列からデコードする方法を説明します。<xref target="jump-table" format="default" sectionFormat="of" derivedContent="Appendix B"/>の<xref target="jumptable" format="default" sectionFormat="of" derivedContent="Table 7"/>にまとめられているように、エンコーディングは最初のバイトによってインデックス化されています。エンコーダーはウェルフォームなエンコード済みデータアイテムのみを生成<bcp14>しなければなりません（MUST）</bcp14>。デコーダーはウェルフォームでない入力に遭遇した場合、デコード済みデータアイテムを返<bcp14>してはなりません（MUST NOT）</bcp14>。（これは、損傷したエンコード済みCBORデータアイテムから情報を利用可能にする診断回復ツールの有用性を損なうものではありません）。</t>
      <t indent="0" pn="section-3-2">エンコード済みデータアイテムの最初のバイトには、メジャータイプに関する情報（上位3ビット、<xref target="majortypes" format="default" sectionFormat="of" derivedContent="Section 3.1"/>で説明されています）と追加情報（下位5ビット）の両方が含まれます。いくつかの例外を除いて、追加情報の値は、符号なし整数の「引数」をどのようにロードするかを説明します。</t>
      <dl newline="false" spacing="normal" indent="3" pn="section-3-3">
        <dt pn="section-3-3.1">24未満:</dt>
        <dd pn="section-3-3.2">
  引数の値は、追加情報の値そのものです。</dd>
        <dt pn="section-3-3.3">24、25、26、または27:</dt>
        <dd pn="section-3-3.4">
  引数の値は、次の1、2、4、または8バイトに、それぞれネットワークバイトオーダーで保持されます。メジャータイプ7および追加情報値25、26、27の場合、これらのバイトは整数引数として使用されず、浮動小数点値として使用されます（<xref target="fpnocont" format="default" sectionFormat="of" derivedContent="Section 3.3"/>を参照）。</dd>
        <dt pn="section-3-3.5">28、29、30:</dt>
        <dd pn="section-3-3.6">
  これらの値は、将来のCBORフォーマットの追加のために予約されています。CBORの現在のバージョンでは、エンコードされたアイテムはウェルフォームではありません。</dd>
        <dt pn="section-3-3.7">31:</dt>
        <dd pn="section-3-3.8">
  引数値は導出されません。
メジャータイプが0、1、または6の場合、エンコードされたアイテムはウェルフォームではありません。メジャータイプ2から5の場合、アイテムの長さは不定であり、メジャータイプ7の場合、バイトはデータアイテムを構成せず、不定長アイテムを終了します。これらについては<xref target="indefinite" format="default" sectionFormat="of" derivedContent="Section 3.2"/>で説明されています。</dd>
      </dl>
      <t indent="0" pn="section-3-4">初期バイトと構築に消費される追加バイトは、データアイテムの<em>ヘッド</em>として集合的に参照されます。</t>
      <t indent="0" pn="section-3-5">この引数の意味は、メジャータイプに依存します。
たとえば、メジャータイプ0では、引数はデータアイテム自体の値です（メジャータイプ1では、データアイテムの値は引数から計算されます）。メジャータイプ2および3では、後続する文字列データのバイト数を指定します。メジャータイプ4および5では、囲まれたデータアイテムの数を決定するために使用されます。</t>
      <t indent="0" pn="section-3-6">エンコードされたバイト列がデータアイテムの終わりよりも前に終了した場合、そのアイテムはウェルフォームではありません。外側のエンコードされたアイテムがデコードされた後に、バイトが残っている場合、そのエンコードは単一のウェルフォームCBORアイテムではありません。アプリケーションによっては、デコーダーがエンコードをウェルフォームでないとして扱うか、残りのバイトの開始をアプリケーションに識別するだけで済む場合があります。</t>
      <t indent="0" pn="section-3-7">CBORデコーダーの実装は、初期バイトのすべての256定義値を持つジャンプテーブルに基づくことができます（<xref target="jumptable" format="default" sectionFormat="of" derivedContent="Table 7"/>）。制約のある実装のデコーダーは、代わりに初期バイトと後続するバイトの構造をよりコンパクトなコードに使用できます（これがどのように見えるかの大まかな印象については、<xref target="pseudocode" format="default" sectionFormat="of" derivedContent="Appendix C"/>を参照してください）。</t>
      <section anchor="majortypes" toc="include" numbered="true" removeInRFC="false" pn="section-3.1">
        <name slugifiedName="name-major-types">Major Types</name>
        <t indent="0" pn="section-3.1-1">以下は、メジャータイプとタイプに関連する追加情報およびその他のバイトを示しています。</t>
        <dl newline="true" spacing="normal" indent="3" pn="section-3.1-2">
          <dt pn="section-3.1-2.1">メジャータイプ0：</dt>
          <dd pn="section-3.1-2.2">
  0から2<sup>64</sup>-1までの範囲の符号なし整数。エンコードされたアイテムの値は引数自体です。たとえば、整数10は1バイトの0b000_01010（メジャータイプ0、追加情報10）として表されます。整数500は0b000_11001（メジャータイプ0、追加情報25）に続いて、10進数で500を表す2バイトの0x01f4が続きます。</dd>
          <dt pn="section-3.1-2.3">メジャータイプ1：</dt>
          <dd pn="section-3.1-2.4">
  -2<sup>64</sup>から-1までの範囲の負の整数。アイテムの値は、-1から引数を引いたものです。たとえば、整数-500は0b001_11001（メジャータイプ1、追加情報25）に続いて、10進数で499を表す2バイトの0x01f3が続きます。</dd>
          <dt pn="section-3.1-2.5">メジャータイプ2：</dt>
          <dd pn="section-3.1-2.6">
  バイト文字列。文字列のバイト数は引数と等しい。たとえば、長さが5のバイト文字列は、初期バイトが0b010_00101（メジャータイプ2、追加情報5で長さを示す）であるバイナリコンテンツの5バイトに続きます。長さが500のバイト文字列は、長さを示すための2バイトの0x01f4に続く3つの初期バイト0b010_11001（メジャータイプ2、追加情報25）を持ち、500バイトのバイナリコンテンツが続きます。</dd>
          <dt pn="section-3.1-2.7">メジャータイプ3：</dt>
          <dd pn="section-3.1-2.8">
  UTF-8でエンコードされたテキスト文字列（<xref target="cbor-data-models" format="default" sectionFormat="of" derivedContent="Section 2"/>）。文字列のバイト数は引数と等しい。無効なUTF-8シーケンスを含む文字列は、ウェルフォームではあるが無効である（<xref target="terminology" format="default" sectionFormat="of" derivedContent="Section 1.2"/>）。このタイプは、人間が読めるテキストを解釈または表示する必要があるシステム向けに提供され、構造化されていないバイトと、指定されたレパートリー（Unicodeのレパートリー）とエンコーディング（UTF-8）を持つテキストとの区別を可能にします。JSONなどのフォーマットとは異なり、このタイプのUnicode文字はエスケープされません。したがって、改行文字（U+000A）は常にバイト0x0aとして表され、文字"\"と"n"のバイト0x5c6eや、文字"\"、"u"、"0"、"0"、"0"、および"a"のバイト0x5c7530303061として表されることはありません。</dd>
          <dt pn="section-3.1-2.9">メジャータイプ4：</dt>
          <dd pn="section-3.1-2.10">
  データアイテムの配列。他のフォーマットでは、配列はリスト、シーケンス、またはタプルとも呼ばれます（「CBORシーケンス」は、<xref target="RFC8742" format="default" sectionFormat="of" derivedContent="RFC8742"/>でわずかに異なるものです）。
引数は、配列内のデータアイテムの数です。
配列内のアイテムはすべて同じタイプである必要はありません。たとえば、任意のタイプの10個のアイテムを含む配列は、初期バイトが0b100_01010（メジャータイプ4、追加情報10で長さを示す）であることに続き、残りの10個のアイテムが続きます。</dd>
          <dt pn="section-3.1-2.11">メジャータイプ5：</dt>
          <dd pn="section-3.1-2.12">
  データアイテムのペアのマップ。マップは、テーブル、ディクショナリ、ハッシュ、またはオブジェクト（JSONでは）とも呼ばれます。マップは、キーと値のペアで構成され、各ペアはすぐに値が続くキーで構成されます。引数は、マップ内のデータアイテムのペア数です。たとえば、9つのペアを含むマップは、初期バイトが0b101_01001（メジャータイプ5、追加情報9でペア数を示す）であることに続き、残りの18個のアイテムが続きます。最初のアイテムは最初のキー、2番目のアイテムは最初の値、3番目のアイテムは2番目のキーであり、以降続きます。マップ内のアイテムはペアであるため、その総数は常に偶数です。アイテムの数が奇数であるマップ（最後のキーデータアイテムの後に値データが存在しない場合）はウェルフォームではありません。重複するキーを持つマップはウェルフォームである場合がありますが、有効ではなく、したがって不確定なデコードを引き起こします。詳細については、<xref target="map-keys" format="default" sectionFormat="of" derivedContent="Section 5.6"/>も参照してください。</dd>
          <dt pn="section-3.1-2.13">メジャータイプ6：</dt>
          <dd pn="section-3.1-2.14">
  タグ番号が引数であるタグ付きデータアイテム（「タグ」）であり、タグ番号は0から2<sup>64</sup>-1までの範囲の整数であり、<em>タグコンテンツ</em>はヘッドに続く単一のエンコードされたデータアイテムです。
<xref target="tags" format="default" sectionFormat="of" derivedContent="Section 3.4"/>を参照してください。</dd>
          <dt pn="section-3.1-2.15">メジャータイプ7：</dt>
          <dd pn="section-3.1-2.16">
  浮動小数点数と単純な値、および「break」ストップコード。詳細については、<xref target="fpnocont" format="default" sectionFormat="of" derivedContent="Section 3.3"/>を参照してください。</dd>
        </dl>
        <t indent="0" pn="section-3.1-3">これらの8つのメジャータイプにより、データアイテムの初期バイトの256個の可能な値のうち、どの値が使用されるかを示す簡単な表が作成されます（<xref target="jumptable" format="default" sectionFormat="of" derivedContent="Table 7"/>）。</t>
        <t indent="0" pn="section-3.1-4">メジャータイプ6および7では、多くの可能な値が将来の仕様のために予約されています。これらの値に関する詳細については、<xref target="ianacons" format="default" sectionFormat="of" derivedContent="Section 9"/>を参照してください。</t>
        <t indent="0" pn="section-3.1-5"><xref target="major-type-table" format="default" sectionFormat="of" derivedContent="Table 1"/>は、CBORで定義されたメジャータイプを、<xref target="indefinite" format="default" sectionFormat="of" derivedContent="Section 3.2"/>を無視してまとめたものです。この表のNは引数を表します。</t>
        <table anchor="major-type-table" align="center" pn="table-1">
          <name slugifiedName="name-overview-over-the-definite-">Overview over the Definite-Length Use of CBOR Major Types (N = Argument)</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">メジャータイプ</th>
              <th align="left" colspan="1" rowspan="1">意味</th>
              <th align="left" colspan="1" rowspan="1">内容</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">0</td>
              <td align="left" colspan="1" rowspan="1">非負整数N</td>
              <td align="left" colspan="1" rowspan="1">-</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1">負の整数-1-N</td>
              <td align="left" colspan="1" rowspan="1">-</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2</td>
              <td align="left" colspan="1" rowspan="1">バイト文字列</td>
              <td align="left" colspan="1" rowspan="1">Nバイト</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">3</td>
              <td align="left" colspan="1" rowspan="1">テキスト文字列</td>
              <td align="left" colspan="1" rowspan="1">Nバイト（UTF-8テキスト）</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">4</td>
              <td align="left" colspan="1" rowspan="1">配列</td>
              <td align="left" colspan="1" rowspan="1">Nデータアイテム（要素）</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">5</td>
              <td align="left" colspan="1" rowspan="1">マップ</td>
              <td align="left" colspan="1" rowspan="1">2Nデータアイテム（キー/値のペア）</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">6</td>
              <td align="left" colspan="1" rowspan="1">数値Nのタグ</td>
              <td align="left" colspan="1" rowspan="1">1データアイテム</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">7</td>
              <td align="left" colspan="1" rowspan="1">シンプル/フロート</td>
              <td align="left" colspan="1" rowspan="1">-</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="indefinite" toc="include" numbered="true" removeInRFC="false" pn="section-3.2">
        <name slugifiedName="name-indefinite-lengths-for-some">Indefinite Lengths for Some Major Types</name>
        <t indent="0" pn="section-3.2-1">配列、マップ、バイト文字列、およびテキスト文字列の4つのCBORアイテムは、追加情報値31を使用して長さを決定せずにエンコードできます。これは、配列またはマップ内のアイテムの数、または文字列の総長がわからない場合に、アイテムのエンコードを開始する必要がある場合に便利です。 (データアイテムのすべてがわかる前にデータアイテムを送信を開始できる能力は、しばしばそのデータアイテム内で「ストリーミング」と呼ばれます。)</t>
        <t indent="0" pn="section-3.2-2">不定長の配列とマップは、不定長の文字列（バイト文字列とテキスト文字列）とは異なる方法で処理されます。</t>
        <section anchor="break" toc="include" numbered="true" removeInRFC="false" pn="section-3.2.1">
          <name slugifiedName="name-the-break-stop-code">The "break" Stop Code</name>
          <t indent="0" pn="section-3.2.1-1">「break」ストップコードは、メジャータイプ7および追加情報値31（0b111_11111）でエンコードされます。それ自体はデータアイテムではありません。不定長アイテムを閉じるための構文的な機能です。</t>
          <t indent="0" pn="section-3.2.1-2">データアイテムが期待される場所で「break」ストップコードが現れた場合、不定長文字列、配列、またはマップの直接内部以外の場所で（たとえば、定義済み長の配列またはマップの直接内部でない場合）、囲んでいるアイテムは正しく形成されていません。</t>
        </section>
        <section anchor="indef" toc="include" numbered="true" removeInRFC="false" pn="section-3.2.2">
          <name slugifiedName="name-indefinite-length-arrays-an">Indefinite-Length Arrays and Maps</name>
          <t indent="0" pn="section-3.2.2-1">不定長の配列とマップは、追加情報値31を使用してメジャータイプを表し、配列の場合は任意長の0個以上のアイテムのシーケンス、マップの場合はキー/値のペアのシーケンスが続き、「break」ストップコード(<xref target="break" format="default" sectionFormat="of" derivedContent="Section 3.2.1"/>)で終了します。つまり、不定長の配列とマップは、追加情報値31で始まり、「break」ストップコードで終わる以外は、他の配列とマップと同じように見えます。</t>
          <t indent="0" pn="section-3.2.2-2">マップ内のキーの後に「break」ストップコードが現れた場合、そのキーの値の代わりに、マップは正しく形成されていません。</t>
          <t indent="0" pn="section-3.2.2-3">不定長配列またはマップアイテムをネストする制限はありません。「break」は単一のアイテムを終了するだけであるため、不定長アイテムを開始するタイプバイトがあるだけ、ネストされた不定長アイテムには正確に同じ数の「break」ストップコードが必要です。</t>
          <t indent="0" pn="section-3.2.2-4">たとえば、エンコーダーが抽象的な配列[1、[2、3]、[4、5]]を表現したい場合、定義済み長エンコーディングは0x8301820203820405となります。</t>
          <artwork type="hex-dump" align="left" pn="section-3.2.2-5">
83        -- 長さ3の配列
   01     -- 1
   82     -- 長さ2の配列
      02  -- 2
      03  -- 3
   82     -- 長さ2の配列
      04  -- 4
      05  -- 5
</artwork>
          <t indent="0" pn="section-3.2.2-6">このデータアイテムでエンコードされた3つの配列それぞれに対して、必要に応じて不定長エンコーディングを独立して適用でき、次のような表現が得られます。</t>
          <artwork type="hex-dump" align="left" pn="section-3.2.2-7">
0x9f018202039f0405ffff
9F        -- 不定長配列の開始
   01     -- 1
   82     -- 長さ2の配列
      02  -- 2
      03  -- 3
   9F     -- 不定長配列の開始
      04  -- 4
      05  -- 5
      FF  -- 「break」ストップコード（内側の配列）
   FF     -- 「break」ストップコード（外側の配列）
</artwork>
          <artwork type="hex-dump" align="left" pn="section-3.2.2-8">
0x9f01820203820405ff
9F        -- 不定長配列の開始
   01     -- 1
   82     -- 長さ2の配列
      02  -- 2
      03  -- 3
   82     -- 長さ2の配列
      04  -- 4
      05  -- 5
   FF     -- 「break」ストップコード
</artwork>
          <artwork type="hex-dump" align="left" pn="section-3.2.2-9">
0x83018202039f0405ff
83        -- 長さ3の配列
   01     -- 1
   82     -- 長さ2の配列
      02  -- 2
      03  -- 3
   9F     -- 不定長配列の開始
      04  -- 4
      05  -- 5
      FF  -- 「break」ストップコード
</artwork>
          <artwork type="hex-dump" align="left" pn="section-3.2.2-10">
0x83019f0203ff820405
83        -- 長さ3の配列
   01     -- 1
   9F     -- 不定長配列の開始
      02  -- 2
      03  -- 3
      FF  -- 「break」ストップコード
   82     -- 長さ2の配列
      04  -- 4
      05  -- 5
</artwork>
          <t indent="0" pn="section-3.2.2-11">不定長マップの例（2つのキー/値ペアを持つ）は次のようになります。</t>
          <artwork type="hex-dump" align="left" pn="section-3.2.2-12">
0xbf6346756ef563416d7421ff
BF           -- 不定長マップの開始
   63        -- 最初のキー、UTF-8文字列長3
      46756e --   "Fun"
   F5        -- 最初の値、true
   63        -- 2番目のキー、UTF-8文字列長3
      416d74 --   "Amt"
   21        -- 2番目の値、-2
   FF        -- 「break」ストップコード
</artwork>
        </section>
        <section anchor="indefinite-length-byte-strings-and-text-strings" toc="include" numbered="true" removeInRFC="false" pn="section-3.2.3">
          <name slugifiedName="name-indefinite-length-byte-stri">Indefinite-Length Byte Strings and Text Strings</name>
          <t indent="0" pn="section-3.2.3-1">不定長文字列は、バイト文字列またはテキスト文字列のメジャータイプを表すバイトと、追加情報値31を含むシリーズのゼロ個以上の指定されたタイプの文字列（「チャンク」）に続いて、「break」ストップコード（<xref target="break" format="default" sectionFormat="of" derivedContent="Section 3.2.1"/>）で終了します。不定長文字列で表されるデータアイテムは、チャンクの連結です。チャンクが存在しない場合、データアイテムは指定されたタイプの空の文字列です。長さゼロのチャンクは、特に有用ではありませんが、許可されています。</t>
          <t indent="0" pn="section-3.2.3-2">不定長文字列指示子（0b010_11111または0b011_11111）と「break」ストップコードの間にあるアイテムのうち、同じメジャータイプの定長文字列アイテムでないものがある場合、文字列は正しく形成されていません。</t>
          <t indent="0" pn="section-3.2.3-3">この設計では、不定長文字列をチャンクとして不定長文字列にネストすることはできません。許可された場合、デコーダーの実装にはスタック、または少なくともネストレベルのカウントを保持する必要があります。内部の不定長文字列はチャンクで構成されているため、エンコーダー側では不要であり、これらは代わりに外部の不定長文字列に直接配置できます。</t>
          <t indent="0" pn="section-3.2.3-4">不定長テキスト文字列内の定長テキスト文字列のいずれかが無効な場合、不定長テキスト文字列は無効です。これは、単一のUnicodeコードポイント（スカラー値）のUTF-8バイトがチャンク間に分散されることはできないことを意味します。つまり、テキスト文字列の新しいチャンクは、コードポイントの境界でのみ開始できます。</t>
          <t indent="0" pn="section-3.2.3-5">たとえば、次のバイトから構成される符号化されたデータアイテムを想定してください。</t>
<artwork type="hex-dump" align="left" pn="section-3.2.3-7">
0b010_11111 0b011_11111 0b010_00100 0xaabbccdd 0b010_00011 0xeeff99 0b111_11111
5F              -- Start indefinite-length byte string
   44           -- Byte string of length 4
      aabbccdd  -- Bytes content
   43           -- Byte string of length 3
      eeff99    -- Bytes content
   FF           -- "break"
</artwork>
          <t indent="0" pn="section-3.2.3-7">デコード後、これにより7バイトの単一のバイト文字列が生成されます：0xaabbccddeeff99。</t>
        </section>
        <section anchor="summary-of-indefinite-length-use-of-major-types" toc="include" numbered="true" removeInRFC="false" pn="section-3.2.4">
          <name slugifiedName="name-summary-of-indefinite-lengt">Summary of Indefinite-Length Use of Major Types</name>
          <t indent="0" pn="section-3.2.4-1"><xref target="major-type-indef-table" format="default" sectionFormat="of" derivedContent="Table 2"/> は、追加情報値31を使用して不定長エンコーディングに使用されるCBORによって定義されたメジャータイプをまとめたものです。</t>
          <table anchor="major-type-indef-table" align="center" pn="table-2">
            <name slugifiedName="name-overview-of-the-indefinite-">Overview of the Indefinite-Length Use of CBOR Major Types (Additional Information = 31)</name>
            <thead>
              <tr>
                  <th align="left" colspan="1" rowspan="1">メジャータイプ</th>
                  <th align="left" colspan="1" rowspan="1">意味</th>
                  <th align="left" colspan="1" rowspan="1">「break」ストップコードまでの内容</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">0</td>
                <td align="left" colspan="1" rowspan="1">(not well-formed)</td>
                <td align="left" colspan="1" rowspan="1">-</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">1</td>
                <td align="left" colspan="1" rowspan="1">(not well-formed)</td>
                <td align="left" colspan="1" rowspan="1">-</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">2</td>
                <td align="left" colspan="1" rowspan="1">byte string</td>
                <td align="left" colspan="1" rowspan="1">definite-length byte strings</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">3</td>
                <td align="left" colspan="1" rowspan="1">text string</td>
                <td align="left" colspan="1" rowspan="1">definite-length text strings</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">4</td>
                <td align="left" colspan="1" rowspan="1">array</td>
                <td align="left" colspan="1" rowspan="1">data items (elements)</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">5</td>
                <td align="left" colspan="1" rowspan="1">map</td>
                <td align="left" colspan="1" rowspan="1">data items (key/value pairs)</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">6</td>
                <td align="left" colspan="1" rowspan="1">(not well-formed)</td>
                <td align="left" colspan="1" rowspan="1">-</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">7</td>
                <td align="left" colspan="1" rowspan="1">"break" stop code</td>
                <td align="left" colspan="1" rowspan="1">-</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="fpnocont" toc="include" numbered="true" removeInRFC="false" pn="section-3.3">
        <name slugifiedName="name-floating-point-numbers-and-">Floating-Point Numbers and Values with No Content</name>
        <t indent="0" pn="section-3.3-1">メジャータイプ7は、浮動小数点数とコンテンツを必要としない「シンプルな値」の2つのデータタイプに使用されます。初期バイトの5ビットの追加情報値の各値には、<xref target="fpnoconttbl" format="default" sectionFormat="of" derivedContent="Table 3"/>で定義された独自の意味があります。整数のメジャータイプと同様に、このメジャータイプのアイテムにはコンテンツデータが含まれていません。すべての情報は初期バイト（ヘッド）に含まれています。</t>
        <table anchor="fpnoconttbl" align="center" pn="table-3">
          <name slugifiedName="name-values-for-additional-infor">Values for Additional Information in Major Type 7</name>
          <thead>
            <tr>
                <th align="left" colspan="1" rowspan="1">5ビット値</th>
                <th align="left" colspan="1" rowspan="1">意味</th>
            </tr>
          </thead>
          <tbody>
            <tr>
                <td align="left" colspan="1" rowspan="1">0..23</td>
                <td align="left" colspan="1" rowspan="1">シンプルな値（値0..23）</td>
            </tr>
            <tr>
                <td align="left" colspan="1" rowspan="1">24</td>
                <td align="left" colspan="1" rowspan="1">シンプルな値（値32..255は次のバイトにある）</td>
            </tr>
            <tr>
                <td align="left" colspan="1" rowspan="1">25</td>
                <td align="left" colspan="1" rowspan="1">IEEE 754半精度浮動小数点数（16ビットが続く）</td>
            </tr>
            <tr>
                <td align="left" colspan="1" rowspan="1">26</td>
                <td align="left" colspan="1" rowspan="1">IEEE 754単精度浮動小数点数（32ビットが続く）</td>
            </tr>
            <tr>
                <td align="left" colspan="1" rowspan="1">27</td>
                <td align="left" colspan="1" rowspan="1">IEEE 754倍精度浮動小数点数（64ビットが続く）</td>
            </tr>
            <tr>
                <td align="left" colspan="1" rowspan="1">28-30</td>
                <td align="left" colspan="1" rowspan="1">予約済み、現在の文書では正しく形成されていません</td>
            </tr>
            <tr>
                <td align="left" colspan="1" rowspan="1">31</td>
                <td align="left" colspan="1" rowspan="1">不定長アイテムの「break」ストップコード（<xref target="break" format="default" sectionFormat="of" derivedContent="Section 3.2.1"/>参照）</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-3.3-3">他のすべてのメジャータイプと同様に、5ビット値24は単一バイト拡張を示します。これに続いて、追加のバイトが続き、シンプルな値を表します（混乱を最小限に抑えるため、値32から255のみが使用されます）。これにより、初期バイトの構造が維持されます。他のメジャータイプと同様に、これらの長さは常に最初のバイトの追加情報に依存します。<xref target="fpnoconttbl2" format="default" sectionFormat="of" derivedContent="Table 4"/> には、シンプルな値に割り当てられた数値値と使用可能な値がリストされています。</t>
        <table anchor="fpnoconttbl2" align="center" pn="table-4">
          <name slugifiedName="name-simple-values">Simple Values</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">値</th>
              <th align="left" colspan="1" rowspan="1">意味</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">0..19</td>
              <td align="left" colspan="1" rowspan="1">(unassigned)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">20</td>
              <td align="left" colspan="1" rowspan="1">false</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">21</td>
              <td align="left" colspan="1" rowspan="1">true</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">22</td>
              <td align="left" colspan="1" rowspan="1">null</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">23</td>
              <td align="left" colspan="1" rowspan="1">undefined</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">24..31</td>
              <td align="left" colspan="1" rowspan="1">(reserved)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">32..255</td>
              <td align="left" colspan="1" rowspan="1">(unassigned)</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-3.3-5">エンコーダーは、0xf8（メジャータイプ7、追加情報値24）で始まり、0x20（10進数32）未満のバイトで続く2バイトシーケンスを発行<bcp14>してはなりません（MUST NOT）</bcp14>。このようなシーケンスはウェルフォームではありません。（これは、エンコーダーが2バイトシーケンスで<tt>false</tt>、<tt>true</tt>、<tt>null</tt>、または<tt>undefined</tt>をエンコードできないことを意味し、これらの1バイトバリアントのみが正しく形成されることを意味します。より一般的には、各シンプルな値には単一の表現バリアントしかありません。）</t>
        <t indent="0" pn="section-3.3-6">メジャータイプ25、26、27の5ビット値は、16ビット、32ビット、64ビットのIEEE 754バイナリ浮動小数点値<xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/>に使用されます。これらの浮動小数点値は、適切なサイズの追加バイトでエンコードされます。 （16ビット浮動小数点数に関する情報については、<xref target="half-precision" format="default" sectionFormat="of" derivedContent="Appendix D"/>を参照してください。）</t>
      </section>
      <section anchor="tags" toc="include" numbered="true" removeInRFC="false" pn="section-3.4">
        <name slugifiedName="name-tagging-of-items">Tagging of Items</name>
        <t indent="0" pn="section-3.4-1">CBORでは、データアイテムにタグを付けることで、<em>タグ番号</em>によって一意に識別されるいくつかの追加セマンティクスを付与できます。タグはメジャータイプ6であり、その引数（<xref target="encoding" format="default" sectionFormat="of" derivedContent="Section 3"/>で定義されている）はタグ番号を示し、単一の囲まれたデータアイテムである<em>タグコンテンツ</em>を含みます。 （タグにコンテンツのさらなる構造が必要な場合は、この構造は囲まれたデータアイテムによって提供されます。）私たちは、タグ番号とタグコンテンツの両方から構成されるデータアイテム全体を<em>タグ</em>と呼びます：タグコンテンツは、タグが付けられているデータアイテムです。</t>
        <t indent="0" pn="section-3.4-2">たとえば、長さ12のバイト文字列が、符号なしの<em>bignum</em>（<xref target="bignums" format="default" sectionFormat="of" derivedContent="Section 3.4.3"/>）であることを示すために、タグ番号2でマークされているとします。エンコードされたデータアイテムは、バイト0b110_00010（メジャータイプ6、タグ番号の追加情報2）で始まり、エンコードされたタグコンテンツが続きます：0b010_01100（長さの追加情報12のメジャータイプ2）に続いて、bignumの12バイトが続きます。</t>
        <t indent="0" pn="section-3.4-3">拡張ジェネリックデータモデルでは、タグ番号の定義によって、タグ番号で伝達される追加のセマンティクスが説明されます。これらのセマンティクスには、基本的なジェネリックデータモデルで表現できるものを含め、タグ付きデータアイテムの一部を他のデータアイテムと同等にすることができます。たとえば、タグコンテンツが単一バイト0x01のバイト文字列である0xc24101のbignumは、整数1と等価であり、0x01、0x1801、または0x190001でエンコードすることもできます。タグの定義では、ジェネリックエンコーダーに推奨される優先シリアル化（<xref target="preferred" format="default" sectionFormat="of" derivedContent="Section 4.1"/>）を指定できます。これにより、タグを使用するものよりも基本的なジェネリックデータモデルの表現が優先される場合があります。</t>
        <t indent="0" pn="section-3.4-4">タグの定義では、通常、そのようなタグに対して有効なネストされたデータアイテムを定義します。タグの定義は、このドキュメントで定義されているタグのように、非常に特定の構文構造にその内容を制限することができます。また、より意味的な方法でその内容を定義することもできます。後者の例として、タグ40および1040が配列を表す複数の方法を受け入れる方法があります。<xref target="RFC8746" format="default" sectionFormat="of" derivedContent="RFC8746"/>。</t>
        <t indent="0" pn="section-3.4-5">多くのタグでは、<tt>null</tt>または<tt>undefined</tt>の値をタグコンテンツとして受け入れないことが慣例となっています。代わりに、<tt>null</tt>または<tt>undefined</tt>の値は、タグ全体の代わりに使用できることが期待されています。<xref target="epochdatetimesect" format="default" sectionFormat="of" derivedContent="Section 3.4.2"/>は、アプリケーションプロトコルおよびプラットフォームタイプへのマッピングにおけるこの慣例の扱いについて、1つの特定のタグに関するさらなる考慮事項を提供しています。</t>
        <t indent="0" pn="section-3.4-6">デコーダーは、すべてのタグ番号のタグを理解する必要はなく、特定のCBORデータアイテムを作成する実装と、そのストリームをデコードする実装がデータフロー内の各アイテムの意味を知っているアプリケーションでは、タグがあまり役に立たない場合があります。この仕様におけるタグの主な目的は、日付などの共通のデータ型を定義することです。2次的な目的は、アイテムの内容に関するヒントが必要な別の形式にCBORデータアイテムを変換する必要がある場合に、変換ヒントを提供することです。タグの意味を理解することは、デコーダーにとってオプションです。デコーダーは、単にタグ番号とタグコンテンツの両方をアプリケーションに提示し、タグの追加セマンティクスを解釈せずに済ませることができます。</t>
        <t indent="0" pn="section-3.4-7">タグは、それが囲んでいるデータアイテムにセマンティクスを適用します。
タグはネストできます。つまり、タグAがタグBを囲み、タグBがデータアイテムCを囲む場合、タグAはデータアイテムCにタグBを適用した結果にタグを適用します。</t>
        <t indent="0" pn="section-3.4-8">IANAは、<xref target="ianatags" format="default" sectionFormat="of" derivedContent="Section 9.2"/>で説明されているように、タグ番号のレジストリを維持しています。
<xref target="tagvalues" format="default" sectionFormat="of" derivedContent="Table 5"/>は、このセクションの残りの部分で定義されたタグ番号のリストを提供します。
（タグ番号35も RFC7049 で定義されています。このタグ番号に関する議論は、<xref target="encodedtext" format="default" sectionFormat="of" derivedContent="Section 3.4.5.3"/>で続きます。）
RFC7049 の発行以降、多くの他のタグ番号が定義されています。完全なリストについては、<xref target="ianatags" format="default" sectionFormat="of" derivedContent="Section 9.2"/>で説明されているレジストリを参照してください。</t>
        <table anchor="tagvalues" align="center" pn="table-5">
          <name slugifiedName="name-tag-numbers-defined-in-rfc-">Tag Numbers Defined in RFC 7049</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">タグ</th>
              <th align="left" colspan="1" rowspan="1">データアイテム</th>
              <th align="left" colspan="1" rowspan="1">セマンティクス</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">0</td>
              <td align="left" colspan="1" rowspan="1">text string</td>
              <td align="left" colspan="1" rowspan="1">Standard date/time string; see <xref target="stringdatetimesect" format="default" sectionFormat="of" derivedContent="Section 3.4.1"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1">integer or float</td>
              <td align="left" colspan="1" rowspan="1">Epoch-based date/time; see <xref target="epochdatetimesect" format="default" sectionFormat="of" derivedContent="Section 3.4.2"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2</td>
              <td align="left" colspan="1" rowspan="1">byte string</td>
              <td align="left" colspan="1" rowspan="1">Unsigned bignum; see <xref target="bignums" format="default" sectionFormat="of" derivedContent="Section 3.4.3"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">3</td>
              <td align="left" colspan="1" rowspan="1">byte string</td>
              <td align="left" colspan="1" rowspan="1">Negative bignum; see <xref target="bignums" format="default" sectionFormat="of" derivedContent="Section 3.4.3"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">4</td>
              <td align="left" colspan="1" rowspan="1">array</td>
              <td align="left" colspan="1" rowspan="1">Decimal fraction; see <xref target="fractions" format="default" sectionFormat="of" derivedContent="Section 3.4.4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">5</td>
              <td align="left" colspan="1" rowspan="1">array</td>
              <td align="left" colspan="1" rowspan="1">Bigfloat; see <xref target="fractions" format="default" sectionFormat="of" derivedContent="Section 3.4.4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">21</td>
              <td align="left" colspan="1" rowspan="1">(any)</td>
              <td align="left" colspan="1" rowspan="1">Expected conversion to base64url encoding; see <xref target="convexpect" format="default" sectionFormat="of" derivedContent="Section 3.4.5.2"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">22</td>
              <td align="left" colspan="1" rowspan="1">(any)</td>
              <td align="left" colspan="1" rowspan="1">Expected conversion to base64 encoding; see <xref target="convexpect" format="default" sectionFormat="of" derivedContent="Section 3.4.5.2"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">23</td>
              <td align="left" colspan="1" rowspan="1">(any)</td>
              <td align="left" colspan="1" rowspan="1">Expected conversion to base16 encoding; see <xref target="convexpect" format="default" sectionFormat="of" derivedContent="Section 3.4.5.2"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">24</td>
              <td align="left" colspan="1" rowspan="1">byte string</td>
              <td align="left" colspan="1" rowspan="1">Encoded CBOR data item; see <xref target="embedded-di" format="default" sectionFormat="of" derivedContent="Section 3.4.5.1"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">32</td>
              <td align="left" colspan="1" rowspan="1">text string</td>
              <td align="left" colspan="1" rowspan="1">URI; see <xref target="encodedtext" format="default" sectionFormat="of" derivedContent="Section 3.4.5.3"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">33</td>
              <td align="left" colspan="1" rowspan="1">text string</td>
              <td align="left" colspan="1" rowspan="1">base64url; see <xref target="encodedtext" format="default" sectionFormat="of" derivedContent="Section 3.4.5.3"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">34</td>
              <td align="left" colspan="1" rowspan="1">text string</td>
              <td align="left" colspan="1" rowspan="1">base64; see <xref target="encodedtext" format="default" sectionFormat="of" derivedContent="Section 3.4.5.3"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">36</td>
              <td align="left" colspan="1" rowspan="1">text string</td>
              <td align="left" colspan="1" rowspan="1">MIME message; see <xref target="encodedtext" format="default" sectionFormat="of" derivedContent="Section 3.4.5.3"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">55799</td>
              <td align="left" colspan="1" rowspan="1">(any)</td>
              <td align="left" colspan="1" rowspan="1">Self-described CBOR; see <xref target="self-describe" format="default" sectionFormat="of" derivedContent="Section 3.4.6"/></td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-3.4-10">概念的には、タグは一般的なデータモデルで解釈され、(de-)シリアル化時に解釈されます。少数のタグ（現時点では、タグ番号25とタグ番号29<xref target="IANA.cbor-tags" format="default" sectionFormat="of" derivedContent="IANA.cbor-tags"/>）は、(de-)シリアル化時に処理が必要なセマンティクスで登録されています。デコーダーは、CBORデータアイテムにデータアイテムがエンコードされる正確なシーケンスを把握する必要があり、エンコーダーはその制御下にある必要があります。これは、これらのタグが任意の一般的なCBORエンコーダー/デコーダーの上に実装できないことを意味します（データモデルレベルのマップのエントリのシリアル化順序とその逆を反映しない可能性があるため）。そのため、これらのタグの実装は通常、一般的なエンコーダー/デコーダーに統合する必要があります。このようなプロパティを持つ新しいタグの定義は、<bcp14>推奨されていません</bcp14>。</t>
        <t indent="0" pn="section-3.4-11">IANAは、タグ番号65535、4294967295、および18446744073709551615（16ビット、32ビット、および64ビットのすべてが1であるバイナリ）を割り当てました。
これらは、特定のタグの存在またはタグの不在を示す単一の整数データ構造を実装者が必要とする場合の便宜のために使用できます。
この割り当てについては、<xref target="I-D.bormann-cbor-notable-tags" section="10" sectionFormat="of" format="default" derivedLink="https://tools.ietf.org/html/draft-bormann-cbor-notable-tags-02#section-10" derivedContent="CBOR-TAGS"/>で説明されています。
これらのタグは、実際のCBORデータアイテムには出現しないことが意図されています。
実装は、そのような出現をエラーとしてフラグ付けする<bcp14>ことができます</bcp14>。</t>
        <t indent="0" pn="section-3.4-12">プロトコルは、タグ番号0および1を使用して時間の点を表すデータアイテム、タグ番号2および3を使用して任意のサイズの整数、およびタグ番号4および5を使用して任意のサイズと精度の浮動小数点値を使用して、一般的なデータモデル(<xref target="cbor-data-models" format="default" sectionFormat="of" derivedContent="Section 2"/>)を拡張することができます。</t>
        <section anchor="stringdatetimesect" toc="include" numbered="true" removeInRFC="false" pn="section-3.4.1">
          <name slugifiedName="name-standard-date-time-string">Standard Date/Time String</name>
          <t indent="0" pn="section-3.4.1-1">タグ番号0には、<xref target="RFC3339" format="default" sectionFormat="of" derivedContent="RFC3339"/>で説明されている標準的なフォーマットのテキスト文字列が含まれます。このフォーマットは、<xref target="RFC4287" section="3.3" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4287#section-3.3" derivedContent="RFC4287"/>によって改良され、そこで説明されている時点を表します。他のタイプのネストされたアイテムや、<xref target="RFC4287" format="default" sectionFormat="of" derivedContent="RFC4287"/>で説明されているフォーマットに一致しないテキスト文字列は無効です。</t>
        </section>
        <section anchor="epochdatetimesect" toc="include" numbered="true" removeInRFC="false" pn="section-3.4.2">
          <name slugifiedName="name-epoch-based-date-time">Epoch-Based Date/Time</name>
          <t indent="0" pn="section-3.4.2-1">タグ番号1には、UTC時間で1970年1月1日00:00Zから表される時点までの秒数を数える数値が含まれています。</t>
          <t indent="0" pn="section-3.4.2-2">タグの内容は、符号なしまたは負の整数（主要型0および1）または浮動小数点数（主要型7と追加情報25、26、または27）である<bcp14>必要があります（MUST）</bcp14>。<bcp14>それ以外の含まれる型は無効です</bcp14>。</t>
          <t indent="0" pn="section-3.4.2-3">非負の値（主要型0および非負の浮動小数点数）は、1970-01-01T00:00Z UTC以降の時刻値を表し、POSIX <xref target="TIME_T" format="default" sectionFormat="of" derivedContent="TIME_T"/>にしたがって解釈されます。
（POSIX時間は「UNIXエポック時間」としても知られています。）
POSIX時間では、閏秒は特別に扱われ、数十年に数回1秒の不連続性が生じます。
なお、早期の2106年以降の時刻の表現を必要とするアプリケーションは、タグの内容に64ビット整数のサポートを省略できません。</t>
          <t indent="0" pn="section-3.4.2-4">負の値（主要型1および負の浮動小数点数）は、1970-01-01T00:00Z以前のUTC秒数の時間を決定するための普遍的な標準がないため、アプリケーションの要件によって解釈されます（これは、国民的なカレンダーの不連続性の前の時点にとくに当てはまります）。 非有限値についても同様です。</t>
          <t indent="0" pn="section-3.4.2-5">小数秒を示すために、整数値の代わりにタグ番号1内で浮動小数点値を使用できます。ただし、これには一般的にバイナリ64のサポートが必要であり、バイナリ16およびバイナリ32は1970年前後の短い期間にしか秒未満の小数を提供しません。タグ番号1のサポートが必要なアプリケーションは、タグの内容を整数値（または浮動小数点値）に制限することがあります。</t>
          <t indent="0" pn="section-3.4.2-6">日付/時刻のプラットフォーム型には、アプリケーションプロトコルレベルで望ましい場合がある<tt>null</tt>または<tt>undefined</tt>の値が含まれる場合があります。
非有限のタグコンテンツ値（例：未定義の日付/時刻値にNaNを使用するか、設定されていない有効期限日にInfinityを使用する）でタグ番号1値を出力することは、これを処理する明らかな方法のように思えるかもしれませんが、非有限値の使用を避け、より短いエンコーディングを生成するために、タグのない<tt>null</tt>または<tt>undefined</tt>を使用できます。
アプリケーションプロトコルの設計者は、これらのケースを考慮し、それらを処理するための明確なガイドラインを含めることが推奨されます。</t>
        </section>
        <section anchor="bignums" toc="include" numbered="true" removeInRFC="false" pn="section-3.4.3">
          <name slugifiedName="name-bignums">Bignums</name>
          <t indent="0" pn="section-3.4.3-1">タグ番号2および3を使用するプロトコルは、任意のサイズの整数を表す「bignums」で一般的なデータモデル(<xref target="cbor-data-models" format="default" sectionFormat="of" derivedContent="Section 2"/>)を拡張します。基本的な一般的なデータモデルでは、bignum値は同じモデルの整数と等しくありませんが、このタグ定義によって作成された拡張一般的なデータモデルは、数値値に基づく同等性を定義し、優先されるシリアル化(<xref target="preferred" format="default" sectionFormat="of" derivedContent="Section 4.1"/>)は、基本的な整数として表現できるbignumsを使用しません（以下を参照）。</t>
          <t indent="0" pn="section-3.4.3-2">bignumは、符号なし整数nとして解釈されるバイト文字列データアイテムとしてエンコードされます。他のタイプの含まれるアイテムは無効です。タグ番号2の場合、bignumの値はnです。タグ番号3の場合、bignumの値は-1-nです。バイト文字列の優先シリアル化は、先頭のゼロを省略することです（n = 0の場合、優先シリアル化は空のバイト文字列ですが、以下を参照してください）。
これらのタグを理解するデコーダーは、先頭にゼロがあるbignumをデコードできる<bcp14>必要があります</bcp14>。
主要型0または1で表現できる整数の優先シリアル化は、bignumとしてエンコードする代わりにこの方法でエンコードすることです（つまり、優先シリアル化を使用する場合、空の文字列はbignumには決して現れません）。
つまり、数値をエンコードするための基本的な整数の代わりにbignum表現を選択する非優先選択肢には、アプリケーションセマンティクスがあるわけではないことに注意してください（つまり、0x00の代わりに0x1800など、必要以上に長い基本的な整数表現を選択することと同様です）。</t>
          <t indent="0" pn="section-3.4.3-3">たとえば、数値18446744073709551616（2<sup>64</sup>）は、0b110_00010（主要型6、タグ番号2）で表され、次に0b010_01001（主要型2、長さ9）が続き、その後に0x010000000000000000（1バイト0x01と8バイト0x00）が続きます。16進数で表すと：</t>
          <artwork type="hex-dump" align="left" pn="section-3.4.3-4">
C2                        -- タグ2
   49                     -- 長さ9のバイト文字列
      010000000000000000  -- バイトの内容
</artwork>
        </section>
        <section anchor="fractions" toc="include" numbered="true" removeInRFC="false" pn="section-3.4.4">
          <name slugifiedName="name-decimal-fractions-and-bigfl">Decimal Fractions and Bigfloats</name>
          <t indent="0" pn="section-3.4.4-1">タグ番号4を使用するプロトコルは、m*(10<sup>e</sup>)の形式の任意長の10進小数を表すデータアイテムで一般的なデータモデルを拡張します。
タグ番号5を使用するプロトコルは、m*(2<sup>e</sup>)の形式の任意長の2進小数を表すデータアイテムで一般的なデータモデルを拡張します。
bignumと同様に、異なる型の値は一般的なデータモデルでは等しくありません。</t>
          <t indent="0" pn="section-3.4.4-2">10進小数は、整数の仮数と10進のスケーリング因子を組み合わせたものです。多くの10進小数には、2進浮動小数点表現では正確な表現がないため、1.1のような10進小数の正確な表現が必要な場合に最も有用です。</t>
          <t indent="0" pn="section-3.4.4-3">「Bigfloats」は、整数の仮数と2進のスケーリング因子を組み合わせたものです。
これらは、CBORでサポートされている3つのIEEE 754フォーマットの範囲または精度を超えるバイナリ浮動小数点値です
(<xref target="fpnocont" format="default" sectionFormat="of" derivedContent="Section 3.3"/>）。Bigfloatsは、IEEE 754のサポートが必要なく、基本的なバイナリ浮動小数点機能が必要な制約されたアプリケーションでも使用できます。</t>
          <t indent="0" pn="section-3.4.4-4">10進小数またはBigfloatは、正確に2つの整数値（指数eと仮数m）を含むタグ付き配列として表されます。
10進小数（タグ番号4）は、10進の指数を使用します。10進小数データアイテムの値はm*(10<sup>e</sup>)です。
Bigfloat（タグ番号5）は、2進の指数を使用します。Bigfloatデータアイテムの値はm*(2<sup>e</sup>)です。
指数eは、整数の主要型0または1で表現する必要があります。仮数はbignumであることもできます
(<xref target="bignums" format="default" sectionFormat="of" derivedContent="Section 3.4.3"/>）。他の構造を持つアイテムは無効です。<bcp14>必ず</bcp14>注意してください。</t>
          <t indent="0" pn="section-3.4.4-5">10進小数の例として、数値273.15の表現があります。これは、0b110_00100（主要型6のタグ、追加情報4のタグ番号）に続いて、0b100_00010（配列の主要型4、長さ2の追加情報）が続き、次に0b001_00001（最初の整数の主要型1、値-2の追加情報1）が続き、次に0b000_11001（2バイト値の追加情報25の第2整数の主要型0）が続き、最後に0b0110101010110011（2バイトの27315）が続きます。16進数で表すと：</t>
          <artwork type="hex-dump" align="left" pn="section-3.4.4-6">
C4             -- タグ4
   82          -- 長さ2の配列
      21       -- -2
      19 6ab3  -- 27315
</artwork>
          <t indent="0" pn="section-3.4.4-7">Bigfloatの例として、数値1.5の表現があります。これは、0b110_00101（主要型6のタグ、追加情報5のタグ番号）に続いて、0b100_00010（配列の主要型4、長さ2の追加情報）が続き、次に0b001_00000（最初の整数の主要型1、値-1の追加情報0）が続き、次に0b000_00011（2番目の整数の主要型0、値3の追加情報3）が続きます。16進数で表すと：</t>
          <artwork type="hex-dump" align="left" pn="section-3.4.4-8">
C5             -- タグ5
   82          -- 長さ2の配列
      20       -- -1
      03       -- 3
</artwork>
          <t indent="0" pn="section-3.4.4-9">10進小数とBigfloatには、Infinity、-Infinity、またはNaNの表現がありません。これらが10進小数またはBigfloatの代わりに必要な場合は、IEEE 754半精度表現を使用できます
(<xref target="fpnocont" format="default" sectionFormat="of" derivedContent="Section 3.3"/>）。</t>
        </section>
        <section anchor="content-hints" toc="include" numbered="true" removeInRFC="false" pn="section-3.4.5">
          <name slugifiedName="name-content-hints">Content Hints</name>
          <t indent="0" pn="section-3.4.5-1">このセクションのタグは、一般的なCBORプロセッサで使用される可能性のあるコンテンツのヒントです。これらのコンテンツのヒントは、一般的なデータモデルを拡張しません。</t>
          <section anchor="embedded-di" toc="include" numbered="true" removeInRFC="false" pn="section-3.4.5.1">
            <name slugifiedName="name-encoded-cbor-data-item">Encoded CBOR Data Item</name>
            <t indent="0" pn="section-3.4.5.1-1">エンコード中の外側のデータアイテムをデコードする際に直ちにデコードすることが意図されていない埋め込みCBORデータアイテムを持つことが有益な場合があります。タグ番号24（CBORデータアイテム）は、埋め込みバイト文字列をCBOR形式でエンコードされた単一のデータアイテムとしてタグ付けするために使用できます。バイト文字列でない含まれるアイテムは無効です。含まれるバイト文字列は、適切に形成されたCBORデータアイテムをエンコードする場合に有効です。デコードされたCBORアイテムの妥当性チェックは、タグの妥当性のために必要ではありません（ただし、一般的なデコーダーによって特別なオプションとして提供される可能性があります）。</t>
          </section>
          <section anchor="convexpect" toc="include" numbered="true" removeInRFC="false" pn="section-3.4.5.2">
            <name slugifiedName="name-expected-later-encoding-for">Expected Later Encoding for CBOR-to-JSON Converters</name>
            <t indent="0" pn="section-3.4.5.2-1">タグ番号21から23は、バイト文字列がテキストベースの表現と相互運用する際に特定のエンコーディングが必要である可能性があることを示します。これらのタグは、エンコーダーが書き込んでいるバイト文字列データが後で特定のJSONベースの使用法に変換される可能性がある場合に有用です。その使用法では、一部の文字列がbase64、base64urlなどとしてエンコードされます。エンコーダーは、メッセージサイズを減らし、エンコーダーのコードサイズを減らすために、エンコード自体を行わずにバイト文字列を使用します。エンコーダーは、変換器が一般的かどうかを知らないため、バイナリ文字列をJSONに変換する適切な方法を示したいと考えています。</t>
            <t indent="0" pn="section-3.4.5.2-2">タグ付けされたデータアイテムは、バイト文字列または他のデータアイテムである可能性があります。後者の場合、タグは、期待される変換でタグ付けされたネストされたデータアイテムに含まれるバイト文字列データアイテムを除く、データアイテムに含まれるすべてのバイト文字列データアイテムに適用されます。</t>
            <t indent="0" pn="section-3.4.5.2-3">これらの3つのタグ番号は、<xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/>で定義された3つの基本データエンコーディングに変換することを示唆しています。タグ番号21は、パディングが使用されないbase64urlエンコーディング
(<xref target="RFC4648" section="5" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-5" derivedContent="RFC4648"/>)に変換することを示唆しています。つまり、エンコードされた文字列からすべての末尾の等号（"="）が削除されます。
タグ番号22は、RFC 4648で定義されたパディングを使用した古典的なbase64エンコーディング
(<xref target="RFC4648" section="4" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-4" derivedContent="RFC4648"/>)に変換することを示唆しています。
base64urlとbase64の両方の場合、パディングビットはゼロに設定されます（<xref target="RFC4648" section="3.5" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.5" derivedContent="RFC4648"/>を参照）、
そして、代替エンコーディングへの変換は、バイト文字列の内容に対して実行されます（つまり、改行、空白、または
その他の追加文字を追加しないでください）。タグ番号23は、大文字のアルファベットを使用したbase16（hex）エンコーディングに変換することを示唆しています（<xref target="RFC4648" section="8" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-8" derivedContent="RFC4648"/>を参照）。
これらの3つのタグ番号すべてについて、空のバイト文字列のエンコーディングは空のテキスト文字列です。</t>
          </section>
          <section anchor="encodedtext" toc="include" numbered="true" removeInRFC="false" pn="section-3.4.5.3">
            <name slugifiedName="name-encoded-text">Encoded Text</name>
            <t indent="0" pn="section-3.4.5.3-1">一部のテキスト文字列は、インターネットで広く使用されているフォーマットを持つデータを保持し、デコーダーによって適切な形式でアプリケーションに検証および表示される場合があります。これらのフォーマットのいくつかには、タグがあります。</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.4.5.3-2">
              <li pn="section-3.4.5.3-2.1">タグ番号32は、<xref target="RFC3986" format="default" sectionFormat="of" derivedContent="RFC3986"/>で定義されたURIに対して使用されます。テキスト文字列が<tt>URI-reference</tt>プロダクションに一致しない場合、文字列は無効です。</li>
              <li pn="section-3.4.5.3-2.2">
                <t indent="0" pn="section-3.4.5.3-2.2.1">タグ番号33と34は、それぞれbase64urlエンコードされたテキスト文字列とbase64エンコードされたテキスト文字列に対して使用されます。これらは、<xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/>で定義されています。次のいずれかが適用される場合：</t>
                <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.4.5.3-2.2.2">
                  <li pn="section-3.4.5.3-2.2.2.1">エンコードされたテキスト文字列に、アルファベット以外の文字が含まれているか、または最後の4ブロックのうち1つだけがアルファベットの場合（アルファベットは、タグ番号33の場合は<xref target="RFC4648" section="5" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-5" derivedContent="RFC4648"/>で定義されたものであり、タグ番号34の場合は<xref target="RFC4648" section="4" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-4" derivedContent="RFC4648"/>で定義されたものである）。</li>
                  <li pn="section-3.4.5.3-2.2.2.2">2文字または3文字のブロックのパディングビットが0でない場合、または</li>
                  <li pn="section-3.4.5.3-2.2.2.3">base64エンコーディングに誤った数のパディング文字が含まれる場合、または</li>
                  <li pn="section-3.4.5.3-2.2.2.4">base64urlエンコーディングにパディング文字が含まれる場合、</li>
                </ul>
                <t indent="0" pn="section-3.4.5.3-2.2.3">文字列が無効です。</t>
              </li>
              <li pn="section-3.4.5.3-2.3">タグ番号36は、<xref target="RFC2045" format="default" sectionFormat="of" derivedContent="RFC2045"/>で定義されたMIMEメッセージ（すべてのヘッダーを含む）に対して使用されます。有効なMIMEメッセージでないテキスト文字列は無効です。（このタグについては、汎用デコーダーにとって有効性チェックが特に困難である場合があり、提供されない場合があります。多くのMIMEメッセージは一般的なバイナリデータであり、テキスト文字列で表現することはできません。タグ番号257の登録が、タグ番号36に似ているが、タグコンテンツとしてバイト文字列を使用するものが、<xref target="IANA.cbor-tags" format="default" sectionFormat="of" derivedContent="IANA.cbor-tags"/>にリストされています。）</li>
            </ul>
            <t indent="0" pn="section-3.4.5.3-3">タグ番号33と34は、データが前者の場合はbaseエンコード形式で、後者の場合は生のバイト文字列形式で輸送されることを示す点で、タグ番号21と22とは異なります。</t>
            <t indent="0" pn="section-3.4.5.3-4"><xref target="RFC7049" format="default" sectionFormat="of" derivedContent="RFC7049"/>は、Perl Compatible Regular Expressions (PCRE/PCRE2)形式<xref target="PCRE" format="default" sectionFormat="of" derivedContent="PCRE"/>またはJavaScript正規表現構文<xref target="ECMA262" format="default" sectionFormat="of" derivedContent="ECMA262"/>で表される正規表現に対して、タグ番号35を定義しています。これらの正規表現仕様の最新の状況は進歩し続けており、この仕様書では参照を更新することは試みません。代わりに、このタグは（<xref target="RFC7049" format="default" sectionFormat="of" derivedContent="RFC7049"/>で登録されているように）利用可能であり、アプリケーションがPCREとECMA262の定義済みの共通サブセットを使用することによって、使用する特定の正規表現バリアントを指定することができます。この仕様書がタグの有効性を明確にするため、<xref target="RFC7049" format="default" sectionFormat="of" derivedContent="RFC7049"/>を超えて、このタグに含まれる文字列値はCBORタグレベルで有効である必要があることに注意してください（ただし、アプリケーションレベルで「期待される」値である必要はありません）。</t>
          </section>
        </section>
        <section anchor="self-describe" toc="include" numbered="true" removeInRFC="false" pn="section-3.4.6">
          <name slugifiedName="name-self-described-cbor">Self-Described CBOR</name>
          <t indent="0" pn="section-3.4.6-1">多くのアプリケーションでは、データ項目をエンコードするためにCBORが使用されていることが文脈から明らかになる場合があります。たとえば、特定のプロトコルがCBORの使用を指定する場合や、使用を指定するメディアタイプが示される場合があります。ただし、CBORデータが区別可能なメタデータを持たないファイルに保存されている場合など、そのような文脈情報が利用できないアプリケーションがあるかもしれません。ここで、データ自体に識別可能な特徴があると役立つ場合があります。</t>
          <t indent="0" pn="section-3.4.6-2">タグ番号55799は、アプリケーションによって指定された保存されたエンコードされたCBORデータ項目の先頭で使用するために特別に定義されています。これは、囲まれたデータ項目に特別な意味を与えるものではありません。つまり、タグ番号55799で囲まれたタグコンテンツの意味は、タグコンテンツ自体の意味とまったく同じです。</t>
          <t indent="0" pn="section-3.4.6-3">このタグのヘッダーのシリアル化は0xd9d9f7であり、頻繁に使用されるファイルタイプの識別マークとして使用されているようには見えません。特に、0xd9d9f7は、有効なCBORデータ項目が続く場合、任意のUnicodeエンコーディングでUnicodeテキストの開始として有効ではありません。</t>
          <t indent="0" pn="section-3.4.6-4">たとえば、デコーダーがCBORとJSONの両方をデコードできる場合、それらの形式を機械的に区別する必要があります。エンコーダーがデコーダーを支援するための簡単な方法は、タグ番号55799でCBOR項目全体をタグ付けすることです。このタグのシリアル化は、JSONテキストの先頭には決して見つからないため、デコーダーがCBOR項目を正しく識別できます。</t>
        </section>
      </section>
    </section>
    <section anchor="serialization-considerations" toc="include" numbered="true" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-serialization-consideration">Serialization Considerations</name>
      <section anchor="preferred" toc="include" numbered="true" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-preferred-serialization">Preferred Serialization</name>
        <t indent="0" pn="section-4.1-1">データモデルレベルの一部の値について、CBORは複数のシリアル化を提供しています。
        多くのアプリケーションでは、エンコーダーが常に優先されるシリアル化（優先エンコーディング）を選択することが望ましいですが、この仕様書では、この優先順位をエンコーダーまたはデコーダーのどちらにも課すことはありません。</t>
        <t indent="0" pn="section-4.1-2">いくつかの制約のあるデコーダーは、非優先シリアル化をデコードする能力に制限がある場合があります。たとえば、アプリケーションで1_000_000_000（10億）未満の整数のみが想定されている場合、デコーダーは整数の64ビット引数をデコードするために必要なコードを省略する場合があります。常に優先シリアル化（「優先エンコーダー」）を使用するエンコーダーは、このアプリケーションで発生する可能性のある数値に対してこのデコーダーと相互運用します。一般的に、優先エンコーダーは、64ビット整数を常に使用するエンコーダーよりも普遍的に相互運用可能であり（また、無駄が少ない）、より望ましいです。</t>
        <t indent="0" pn="section-4.1-3">同様に、制約のあるエンコーダーは、優先シリアル化を出力しないように設計されることがあります（「バリアントエンコーダー」）。たとえば、制約のあるエンコーダーは、64ビットバリアントが必要ない場合でも、常に32ビットバリアントを使用するように設計されることがあります（64ビットバリアントでしか表現できない整数がアプリケーションで必要ない場合）。優先シリアル化のみを受信することを前提としないデコーダー（「バリエーショントレラントデコーダー」）は、より普遍的に相互運用可能であると言えます（ただし、優先シリアル化を受信することを最適化することもできます）。CBORデコーダーの完全な実装は、定義上、バリエーショントレラントであり、制約のあるCBORデコーダーがバリアントエンコーダーに対応する場合にのみ、この区別が重要です。</t>
        <t indent="0" pn="section-4.1-4">優先シリアル化は、常に引数を表現する最短の形式を使用します（<xref target="encoding" format="default" sectionFormat="of" derivedContent="Section 3"/>）。また、エンコードされる値を保持する最短の浮動小数点エンコーディングも使用します。</t>
        <t indent="0" pn="section-4.1-5">浮動小数点値の優先シリアル化は、その値を保持する最短の浮動小数点エンコーディングを使用します。たとえば、数値5.5の場合は0xf94580、数値5555.5の場合は0xfa45ad9c00が使用されます。NaN値の場合、元のNaN値を再構成するために右側に向かって短い有効桁数をゼロでパディングできる場合、より短いエンコーディングが優先されます（多くのアプリケーションでは、単一のNaNエンコーディング0xf97e00が十分です）。</t>
        <t indent="0" pn="section-4.1-6">長さがアイテムのシリアル化が開始される時点で既知である場合、明示的長さエンコーディングが優先されます。</t>
      </section>
      <section anchor="det-enc" toc="include" numbered="true" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-deterministically-encoded-c">Deterministically Encoded CBOR</name>
        <t indent="0" pn="section-4.2-1">一部のプロトコルでは、エンコーダーがCBORを特定の決定論的形式でのみ出力するように要求し、デコーダーが入力がその決定論的形式であることを確認することを望む場合があります。これらのプロトコルは、「決定論的形式」とは何を意味するか、エンコーダーとデコーダーが何をすることが期待されるかを定義できます。このセクションでは、そのような決定論的形式の基礎となる一連の制限を定義しています。</t>
        <section anchor="core-det" toc="include" numbered="true" removeInRFC="false" pn="section-4.2.1">
          <name slugifiedName="name-core-deterministic-encoding">Core Deterministic Encoding Requirements</name>
          <t indent="0" pn="section-4.2.1-1">CBORエンコーディングが「コア決定論的エンコーディング要件」を満たす場合、以下の制限を満たす場合です。</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2.1-2">
            <li pn="section-4.2.1-2.1">
              <t indent="0" pn="section-4.2.1-2.1.1">優先シリアル化を使用<bcp14>しなければなりません（MUST）</bcp14>。とくに、整数の引数（<xref target="encoding" format="default" sectionFormat="of" derivedContent="Section 3"/>を参照）、メジャータイプ2から5の長さ、およびタグは、できるだけ短くする必要があります。たとえば、次のようになります。</t>
              <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2.1-2.1.2">
                <li pn="section-4.2.1-2.1.2.1">0から23および-1から-24は、同じバイトで表現<bcp14>しなければなりません（MUST）</bcp14>。</li>
                <li pn="section-4.2.1-2.1.2.2">24から255および-25から-256は、追加のuint8_tでのみ表現<bcp14>しなければなりません（MUST）</bcp14>。</li>
                <li pn="section-4.2.1-2.1.2.3">256から65535および-257から-65536は、追加のuint16_tでのみ表現<bcp14>しなければなりません（MUST）</bcp14>。</li>
                <li pn="section-4.2.1-2.1.2.4">65536から4294967295および-65537から-4294967296は、追加のuint32_tでのみ表現<bcp14>しなければなりません（MUST）</bcp14>。</li>
              </ul>
              <t indent="0" pn="section-4.2.1-2.1.3">
              浮動小数点値も、値を保持する最短の形式を使用<bcp14>しなければなりません（MUST）</bcp14>。たとえば、1.5は0xf93e00（binary16）としてエンコードされ、1000000.5は0xfa49742408（binary32）としてエンコードされます。
              （これの1つの実装方法は、すべての浮動小数点数を64ビット浮動小数点数として開始し、32ビット浮動小数点数へのテスト変換を行います。結果が同じ数値である場合、より短い形式を使用して、16ビット浮動小数点数へのテスト変換を繰り返します。これは、正のおよび負の無限大に対して16ビット浮動小数点数を選択するためにも機能します。）</t>
            </li>
            <li pn="section-4.2.1-2.2">不定長のアイテムは出現<bcp14>してはなりません（MUST NOT）</bcp14>。代わりに、定長のアイテムとしてエンコードします。</li>
            <li pn="section-4.2.1-2.3">
              <t indent="0" pn="section-4.2.1-2.3.1">すべてのマップのキーは、その決定論的エンコーディングのバイト単位の辞書順序でソート<bcp14>しなければなりません（MUST）</bcp14>。たとえば、次のキーは正しくソートされます。</t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.1-2.3.2">
                <li pn="section-4.2.1-2.3.2.1" derivedCounter="1.">10は0x0aとしてエンコードされます。</li>
                <li pn="section-4.2.1-2.3.2.2" derivedCounter="2.">100は0x1864としてエンコードされます。</li>
                <li pn="section-4.2.1-2.3.2.3" derivedCounter="3.">-1は0x20としてエンコードされます。</li>
                <li pn="section-4.2.1-2.3.2.4" derivedCounter="4.">"z"は0x617aとしてエンコードされます。</li>
                <li pn="section-4.2.1-2.3.2.5" derivedCounter="5.">"aa"は0x626161としてエンコードされます。</li>
                <li pn="section-4.2.1-2.3.2.6" derivedCounter="6.">[100]は0x811864としてエンコードされます。</li>
                <li pn="section-4.2.1-2.3.2.7" derivedCounter="7.">[-1]は0x8120としてエンコードされます。</li>
                <li pn="section-4.2.1-2.3.2.8" derivedCounter="8.">falseは0xf4としてエンコードされます。</li>
              </ol>
            </li>
          </ul>
          <aside pn="section-4.2.1-3">
            <t indent="0" pn="section-4.2.1-3.1">
            実装上の注意：CBORの自己区切り性質により、1つが他の1つの接頭辞である2つの正しいCBORエンコードされたデータ項目は存在しません。
            異なるマップキーの決定論的エンコーディングのバイト単位の辞書順序のバイト単位のレキシコグラフィック比較は、常に、キーの終わりに到達する前に、キー間のバイトが異なる位置で終了します。</t>
          </aside>
        </section>
        <section anchor="additional-deterministic-encoding-considerations" toc="include" numbered="true" removeInRFC="false" pn="section-4.2.2">
          <name slugifiedName="name-additional-deterministic-en">Additional Deterministic Encoding Considerations</name>
          <t indent="0" pn="section-4.2.2-1">CBORタグは、決定論的エンコーディングに追加の考慮事項を提供します。CBORベースのプロトコルが、特定のタグの存在と不在に対して同じセマンティクスを提供する場合（たとえば、日付/時刻の位置においてタグ1のデータ項目と生の数値の両方を許可し、後者をタグ付きであるかのように扱うことにより）、最短形式の原則に基づいて、決定論的形式ではタグの存在を許可しません。たとえば、プロトコルがURLをテキスト文字列またはテキスト文字列を含むタグ番号32として表現する選択肢をエンコーダーに与える場合、このプロトコルの決定論的エンコーディングは、タグが存在することを要求するか、存在しないことを要求するか、どちらかを要求する必要があります。</t>
          <t indent="0" pn="section-4.2.2-2">特定のセマンティクスを取得するために、特定の場所でタグが必要なプロトコルでは、タグは決定論的形式でも表示する必要があります。タグの内容にも決定論的エンコーディングの考慮事項が適用されます。</t>
          <t indent="0" pn="section-4.2.2-3">プロトコルに2のタグ番号または3のタグ番号を使用して絶対値が2<sup>64</sup>以上の整数を表現できるフィールドが含まれている場合、プロトコルの決定論的エンコーディングは、小さい整数もこれらのタグを使用して表現するか、major type 0および1を使用して表現するかを指定する必要があります。優先シリアル化は後者の選択肢を使用するため、推奨されます。</t>
          <t indent="0" pn="section-4.2.2-4">基本的な浮動小数点値（<xref target="fpnocont" format="default" sectionFormat="of" derivedContent="Section 3.3"/>を参照）またはタグを使用して表現される浮動小数点値を含むプロトコルは、決定論的エンコーディングに対して追加の要件を定義する必要がある場合があります。これらの要件には、次のようなものがあります。</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2.2-5">
            <li pn="section-4.2.2-5.1">IEEE浮動小数点値は、正のゼロと負のゼロの両方を区別できる値として表現できますが、アプリケーションはこれらを区別せず、すべてのゼロ値を正の符号で表現することを決定し、負のゼロを許可しない場合があります。
            （アプリケーションは、64ビットまたは32ビットの浮動小数点値を表現する必要がないように、浮動小数点値の精度を制限することもできます。）</li>
            <li pn="section-4.2.2-5.2">
              <t indent="0" pn="section-4.2.2-5.2.1">プロトコルに、整数と浮動小数点値を相互変換可能であると宣言された特定のデータモデルを持つ浮動小数点値を表現できるフィールドが含まれている場合、プロトコルの決定論的エンコーディングは、たとえば、整数1.0が0x01（符号なし整数）、0xf93c00（binary16）、0xfa3f800000（binary32）、または0xfb3ff0000000000000（binary64）としてエンコードされるかを指定する必要があります。これに関する例のルールは以下のとおりです。</t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.2-5.2.2">
                <li pn="section-4.2.2-5.2.2.1" derivedCounter="1.">64ビットに収まる整数値は、major type 0および1の値としてエンコードし、その他の値は、値を正確に表現する最小の16ビット、32ビット、または64ビットの浮動小数点表現としてエンコードします。</li>
                <li pn="section-4.2.2-5.2.2.2" derivedCounter="2.">整数値であっても、値を正確に表現する最小の浮動小数点表現として、すべての値をエンコードします。</li>
                <li pn="section-4.2.2-5.2.2.3" derivedCounter="3.">すべての値を64ビット浮動小数点表現としてエンコードします。</li>
              </ol>
              <t indent="0" pn="section-4.2.2-5.2.3">
              ルール1は整数と浮動小数点値の境界をまたいでおり、ルール3は優先シリアル化を使用していないため、ルール2は多くの場合良い選択肢となります。</t>
            </li>
            <li pn="section-4.2.2-5.3">NaNが許容されており、NaNペイロードまたはシグナリングNaNをサポートする意図がない場合、プロトコルは通常、単一の表現（通常は0xf97e00）を選択する必要があります。この単純な選択ができない場合は、NaNの処理に特別な注意が必要です。</li>
            <li pn="section-4.2.2-5.4">サブノーマル数（あるIEEE 754数値フォーマットの最低指数を持つゼロ以外の数値）は、一部の浮動小数点実装ではゼロにフラッシュされる出力として扱われる場合があります。プロトコルの決定論的エンコーディングは、サブノーマル数を交換から除外し、代わりにゼロを交換することで、そのような実装に特に対応することができます。</li>
            <li pn="section-4.2.2-5.5">同じ数値は、異なる小数、異なるbigfloat、および数値値を表現するために定義された他のタグの異なる形式によって表現することができます。実装によっては、これらの形式のいずれか（または基本的な一般的なデータモデルの形式）が等価であるかどうかを判断することが常に実用的ではない場合があります。数値の表現形式の選択肢を提示するアプリケーションプロトコルは、決定論的エンコーディングの形式がどのように選択されるかについて明示する必要があります。</li>
          </ul>
        </section>
        <section anchor="length-first" toc="include" numbered="true" removeInRFC="false" pn="section-4.2.3">
          <name slugifiedName="name-length-first-map-key-orderi">Length-First Map Key Ordering</name>
          <t indent="0" pn="section-4.2.3-1">コア決定論的エンコーディング要件（<xref target="core-det" format="default" sectionFormat="of" derivedContent="Section 4.2.1"/>）は、<xref target="RFC7049" section="3.9" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7049#section-3.9" derivedContent="RFC7049"/>で提案された順序（そこでは「Canonical CBOR」と呼ばれる）とは異なる順序でマップキーをソートします。RFC7049で指定された順序と互換性を持つ必要があるプロトコルは、代わりにこの仕様の「長さ優先のコア決定論的エンコーディング要件」で指定できます。</t>
          <t indent="0" pn="section-4.2.3-2">CBORエンコーディングが「長さ優先のコア決定論的エンコーディング要件」を満たす場合、コア決定論的エンコーディング要件を満たすが、すべてのマップのキーが次のようにソートされている<bcp14>必要があります（MUST）</bcp14>：</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.3-3">
            <li pn="section-4.2.3-3.1" derivedCounter="1.">2つのキーの長さが異なる場合、短い方が先にソートされます。</li>
            <li pn="section-4.2.3-3.2" derivedCounter="2.">2つのキーの長さが同じ場合、（バイト単位の）レキシコグラフィック順序で値が低い方が先にソートされます。</li>
          </ol>
          <t indent="0" pn="section-4.2.3-4">たとえば、長さ優先のコア決定論的エンコーディング要件の下では、次のキーが正しくソートされます。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.3-5">
            <li pn="section-4.2.3-5.1" derivedCounter="1.">10は、0x0aとしてエンコードされます。</li>
            <li pn="section-4.2.3-5.2" derivedCounter="2.">-1は、0x20としてエンコードされます。</li>
            <li pn="section-4.2.3-5.3" derivedCounter="3.">falseは、0xf4としてエンコードされます。</li>
            <li pn="section-4.2.3-5.4" derivedCounter="4.">100は、0x1864としてエンコードされます。</li>
            <li pn="section-4.2.3-5.5" derivedCounter="5.">"z"は、0x617aとしてエンコードされます。</li>
            <li pn="section-4.2.3-5.6" derivedCounter="6.">[-1]は、0x8120としてエンコードされます。</li>
            <li pn="section-4.2.3-5.7" derivedCounter="7.">"aa"は、0x626161としてエンコードされます。</li>
            <li pn="section-4.2.3-5.8" derivedCounter="8.">[100]は、0x811864としてエンコードされます。</li>
          </ol>
          <aside pn="section-4.2.3-6">
            <t indent="0" pn="section-4.2.3-6.1">RFC7049では、決定論的エンコーディングの要件に対して「Canonical CBOR」という用語が使用されていますが、この仕様書では、この用語を避けています。なぜなら、「正準化」という用語は、決定論的エンコーディングの特定の用途にのみ関連していることが多いからです。ただし、これらの用語は本質的には同義であり、この仕様書のコア要件のセットは「Canonical CBOR」と呼ばれることができます。一方、その長さ優先順序版は「Old Canonical CBOR」と呼ばれることができます。</t>
          </aside>
        </section>
      </section>
    </section>
    <section anchor="creating-cbor-based-protocols" toc="include" numbered="true" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-creating-cbor-based-protoco">Creating CBOR-Based Protocols</name>
      <t indent="0" pn="section-5-1">CBORのようなデータフォーマットは、フォーマットのネゴシエーションがない環境でしばしば使用されます。CBORの特定の設計目標は、含まれるまたは想定されるスキーマが必要ないことです。つまり、デコーダーはCBORアイテムを取得し、他に何も知らなくてもデコードできます。</t>
      <t indent="0" pn="section-5-2">実際の実装では、エンコーダーとデコーダーはCBORデータアイテムに何が含まれるべきかについて共有の見解を持っています。たとえば、合意されたフォーマットは「アイテムはUTF-8文字列が最初の値であり、2番目の値は整数であり、その後の値は0個以上の浮動小数点数である配列である」または「アイテムは、キーにバイト文字列を持ち、キーが0xab01であるペアを含むマップである」といったものがあります。</t>
      <t indent="0" pn="section-5-3">CBORベースのプロトコルは、そのデコーダーが無効なデータやその他の予期しないデータをどのように処理するかを指定<bcp14>しなければなりません（MUST）</bcp14>。CBORベースのプロトコルは、任意の有効なデータを予期しないデータとして扱うことを<bcp14>MAY</bcp14>指定することができます。CBORベースのプロトコルのエンコーダーは、無効なアイテムを使用することができないため、常に有効なアイテムのみを生成<bcp14>しなければなりません（MUST）</bcp14>。エンコーダーは、使用されるプロトコルで必要な種類の値を多くまたは少なくエンコードできます。デコーダーは、使用されるプロトコルで必要な種類の値を多くまたは少なく理解できます。これらの制限がないため、CBORは非常に制限された環境で使用できます。</t>
      <t indent="0" pn="section-5-4">このセクションの残りの部分では、CBORベースのプロトコルを作成する際の考慮事項について説明します。ほとんどの場合、これはアドバイザリーであり、BCP 14の言語を除いて、明示的に「<bcp14>MAY</bcp14>」と解釈できる言葉を使用します。例外は、一般的なものとアプリケーション固有のエンコーダーとデコーダーの両方を使用することを目的として、CBORベースのプロトコルの相互運用性を容易にすることを目的としています。</t>
      <section anchor="cbor-in-streaming-applications" toc="include" numbered="true" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-cbor-in-streaming-applicati">CBOR in Streaming Applications</name>
        <t indent="0" pn="section-5.1-1">ストリーミングアプリケーションでは、データストリームは連結されたCBORデータアイテムのシーケンスで構成される場合があります。このような環境では、デコーダーは前のデータアイテムの終わりの後にデータが見つかった場合、すぐに新しいデータアイテムのデコードを開始します。</t>
        <t indent="0" pn="section-5.1-2">データアイテムを構成するバイトのすべてがデコーダーにすぐに利用可能であるとは限りません。一部のデコーダーは、完全なデータアイテムがアプリケーションに提供されるまで、追加のデータをバッファリングします。他のデコーダーは、すでにデコードされたネストされたデータアイテムや、まだ完全に到着していないバイト文字列の一部など、トップレベルのデータアイテムに関する部分的な情報をアプリケーションに提供できます。
        このようなアプリケーションは、ストリーミングセキュリティメカニズムを持つ必要があります。この場合、アプリケーションに提供されるインクリメンタルデータに対して、必要な保護が利用可能である<bcp14>必要があります（MUST）</bcp14></t>
        <t indent="0" pn="section-5.1-3">一部のアプリケーションやプロトコルでは、不定長エンコーディングを使用したくない場合があります。不定長エンコーディングを使用すると、エンコーダーはすべてのデータをカウントするためにマーシャリングする必要がなくなりますが、デコーダーはアイテムの終わりを待ちながら増加する量のメモリを割り当てる必要があります。これは、一部のアプリケーションにとっては問題ないかもしれませんが、他のアプリケーションには適していない場合があります。</t>
      </section>
      <section anchor="generic" toc="include" numbered="true" removeInRFC="false" pn="section-5.2">
        <name slugifiedName="name-generic-encoders-and-decode">Generic Encoders and Decoders</name>
        <t indent="0" pn="section-5.2-1">一般的なCBORデコーダーは、すべての形式が正しいエンコードされたCBORデータアイテムをデコードし、アプリケーションにデータアイテムを提供できます。詳細は、<xref target="pseudocode" format="default" sectionFormat="of" derivedContent="Appendix C"/>を参照してください。
        （診断表記法である<xref target="diagnostic-notation" format="default" sectionFormat="of" derivedContent="Section 8"/>は、形式が正しいCBOR値を人間に提示するために使用できます。）</t>
        <t indent="0" pn="section-5.2-2">一般的なCBORエンコーダーは、アプリケーションがエンコーダーに未知の単純な値やタグを含む、任意の形式が正しい値をCBORデータアイテムとしてエンコードするよう指定できるアプリケーションインタフェースを提供します。</t>
        <t indent="0" pn="section-5.2-3">CBORはこれらのケースを最小限に抑えようとしますが、すべての形式が正しいCBORデータが有効であるわけではありません。たとえば、エンコードされたテキスト文字列<tt>0x62c0ae</tt>は有効なUTF-8を含んでいないため（<xref target="RFC3629" format="default" sectionFormat="of" derivedContent="RFC3629"/>は常に最短の形式を使用することを要求するため）、有効なCBORアイテムではありません。
        また、特定のタグは、別のタグを囲む大きな数値タグや、バイト文字列を含むタグ番号0のインスタンス、または内容が<xref target="RFC3339" format="default" sectionFormat="of" derivedContent="RFC3339"/>の<tt>date-time</tt>プロダクションに一致しないテキスト文字列を含むテキスト文字列など、違反する可能性がある意味の制約を設ける場合があります。一般的なエンコーダーとデコーダーが、無効なデータの処理を可能にするために、アプリケーションインタフェースで不自然な選択をする必要はありません。一般的なエンコーダーとデコーダーは、特定のコードポイントがエンコーダー/デコーダーが書かれた時点で登録されていなくても、単純な値とタグを転送することが期待されます（<xref target="validity-checking" format="default" sectionFormat="of" derivedContent="Section 5.4"/>）。</t>
      </section>
      <section anchor="semantic-errors" toc="include" numbered="true" removeInRFC="false" pn="section-5.3">
        <name slugifiedName="name-validity-of-items">Validity of Items</name>
        <t indent="0" pn="section-5.3-1">形式が正しいが無効なCBORデータアイテム（<xref target="terminology" format="default" sectionFormat="of" derivedContent="Section 1.2"/>）は、CBORデータモデルでエンコードされたデータを解釈する際に問題が発生します。CBORベースのプロトコルは、下位レイヤーが転送するCBORデータの意味を処理しない場合があります。これらのレイヤーは、処理しないデータの妥当性エラーに気付くことができず、そのデータをそのまま転送<bcp14>しなければなりません（MUST）</bcp14>。無効なCBORアイテムの意味を処理する最初のレイヤーは、次の2つの選択肢のいずれかを選択<bcp14>しなければなりません（MUST）</bcp14>。</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-5.3-2"><li pn="section-5.3-2.1" derivedCounter="1.">問題のあるアイテムをエラーマーカーで置き換え、次のアイテムを続けるか、</li>
                  <li pn="section-5.3-2.2" derivedCounter="2.">エラーを発行して処理を完全に停止するかのいずれかを行います。</li>
                </ol>
        <t indent="0" pn="section-5.3-3">CBORベースのプロトコルは、デコーダーが遭遇する可能性のある無効なアイテムの種類ごとに、どちらのオプションを取るかを指定<bcp14>しなければなりません（MUST）</bcp14>。</t>
        <t indent="0" pn="section-5.3-4">このような問題は、CBORの基本的な妥当性レベルやタグの文脈（タグの妥当性）で発生する可能性があります。</t>
        <section anchor="basic-validity" toc="include" numbered="true" removeInRFC="false" pn="section-5.3.1">
          <name slugifiedName="name-basic-validity">Basic validity</name>
          <t indent="0" pn="section-5.3.1-1">基本的な汎用データモデルには、2種類の妥当性エラーが発生する可能性があります。</t>
          <dl newline="false" spacing="normal" indent="3" pn="section-5.3.1-2">
                <dt pn="section-5.3.1-2.1">マップ内の重複するキー：</dt>
                <dd pn="section-5.3.1-2.2">
            汎用デコーダー（<xref target="generic" format="default" sectionFormat="of" derivedContent="Section 5.2"/>）は、ネイティブのCBORデータモデルを使用してアプリケーションにデータを提供します。このデータモデルには、ユニークなキーを持つマップ（キーと値のマッピング）が含まれていますが、複数のエントリが同じキーを持つマルチマップ（キーと値のマッピング）は含まれていません。したがって、重複するキーを持つCBORマップアイテムを取得する汎用デコーダーは、そのキーの1つのインスタンスを持つマップにデコードするか、処理を停止するかもしれません。一方、「ストリーミングデコーダー」は、それを気づくことさえできない場合があります。マップ内のキーについての詳細については、<xref target="map-keys" format="default" sectionFormat="of" derivedContent="Section 5.6"/>を参照してください。</dd>
                <dt pn="section-5.3.1-2.3">無効なUTF-8文字列：</dt>
                <dd pn="section-5.3.1-2.4">
            デコーダーは、UTF-8文字列（メジャータイプ3）のバイトシーケンスが実際に有効なUTF-8であるかどうかを検証し、適切に反応するかどうかは、デコーダーによって異なります。</dd>
              </dl>
        </section>
        <section anchor="tag-validity" toc="include" numbered="true" removeInRFC="false" pn="section-5.3.2">
          <name slugifiedName="name-tag-validity">Tag validity</name>
          <t indent="0" pn="section-5.3.2-1">基本的な汎用データモデルにタグを追加することで、2種類の追加の妥当性エラーが導入されます。</t>
          <dl newline="false" spacing="normal" indent="3" pn="section-5.3.2-2">
                <dt pn="section-5.3.2-2.1">タグの内容に不適切なタイプ：</dt>
                <dd pn="section-5.3.2-2.2">
            タグ番号（<xref target="tags" format="default" sectionFormat="of" derivedContent="Section 3.4"/>）は、タグの内容として使用されるデータアイテムのタイプを指定します。たとえば、符号なしまたは負のビッグナンのタグ番号は、バイト文字列に配置する必要があります。ネイティブ表現（この例ではネイティブビッグ整数）にタグ付けされたデータアイテムをデコードするデコーダーは、タグ付けされたデータアイテムのタイプをチェックすることが期待されます。環境にネイティブ表現がないデコーダーでも、彼らに知られているこれらのタグに対してチェックを実行し、適切に反応することができます。</dd>
                <dt pn="section-5.3.2-2.3">タグの内容に不適切な値：</dt>
                <dd pn="section-5.3.2-2.4">
            データアイテムのタイプは、タグの内容に適している場合がありますが、特定の値はそうではない場合があります。たとえば、「昨日」という値は、適切にテキスト文字列であるにもかかわらず、タグ0の内容としては受け入れられません。通常、このようなタグを同等のプラットフォームタイプに取り込むデコーダーは、タグ番号が不明なタグと同様に、このタグをアプリケーションに提示することができます（<xref target="validity-checking" format="default" sectionFormat="of" derivedContent="Section 5.4"/>）。</dd>
              </dl>
        </section>
      </section>
      <section anchor="validity-checking" toc="include" numbered="true" removeInRFC="false" pn="section-5.4">
        <name slugifiedName="name-validity-and-evolution">Validity and Evolution</name>
        <t indent="0" pn="section-5.4-1">妥当性チェックを行うデコーダーは、妥当性エラーを含むデータアイテムを信頼性高く検出するための努力を払います。たとえば、このようなデコーダーは、前のサブセクションにリストされている妥当性エラーのいずれかを含むCBORデータアイテムに対してエラーを報告するAPIを持つ必要があります（データを返さない）。</t>
        <t indent="0" pn="section-5.4-2">「簡潔なバイナリオブジェクト表現（CBOR）タグ」レジストリ（<xref target="ianatags" format="default" sectionFormat="of" derivedContent="Section 9.2"/>）で定義されたタグのセット、および「簡潔なバイナリオブジェクト表現（CBOR）シンプルバリュー」レジストリ（<xref target="ianasimple" format="default" sectionFormat="of" derivedContent="Section 9.1"/>）で定義されたシンプルバリューのセットは、汎用デコーダーが理解するセットを超えていつでも成長する可能性があります。妥当性チェックを行うデコーダーは、認識できない場合に2つのことを行うことができます。</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.4-3">
                  <li pn="section-5.4-3.1">デコーダーはエラーを報告することができます（データを返さない）。
        この場合をエラーとして扱うことは、硬直化を引き起こす可能性があるため、推奨されません。このエラーは、本質的に妥当性エラーではありません。このようなエラーは、既知の場合に妥当性チェックを実行しているデコーダーによってより頻繁に発生する可能性があります。</li>
                  <li pn="section-5.4-3.2">デコーダーが認識できないタグ番号またはシンプルバリューがある場合、デコーダーは、未知のアイテム（タイプ、値、およびタグの場合はデコードされたタグ付きデータアイテム）を呼び出し元のアプリケーションに出力し、デコーダーがそのタグ番号またはシンプルバリューを認識できなかったことを示す指示をアプリケーションに与えることができます。</li>
                </ul>
        <t indent="0" pn="section-5.4-4">後者のアプローチは、妥当性チェックをサポートしていないデコーダーにも適しており、エンコーダーを呼び出すアプリケーションと同時に更新する必要がないまま、新しく登録されたタグやシンプルバリューとの前方互換性を提供します。 （これには、デコーダーのAPIが未知のアイテムをマークする機能が必要であり、呼び出し元のアプリケーションが適切な方法でそれらを処理できるようにする必要があります。）</t>
        <t indent="0" pn="section-5.4-5">妥当性チェックに必要な処理の一部は、マップの重複検出に特にコストがかかる場合があるため、妥当性チェックのサポートはすべてのCBORデコーダーに要求される必要はありません。</t>
        <t indent="0" pn="section-5.4-6">一部のエンコーダーは、アプリケーションがエンコーダーから有効なCBORを生成するように入力データを提供することを期待しています。汎用エンコーダーは、API準拠のデータを提供しているかどうかに関係なく、その出力を有効なCBORに限定する妥当性チェックモードを提供することも望むかもしれません。</t>
      </section>
      <section anchor="numbers" toc="include" numbered="true" removeInRFC="false" pn="section-5.5">
        <name slugifiedName="name-numbers">Numbers</name>
        <t indent="0" pn="section-5.5-1">CBORベースのプロトコルは、異なる言語環境が表現可能な数値の範囲と精度に異なる制限を課すことを考慮する必要があります。たとえば、基本的なJavaScript数値システムは、すべての数値を浮動小数点値として扱うため、53ビット以上の有意なビットを持つ整数をデコードする際に精度の損失が発生する可能性があります。
        また、CBORは、整数表現の符号ビットをメジャータイプに保持するため、同じ長さの典型的なプラットフォーム符号付き整数表現（8バイトint64_tの場合は-2<sup>63</sup>..2<sup>63</sup>-1）よりも、特定の長さの符号付き数値（たとえば、1 + 8バイト整数の場合は-2<sup>64</sup>..2<sup>64</sup>-1）に1ビット多くのビットがあります。
        数値を使用するプロトコルは、デコーダーと受信アプリケーションで非自明な数値の処理に関する期待を定義する必要があります。</t>
        <t indent="0" pn="section-5.5-2">浮動小数点数を含むCBORベースのプロトコルは、サポートするフォーマット（ハーフプレシジョン、シングルプレシジョン、ダブルプレシジョン）のうちどれを制限するかを制限することができます。整数のみのアプリケーションの場合、プロトコルは浮動小数点値の使用を完全に除外することができます。</t>
        <t indent="0" pn="section-5.5-3">コンパクト性を重視したCBORベースのプロトコルは、64ビット整数を実装する必要を省くために、アプリケーションに必要以上に長い特定の整数エンコーディングを除外することができます。エンコーダーは、特定の値を表現できる最もコンパクトな整数表現を使用することが期待されています。ただし、決定論的エンコーディングを必要としないコンパクトなアプリケーションは、アプリケーションが指定されたサイズの整数をデコードできる限り、必要以上に長いエンコーディング（たとえば、「0」を0b000_11001にエンコードして、2バイトの0x00が続くようにエンコードする）を使用する値を受け入れる必要があります。
        浮動小数点値にも同様の考慮事項が適用されます。推奨されるのは、最適なシリアル化と必要以上に長いシリアル化の両方をデコードすることです。</t>
        <t indent="0" pn="section-5.5-4">指数が小さく非負である場合など、特定の数を整数として表現するか、小数点以下の数値またはbigfloatとして表現することを選択できる制約されたアプリケーションのCBORベースのプロトコルは、整数表現が直接使用されることを期待する実装品質の期待値を表現する場合があります。</t>
      </section>
      <section anchor="map-keys" toc="include" numbered="true" removeInRFC="false" pn="section-5.6">
        <name slugifiedName="name-specifying-keys-for-maps">Specifying Keys for Maps</name>
        <t indent="0" pn="section-5.6-1">エンコードおよびデコードアプリケーションは、マップで使用されるキーのタイプについて合意する必要があります。JSONベースのアプリケーションと相互運用する必要があるアプリケーションでは、キーをテキスト文字列に限定することで変換が簡素化されます。それ以外の場合、他のCBORタイプからテキスト文字列への指定されたマッピングが必要であり、これにより実装エラーが発生することがよくあります。キーが数値的な性質を持ち、キーの数値的な順序がアプリケーションにとって重要な場合、キーとして直接数値を使用することが有用です。</t>
        <t indent="0" pn="section-5.6-2">複数の種類のキーを使用する場合、これらの種類が使用される特定のプログラミング環境でどのように表現されるかを考慮する必要があります。たとえば、JavaScript Maps <xref target="ECMA262" format="default" sectionFormat="of" derivedContent="ECMA262"/>では、整数1のキーは浮動小数点1.0のキーと区別できません。これは、整数キーが使用される場合、プロトコルが同じマップ内の整数値である浮動小数点キーの使用を避ける必要があることを意味します。</t>
        <t indent="0" pn="section-5.6-3">CBORデータアイテム内にネストされたデータアイテムをデコードするとすぐに（「ストリーミングデコーダー」）、マップ内のキーの一意性を確認するために必要な状態を保持しないことがよくあります。同様に、データアイテムを完全に利用可能にする前にデータアイテムのエンコードを開始できるエンコーダー（「ストリーミングエンコーダー」）は、データソースが一意性を維持することに依存して、オーバーヘッドを大幅に削減できます。</t>
        <t indent="0" pn="section-5.6-4">CBORベースのプロトコルは、マップ内で複数の同じキーを持つエントリが見つかった場合に受信アプリケーションが何をするかを定義<bcp14>しなければなりません（MUST）</bcp14>。プロトコルによる結果のルールは、CBORデータモデルに準拠する必要があります。つまり、同じキーを持つエントリの処理方法を指定することはできず、ただし、マップ内に同じキーがある場合は、マップが不正なものであることを示すルールがある可能性があり、デコーダーがエラーで停止する必要があります。
        重複するキーを持つエントリを含むマップを処理する場合、汎用デコーダーは次のいずれかを行うことがあります。</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.6-5">
          <li pn="section-5.6-5.1">マップ内に重複するキーがある場合は受け入れない（つまり、マップの妥当性を強制する。詳細は<xref target="validity-checking" format="default" sectionFormat="of" derivedContent="Section 5.4"/>を参照）。これらの汎用デコーダーは普遍的に有用です。アプリケーションは、特定のマップにおいて整数と浮動小数点値をマップキーの位置で同等と見なす場合など、アプリケーションルールに基づいた重複チェックを自己実行する必要がある場合があります。</li>
          <li pn="section-5.6-5.2">重複するキーを含むすべてのマップエントリをアプリケーションに渡す。これには、アプリケーションが重複するキーを処理する（チェックする）必要があるため、アプリケーションルールが汎用データモデルルールと同一である場合でも、重複するキーを処理する必要があります。</li>
          <li pn="section-5.6-5.3">重複するキーを持つエントリのうち、最後のエントリ（または最初のエントリ）のみを配信するなど、一部のエントリを失う。このような汎用デコーダーを使用する場合、アプリケーションは、異なる実行や異なる汎用デコーダーを使用する場合に、特定のキーに対して異なる結果を得る可能性があります。どの値が返されるかは、汎用デコーダーの実装とマップ内のキーの実際の順序に基づいています。特に、アプリケーションは、すべてのエントリを見るわけではないため、自分自身でキーの一意性を検証することができないため、重複チェックを自己実行する必要がある場合があります。これらの汎用デコーダーは、データソースと転送が常に有効なマップを提供する場合にのみ使用できます。データソースと転送が攻撃される可能性がある場合、これは不可能です。</li>
        </ul>
        <t indent="0" pn="section-5.6-6">汎用デコーダーは、これら3つのアプローチのうちどれを実装するかを文書化する必要があります。</t>
        <t indent="0" pn="section-5.6-7">マップのCBORデータモデルでは、マップ表現内のキー/値ペアの順序に意味を付与することはできません。したがって、CBORベースのプロトコルは、マップ内のキー/値ペアの順序を変更することが意味を変えることを指定してはなりません<bcp14>（ただし、決定論的エンコーディングの要件を満たさない場合など、一部の順序が許可されないことを指定することはできます。詳細は<xref target="det-enc" format="default" sectionFormat="of" derivedContent="Section 4.2"/>を参照）</bcp14>。（タイミング、キャッシュ使用、その他の潜在的なサイドチャネルなど、マップの順序による二次的な影響は意味の一部ではありませんが、プロトコルが決定論的エンコーディング形式を要求する理由となる可能性があります。）</t>
        <t indent="0" pn="section-5.6-8">制約されたデバイス向けのアプリケーションでは、頻繁に使用されるキーの数が少ないマップがある場合は、小さな整数をキーとして使用することを検討する必要があります。たとえば、24個以下のキーのセットは、符号なし整数として1バイトでエンコードでき、負の整数も使用する場合は48個までエンコードできます。出現頻度の低いキーは、より長いエンコーディングを持つ整数を使用できます。</t>
        <section anchor="equivalence-of-keys" toc="include" numbered="true" removeInRFC="false" pn="section-5.6.1">
          <name slugifiedName="name-equivalence-of-keys">Equivalence of Keys</name>
          <t indent="0" pn="section-5.6.1-1">CBORデータアイテムに適用される特定のデータモデルは、マップ内に出現するキーが重複しているかどうかを判断するために使用されます。</t>
          <t indent="0" pn="section-5.6.1-2">汎用データモデルレベルでは、数値的に等しい整数と浮動小数点値は互いに異なり、さまざまなビッグナンバー（タグ2から5）とも異なります。同様に、同じバイトから構成されていても、テキスト文字列はバイト文字列とは異なります。タグ付きの値は、タグのない値または異なるタグ番号でタグ付きの値とも異なります。</t>
          <t indent="0" pn="section-5.6.1-3">これらのグループ内では、数値的に等しい場合を除いて、数値値は異なります（具体的には、-0.0は0.0と等しいです）。マップキーの同等性の目的のために、NaN値は、両方の有効桁を右側に64ビットまでゼロ拡張した後、有効桁が同じ場合に等価です。</t>
          <t indent="0" pn="section-5.6.1-4">バイト文字列とテキスト文字列は、バイトごとに比較され、配列は要素ごとに比較され、同じバイト/要素数と同じ位置に同じ値がある場合に等しいと見なされます。2つのマップは、順序に関係なく同じペアのセットを持つ場合に等しいと見なされます。ペアは、キーと値の両方が等しい場合に等しいと見なされます。</t>
          <t indent="0" pn="section-5.6.1-5">タグ付きの値は、タグ番号とタグの内容が等しい場合に等しいです。
          （特定のタグの処理を提供する汎用デコーダーは、タグ2またはタグ3の内容に先行するゼロが含まれる場合など、意味的に等価な値を区別できない場合があることに注意してください（<xref target="bignums" format="default" sectionFormat="of" derivedContent="Section 3.4.3"/>）。）
          シンプルな値は、単に同じ値を持つ場合に等しいです。
          汎用データモデルでは、それ以外のものは等しくありません。シンプルな値2は整数2と等価ではなく、配列はマップと等価ではありません。</t>
          <t indent="0" pn="section-5.6.1-6">特定のデータモデルでは、汎用データモデルで異なるマップキーを比較するために等価な値を作成できます（<xref target="specific-data-models" format="default" sectionFormat="of" derivedContent="Section 2.2"/>で説明されています）。これは、汎用デコーダーが、重複するマップキーをチェックする必要があるアプリケーションにデコードされたマップを提供する可能性があることを意味します（代わりに、デコーダーはアプリケーションのためにこのサービスを実行するプログラミングインターフェースを提供することができます）。特定のデータモデルは、汎用データモデルレベルでこの目的のために等しいマップキーの値を区別することができません。</t>
        </section>
      </section>
      <section anchor="undefined-values" toc="include" numbered="true" removeInRFC="false" pn="section-5.7">
        <name slugifiedName="name-undefined-values">Undefined Values</name>
        <t indent="0" pn="section-5.7-1">いくつかのCBORベースのプロトコルでは、エンコーダーがエンコーディングの問題を代替するために<tt>undefined</tt>のシンプルな値（<xref target="fpnocont" format="default" sectionFormat="of" derivedContent="Section 3.3"/>）を使用する場合があります。これにより、他の囲むデータアイテムを危険にさらすことなく、残りのデータアイテムをエンコードできるようになります。</t>
      </section>
    </section>
    <section anchor="converting-data-between-cbor-and-json" toc="include" numbered="true" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-converting-data-between-cbo">Converting Data between CBOR and JSON</name>
      <t indent="0" pn="section-6-1">このセクションでは、CBORとJSONの変換に関する非規範的なアドバイスを提供します。変換プログラムの実装は、ここで提供されるアドバイスのうち、どちらを使用してもかまいません<bcp14>。</bcp14></t>
      <t indent="0" pn="section-6-2">JSONテキストは文字のシーケンスであり、エンコードされたバイトのシーケンスではないことに注意する価値があります。一方、CBORデータアイテムは文字ではなくバイトで構成されています。</t>
      <section anchor="converting-from-cbor-to-json" toc="include" numbered="true" removeInRFC="false" pn="section-6.1">
        <name slugifiedName="name-converting-from-cbor-to-jso">Converting from CBOR to JSON</name>
        <t indent="0" pn="section-6.1-1">CBORのほとんどのタイプには、JSONに直接対応するものがあります。ただし、一部には対応するものがないものもあり、CBORからJSONへの変換プログラムを実装する場合は、これらの場合にどのように対処するかを考慮する必要があります。次の非規範的なアドバイスは、これらを単一の代替値（JSON nullなど）に変換することで対処します。</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.1-2">
          <li pn="section-6.1-2.1">整数（メジャータイプ0または1）はJSON数値になります。</li>
          <li pn="section-6.1-2.2">提案されたエンコーディングを指定するタグに埋め込まれていないバイト文字列（メジャータイプ2）は、パディングのないbase64urlでエンコードされ、JSON文字列になります。</li>
          <li pn="section-6.1-2.3">UTF-8文字列（メジャータイプ3）はJSON文字列になります。ただし、JSONでは特定の文字（<xref target="RFC8259" section="7" sectionFormat="comma" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8259#section-7" derivedContent="RFC8259"/>）をエスケープする必要があります。これらの文字は、引用符（U+0022）、逆ソリッドスラッシュ（U+005C）、および「C0制御文字」（U+0000からU+001F）です。その他の文字は、JSON UTF-8文字列にそのままコピーされます。</li>
          <li pn="section-6.1-2.4">配列（メジャータイプ4）はJSON配列になります。</li>
          <li pn="section-6.1-2.5">マップ（メジャータイプ5）はJSONオブジェクトになります。これは、すべてのキーがUTF-8文字列である場合にのみ直接可能です。コンバータは、他のキーをUTF-8文字列に変換することもできます（たとえば、整数を10進表記を含む文字列に変換することによって）。ただし、これを行うと、キーの衝突の危険性が生じます。また、UTF-8文字列のタグを以下で提案されるように無視する場合、タグが異なるが文字列が同じ場合にキーの衝突が発生することに注意してください。</li>
          <li pn="section-6.1-2.6">False（メジャータイプ7、追加情報20）はJSON falseになります。</li>
          <li pn="section-6.1-2.7">True（メジャータイプ7、追加情報21）はJSON trueになります。</li>
          <li pn="section-6.1-2.8">Null（メジャータイプ7、追加情報22）はJSON nullになります。</li>
          <li pn="section-6.1-2.9">浮動小数点値（メジャータイプ7、追加情報25から27）は、有限である場合（つまり、JSON数値で表現できる場合）、JSON数値になります。値が有限でない場合（NaN、正のまたは負のInfinity）、代替値で表されます。</li>
          <li pn="section-6.1-2.10">その他のシンプルな値（メジャータイプ7、まだ議論されていない任意の追加情報値）は、代替値で表されます。</li>
          <li pn="section-6.1-2.11">バイト文字列をbase64urlでパディングなしでエンコードすることにより、ビッグナンバー（メジャータイプ6、タグ番号2または3）はエンコードされ、JSON文字列になります。タグ番号3（負のビッグナンバー）の場合、ベースエンコードされた値の前に"~"（ASCIIチルダ）が挿入されます（JSONデコーダーの数値オーバーフローを防ぐために、数値ではなくバイナリブロブに変換されます）。</li>
          <li pn="section-6.1-2.12">エンコーディングヒントを持つバイト文字列（メジャータイプ6、タグ番号21から23）は、ヒントに記載されているようにエンコードされ、JSON文字列になります。</li>
          <li pn="section-6.1-2.13">その他のタグ（メジャータイプ6、その他のタグ番号）の場合、タグの内容はJSON値として表されます。タグ番号は無視されます。</li>
          <li pn="section-6.1-2.14">変換前に、不定長アイテムは定長に変換されます。</li>
        </ul>
        <t indent="0" pn="section-6.1-3">CBORからJSONへの変換プログラムは、相互運用性を最大化し、JSON出力が予測可能な結果で処理できることを保証するために、JSONプロファイルI-JSON<xref target="RFC7493" format="default" sectionFormat="of" derivedContent="RFC7493"/>に従うことが望ましい場合があります。たとえば、これには、信頼性の高い整数の範囲に関する影響があります。また、古いJSON実装でサポートされる可能性のあるトップレベルアイテムにも影響があります。</t>
      </section>
      <section anchor="converting-from-json" toc="include" numbered="true" removeInRFC="false" pn="section-6.2">
        <name slugifiedName="name-converting-from-json-to-cbo">Converting from JSON to CBOR</name>
        <t indent="0" pn="section-6.2-1">JSON値はすべて、デコードされた後、1つ以上のCBOR値に直接マップされます。CBORの生成に関しては、数値表現に関する決定を行う必要があります。提案される変換では、次のようになります。</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.2-2">
          <li pn="section-6.2-2.1">小数部を持たないJSON数値（整数）は、整数（メジャータイプ0および1、おそらくメジャータイプ6、タグ番号2および3）として表され、最短の形式が選択されます。実装定義の閾値よりも長い整数は、代わりに浮動小数点値として表される場合があります。整数として表されるデフォルトの範囲は、-2<sup>53</sup>+1..2<sup>53</sup>-1であり、（JSONデコードによく使用されるbinary64表現で正確な整数の範囲を完全に活用する）。
          CBORベースのプロトコルまたは汎用コンバータ実装では、uint32_tまたはuint64_tで利用可能な整数範囲を完全に使用するために、-2<sup>32</sup>..2<sup>32</sup>-1または-2<sup>64</sup>..2<sup>64</sup>-1を選択することができます。また、2の補数符号付き整数の人気のある範囲である-2<sup>31</sup>..2<sup>31</sup>-1または-2<sup>63</sup>..2<sup>63</sup>-1を使用することもできます。
          （JSONがJavaScript実装から生成された場合、その精度は既に最大53ビットに制限されています。）</li>
          <li pn="section-6.2-2.2">小数部を持つ数値は、IEEE 754 binary64によって提供される精度に基づいて、浮動小数点値として表されます。JSON数値の数学的な値は、<xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/>のセクション4.3.1のroundTiesToEven手順を使用して、binary64に変換されます。その後、CBORでエンコードする際に、最短の浮動小数点表現が使用され、この変換結果を正確に表します。たとえば、1.5は16ビットの浮動小数点値で表されます（すべての実装が最小形式を効率的に見つけることができるわけではありません）。デフォルトのbinary64精度を使用する代わりに、変換の精度に影響を与える実装定義の精度制限がある場合があります。10進表記は、プロトコルで指定されている場合を除き、CBOR側でのみ使用する必要があります。</li>
        </ul>
        <t indent="0" pn="section-6.2-3">CBORは、一般的にJSONよりもコンパクトなエンコーディングを提供するように設計されています。1つの実装戦略は、JSON-to-CBORエンコーディングを単一のバッファ内で実行することです。この戦略では、いくつかの病的なケースを注意深く考慮する必要があります。たとえば、255バイトよりも長く（またははるかに長く）エスケープがない文字列がいくつかあり、CBORでUTF-8文字列としてエンコードされると拡張される可能性があります。同様に、一部のバイナリ浮動小数点表現は、JSONの短い10進表記（1.1、1e9）から拡張される可能性があります。これを正しく行うことは難しい場合があり、その後の脆弱性は攻撃者によって悪用される可能性があります。</t>
      </section>
    </section>
    <section anchor="future-evolution-of-cbor" toc="include" numbered="true" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-future-evolution-of-cbor">Future Evolution of CBOR</name>
      <t indent="0" pn="section-7-1">成功したプロトコルは時間とともに進化します。新しいアイデアが現れ、実装プラットフォームが改善され、関連するプロトコルが開発および進化し、アプリケーションおよびプロトコルからの新しい要件が追加されます。そのため、プロトコルの進化を促進することは、プロトコル開発において重要な設計上の考慮事項です。</t>
      <t indent="0" pn="section-7-2">CBORを使用するプロトコルに対して、CBORはその進化を容易にするための有用なメカニズムを提供します。このため、JSONベースのプロトコルのJSON形式開発から、そのようなベストプラクティスがよく知られています。そのため、この仕様の範囲外で、そのようなベストプラクティスについては言及しません。</t>
      <t indent="0" pn="section-7-3">ただし、CBOR自体の進化を容易にすることは、その範囲内で非常にうまくいきます。CBORは、CBORベースのプロトコルの開発の安定した基盤を提供すると同時に、進化できるように設計されています。成功したプロトコルは数十年間生き残る可能性があるため、CBORは数十年間の使用と進化を考慮して設計する必要があります。このセクションでは、CBORの進化に関するいくつかのガイダンスを提供します。これは、このドキュメントの他の部分よりも主観的である必要があります。また、プロトコル開発の教科書にならないように、必然的に不完全である必要があります。</t>
      <section anchor="extension-points" toc="include" numbered="true" removeInRFC="false" pn="section-7.1">
        <name slugifiedName="name-extension-points">Extension Points</name>
        <t indent="0" pn="section-7.1-1">プロトコル設計において、進化の機会はしばしば拡張ポイントの形で含まれます。たとえば、最初から完全に割り当てられていないコードポイントスペースがある場合があり、プロトコルは、最初に割り当てられたコードポイントよりも多くのコードポイントを使用し始める実装を許容し、受け入れるように設計されています。</t>
        <t indent="0" pn="section-7.1-2">コードポイントスペースのサイズを決定することは困難な場合があります。必要な範囲を予測することが難しいためです。プロトコル設計では、コードポイントスペースが十分に大きくなるように設計する必要があります。これにより、プロトコルの寿命中にゆっくりと埋められるようになります。</t>
        <t indent="0" pn="section-7.1-3">CBOR has three major extension points:</t>
        <dl spacing="normal" indent="3" newline="false" pn="section-7.1-4">
          <dt pn="section-7.1-4.1">「simple」スペース（メジャータイプ7の値）：</dt>
          <dd pn="section-7.1-4.2">24の効率的な値（および224のやや効率的である値）のうち、ごくわずかしか割り当てられていません。不明なシンプルデータアイテムを受信した実装は、値の構造が実際にシンプルである場合、それを処理することができる場合があります。IANAレジストリは、このコードポイントスペースの拡張性をアドレスするための適切な方法です。<xref target="ianasimple" format="default" sectionFormat="of" derivedContent="Section 9.1"/>。</dd>
          <dt pn="section-7.1-4.3">「tag」スペース（メジャータイプ6の値）：</dt>
          <dd pn="section-7.1-4.4">総コードポイントスペースは豊富ですが、そのうちごく一部しか割り当てられていません。ただし、これらのコードポイントがすべて同じ効率であるわけではありません。最初の24個は1つの（「1 + 0」）バイトしか消費せず、そのうちの半分がすでに割り当てられています。次の232個の値は2つの（「1 + 1」）バイトしか消費せず、そのうちの約4分の1がすでに割り当てられています。これらのサブスペースは、数十年間持続するためにいくつかの手入れが必要です。不明なタグ番号を受信した実装は、包含されたタグコンテンツだけを処理するか、好ましくは、タグコンテンツを包む不明なタグ番号としてタグを処理することができます。IANAレジストリは、このコードポイントスペースの拡張性をアドレスするための適切な方法です。<xref target="ianatags" format="default" sectionFormat="of" derivedContent="Section 9.2"/>。</dd>
          <dt pn="section-7.1-4.5">「additional information」スペース：</dt>
          <dd pn="section-7.1-4.6">不明な追加情報値を受信した実装は、デコードを続行する方法がありません。したがって、このスペースにコードポイントを割り当てることは、拡張ポイントを実行する以上の大きなステップです。残りのコードポイントも非常に少ないです。詳細については、<xref target="curating" format="default" sectionFormat="of" derivedContent="Section 7.2"/>も参照してください。</dd>
        </dl>
      </section>
      <section anchor="curating" toc="include" numbered="true" removeInRFC="false" pn="section-7.2">
        <name slugifiedName="name-curating-the-additional-inf">Curating the Additional Information Space</name>
        <t indent="0" pn="section-7.2-1">人間の心は、何かを整然とさせるために、時には小さな認識された隙間を埋めることに引き寄せられることがあります。追加情報値のコードポイントスペースの残りの隙間が、新しいアイデアの引き寄せ子になることを期待しています。それらがあるからです。</t>
        <t indent="0" pn="section-7.2-2">現在の仕様では、追加情報のコードポイントスペースはIANAレジストリによって管理されていません。このスペースからの割り当ては、この仕様を更新することによってのみ行うことができます。</t>
        <t indent="0" pn="section-7.2-3">追加情報値n（n≥24）の場合、追加データのサイズは通常2<sup>n-24</sup>バイトです。したがって、追加情報値28および29は、プロトコルに追加する必要がある場合に128ビットおよび256ビットの数量の候補として見なす必要があります。追加情報値30は、一般的な割り当て用に利用可能な唯一の追加情報値であり、現在の仕様の更新を介して割り当てる前に非常に良い理由がある必要があります。</t>
      </section>
    </section>
    <section anchor="diagnostic-notation" toc="include" numbered="true" removeInRFC="false" pn="section-8">
      <name slugifiedName="name-diagnostic-notation">Diagnostic Notation</name>
      <t indent="0" pn="section-8-1">CBORはバイナリ交換形式です。ドキュメント作成およびデバッグを容易にするため、特にデバッグに協力するエンティティ間の通信を容易にするために、このセクションでは単純な人間が読める診断表記を定義します。実際の交換は常にバイナリ形式で行われます。</t>
      <t indent="0" pn="section-8-2">これは本当に診断用のフォーマットであることに注意してください。解析することを意図していません。そのため、このドキュメントでは、ABNFのような形式的な定義は与えられていません。（構成ファイルでCBORデータアイテムを表現するためのテキストベースのフォーマットを探している実装者は、YAML <xref target="YAML" format="default" sectionFormat="of" derivedContent="YAML"/>を検討することもできます。）</t>
      <t indent="0" pn="section-8-3">診断表記は、必要に応じて拡張されたRFC 8259で定義されているJSONに緩く基づいています。</t>
      <t indent="0" pn="section-8-4">この表記法は、JSONの数値（整数および浮動小数点）、True（&gt;true&lt;）、False（&gt;false&lt;）、Null（&gt;null&lt;）、UTF-8文字列、配列、およびマップ（JSONではマップはオブジェクトと呼ばれます。診断表記法は、キーの位置に任意のデータアイテムを許可することでJSONを拡張しています）。UndefinedはJavaScriptと同様に&gt;undefined&lt;と書かれます。非有限浮動小数点数のInfinity、-Infinity、およびNaNは、この文で書かれているように正確に書かれます（これはJavaScriptで書かれる方法でもありますが、JSONでは許可されていません）。タグは、タグ番号の整数値で書かれ、その後にタグコンテンツが括弧で囲まれて続きます。たとえば、RFC 3339（ISO 8601）で指定された形式の日付は、次のように表記されます。</t>
      <t indent="5" pn="section-8-5">0("2013-03-21T20:04:00Z")</t>
      <t indent="0" pn="section-8-6">または、次のような相対時間として表現されます。</t>
      <t indent="5" pn="section-8-7">1(1363896240)</t>
      <t indent="0" pn="section-8-8">バイト文字列は、パディングなしで、シングルクォートで囲まれ、ベースエンコーディングの1つで表記されます。ベース16の場合は、&gt;h&lt;、ベース32の場合は&gt;b32&lt;、ベース32hexの場合は&gt;h32&lt;、ベース64またはベース64urlの場合は&gt;b64&lt;で接頭辞が付きます（実際のエンコーディングは重複しないため、文字列は曖昧ではありません）。たとえば、バイト文字列0x12345678は、h'12345678'、b32'CI2FM6A'、またはb64'EjRWeA'として書くことができます。</t>
      <t indent="0" pn="section-8-9">未割り当てのシンプル値は、括弧内の適切な整数を伴う"simple()"として与えられます。たとえば、"simple(42)"は、メジャータイプ7、値42を示します。</t>
      <t indent="0" pn="section-8-10">ここで定義された診断表記法には、<xref target="RFC8610" section="G" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8610#appendix-G" derivedContent="RFC8610"/>で提供される「拡張診断表記法」（EDN）による診断表記法の有用な拡張がいくつかあります。
        同様に、この表記法は、この文書ではカバーされていないNaNペイロードのドキュメントを提供するために、別の文書で拡張できます。</t>
      <section anchor="encoding-indicators" toc="include" numbered="true" removeInRFC="false" pn="section-8.1">
        <name slugifiedName="name-encoding-indicators">Encoding Indicators</name>
        <t indent="0" pn="section-8.1-1">診断表記法では、実際に使用された複数の代替表現のうち、どれが使用されたかを示すことがあると便利な場合があります。たとえば、診断デコーダーによって&gt;1.5&lt;と書かれたデータアイテムは、ハーフ、シングル、またはダブル精度の浮動小数点数としてエンコードされている可能性があります。</t>
        <t indent="0" pn="section-8.1-2">エンコーディングインジケータの規約は、アンダースコアで始まり、その後のすべての英数字またはアンダースコアがエンコーディングインジケータであることであり、この情報に関心のない人は無視できます。たとえば、<tt>_</tt>または<tt>_3</tt>。エンコーディングインジケータは常にオプションです。</t>
        <t indent="0" pn="section-8.1-3">マップの開始括弧の後または配列の開始括弧の後に単一のアンダースコアを書くことで、データアイテムが不定長形式で表現されたことを示すことができます。たとえば、[_ 1, 2]には、データアイテム[1, 2]が不定長形式で表現されたことを示すインジケータが含まれています。</t>
        <t indent="0" pn="section-8.1-4">アンダースコアの後に10進数の数字nが続く場合、前のアイテム（または配列やマップの場合は、前の括弧またはブレースで始まるアイテム）が、追加情報値24+nでエンコードされたことを示します。たとえば、1.5_1は半精度浮動小数点数であり、1.5_3は倍精度でエンコードされます。このエンコーディングインジケータは<xref target="examples" format="default" sectionFormat="of" derivedContent="Appendix A"/>には表示されません。（エンコーディングインジケータ"_"は、使用されない完全な形式"_7"の略語であることに注意してください。）</t>
        <t indent="0" pn="section-8.1-5">不定長のバイト文字列とテキスト文字列の詳細なチャンク構造は、(_ h'0123', h'4567')および(_ "foo", "bar")の形式で表記できます。ただし、内部にチャンクがない不定長文字列の場合、(_ )はバイト文字列（0x5fff）またはテキスト文字列（0x7fff）のどちらを意味するか不明確であり、使用されません。
        基本形式''_および""_は、チャンクがない場合にのみ使用でき、空のチャンクのみを持つ（許可されていますが、実際にはあまり有用ではない）エンコーディングは(_ '')、(_ "")などと表記する必要があります。チャンク構造を保持するために。</t>
      </section>
    </section>
    <section anchor="ianacons" toc="include" numbered="true" removeInRFC="false" pn="section-9">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-9-1">IANAは、新しいCBOR値のために2つのレジストリを作成しました。レジストリは別々であり、傘下のレジストリではありません。また、<xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>の規則に従います。IANAは、新しいメディアタイプ、関連するCoAPコンテンツフォーマットエントリ、および構造化構文接尾辞も割り当てました。</t>
      <section anchor="ianasimple" toc="include" numbered="true" removeInRFC="false" pn="section-9.1">
        <name slugifiedName="name-cbor-simple-values-registry">CBOR Simple Values Registry</name>
        <t indent="0" pn="section-9.1-1">IANAは、<xref target="IANA.cbor-simple-values" format="default" sectionFormat="of" derivedContent="Concise Binary Object Representation (CBOR) Simple Values"/>レジストリを作成しました。初期値は<xref target="fpnoconttbl2" format="default" sectionFormat="of" derivedContent="Table 4"/>に示されています。</t>
        <t indent="0" pn="section-9.1-2">0から19の範囲の新しいエントリは、標準アクションによって割り当てられます。割り当ては、<xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>によって行われます。連続するブロック（ある場合）の下位番号を予約するために、IANAが16から始まる値を割り当てることが提案されています。</t>
        <t indent="0" pn="section-9.1-3">32から255の範囲の新しいエントリは、Specification Requiredによって割り当てられます。</t>
      </section>
      <section anchor="ianatags" toc="include" numbered="true" removeInRFC="false" pn="section-9.2">
        <name slugifiedName="name-cbor-tags-registry">CBOR Tags Registry</name>
        <t indent="0" pn="section-9.2-1">IANAは、<xref target="IANA.cbor-tags" format="default" sectionFormat="of" derivedContent="IANA.cbor-tags"/>において、「Concise Binary Object Representation (CBOR) Tags」レジストリを作成しました。<xref target="RFC7049" format="default" sectionFormat="of" derivedContent="RFC7049"/>で定義されたタグについては、<xref target="tags" format="default" sectionFormat="of" derivedContent="Section 3.4"/>で詳しく説明されており、その後も他のタグが定義されています。</t>
        <t indent="0" pn="section-9.2-2">0から23の範囲の新しいエントリは、標準アクションによって割り当てられます。
        24から255（"1+1"）および256から32767（"1+2"の下位半分）の範囲の新しいエントリは、Specification Requiredによって割り当てられます。32768から18446744073709551615（"1+2"の上位半分、"1+4"、および"1+8"）の範囲の新しいエントリは、First Come First Servedによって割り当てられます。登録リクエストのテンプレートは以下のとおりです。</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-9.2-3">
          <li pn="section-9.2-3.1">データアイテム</li>
          <li pn="section-9.2-3.2">意味（短い形式）</li>
        </ul>
        <t indent="0" pn="section-9.2-4">さらに、First Come First Servedリクエストには、以下が含まれる必要があります。</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-9.2-5">
          <li pn="section-9.2-5.1">連絡先</li>
          <li pn="section-9.2-5.2">意味の説明（URL）-- この説明はオプションです。URLは、インターネットドラフトやWebページのようなものを指すことができます。</li>
        </ul>
        <t indent="0" pn="section-9.2-6">First Come First Served範囲を使用し、32ビットで表現できない（つまり、4294967295より大きい）タグ番号の提案を行う申請者は、64ビットの数値をサポートしていない実装との相互運用性が低下する可能性があることに注意する必要があります。</t>
      </section>
      <section anchor="media-type-mime-type" toc="include" numbered="true" removeInRFC="false" pn="section-9.3">
        <name slugifiedName="name-media-types-registry">Media Types Registry</name>
        <t indent="0" pn="section-9.3-1">単一のエンコードされたCBORデータアイテムのインターネットメディアタイプ<xref target="RFC6838" format="default" sectionFormat="of" derivedContent="RFC6838"/>（「MIMEタイプ」）は、「Media Types」レジストリ<xref target="IANA.media-types" format="default" sectionFormat="of" derivedContent="IANA.media-types"/>で定義されている「application/cbor」です。</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-9.3-2">
          <dt pn="section-9.3-2.1">タイプ名:</dt>
          <dd pn="section-9.3-2.2">application</dd>
          <dt pn="section-9.3-2.3">サブタイプ名:</dt>
          <dd pn="section-9.3-2.4">cbor</dd>
          <dt pn="section-9.3-2.5">必須パラメータ:</dt>
          <dd pn="section-9.3-2.6">なし</dd>
          <dt pn="section-9.3-2.7">オプションパラメータ:</dt>
          <dd pn="section-9.3-2.8">なし</dd>
          <dt pn="section-9.3-2.9">エンコードに関する考慮事項:</dt>
          <dd pn="section-9.3-2.10">バイナリ</dd>
          <dt pn="section-9.3-2.11">セキュリティに関する考慮事項:</dt>
          <dd pn="section-9.3-2.12"><xref target="securitycons" format="default" sectionFormat="of" derivedContent="RFC 8949"/>の<xref target="securitycons" format="default" sectionFormat="of" derivedContent="Section 10"/>を参照してください。</dd>
          <dt pn="section-9.3-2.13">相互運用性に関する考慮事項:</dt>
          <dd pn="section-9.3-2.14">なし</dd>
          <dt pn="section-9.3-2.15">公開された仕様:</dt>
          <dd pn="section-9.3-2.16">RFC 8949</dd>
          <dt pn="section-9.3-2.17">このメディアタイプを使用するアプリケーション:</dt>
          <dd pn="section-9.3-2.18">多数</dd>
          <dt pn="section-9.3-2.19">追加情報:</dt>
          <dd pn="section-9.3-2.20">
            <t indent="0" pn="section-9.3-2.20.1"><br/></t>
            <dl spacing="compact" indent="3" newline="false" pn="section-9.3-2.20.2">
              <dt pn="section-9.3-2.20.2.1">マジックナンバー:</dt>
              <dd pn="section-9.3-2.20.2.2">なし</dd>
              <dt pn="section-9.3-2.20.2.3">ファイル拡張子:</dt>
              <dd pn="section-9.3-2.20.2.4">.cbor</dd>
              <dt pn="section-9.3-2.20.2.5">Macintoshファイルタイプコード:</dt>
              <dd pn="section-9.3-2.20.2.6">なし</dd>
            </dl>
          </dd>
          <dt pn="section-9.3-2.21">詳細情報の連絡先とメールアドレス:</dt>
          <dd pn="section-9.3-2.22">IETF CBOR Working Group (cbor@ietf.org) または IETF Applications and Real-Time Area (art@ietf.org)</dd>
          <dt pn="section-9.3-2.23">使用目的:</dt>
          <dd pn="section-9.3-2.24">共通</dd>
          <dt pn="section-9.3-2.25">使用上の制限:</dt>
          <dd pn="section-9.3-2.26">なし</dd>
          <dt pn="section-9.3-2.27">著者:</dt>
          <dd pn="section-9.3-2.28">IETF CBOR Working Group (cbor@ietf.org)</dd>
          <dt pn="section-9.3-2.29">変更管理者:</dt>
          <dd pn="section-9.3-2.30">The IESG (iesg@ietf.org)</dd>
        </dl>
      </section>
      <section anchor="coap-content-format" toc="include" numbered="true" removeInRFC="false" pn="section-9.4">
        <name slugifiedName="name-coap-content-format-registr">CoAP Content-Format Registry</name>
        <t indent="0" pn="section-9.4-1">CBORのCoAPコンテンツフォーマットは、「Constrained RESTful Environments (CoRE) Parameters」レジストリ<xref target="IANA.core-parameters" format="default" sectionFormat="of" derivedContent="IANA.core-parameters"/>内の「CoAP Content-Formats」サブレジストリに登録されています。</t>
        <dl indent="3" newline="false" spacing="normal" pn="section-9.4-2">
          <dt pn="section-9.4-2.1">メディアタイプ:</dt>
          <dd pn="section-9.4-2.2">application/cbor</dd>
          <dt pn="section-9.4-2.3">エンコーディング:</dt>
          <dd pn="section-9.4-2.4">-</dd>
          <dt pn="section-9.4-2.5">ID:</dt>
          <dd pn="section-9.4-2.6">60</dd>
          <dt pn="section-9.4-2.7">参照:</dt>
          <dd pn="section-9.4-2.8">RFC 8949</dd>
        </dl>
      </section>
      <section anchor="the-cbor-structured-syntax-suffix-registration" toc="include" numbered="true" removeInRFC="false" pn="section-9.5">
        <name slugifiedName="name-structured-syntax-suffix-re">Structured Syntax Suffix Registry</name>
        <t indent="0" pn="section-9.5-1">単一のエンコードされたCBORデータアイテムに基づくメディアタイプの構造化構文サフィックスは、+cborであり、IANAは「Structured Syntax Suffixes」レジストリ<xref target="IANA.structured-suffix" format="default" sectionFormat="of" derivedContent="IANA.structured-suffix"/>に登録しています。<xref target="RFC6838" format="default" sectionFormat="of" derivedContent="RFC6838"/>。</t>
        <dl indent="3" newline="false" spacing="normal" pn="section-9.5-2">
          <dt pn="section-9.5-2.1">名前:</dt>
          <dd pn="section-9.5-2.2">Concise Binary Object Representation (CBOR)</dd>
          <dt pn="section-9.5-2.3">+suffix:</dt>
          <dd pn="section-9.5-2.4">+cbor</dd>
          <dt pn="section-9.5-2.5">参照:</dt>
          <dd pn="section-9.5-2.6">RFC 8949</dd>
          <dt pn="section-9.5-2.7">エンコードに関する考慮事項:</dt>
          <dd pn="section-9.5-2.8">CBORはバイナリ形式です。</dd>
          <dt pn="section-9.5-2.9">相互運用性に関する考慮事項:</dt>
          <dd pn="section-9.5-2.10">なし</dd>
          <dt pn="section-9.5-2.11">フラグメント識別子に関する考慮事項:</dt>
          <dd pn="section-9.5-2.12">
            <t indent="0" pn="section-9.5-2.12.1">
  +cborのために指定されたフラグメント識別子の構文と意味は、「application/cbor」のために指定されたものと同じであるべきです。<bcp14>（RFC 8949の発行時点では、「application/cbor」のためにフラグメント識別子の構文が定義されていません。）</bcp14></t>
            <t indent="0" pn="section-9.5-2.12.2">特定の「xxx/yyy+cbor」のフラグメント識別子の構文と意味は、以下のように処理する必要があります。</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-9.5-2.12.3">
              <li pn="section-9.5-2.12.3.1">+cborで定義された場合、フラグメント識別子が+cborのルールに従って解決される場合は、+cborで指定されたように処理します。</li>
              <li pn="section-9.5-2.12.3.2">+cborで定義された場合、フラグメント識別子が+cborのルールに従って解決されない場合は、「xxx/yyy+cbor」で指定されたように処理します。</li>
              <li pn="section-9.5-2.12.3.3">+cborで定義されていない場合は、「xxx/yyy+cbor」で指定されたように処理します。</li>
            </ul>
          </dd>
          <dt pn="section-9.5-2.13">セキュリティに関する考慮事項:</dt>
          <dd pn="section-9.5-2.14"><xref target="securitycons" format="default" sectionFormat="of" derivedContent="RFC 8949"/>の<xref target="securitycons" format="default" sectionFormat="of" derivedContent="Section 10"/>を参照してください。</dd>
          <dt pn="section-9.5-2.15">連絡先:</dt>
          <dd pn="section-9.5-2.16">IETF CBOR Working Group (cbor@ietf.org) または IETF Applications and Real-Time Area (art@ietf.org)</dd>
          <dt pn="section-9.5-2.17">著者/変更管理者:</dt>
          <dd pn="section-9.5-2.18">IETF</dd>
        </dl>
      </section>
    </section>
    <section anchor="securitycons" toc="include" numbered="true" removeInRFC="false" pn="section-10">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-10-1">ネットワークに面したアプリケーションは、受信データの処理ロジックに脆弱性を示すことがあります。複雑なパーサは、ノードをリモートでクラッシュさせたり、さらにはリモートで任意のコードを実行することができる可能性があるとして、そのような脆弱性の発生源としてよく知られています。CBORは、可能な限りエンコード可能な値の範囲に意味を与えることにより、パーサの複雑さを減らすことで、そのような脆弱性を導入する機会を狭めることを試みています。</t>
      <t indent="0" pn="section-10-2">CBORデコーダは、検証されていない入力を処理する最初のステップとしてしばしば使用されるため、CBORデータアイテムのデコードを行うシステムを破壊、オーバーラン、または制御するために設計されたあらゆる種類の攻撃的な入力に完全に対応する必要があります。CBORデコーダは、ファイアウォールによってチェックされた、TLSのような安全なチャネルを介して送信された、暗号化または署名された、または信頼されると想定される他のソースから来た入力であっても、すべての入力が攻撃的であると想定する必要があります。</t>
      <t indent="0" pn="section-10-3"><xref target="preferred" format="default" sectionFormat="of" derivedContent="Section 4.1"/>は、制限されたCBORデコーダを使用して、非推奨のシリアライゼーションを使用するCBORエンコーダからの入力を処理する場合の相互運用性の制限の例を示しています。制限されたデコーダと完全なデコーダの両方によって単一のデータアイテムが消費される場合、攻撃者がコンテンツを注入または操作できるセキュリティ問題が発生する可能性があります。</t>
      <t indent="0" pn="section-10-4">本文書全体で議論されているように、ある状況では「同等」と見なされる値が、他の状況では「非同等」と見なされることがあります。たとえば、数字の「1」の数値値は、整数またはビッグナンバーとして表現される可能性があります。CBOR入力を解釈するシステムは、「1」の数値に対してどちらの形式でも受け入れることができるか、またはどちらか（または両方）の形式を拒否することができます。そのような受け入れまたは拒否は、解釈された入力を使用しているプログラムにセキュリティ上の影響を与える可能性があります。</t>
      <t indent="0" pn="section-10-5">敵対的な入力は、バッファをオーバーランしたり、整数演算をオーバーフローまたはアンダーフローさせたり、または他のデコードの妨害を引き起こすために構築される可能性があります。CBORデータアイテムには、意図的に非常に大きな長さやサイズがある場合があります。
      リソース枯渇攻撃は、非常に大きなデータアイテム（文字列、配列、マップ、または任意の精度の数値）を割り当てさせたり、深くネストされたアイテムを設定することでスタックの深さを枯渇させたりすることを試みる場合があります。デコーダは、これらの攻撃を緩和するために適切なリソース管理を持つ必要があります。 （非常に大きなサイズが指定されたアイテムは、整数オーバーフローの脆弱性を悪用することも試みることができます。）</t>
      <t indent="0" pn="section-10-6">CBORデコーダは、定義により、正しく形成されたCBORのみを受け入れます。これは、その堅牢性にとって最初のステップです。正しく形成されていないCBORの入力は、形成不良が検出された時点からの処理を引き起こしません。可能であれば、この時点までにデコードされたデータは、CBORデコーダを使用するアプリケーションに影響を与えないようにする必要があります。</t>
      <t indent="0" pn="section-10-7">CBORデコーダは、形成の正当性を確認するだけでなく、CBORデータに対して妥当性チェックを実行することもできます。また、それらのチェックをデコーダを使用するアプリケーションに任せることもできます。この選択は、デコーダで明確に文書化する必要があります。CBORレベルでの妥当性に加えて、アプリケーションは、CBORでシリアル化されたアプリケーションプロトコルと整合していることを確認する必要があります。</t>
      <t indent="0" pn="section-10-8">入力チェック自体がリソースを消費する可能性があります。これは通常、入力のサイズに比例して線形になるため、攻撃者は防御側が入力検証に費やすリソースに相当するリソースを費やす必要があります。
      ただし、攻撃者は、ターゲットデコーダが処理するのに攻撃者が生成するよりも長い時間がかかる入力を作成できる場合があります。
      任意精度の数値の処理は、線形努力を超える場合があります。また、デコーダがマップのインメモリ表現を構築するために使用するハッシュテーブルの実装には、秘密鍵（<xref target="SIPHASH_LNCS" format="default" sectionFormat="of" derivedContent="SIPHASH_LNCS"/>のセクション7も参照してください。また、<xref target="SIPHASH_OPEN" format="default" sectionFormat="of" derivedContent="SIPHASH_OPEN"/>）または他の緩和策が採用されていない限り、二次努力を費やす攻撃ができます。
      このような超線形の努力は、入力検証前または入力検証時にリソースを枯渇させるため、攻撃者によって悪用される可能性があるため、CBORデコーダの実装では避ける必要があります。タグ番号の定義とその実装は、このようなセキュリティ上の考慮事項を追加する可能性があります。その場合は、タグ番号の定義のセキュリティ上の考慮事項で議論する必要があります。</t>
      <t indent="0" pn="section-10-9">CBORエンコーダは、ネットワークから直接入力を受け取らず、CBORデコーダと同じ方法で直接攻撃されることはありません。ただし、CBORエンコーダには、実装の別のレベルから入力を受け取るAPIがしばしばあり、そのAPIを介して攻撃される可能性があります。そのAPIの設計と実装は、呼び出し元の動作が攻撃的な入力またはコーディングのミスに基づく可能性があることを前提とする必要があります。バッファオーバーラン、整数演算のオーバーフローおよびアンダーフロー、およびその他のエラーなど、エンコーダを妨害することを目的としたエラーをチェックする必要があります。</t>
      <t indent="0" pn="section-10-10">プロトコルは、潜在的な複数の解釈が確実に単一の解釈に減少するように定義する必要があります。たとえば、攻撃者は、マップ内の重複したキーなどの無効な入力を利用したり、数値の処理における異なる精度を悪用したりして、1つのアプリケーションが2番目のアプリケーションで使用される解釈とは異なる解釈に基づいて決定を下すようにすることができます。一貫した解釈を容易にするために、エンコーダとデコーダの実装は、動作モードでの妥当性チェックを提供する必要があります（<xref target="validity-checking" format="default" sectionFormat="of" derivedContent="Section 5.4"/>）。ただし、一般的なデコーダは、アプリケーションが入力データに対して要求するすべての要件を知ることができないため、アプリケーションが独自の入力チェックを実行することから解放されるわけではありません。また、定義されたタグ番号のセットが進化するため、アプリケーションは、使用する一般的なデコーダでまだ妥当性チェックがサポートされていないタグ番号を使用する場合があります。一般的なデコーダは、サポートするタグ番号と、それらのタグ番号に対して提供する妥当性チェック、および基本的なCBOR（UTF-8チェック、重複マップキーのチェック）に対して提供する妥当性チェックを文書化する必要があります。</t>
      <t indent="0" pn="section-10-11"><xref target="bignums" format="default" sectionFormat="of" derivedContent="Section 3.4.3"/>は、数値をエンコードするために基本的な整数の代わりにビッグナンバー表現を使用することは、アプリケーションの意味論を持つことを意図していないことを示していますが、CBORデータを受信するアプリケーションが基本的な汎用データモデルのデコーダを使用している場合、そのような意味論を持つことがあります。この不一致は、2つの意味論が異なる場合にセキュリティ上の問題を引き起こす可能性があります。したがって、CBORを使用するアプリケーションは、CBORデータの各使用について使用しているデータモデルを指定する必要があります。</t>
      <t indent="0" pn="section-10-12">CBORデータを他の形式に変換することは一般的です。多くの場合、CBORには他の形式よりも表現力の高い型があります。これは、JSONへの一般的な変換に特に当てはまります。型情報の欠落は、表現力の低いデータを処理しているシステムにセキュリティ上の問題を引き起こす可能性があります。</t>
      <t indent="0" pn="section-10-13"><xref target="converting-from-json" format="default" sectionFormat="of" derivedContent="Section 6.2"/>は、CBORとJSONの間で変換する可能性のある一般的な使用シナリオを説明しており、攻撃者がアプリケーションが変換を実行していることを知っている場合、攻撃を許可する可能性があります。</t>
      <t indent="0" pn="section-10-14">CBORに関しては、<xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/>で定義されたbase16およびbase64の使用、および<xref target="RFC3629" format="default" sectionFormat="of" derivedContent="RFC3629"/>で定義されたUTF-8の使用に関するセキュリティ上の考慮事項が関連しています。</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.bormann-cbor-notable-tags" to="CBOR-TAGS"/>
    <references pn="section-11">
      <name slugifiedName="name-references">References</name>
      <references pn="section-11.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="C" target="https://www.iso.org/standard/74528.html" quoteTitle="true" derivedAnchor="C">
          <front>
            <title>Information technology - Programming languages - C</title>
            <author>
              <organization showOnFrontPage="true">International Organization for Standardization</organization>
            </author>
            <date year="2018" month="June"/>
          </front>
          <seriesInfo name="ISO/IEC" value="9899:2018"/>
          <refcontent>Fourth Edition</refcontent>
        </reference>
        <reference anchor="Cplusplus20" target="https://isocpp.org/files/papers/N4860.pdf" quoteTitle="true" derivedAnchor="Cplusplus20">
          <front>
            <title>Programming languages - C++</title>
            <author>
              <organization showOnFrontPage="true">International Organization for Standardization</organization>
            </author>
            <date year="2020" month="March"/>
          </front>
          <seriesInfo name="ISO/IEC" value="DIS 14882"/>
          <seriesInfo name="ISO/IEC" value="ISO/IEC JTC1 SC22 WG21 N 4860"/>
          <refcontent>Sixth Edition</refcontent>
        </reference>
        <reference anchor="IEEE754" target="https://ieeexplore.ieee.org/document/8766229" quoteTitle="true" derivedAnchor="IEEE754">
          <front>
            <title>IEEE Standard for Floating-Point Arithmetic</title>
            <author>
              <organization showOnFrontPage="true">IEEE</organization>
            </author>
            <date/>
          </front>
          <seriesInfo name="IEEE Std" value="754-2019"/>
          <seriesInfo name="DOI" value="10.1109/IEEESTD.2019.8766229"/>
        </reference>
        <reference anchor="RFC2045" target="https://www.rfc-editor.org/info/rfc2045" quoteTitle="true" derivedAnchor="RFC2045">
          <front>
            <title>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
            <author initials="N." surname="Freed" fullname="N. Freed">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Borenstein" fullname="N. Borenstein">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1996" month="November"/>
            <abstract>
              <t indent="0">This initial document specifies the various headers used to describe the structure of MIME messages.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2045"/>
          <seriesInfo name="DOI" value="10.17487/RFC2045"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3339" target="https://www.rfc-editor.org/info/rfc3339" quoteTitle="true" derivedAnchor="RFC3339">
          <front>
            <title>Date and Time on the Internet: Timestamps</title>
            <author initials="G." surname="Klyne" fullname="G. Klyne">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Newman" fullname="C. Newman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2002" month="July"/>
            <abstract>
              <t indent="0">This document defines a date and time format for use in Internet protocols that is a profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3339"/>
          <seriesInfo name="DOI" value="10.17487/RFC3339"/>
        </reference>
        <reference anchor="RFC3629" target="https://www.rfc-editor.org/info/rfc3629" quoteTitle="true" derivedAnchor="RFC3629">
          <front>
            <title>UTF-8, a transformation format of ISO 10646</title>
            <author initials="F." surname="Yergeau" fullname="F. Yergeau">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2003" month="November"/>
            <abstract>
              <t indent="0">ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="63"/>
          <seriesInfo name="RFC" value="3629"/>
          <seriesInfo name="DOI" value="10.17487/RFC3629"/>
        </reference>
        <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986" quoteTitle="true" derivedAnchor="RFC3986">
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="January"/>
            <abstract>
              <t indent="0">A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="66"/>
          <seriesInfo name="RFC" value="3986"/>
          <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
        <reference anchor="RFC4287" target="https://www.rfc-editor.org/info/rfc4287" quoteTitle="true" derivedAnchor="RFC4287">
          <front>
            <title>The Atom Syndication Format</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Sayre" fullname="R. Sayre" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="December"/>
            <abstract>
              <t indent="0">This document specifies Atom, an XML-based Web content and metadata syndication format.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4287"/>
          <seriesInfo name="DOI" value="10.17487/RFC4287"/>
        </reference>
        <reference anchor="RFC4648" target="https://www.rfc-editor.org/info/rfc4648" quoteTitle="true" derivedAnchor="RFC4648">
          <front>
            <title>The Base16, Base32, and Base64 Data Encodings</title>
            <author initials="S." surname="Josefsson" fullname="S. Josefsson">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="October"/>
            <abstract>
              <t indent="0">This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4648"/>
          <seriesInfo name="DOI" value="10.17487/RFC4648"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author initials="M." surname="Cotton" fullname="M. Cotton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="June"/>
            <abstract>
              <t indent="0">Many protocols make use of points of extensibility that use constants to identify various protocol parameters.  To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper.  For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t indent="0">To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed.  This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t indent="0">This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="TIME_T" target="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16" quoteTitle="true" derivedAnchor="TIME_T">
          <front>
            <title>The Open Group Base Specifications</title>
            <author>
              <organization showOnFrontPage="true">The Open Group</organization>
            </author>
            <date year="2018"/>
          </front>
          <seriesInfo name="IEEE Std" value="1003.1"/>
          <refcontent>Section 4.16, 'Seconds Since the Epoch'</refcontent>
          <refcontent>Issue 7, 2018 Edition</refcontent>
        </reference>
      </references>
      <references pn="section-11.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="ASN.1" target="https://www.itu.int/rec/T-REC-X.690-201508-I/en" quoteTitle="true" derivedAnchor="ASN.1">
          <front>
            <title>Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
            <author>
              <organization showOnFrontPage="true">International Telecommunication Union</organization>
            </author>
            <date year="2015"/>
          </front>
          <seriesInfo name="ITU-T" value="Recommendation X.690"/>
        </reference>
        <reference anchor="BSON" target="http://bsonspec.org/" quoteTitle="true" derivedAnchor="BSON">
          <front>
            <title>BSON - Binary JSON</title>
            <author>
              <organization showOnFrontPage="true">Various</organization>
            </author>
          </front>
        </reference>
        <reference anchor="I-D.bormann-cbor-notable-tags" quoteTitle="true" target="https://tools.ietf.org/html/draft-bormann-cbor-notable-tags-02" derivedAnchor="CBOR-TAGS">
          <front>
            <title>Notable CBOR Tags</title>
            <author initials="C" surname="Bormann" fullname="Carsten Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="June" day="25" year="2020"/>
            <abstract>
              <t indent="0">The Concise Binary Object Representation (CBOR, RFC 7049) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  In CBOR, one point of extensibility is the definition of CBOR tags. RFC 7049 and its revision 7049bis define a basic set of tags as well as a registry that can be used to contribute additional tag definitions [IANA.cbor-tags].  Since RFC 7049 was published, some 80 tag definitions have been added to that registry.  The present document provides a roadmap to a large subset of these tag definitions.  Where applicable, it points to a IETF standards or standard development document that specifies the tag.  Where no such document exists, the intention is to collect specification information from the sources of the registrations.  After some more development, the present document is intended to be useful as a reference document for the IANA registrations of the CBOR tags the definitions of which have been collected.</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-bormann-cbor-notable-tags-02"/>
          <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-bormann-cbor-notable-tags-02.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="ECMA262" target="https://www.ecma-international.org/publications/standards/Ecma-262.htm" quoteTitle="true" derivedAnchor="ECMA262">
          <front>
            <title>ECMAScript 2020 Language Specification</title>
            <author>
              <organization showOnFrontPage="true">Ecma International</organization>
            </author>
            <date year="2020" month="June"/>
          </front>
          <refcontent>Standard ECMA-262, 11th Edition</refcontent>
        </reference>
        <reference anchor="Err3764" target="https://www.rfc-editor.org/errata/eid3764" quoteTitle="false" derivedAnchor="Err3764">
          <front>
            <title>Erratum ID 3764</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
          </front>
          <refcontent>RFC 7049</refcontent>
        </reference>
        <reference anchor="Err3770" target="https://www.rfc-editor.org/errata/eid3770" quoteTitle="false" derivedAnchor="Err3770">
          <front>
            <title>Erratum ID 3770</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
          </front>
          <refcontent>RFC 7049</refcontent>
        </reference>
        <reference anchor="Err4294" target="https://www.rfc-editor.org/errata/eid4294" quoteTitle="false" derivedAnchor="Err4294">
          <front>
            <title>Erratum ID 4294</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
          </front>
          <refcontent>RFC 7049</refcontent>
        </reference>
        <reference anchor="Err4409" target="https://www.rfc-editor.org/errata/eid4409" quoteTitle="false" derivedAnchor="Err4409">
          <front>
            <title>Erratum ID 4409</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
          </front>
          <refcontent>RFC 7049</refcontent>
        </reference>
        <reference anchor="Err4963" target="https://www.rfc-editor.org/errata/eid4963" quoteTitle="false" derivedAnchor="Err4963">
          <front>
            <title>Erratum ID 4963</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
          </front>
          <refcontent>RFC 7049</refcontent>
        </reference>
        <reference anchor="Err4964" target="https://www.rfc-editor.org/errata/eid4964" quoteTitle="false" derivedAnchor="Err4964">
          <front>
            <title>Erratum ID 4964</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
          </front>
          <refcontent>RFC 7049</refcontent>
        </reference>
        <reference anchor="Err5434" target="https://www.rfc-editor.org/errata/eid5434" quoteTitle="false" derivedAnchor="Err5434">
          <front>
            <title>Erratum ID 5434</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
          </front>
          <refcontent>RFC 7049</refcontent>
        </reference>
        <reference anchor="Err5763" target="https://www.rfc-editor.org/errata/eid5763" quoteTitle="false" derivedAnchor="Err5763">
          <front>
            <title>Erratum ID 5763</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
          </front>
          <refcontent>RFC 7049</refcontent>
        </reference>
        <reference anchor="Err5917" target="https://www.rfc-editor.org/errata/eid5917" quoteTitle="false" derivedAnchor="Err5917">
          <front>
            <title>Erratum ID 5917</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
          </front>
          <refcontent>RFC 7049</refcontent>
        </reference>
        <reference anchor="IANA.cbor-simple-values" target="https://www.iana.org/assignments/cbor-simple-values" quoteTitle="true" derivedAnchor="IANA.cbor-simple-values">
          <front>
            <title>Concise Binary Object Representation (CBOR) Simple Values</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
          </front>
        </reference>
        <reference anchor="IANA.cbor-tags" target="https://www.iana.org/assignments/cbor-tags" quoteTitle="true" derivedAnchor="IANA.cbor-tags">
          <front>
            <title>Concise Binary Object Representation (CBOR) Tags</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
          </front>
        </reference>
        <reference anchor="IANA.core-parameters" target="https://www.iana.org/assignments/core-parameters" quoteTitle="true" derivedAnchor="IANA.core-parameters">
          <front>
            <title>Constrained RESTful Environments (CoRE) Parameters</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
          </front>
        </reference>
        <reference anchor="IANA.media-types" target="https://www.iana.org/assignments/media-types" quoteTitle="true" derivedAnchor="IANA.media-types">
          <front>
            <title>Media Types</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
          </front>
        </reference>
        <reference anchor="IANA.structured-suffix" target="https://www.iana.org/assignments/media-type-structured-suffix" quoteTitle="true" derivedAnchor="IANA.structured-suffix">
          <front>
            <title>Structured Syntax Suffixes</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
          </front>
        </reference>
        <reference anchor="MessagePack" target="https://msgpack.org/" quoteTitle="true" derivedAnchor="MessagePack">
          <front>
            <title>MessagePack</title>
            <author initials="S." surname="Furuhashi" fullname="Sadayuki Furuhashi">
              <organization showOnFrontPage="true"/>
            </author>
          </front>
        </reference>
        <reference anchor="PCRE" target="https://www.pcre.org/" quoteTitle="true" derivedAnchor="PCRE">
          <front>
            <title>PCRE - Perl Compatible Regular Expressions</title>
            <author initials="P." surname="Hazel" fullname="Philip Hazel">
              <organization showOnFrontPage="true"/>
            </author>
          </front>
        </reference>
        <reference anchor="RFC0713" target="https://www.rfc-editor.org/info/rfc713" quoteTitle="true" derivedAnchor="RFC0713">
          <front>
            <title>MSDTP-Message Services Data Transmission Protocol</title>
            <author initials="J." surname="Haverty" fullname="J. Haverty">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1976" month="April"/>
          </front>
          <seriesInfo name="RFC" value="713"/>
          <seriesInfo name="DOI" value="10.17487/RFC0713"/>
        </reference>
        <reference anchor="RFC6838" target="https://www.rfc-editor.org/info/rfc6838" quoteTitle="true" derivedAnchor="RFC6838">
          <front>
            <title>Media Type Specifications and Registration Procedures</title>
            <author initials="N." surname="Freed" fullname="N. Freed">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Klensin" fullname="J. Klensin">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Hansen" fullname="T. Hansen">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="January"/>
            <abstract>
              <t indent="0">This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols.  This memo documents an Internet Best Current Practice.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="13"/>
          <seriesInfo name="RFC" value="6838"/>
          <seriesInfo name="DOI" value="10.17487/RFC6838"/>
        </reference>
        <reference anchor="RFC7049" target="https://www.rfc-editor.org/info/rfc7049" quoteTitle="true" derivedAnchor="RFC7049">
          <front>
            <title>Concise Binary Object Representation (CBOR)</title>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="October"/>
            <abstract>
              <t indent="0">The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7049"/>
          <seriesInfo name="DOI" value="10.17487/RFC7049"/>
        </reference>
        <reference anchor="RFC7228" target="https://www.rfc-editor.org/info/rfc7228" quoteTitle="true" derivedAnchor="RFC7228">
          <front>
            <title>Terminology for Constrained-Node Networks</title>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Ersue" fullname="M. Ersue">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Keranen" fullname="A. Keranen">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="May"/>
            <abstract>
              <t indent="0">The Internet Protocol Suite is increasingly used on small devices with severe constraints on power, memory, and processing resources, creating constrained-node networks.  This document provides a number of basic terms that have been useful in the standardization work for constrained-node networks.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7228"/>
          <seriesInfo name="DOI" value="10.17487/RFC7228"/>
        </reference>
        <reference anchor="RFC7493" target="https://www.rfc-editor.org/info/rfc7493" quoteTitle="true" derivedAnchor="RFC7493">
          <front>
            <title>The I-JSON Message Format</title>
            <author initials="T." surname="Bray" fullname="T. Bray" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="March"/>
            <abstract>
              <t indent="0">I-JSON (short for "Internet JSON") is a restricted profile of JSON designed to maximize interoperability and increase confidence that software can process it successfully with predictable results.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7493"/>
          <seriesInfo name="DOI" value="10.17487/RFC7493"/>
        </reference>
        <reference anchor="RFC7991" target="https://www.rfc-editor.org/info/rfc7991" quoteTitle="true" derivedAnchor="RFC7991">
          <front>
            <title>The "xml2rfc" Version 3 Vocabulary</title>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="December"/>
            <abstract>
              <t indent="0">This document defines the "xml2rfc" version 3 vocabulary: an XML-based language used for writing RFCs and Internet-Drafts.  It is heavily derived from the version 2 vocabulary that is also under discussion.  This document obsoletes the v2 grammar described in RFC 7749.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7991"/>
          <seriesInfo name="DOI" value="10.17487/RFC7991"/>
        </reference>
        <reference anchor="RFC8259" target="https://www.rfc-editor.org/info/rfc8259" quoteTitle="true" derivedAnchor="RFC8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author initials="T." surname="Bray" fullname="T. Bray" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="December"/>
            <abstract>
              <t indent="0">JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t>
              <t indent="0">This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
          <seriesInfo name="DOI" value="10.17487/RFC8259"/>
        </reference>
        <reference anchor="RFC8610" target="https://www.rfc-editor.org/info/rfc8610" quoteTitle="true" derivedAnchor="RFC8610">
          <front>
            <title>Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures</title>
            <author initials="H." surname="Birkholz" fullname="H. Birkholz">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Vigano" fullname="C. Vigano">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="June"/>
            <abstract>
              <t indent="0">This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8610"/>
          <seriesInfo name="DOI" value="10.17487/RFC8610"/>
        </reference>
        <reference anchor="RFC8618" target="https://www.rfc-editor.org/info/rfc8618" quoteTitle="true" derivedAnchor="RFC8618">
          <front>
            <title>Compacted-DNS (C-DNS): A Format for DNS Packet Capture</title>
            <author initials="J." surname="Dickinson" fullname="J. Dickinson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Hague" fullname="J. Hague">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Dickinson" fullname="S. Dickinson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Manderson" fullname="T. Manderson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Bond" fullname="J. Bond">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="September"/>
            <abstract>
              <t indent="0">This document describes a data representation for collections of DNS messages.  The format is designed for efficient storage and transmission of large packet captures of DNS traffic; it attempts to minimize the size of such packet capture files but retain the full DNS message contents along with the most useful transport metadata. It is intended to assist with the development of DNS traffic- monitoring applications.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8618"/>
          <seriesInfo name="DOI" value="10.17487/RFC8618"/>
        </reference>
        <reference anchor="RFC8742" target="https://www.rfc-editor.org/info/rfc8742" quoteTitle="true" derivedAnchor="RFC8742">
          <front>
            <title>Concise Binary Object Representation (CBOR) Sequences</title>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="February"/>
            <abstract>
              <t indent="0">This document describes the Concise Binary Object Representation (CBOR) Sequence format and associated media type "application/cbor-seq".  A CBOR Sequence consists of any number of encoded CBOR data items, simply concatenated in sequence.</t>
              <t indent="0">Structured syntax suffixes for media types allow other media types to build on them and make it explicit that they are built on an existing media type as their foundation.  This specification defines and registers "+cbor-seq" as a structured syntax suffix for CBOR Sequences.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8742"/>
          <seriesInfo name="DOI" value="10.17487/RFC8742"/>
        </reference>
        <reference anchor="RFC8746" target="https://www.rfc-editor.org/info/rfc8746" quoteTitle="true" derivedAnchor="RFC8746">
          <front>
            <title>Concise Binary Object Representation (CBOR) Tags for Typed Arrays</title>
            <author initials="C." surname="Bormann" fullname="C. Bormann" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="February"/>
            <abstract>
              <t indent="0">The Concise Binary Object Representation (CBOR), as defined in RFC 7049, is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.</t>
              <t indent="0">This document makes use of this extensibility to define a number of CBOR tags for typed arrays of numeric data, as well as additional tags for multi-dimensional and homogeneous arrays.  It is intended as the reference document for the IANA registration of the CBOR tags defined.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8746"/>
          <seriesInfo name="DOI" value="10.17487/RFC8746"/>
        </reference>
        <reference anchor="SIPHASH_LNCS" quoteTitle="true" target="https://doi.org/10.1007/978-3-642-34931-7_28" derivedAnchor="SIPHASH_LNCS">
          <front>
            <title>SipHash: A Fast Short-Input PRF</title>
            <author initials="J." surname="Aumasson" fullname="Jean-Philippe Aumasson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Bernstein" fullname="Daniel J. Bernstein">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012"/>
          </front>
          <seriesInfo name="DOI" value="10.1007/978-3-642-34931-7_28"/>
          <refcontent>Progress in Cryptology - INDOCRYPT 2012, pp. 489-508</refcontent>
        </reference>
        <reference anchor="SIPHASH_OPEN" target="https://www.aumasson.jp/siphash/siphash.pdf" quoteTitle="true" derivedAnchor="SIPHASH_OPEN">
          <front>
            <title>SipHash: a fast short-input PRF</title>
            <author initials="J." surname="Aumasson" fullname="Jean-Philippe Aumasson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D.J." surname="Bernstein" fullname="Daniel J. Bernstein">
              <organization showOnFrontPage="true"/>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="YAML" target="https://www.yaml.org/spec/1.2/spec.html" quoteTitle="true" derivedAnchor="YAML">
          <front>
            <title>YAML Ain't Markup Language (YAML[TM]) Version 1.2</title>
            <author initials="O." surname="Ben-Kiki" fullname="Oren Ben-Kiki">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Evans" fullname="Clark Evans">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="I.d." surname="Net" fullname="Ingy döt Net">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="October"/>
          </front>
          <refcontent>3rd Edition</refcontent>
        </reference>
      </references>
    </references>
    <section anchor="examples" toc="include" numbered="true" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-examples-of-encoded-cbor-da">Examples of Encoded CBOR Data Items</name>
      <t indent="0" pn="section-appendix.a-1">以下の表は、いくつかのCBORエンコードされた値の診断表記（左列）と16進数表記（右列）を提供しています。注意：文字列 "\u00fc" は、単一のUnicode文字 <u format="num-name-lit" pn="u-1">ü</u> を含むUTF-8文字列を表す診断表記の一形式です。同様に、"\u6c34" は、単一の文字 <u format="num-name-lit" pn="u-2">水</u> を含むUTF-8文字列で、しばしば「水」と表現されます。また、"\ud800\udd51" は、単一の文字 <u format="num-name-lit" pn="u-3">𐅑</u> を含むUTF-8文字列で、診断表記の一形式です。（これらのすべての単一文字列は、ASCIIのみの仕様が必要な場合を除き、診断表記のネイティブUTF-8でも表現できます。）bignumsに対する診断表記では、意図された数値値がタグ付きバイト文字列（例：2(h'010000000000000000'））ではなく、10進数（例：18446744073709551616）として表示されます。</t>
      <table anchor="table_examples" align="center" pn="table-6">
        <name slugifiedName="name-examples-of-encoded-cbor-dat">Examples of Encoded CBOR Data Items</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Diagnostic</th>
            <th align="left" colspan="1" rowspan="1">Encoded</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">0</td>
            <td align="left" colspan="1" rowspan="1">0x00</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1</td>
            <td align="left" colspan="1" rowspan="1">0x01</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">10</td>
            <td align="left" colspan="1" rowspan="1">0x0a</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">23</td>
            <td align="left" colspan="1" rowspan="1">0x17</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">24</td>
            <td align="left" colspan="1" rowspan="1">0x1818</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">25</td>
            <td align="left" colspan="1" rowspan="1">0x1819</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">100</td>
            <td align="left" colspan="1" rowspan="1">0x1864</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1000</td>
            <td align="left" colspan="1" rowspan="1">0x1903e8</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1000000</td>
            <td align="left" colspan="1" rowspan="1">0x1a000f4240</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1000000000000</td>
            <td align="left" colspan="1" rowspan="1">0x1b000000e8d4a51000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">18446744073709551615</td>
            <td align="left" colspan="1" rowspan="1">0x1bffffffffffffffff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">18446744073709551616</td>
            <td align="left" colspan="1" rowspan="1">0xc249010000000000000000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-18446744073709551616</td>
            <td align="left" colspan="1" rowspan="1">0x3bffffffffffffffff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-18446744073709551617</td>
            <td align="left" colspan="1" rowspan="1">0xc349010000000000000000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-1</td>
            <td align="left" colspan="1" rowspan="1">0x20</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-10</td>
            <td align="left" colspan="1" rowspan="1">0x29</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-100</td>
            <td align="left" colspan="1" rowspan="1">0x3863</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-1000</td>
            <td align="left" colspan="1" rowspan="1">0x3903e7</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0.0</td>
            <td align="left" colspan="1" rowspan="1">0xf90000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-0.0</td>
            <td align="left" colspan="1" rowspan="1">0xf98000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1.0</td>
            <td align="left" colspan="1" rowspan="1">0xf93c00</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1.1</td>
            <td align="left" colspan="1" rowspan="1">0xfb3ff199999999999a</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1.5</td>
            <td align="left" colspan="1" rowspan="1">0xf93e00</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">65504.0</td>
            <td align="left" colspan="1" rowspan="1">0xf97bff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">100000.0</td>
            <td align="left" colspan="1" rowspan="1">0xfa47c35000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">3.4028234663852886e+38</td>
            <td align="left" colspan="1" rowspan="1">0xfa7f7fffff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1.0e+300</td>
            <td align="left" colspan="1" rowspan="1">0xfb7e37e43c8800759c</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">5.960464477539063e-8</td>
            <td align="left" colspan="1" rowspan="1">0xf90001</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0.00006103515625</td>
            <td align="left" colspan="1" rowspan="1">0xf90400</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-4.0</td>
            <td align="left" colspan="1" rowspan="1">0xf9c400</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-4.1</td>
            <td align="left" colspan="1" rowspan="1">0xfbc010666666666666</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Infinity</td>
            <td align="left" colspan="1" rowspan="1">0xf97c00</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">NaN</td>
            <td align="left" colspan="1" rowspan="1">0xf97e00</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-Infinity</td>
            <td align="left" colspan="1" rowspan="1">0xf9fc00</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Infinity</td>
            <td align="left" colspan="1" rowspan="1">0xfa7f800000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">NaN</td>
            <td align="left" colspan="1" rowspan="1">0xfa7fc00000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-Infinity</td>
            <td align="left" colspan="1" rowspan="1">0xfaff800000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Infinity</td>
            <td align="left" colspan="1" rowspan="1">0xfb7ff0000000000000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">NaN</td>
            <td align="left" colspan="1" rowspan="1">0xfb7ff8000000000000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">-Infinity</td>
            <td align="left" colspan="1" rowspan="1">0xfbfff0000000000000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">false</td>
            <td align="left" colspan="1" rowspan="1">0xf4</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">true</td>
            <td align="left" colspan="1" rowspan="1">0xf5</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">null</td>
            <td align="left" colspan="1" rowspan="1">0xf6</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">undefined</td>
            <td align="left" colspan="1" rowspan="1">0xf7</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">simple(16)</td>
            <td align="left" colspan="1" rowspan="1">0xf0</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">simple(255)</td>
            <td align="left" colspan="1" rowspan="1">0xf8ff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0("2013-03-21T20:04:00Z")</td>
            <td align="left" colspan="1" rowspan="1">0xc074323031332d30332d32315432303a 30343a30305a</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1(1363896240)</td>
            <td align="left" colspan="1" rowspan="1">0xc11a514b67b0</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1(1363896240.5)</td>
            <td align="left" colspan="1" rowspan="1">0xc1fb41d452d9ec200000</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">23(h'01020304')</td>
            <td align="left" colspan="1" rowspan="1">0xd74401020304</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">24(h'6449455446')</td>
            <td align="left" colspan="1" rowspan="1">0xd818456449455446</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">32("http://www.example.com")</td>
            <td align="left" colspan="1" rowspan="1">0xd82076687474703a2f2f7777772e6578 616d706c652e636f6d</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">h''</td>
            <td align="left" colspan="1" rowspan="1">0x40</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">h'01020304'</td>
            <td align="left" colspan="1" rowspan="1">0x4401020304</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">""</td>
            <td align="left" colspan="1" rowspan="1">0x60</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">"a"</td>
            <td align="left" colspan="1" rowspan="1">0x6161</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">"IETF"</td>
            <td align="left" colspan="1" rowspan="1">0x6449455446</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">"\"\\"</td>
            <td align="left" colspan="1" rowspan="1">0x62225c</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">"\u00fc"</td>
            <td align="left" colspan="1" rowspan="1">0x62c3bc</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">"\u6c34"</td>
            <td align="left" colspan="1" rowspan="1">0x63e6b0b4</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">"\ud800\udd51"</td>
            <td align="left" colspan="1" rowspan="1">0x64f0908591</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[]</td>
            <td align="left" colspan="1" rowspan="1">0x80</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[1, 2, 3]</td>
            <td align="left" colspan="1" rowspan="1">0x83010203</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[1, [2, 3], [4, 5]]</td>
            <td align="left" colspan="1" rowspan="1">0x8301820203820405</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]</td>
            <td align="left" colspan="1" rowspan="1">0x98190102030405060708090a0b0c0d0e 0f101112131415161718181819</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">{}</td>
            <td align="left" colspan="1" rowspan="1">0xa0</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">{1: 2, 3: 4}</td>
            <td align="left" colspan="1" rowspan="1">0xa201020304</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">{"a": 1, "b": [2, 3]}</td>
            <td align="left" colspan="1" rowspan="1">0xa26161016162820203</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">["a", {"b": "c"}]</td>
            <td align="left" colspan="1" rowspan="1">0x826161a161626163</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">{"a": "A", "b": "B", "c": "C", "d": "D", "e": "E"}</td>
            <td align="left" colspan="1" rowspan="1">0xa5616161416162614261636143616461 4461656145</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">(_ h'0102', h'030405')</td>
            <td align="left" colspan="1" rowspan="1">0x5f42010243030405ff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">(_ "strea", "ming")</td>
            <td align="left" colspan="1" rowspan="1">0x7f657374726561646d696e67ff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[_ ]</td>
            <td align="left" colspan="1" rowspan="1">0x9fff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[_ 1, [2, 3], [_ 4, 5]]</td>
            <td align="left" colspan="1" rowspan="1">0x9f018202039f0405ffff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[_ 1, [2, 3], [4, 5]]</td>
            <td align="left" colspan="1" rowspan="1">0x9f01820203820405ff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[1, [2, 3], [_ 4, 5]]</td>
            <td align="left" colspan="1" rowspan="1">0x83018202039f0405ff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[1, [_ 2, 3], [4, 5]]</td>
            <td align="left" colspan="1" rowspan="1">0x83019f0203ff820405</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">[_ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]</td>
            <td align="left" colspan="1" rowspan="1">0x9f0102030405060708090a0b0c0d0e0f 101112131415161718181819ff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">{_ "a": 1, "b": [_ 2, 3]}</td>
            <td align="left" colspan="1" rowspan="1">0xbf61610161629f0203ffff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">["a", {_ "b": "c"}]</td>
            <td align="left" colspan="1" rowspan="1">0x826161bf61626163ff</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">{_ "Fun": true, "Amt": -2}</td>
            <td align="left" colspan="1" rowspan="1">0xbf6346756ef563416d7421ff</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="jump-table" toc="include" numbered="true" removeInRFC="false" pn="section-appendix.b">
      <name slugifiedName="name-jump-table-for-initial-byte">Jump Table for Initial Byte</name>
      <t indent="0" pn="section-appendix.b-1">簡潔さのために、このジャンプテーブルには将来の拡張のために予約された初期バイトは表示されません。また、オプションの機能に使用できる初期バイトの選択のみを表示します。 （すべての符号なし整数はネットワークバイトオーダーで表されます。）</t>
      <table anchor="jumptable" align="center" pn="table-7">
        <name slugifiedName="name-jump-table-for-initial-byte-2">Jump Table for Initial Byte</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">バイト</th>
            <th align="left" colspan="1" rowspan="1">構造/意味</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x00..0x17</td>
            <td align="left" colspan="1" rowspan="1">0x00..0x17（0..23）の符号なし整数</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x18</td>
            <td align="left" colspan="1" rowspan="1">符号なし整数（1バイトのuint8_tが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x19</td>
            <td align="left" colspan="1" rowspan="1">符号なし整数（2バイトのuint16_tが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x1a</td>
            <td align="left" colspan="1" rowspan="1">符号なし整数（4バイトのuint32_tが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x1b</td>
            <td align="left" colspan="1" rowspan="1">符号なし整数（8バイトのuint64_tが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x20..0x37</td>
            <td align="left" colspan="1" rowspan="1">負の整数 -1-0x00..-1-0x17 (-1..-24)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x38</td>
            <td align="left" colspan="1" rowspan="1">負の整数 -1-n (1バイトのuint8_tが続く)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x39</td>
            <td align="left" colspan="1" rowspan="1">負の整数 -1-n (2バイトのuint16_tが続く)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x3a</td>
            <td align="left" colspan="1" rowspan="1">負の整数 -1-n (4バイトのuint32_tが続く)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x3b</td>
            <td align="left" colspan="1" rowspan="1">負の整数 -1-n (8バイトのuint64_tが続く)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x40..0x57</td>
            <td align="left" colspan="1" rowspan="1">バイト文字列（0x00..0x17バイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x58</td>
            <td align="left" colspan="1" rowspan="1">バイト文字列（1バイトのuint8_tが続き、その後nバイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x59</td>
            <td align="left" colspan="1" rowspan="1">バイト文字列（2バイトのuint16_tが続き、その後nバイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x5a</td>
            <td align="left" colspan="1" rowspan="1">バイト文字列（4バイトのuint32_tが続き、その後nバイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x5b</td>
            <td align="left" colspan="1" rowspan="1">バイト文字列（8バイトのuint64_tが続き、その後nバイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x5f</td>
            <td align="left" colspan="1" rowspan="1">バイト文字列、"break"で終了する</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x60..0x77</td>
            <td align="left" colspan="1" rowspan="1">UTF-8文字列（0x00..0x17バイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x78</td>
            <td align="left" colspan="1" rowspan="1">UTF-8文字列（1バイトのuint8_tが続き、その後nバイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x79</td>
            <td align="left" colspan="1" rowspan="1">UTF-8文字列（2バイトのuint16_tが続き、その後nバイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x7a</td>
            <td align="left" colspan="1" rowspan="1">UTF-8文字列（4バイトのuint32_tが続き、その後nバイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x7b</td>
            <td align="left" colspan="1" rowspan="1">UTF-8文字列（8バイトのuint64_tが続き、その後nバイトが続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x7f</td>
            <td align="left" colspan="1" rowspan="1">UTF-8文字列、UTF-8文字列が "break" で終了する</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x80..0x97</td>
            <td align="left" colspan="1" rowspan="1">配列（0x00..0x17のデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x98</td>
            <td align="left" colspan="1" rowspan="1">配列（1バイトのuint8_tが続き、その後n個のデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x99</td>
            <td align="left" colspan="1" rowspan="1">配列（2バイトのuint16_tが続き、その後n個のデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x9a</td>
            <td align="left" colspan="1" rowspan="1">配列（4バイトのuint32_tが続き、その後n個のデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x9b</td>
            <td align="left" colspan="1" rowspan="1">配列（8バイトのuint64_tが続き、その後n個のデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0x9f</td>
            <td align="left" colspan="1" rowspan="1">配列、データ項目が "break" で終了する</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xa0..0xb7</td>
            <td align="left" colspan="1" rowspan="1">マップ（0x00..0x17ペアのデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xb8</td>
            <td align="left" colspan="1" rowspan="1">マップ（1バイトのuint8_tが続き、その後nペアのデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xb9</td>
            <td align="left" colspan="1" rowspan="1">マップ（2バイトのuint16_tが続き、その後nペアのデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xba</td>
            <td align="left" colspan="1" rowspan="1">マップ（4バイトのuint32_tが続き、その後nペアのデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xbb</td>
            <td align="left" colspan="1" rowspan="1">マップ（8バイトのuint64_tが続き、その後nペアのデータ項目が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xbf</td>
            <td align="left" colspan="1" rowspan="1">マップ、データ項目が "break" で終了する</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xc0</td>
            <td align="left" colspan="1" rowspan="1">テキストベースの日付/時刻（データ項目が続く。詳細は<xref target="stringdatetimesect" format="default" sectionFormat="of" derivedContent="Section 3.4.1"/>を参照）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xc1</td>
            <td align="left" colspan="1" rowspan="1">エポックベースの日付/時刻（データ項目が続く。詳細は<xref target="epochdatetimesect" format="default" sectionFormat="of" derivedContent="Section 3.4.2"/>を参照）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xc2</td>
            <td align="left" colspan="1" rowspan="1">符号なしビッグナンバー（データ項目 "byte string" が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xc3</td>
            <td align="left" colspan="1" rowspan="1">負のビッグナンバー（データ項目 "byte string" が続く）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xc4</td>
            <td align="left" colspan="1" rowspan="1">10進数の分数（データ項目 "array" が続く。詳細は<xref target="fractions" format="default" sectionFormat="of" derivedContent="Section 3.4.4"/>を参照）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xc5</td>
            <td align="left" colspan="1" rowspan="1">ビッグフロート（データ項目 "array" が続く。詳細は<xref target="fractions" format="default" sectionFormat="of" derivedContent="Section 3.4.4"/>を参照）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xc6..0xd4</td>
            <td align="left" colspan="1" rowspan="1">(タグ)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xd5..0xd7</td>
            <td align="left" colspan="1" rowspan="1">期待される変換（データ項目が続く。詳細は<xref target="convexpect" format="default" sectionFormat="of" derivedContent="Section 3.4.5.2"/>を参照）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xd8..0xdb</td>
            <td align="left" colspan="1" rowspan="1">(タグの続き; 1/2/4/8バイトのタグ番号が続き、その後にデータ項目が続く)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xe0..0xf3</td>
            <td align="left" colspan="1" rowspan="1">(シンプルな値)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xf4</td>
            <td align="left" colspan="1" rowspan="1">false</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xf5</td>
            <td align="left" colspan="1" rowspan="1">true</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xf6</td>
            <td align="left" colspan="1" rowspan="1">null</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xf7</td>
            <td align="left" colspan="1" rowspan="1">undefined</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xf8</td>
            <td align="left" colspan="1" rowspan="1">(シンプルな値、1バイトが続く)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xf9</td>
            <td align="left" colspan="1" rowspan="1">半精度浮動小数点数（2バイトIEEE 754）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xfa</td>
            <td align="left" colspan="1" rowspan="1">単精度浮動小数点数（4バイトIEEE 754）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xfb</td>
            <td align="left" colspan="1" rowspan="1">倍精度浮動小数点数（8バイトIEEE 754）</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0xff</td>
            <td align="left" colspan="1" rowspan="1">"break" ストップコード</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="pseudocode" toc="include" numbered="true" removeInRFC="false" pn="section-appendix.c">
      <name slugifiedName="name-pseudocode">Pseudocode</name>
      <t indent="0" pn="section-appendix.c-1">The well-formedness of a CBOR item can be checked by the
pseudocode in <xref target="pseudo" format="default" sectionFormat="of" derivedContent="Figure 1"/>.  The data is well-formed if and only if:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.c-2">
        <li pn="section-appendix.c-2.1">the pseudocode does not "fail";</li>
        <li pn="section-appendix.c-2.2">after execution of the pseudocode, no bytes are left in the input
(except in streaming applications).</li>
      </ul>
      <t indent="0" pn="section-appendix.c-3">The pseudocode has the following prerequisites:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.c-4">
        <li pn="section-appendix.c-4.1">take(n) reads n bytes from the input data and returns them as a byte
string.  If n bytes are no longer available, take(n) fails.</li>
        <li pn="section-appendix.c-4.2">uint() converts a byte string into an unsigned integer by
interpreting the byte string in network byte order.</li>
        <li pn="section-appendix.c-4.3">Arithmetic works as in C.</li>
        <li pn="section-appendix.c-4.4">All variables are unsigned integers of sufficient range.</li>
      </ul>
      <t indent="0" pn="section-appendix.c-5">Note that <tt>well_formed</tt> returns the major type for well-formed
definite-length items, but 99 for an indefinite-length item (or -1 for
a "break" stop code, only if <tt>breakable</tt> is set).  This is used in
<tt>well_formed_indefinite</tt> to ascertain that indefinite-length strings
only contain definite-length strings as chunks.</t>
      <figure anchor="pseudo" align="left" suppress-title="false" pn="figure-1">
        <name slugifiedName="name-pseudocode-for-well-formedn">Pseudocode for Well-Formedness Check</name>
        <sourcecode type="pseudocode" markers="false" pn="section-appendix.c-6.1">
well_formed(breakable = false) {
  // process initial bytes
  ib = uint(take(1));
  mt = ib &gt;&gt; 5;
  val = ai = ib &amp; 0x1f;
  switch (ai) {
    case 24: val = uint(take(1)); break;
    case 25: val = uint(take(2)); break;
    case 26: val = uint(take(4)); break;
    case 27: val = uint(take(8)); break;
    case 28: case 29: case 30: fail();
    case 31:
      return well_formed_indefinite(mt, breakable);
  }
  // process content
  switch (mt) {
    // case 0, 1, 7 do not have content; just use val
    case 2: case 3: take(val); break; // bytes/UTF-8
    case 4: for (i = 0; i &lt; val; i++) well_formed(); break;
    case 5: for (i = 0; i &lt; val*2; i++) well_formed(); break;
    case 6: well_formed(); break;     // 1 embedded data item
    case 7: if (ai == 24 &amp;&amp; val &lt; 32) fail(); // bad simple
  }
  return mt;                    // definite-length data item
}

well_formed_indefinite(mt, breakable) {
  switch (mt) {
    case 2: case 3:
      while ((it = well_formed(true)) != -1)
        if (it != mt)           // need definite-length chunk
          fail();               //    of same type
      break;
    case 4: while (well_formed(true) != -1); break;
    case 5: while (well_formed(true) != -1) well_formed(); break;
    case 7:
      if (breakable)
        return -1;              // signal break out
      else fail();              // no enclosing indefinite
    default: fail();            // wrong mt
  }
  return 99;                    // indefinite-length data item
}
</sourcecode>
      </figure>
      <t indent="0" pn="section-appendix.c-7">Note that the remaining complexity of a complete CBOR decoder is about
presenting data that has been decoded to the application in an
appropriate form.</t>
      <t indent="0" pn="section-appendix.c-8">Major types 0 and 1 are designed in such a way that they can be
encoded in C from a signed integer without actually doing an
if-then-else for positive/negative (<xref target="branchless" format="default" sectionFormat="of" derivedContent="Figure 2"/>).  This uses the
fact that (-1-n), the transformation for major type 1, is the same as
~n (bitwise complement) in C unsigned arithmetic; ~n can then be
expressed as (-1)^n for the negative case, while 0^n leaves n
unchanged for nonnegative.  The sign of a number can be converted to
-1 for negative and 0 for nonnegative (0 or positive) by
arithmetic-shifting the number by one bit less than the bit length of
the number (for example, by 63 for 64-bit numbers).</t>
      <figure anchor="branchless" align="left" suppress-title="false" pn="figure-2">
        <name slugifiedName="name-pseudocode-for-encoding-a-s">Pseudocode for Encoding a Signed Integer</name>
        <sourcecode type="pseudocode" markers="false" pn="section-appendix.c-9.1">
void encode_sint(int64_t n) {
  uint64t ui = n &gt;&gt; 63;    // extend sign to whole length
  unsigned mt = ui &amp; 0x20; // extract (shifted) major type
  ui ^= n;                 // complement negatives
  if (ui &lt; 24)
    *p++ = mt + ui;
  else if (ui &lt; 256) {
    *p++ = mt + 24;
    *p++ = ui;
  } else
       ...
</sourcecode>
      </figure>
      <t indent="0" pn="section-appendix.c-10">See <xref target="terminology" format="default" sectionFormat="of" derivedContent="Section 1.2"/> for some specific assumptions about the profile of
the C language used in these pieces of code.</t>
    </section>
    <section anchor="half-precision" toc="include" numbered="true" removeInRFC="false" pn="section-appendix.d">
      <name slugifiedName="name-half-precision">Half-Precision</name>
      <t indent="0" pn="section-appendix.d-1">As half-precision floating-point numbers were only added to IEEE 754
in 2008 <xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/>, today's programming platforms often still only have limited
support for them.  It is very easy to include at least decoding
support for them even without such support.  An example of a small
decoder for half-precision floating-point numbers in the C language is
shown in <xref target="decode-half-c" format="default" sectionFormat="of" derivedContent="Figure 3"/>.  A similar program for Python is in
<xref target="decode-half-py" format="default" sectionFormat="of" derivedContent="Figure 4"/>; this code assumes that the 2-byte value has
already been decoded as an (unsigned short) integer in network byte
order (as would be done by the pseudocode in <xref target="pseudocode" format="default" sectionFormat="of" derivedContent="Appendix C"/>).</t>
      <figure anchor="decode-half-c" align="left" suppress-title="false" pn="figure-3">
        <name slugifiedName="name-c-code-for-a-half-precision">C Code for a Half-Precision Decoder</name>
        <sourcecode type="c" markers="false" pn="section-appendix.d-2.1">
#include &lt;math.h&gt;

double decode_half(unsigned char *halfp) {
  unsigned half = (halfp[0] &lt;&lt; 8) + halfp[1];
  unsigned exp = (half &gt;&gt; 10) &amp; 0x1f;
  unsigned mant = half &amp; 0x3ff;
  double val;
  if (exp == 0) val = ldexp(mant, -24);
  else if (exp != 31) val = ldexp(mant + 1024, exp - 25);
  else val = mant == 0 ? INFINITY : NAN;
  return half &amp; 0x8000 ? -val : val;
}
</sourcecode>
      </figure>
      <figure anchor="decode-half-py" align="left" suppress-title="false" pn="figure-4">
        <name slugifiedName="name-python-code-for-a-half-prec">Python Code for a Half-Precision Decoder</name>
        <sourcecode type="python" markers="false" pn="section-appendix.d-3.1">
import struct
from math import ldexp

def decode_single(single):
    return struct.unpack("!f", struct.pack("!I", single))[0]

def decode_half(half):
    valu = (half &amp; 0x7fff) &lt;&lt; 13 | (half &amp; 0x8000) &lt;&lt; 16
    if ((half &amp; 0x7c00) != 0x7c00):
        return ldexp(decode_single(valu), 112)
    return decode_single(valu | 0x7f800000)
</sourcecode>
      </figure>
    </section>
    <section anchor="comparison-app" toc="include" numbered="true" removeInRFC="false" pn="section-appendix.e">
      <name slugifiedName="name-comparison-of-other-binary-">Comparison of Other Binary Formats to CBOR's Design Objectives</name>
      <t indent="0" pn="section-appendix.e-1">The proposal for CBOR follows a history of binary formats that is as
long as the history of computers themselves. Different formats have
had different objectives. In most cases, the objectives of the format
were never stated, although they can sometimes be implied by the
context where the format was first used. Some formats were meant to be
universally usable, although history has proven that no binary format
meets the needs of all protocols and applications.</t>
      <t indent="0" pn="section-appendix.e-2">CBOR differs from many of these formats due to it starting with a set
of objectives and attempting to meet just those. This section compares
a few of the dozens of formats with CBOR's objectives in order to help
the reader decide if they want to use CBOR or a different format for a
particular protocol or application.</t>
      <t indent="0" pn="section-appendix.e-3">Note that the discussion here is not meant to be a criticism of any
format: to the best of our knowledge, no format before CBOR was meant
to cover CBOR's objectives in the priority we have assigned them.  A
brief recap of the objectives from <xref target="objectives" format="default" sectionFormat="of" derivedContent="Section 1.1"/> is:</t>
      <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-appendix.e-4"><li pn="section-appendix.e-4.1" derivedCounter="1.">unambiguous encoding of most common data formats from Internet
  standards</li>
        <li pn="section-appendix.e-4.2" derivedCounter="2.">code compactness for encoder or decoder</li>
        <li pn="section-appendix.e-4.3" derivedCounter="3.">no schema description needed</li>
        <li pn="section-appendix.e-4.4" derivedCounter="4.">reasonably compact serialization</li>
        <li pn="section-appendix.e-4.5" derivedCounter="5.">applicability to constrained and unconstrained applications</li>
        <li pn="section-appendix.e-4.6" derivedCounter="6.">good JSON conversion</li>
        <li pn="section-appendix.e-4.7" derivedCounter="7.">extensibility</li>
      </ol>
      <t indent="0" pn="section-appendix.e-5">A discussion of CBOR and other formats with respect to a different set
of design objectives is provided in Section <xref target="RFC8618" section="5" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8618#section-5" derivedContent="RFC8618"/> 
and Appendix <xref target="RFC8618" section="C" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8618#appendix-C" derivedContent="RFC8618"/> of
<xref target="RFC8618" format="default" sectionFormat="of" derivedContent="RFC8618"/>.</t>
      <section anchor="asn1-der-ber-and-per" toc="include" numbered="true" removeInRFC="false" pn="section-e.1">
        <name slugifiedName="name-asn1-der-ber-and-per">ASN.1 DER, BER, and PER</name>
        <t indent="0" pn="section-e.1-1"><xref target="ASN.1" format="default" sectionFormat="of" derivedContent="ASN.1"/> has many serializations. In the IETF, DER and BER are the
most common. The serialized output is not particularly compact for
many items, and the code needed to decode numeric items can be complex
on a constrained device.</t>
        <t indent="0" pn="section-e.1-2">Few (if any) IETF protocols have adopted one of the several variants
of Packed Encoding Rules (PER).  There could be many reasons for this,
but one that is commonly stated is that PER makes use of the schema
even for parsing the surface structure of the data item, requiring
significant tool support.  There are different versions of the ASN.1
schema language in use, which has also hampered adoption.</t>
      </section>
      <section anchor="messagepack" toc="include" numbered="true" removeInRFC="false" pn="section-e.2">
        <name slugifiedName="name-messagepack">MessagePack</name>
        <t indent="0" pn="section-e.2-1"><xref target="MessagePack" format="default" sectionFormat="of" derivedContent="MessagePack"/> is a concise, widely implemented counted binary
serialization format, similar in many properties to CBOR, although
somewhat less regular.  While the data model can be used to represent
JSON data, MessagePack has also been used in many remote procedure
call (RPC) applications and for long-term storage of data.</t>
        <t indent="0" pn="section-e.2-2">MessagePack has been essentially stable since it was first published
around 2011; it has not yet had a transition.  The evolution of
MessagePack is impeded by an imperative to maintain complete backwards
compatibility with existing stored data, while only few bytecodes are
still available for extension.  Repeated requests over the years from
the MessagePack user community to separate out binary and text strings
in the encoding recently have led to an extension proposal that would
leave MessagePack's "raw" data ambiguous between its usages for binary
and text data. The extension mechanism for MessagePack remains
unclear.</t>
      </section>
      <section anchor="bson" toc="include" numbered="true" removeInRFC="false" pn="section-e.3">
        <name slugifiedName="name-bson">BSON</name>
        <t indent="0" pn="section-e.3-1"><xref target="BSON" format="default" sectionFormat="of" derivedContent="BSON"/> is a data format that was developed for the storage of
JSON-like maps (JSON objects) in the MongoDB database.  Its major
distinguishing feature is the capability for in-place update,
which prevents a compact representation.  BSON uses a counted
representation except for map keys, which are null-byte terminated.
While BSON can be used for the representation of JSON-like objects on
the wire, its specification is dominated by the requirements of the
database application and has become somewhat baroque. The status of
how BSON extensions will be implemented remains unclear.</t>
      </section>
      <section anchor="msdtp-rfc-713" toc="include" numbered="true" removeInRFC="false" pn="section-e.4">
        <name slugifiedName="name-msdtp-rfc-713">MSDTP: RFC 713</name>
        <t indent="0" pn="section-e.4-1">Message Services Data Transmission (MSDTP) is a very early example of
a compact message format; it is described in <xref target="RFC0713" format="default" sectionFormat="of" derivedContent="RFC0713"/>, written
in 1976. It is included here for its historical value, not because it
was ever widely used.</t>
      </section>
      <section anchor="conciseness-on-the-wire" toc="include" numbered="true" removeInRFC="false" pn="section-e.5">
        <name slugifiedName="name-conciseness-on-the-wire">Conciseness on the Wire</name>
        <t indent="0" pn="section-e.5-1">While CBOR's design objective of code compactness for encoders and
decoders is a higher priority than its objective of conciseness on the
wire, many people focus on the wire size. <xref target="concise" format="default" sectionFormat="of" derivedContent="Table 8"/> shows some
encoding examples for the simple nested array [1, [2, 3]]; where some
form of indefinite-length encoding is supported by the encoding,
[_ 1, [2, 3]] (indefinite length on the outer array) is also
shown.</t>
        <table anchor="concise" align="center" pn="table-8">
          <name slugifiedName="name-examples-for-different-leve">Examples for Different Levels of Conciseness</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Format</th>
              <th align="left" colspan="1" rowspan="1">[1, [2, 3]]</th>
              <th align="left" colspan="1" rowspan="1">[_ 1, [2, 3]]</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">RFC 713</td>
              <td align="left" colspan="1" rowspan="1">c2 05 81 c2 02 82 83</td>
              <td align="left" colspan="1" rowspan="1"> </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">ASN.1 BER</td>
              <td align="left" colspan="1" rowspan="1">30 0b 02 01 01 30 06 02 01 02 02 01 03</td>
              <td align="left" colspan="1" rowspan="1">30 80 02 01 01 30 06 02 01 02 02 01 03 00 00</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">MessagePack</td>
              <td align="left" colspan="1" rowspan="1">92 01 92 02 03</td>
              <td align="left" colspan="1" rowspan="1"> </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">BSON</td>
              <td align="left" colspan="1" rowspan="1">22 00 00 00 10 30 00 01 00 00 00 04 31 00 13 00 00 00 10 30 00 02 00 00 00 10 31 00 03 00 00 00 00 00</td>
              <td align="left" colspan="1" rowspan="1"> </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">CBOR</td>
              <td align="left" colspan="1" rowspan="1">82 01 82 02 03</td>
              <td align="left" colspan="1" rowspan="1">9f 01 82 02 03 ff</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="errors" toc="include" numbered="true" removeInRFC="false" pn="section-appendix.f">
      <name slugifiedName="name-well-formedness-errors-and-">Well-Formedness Errors and Examples</name>
      <t indent="0" pn="section-appendix.f-1">There are three basic kinds of well-formedness errors that can occur
in decoding a CBOR data item:</t>
      <dl spacing="normal" indent="3" newline="false" pn="section-appendix.f-2">
        <dt pn="section-appendix.f-2.1">Too much data:</dt>
        <dd pn="section-appendix.f-2.2">There are input bytes left that were not consumed.
This is only an error if the application assumed that the input
bytes would span exactly one data item.  Where the application
uses the self-delimiting nature of CBOR encoding to permit
additional data after the data item, as is done in CBOR
sequences <xref target="RFC8742" format="default" sectionFormat="of" derivedContent="RFC8742"/>, for example, the CBOR decoder can simply
indicate which part of the input has not been consumed.</dd>
        <dt pn="section-appendix.f-2.3">Too little data:</dt>
        <dd pn="section-appendix.f-2.4">The input data available would need additional
bytes added at their end for a complete CBOR data item.  This may
indicate the input is truncated; it is also a common error when
trying to decode random data as CBOR.  For some
applications, however, this may not actually be an error, as the
application may not be certain it has all the data yet and can
obtain or wait for additional input bytes.  Some of
these applications may have an upper limit for how much additional
data can appear; here the decoder may be able to indicate that the
encoded CBOR data item cannot be completed within this limit.</dd>
        <dt pn="section-appendix.f-2.5">Syntax error:</dt>
        <dd pn="section-appendix.f-2.6">The input data are not consistent with the
requirements of the CBOR encoding, and this cannot be remedied by
adding (or removing) data at the end.</dd>
      </dl>
      <t indent="0" pn="section-appendix.f-3">In <xref target="pseudocode" format="default" sectionFormat="of" derivedContent="Appendix C"/>, errors of the first kind are addressed in the first
paragraph and bullet list (requiring "no bytes are left"), and errors of
the second kind are addressed in the second paragraph/bullet list
(failing "if n bytes are no longer available").  Errors of the third
kind are identified in the pseudocode by specific instances of calling
fail(), in order:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.f-4">
        <li pn="section-appendix.f-4.1">a reserved value is used for additional information (28, 29, 30)</li>
        <li pn="section-appendix.f-4.2">major type 7, additional information 24, value &lt; 32 (incorrect)</li>
        <li pn="section-appendix.f-4.3">incorrect substructure of indefinite-length byte string or text string (may
only contain definite-length strings of the same major type)</li>
        <li pn="section-appendix.f-4.4">"break" stop code (major type 7, additional information 31) occurs in a value position of a map or
except at a position directly in an indefinite-length item where
also another enclosed data item could occur</li>
        <li pn="section-appendix.f-4.5">additional information 31 used with major type 0, 1, or 6</li>
      </ul>
      <section anchor="examples-for-cbor-data-items-that-are-not-well-formed" toc="include" numbered="true" removeInRFC="false" pn="section-f.1">
        <name slugifiedName="name-examples-of-cbor-data-items">Examples of CBOR Data Items That Are Not Well-Formed</name>
        <t indent="0" pn="section-f.1-1">This subsection shows a few examples for CBOR data items that are not
well-formed.  Each example is a sequence of bytes, each shown in
hexadecimal; multiple examples in a list are separated by commas.</t>
        <t indent="0" pn="section-f.1-2">Examples for well-formedness error kind 1 (too much data) can easily
be formed by adding data to a well-formed encoded CBOR data item.</t>
        <t indent="0" pn="section-f.1-3">Similarly, examples for well-formedness error kind 2 (too little data)
can be formed by truncating a well-formed encoded CBOR data item.  In
test suites, it may be beneficial to specifically test with incomplete
data items that would require large amounts of addition to be
completed (for instance by starting the encoding of a string of a very
large size).</t>
        <t indent="0" pn="section-f.1-4">A premature end of the input can occur in a head or within the enclosed
data, which may be bare strings or enclosed data items that are either
counted or should have been ended by a "break" stop code.</t>
        <dl spacing="normal" indent="3" newline="false" pn="section-f.1-5">
          <dt pn="section-f.1-5.1">End of input in a head:</dt>
          <dd pn="section-f.1-5.2">18, 19, 1a, 1b, 19 01, 1a 01 02, 1b 01 02 03
04 05 06 07, 38, 58, 78, 98, 9a 01 ff 00, b8, d8, f8, f9 00, fa 00
00, fb 00 00 00</dd>
          <dt pn="section-f.1-5.3">Definite-length strings with short data:</dt>
          <dd pn="section-f.1-5.4">41, 61, 5a ff ff ff ff 00,
5b ff ff ff ff ff ff ff ff 01 02 03, 7a ff ff ff ff 00, 7b 7f ff ff
ff ff ff ff ff 01 02 03</dd>
          <dt pn="section-f.1-5.5">Definite-length maps and arrays not closed with enough items:</dt>
          <dd pn="section-f.1-5.6">81, 81
81 81 81 81 81 81 81 81, 82 00, a1, a2 01 02, a1 00, a2 00 00 00</dd>
          <dt pn="section-f.1-5.7">Tag number not followed by tag content:</dt>
          <dd pn="section-f.1-5.8">c0</dd>
          <dt pn="section-f.1-5.9">Indefinite-length strings not closed by a "break" stop code:</dt>
          <dd pn="section-f.1-5.10">5f 41 00, 7f 61 00</dd>
          <dt pn="section-f.1-5.11">Indefinite-length maps and arrays not closed by a "break" stop code:</dt>
          <dd pn="section-f.1-5.12">
9f, 9f 01 02, bf, bf 01 02 01 02, 81 9f, 9f 80 00, 9f 9f 9f 9f 9f ff
ff ff ff, 9f 81 9f 81 9f 9f ff ff ff</dd>
        </dl>
        <t indent="0" pn="section-f.1-6">A few examples for the five subkinds of well-formedness error kind 3
(syntax error) are shown below.</t>
        <dl newline="true" spacing="normal" indent="3" pn="section-f.1-7">
          <dt pn="section-f.1-7.1">Subkind 1:</dt>
          <dd pn="section-f.1-7.2">
            <t indent="0" pn="section-f.1-7.2.1"/>
            <dl spacing="normal" indent="3" newline="false" pn="section-f.1-7.2.2">
              <dt pn="section-f.1-7.2.2.1">Reserved additional information values:</dt>
              <dd pn="section-f.1-7.2.2.2">1c, 1d, 1e, 3c, 3d, 3e, 5c,
5d, 5e, 7c, 7d, 7e, 9c, 9d, 9e, bc, bd, be, dc, dd, de, fc, fd, fe,</dd>
            </dl>
          </dd>
          <dt pn="section-f.1-7.3">Subkind 2:</dt>
          <dd pn="section-f.1-7.4">
            <t indent="0" pn="section-f.1-7.4.1"/>
            <dl spacing="normal" indent="3" newline="false" pn="section-f.1-7.4.2">
              <dt pn="section-f.1-7.4.2.1">Reserved two-byte encodings of simple values:</dt>
              <dd pn="section-f.1-7.4.2.2">f8 00, f8 01, f8 18, f8 1f</dd>
            </dl>
          </dd>
          <dt pn="section-f.1-7.5">Subkind 3:</dt>
          <dd pn="section-f.1-7.6">
            <t indent="0" pn="section-f.1-7.6.1"/>
            <dl spacing="normal" indent="3" newline="false" pn="section-f.1-7.6.2">
              <dt pn="section-f.1-7.6.2.1">Indefinite-length string chunks not of the correct type:</dt>
              <dd pn="section-f.1-7.6.2.2">5f 00 ff,
5f 21 ff, 5f 61 00 ff, 5f 80 ff, 5f a0 ff, 5f c0 00 ff, 5f e0 ff, 7f
41 00 ff</dd>
              <dt pn="section-f.1-7.6.2.3">Indefinite-length string chunks not definite length:</dt>
              <dd pn="section-f.1-7.6.2.4">
5f 5f 41 00 ff ff, 7f 7f 61 00 ff ff</dd>
            </dl>
          </dd>
          <dt pn="section-f.1-7.7">Subkind 4:</dt>
          <dd pn="section-f.1-7.8">
            <t indent="0" pn="section-f.1-7.8.1"/>
            <dl spacing="normal" indent="3" newline="false" pn="section-f.1-7.8.2">
              <dt pn="section-f.1-7.8.2.1">Break occurring on its own outside of an indefinite-length item:</dt>
              <dd pn="section-f.1-7.8.2.2"> ff</dd>
              <dt pn="section-f.1-7.8.2.3">Break occurring in a definite-length array or map or a tag:</dt>
              <dd pn="section-f.1-7.8.2.4">81 ff,
82 00 ff, a1 ff, a1 ff 00, a1 00 ff, a2 00 00 ff, 9f 81 ff, 9f 82 9f
81 9f 9f ff ff ff ff</dd>
              <dt pn="section-f.1-7.8.2.5">Break in an indefinite-length map that would lead to an odd number of items
(break in a value position):</dt>
              <dd pn="section-f.1-7.8.2.6">bf 00 ff, bf 00 00 00 ff</dd>
            </dl>
          </dd>
          <dt pn="section-f.1-7.9">Subkind 5:</dt>
          <dd pn="section-f.1-7.10">
            <t indent="0" pn="section-f.1-7.10.1"/>
            <dl spacing="normal" indent="3" newline="false" pn="section-f.1-7.10.2">
              <dt pn="section-f.1-7.10.2.1">Major type 0, 1, 6 with additional information 31:</dt>
              <dd pn="section-f.1-7.10.2.2">1f, 3f, df</dd>
            </dl>
          </dd>
        </dl>
      </section>
    </section>
    <section anchor="changes-from-rfc-7049" toc="include" numbered="true" removeInRFC="false" pn="section-appendix.g">
      <name slugifiedName="name-changes-from-rfc-7049">Changes from RFC 7049</name>
      <t indent="0" pn="section-appendix.g-1">As discussed in the introduction,
this document formally obsoletes RFC 7049 while keeping full compatibility
with the interchange format from RFC 7049. This document provides editorial
improvements, added detail, and fixed errata.
This document does not create a new version of the format.</t>
      <section anchor="errata-processing-clerical-changes" toc="include" numbered="true" removeInRFC="false" pn="section-g.1">
        <name slugifiedName="name-errata-processing-and-cleri">Errata Processing and Clerical Changes</name>
        <t indent="0" pn="section-g.1-1">The two verified errata on RFC 7049, 
<xref target="Err3764" format="default" sectionFormat="of" derivedContent="Err3764"/> 
and <xref target="Err3770" format="default" sectionFormat="of" derivedContent="Err3770"/>, concerned
two encoding examples in the text that have been corrected
(<xref target="bignums" format="default" sectionFormat="of" derivedContent="Section 3.4.3"/>: "29" -&gt; "49", 
<xref target="numbers" format="default" sectionFormat="of" derivedContent="Section 5.5"/>: "0b000_11101" -&gt;
"0b000_11001").  Also, RFC 7049 contained an example using the numeric
value 24 for a simple value <xref target="Err5917" format="default" sectionFormat="of" derivedContent="Err5917"/>, 
which is not well-formed; this example has
been removed.  Errata report 5763 <xref target="Err5763" format="default" sectionFormat="of" derivedContent="Err5763"/> 
pointed to an error in the
wording of the definition of tags; this was resolved during a rewrite
of <xref target="tags" format="default" sectionFormat="of" derivedContent="Section 3.4"/>.  Errata report 5434 
<xref target="Err5434" format="default" sectionFormat="of" derivedContent="Err5434"/> pointed out that the Universal Binary JSON
(UBJSON) example
in <xref target="comparison-app" format="default" sectionFormat="of" derivedContent="Appendix E"/> no longer complied with the version of UBJSON
current at the time of the errata report submission.  It turned out that the
UBJSON specification had completely changed since 2013; this example
therefore was removed.  Other errata reports 
<xref target="Err4409" format="default" sectionFormat="of" derivedContent="Err4409"/>
          <xref target="Err4963" format="default" sectionFormat="of" derivedContent="Err4963"/>
          <xref target="Err4964" format="default" sectionFormat="of" derivedContent="Err4964"/> 
complained that the map key sorting rules for canonical encoding were
onerous; these led to a reconsideration of the canonical encoding
suggestions and replacement by the deterministic encoding suggestions
(described below).  An editorial suggestion in errata report 4294 
<xref target="Err4294" format="default" sectionFormat="of" derivedContent="Err4294"/> was also
implemented (improved symmetry by adding "Second value" to a comment
to the last example in <xref target="indef" format="default" sectionFormat="of" derivedContent="Section 3.2.2"/>).</t>
        <t indent="0" pn="section-g.1-2">Other clerical changes include:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-g.1-3">
          <li pn="section-g.1-3.1">the use of new xml2rfc functionality <xref target="RFC7991" format="default" sectionFormat="of" derivedContent="RFC7991"/>;</li>
          <li pn="section-g.1-3.2">more explanation of the notation used;</li>
          <li pn="section-g.1-3.3">the update of references, e.g., from RFC 4627 to 
<xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/>,
from CNN-TERMS to <xref target="RFC7228" format="default" sectionFormat="of" derivedContent="RFC7228"/>, and
from the 5.1 edition to the 11th edition of <xref target="ECMA262" format="default" sectionFormat="of" derivedContent="ECMA262"/>; 
the addition of a reference to <xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/> and importation of required definitions; 
the addition of references to <xref target="C" format="default" sectionFormat="of" derivedContent="C"/> and <xref target="Cplusplus20" format="default" sectionFormat="of" derivedContent="Cplusplus20"/>;
and the addition of a reference to <xref target="RFC8618" format="default" sectionFormat="of" derivedContent="RFC8618"/> that further illustrates the discussion in
<xref target="comparison-app" format="default" sectionFormat="of" derivedContent="Appendix E"/>;</li>
          <li pn="section-g.1-3.4">in the discussion of diagnostic notation (<xref target="diagnostic-notation" format="default" sectionFormat="of" derivedContent="Section 8"/>), 
the "Extended Diagnostic Notation" (EDN) defined in <xref target="RFC8610" format="default" sectionFormat="of" derivedContent="RFC8610"/> is now mentioned, 
the gap in representing NaN payloads is now highlighted,  
and an explanation of representing indefinite-length strings with 
no chunks has been added (<xref target="encoding-indicators" format="default" sectionFormat="of" derivedContent="Section 8.1"/>);
          </li>
          <li pn="section-g.1-3.5">the addition of this appendix.</li>
        </ul>
      </section>
      <section anchor="changes-in-iana-considerations" toc="include" numbered="true" removeInRFC="false" pn="section-g.2">
        <name slugifiedName="name-changes-in-iana-considerati">Changes in IANA Considerations</name>
        <t indent="0" pn="section-g.2-1">The IANA considerations were generally updated (clerical changes,
e.g., now pointing to the CBOR Working Group as the author of the
specification).  References to the respective IANA registries were
added to the informative references.</t>
        <t indent="0" pn="section-g.2-2">In the "Concise Binary Object Representation (CBOR) Tags" registry
	<xref target="IANA.cbor-tags" format="default" sectionFormat="of" derivedContent="IANA.cbor-tags"/>,
	tags in the space from 256 to 32767 (lower half of
"1+2") are no longer assigned by First Come First Served; this range
is now Specification Required.</t>
      </section>
      <section anchor="changes-in-suggestions-and-other-informational-components" toc="include" numbered="true" removeInRFC="false" pn="section-g.3">
        <name slugifiedName="name-changes-in-suggestions-and-">Changes in Suggestions and Other Informational Components</name>
        <t indent="0" pn="section-g.3-1">While revising the document, beyond the addressing of the errata reports, 
   the working group drew upon nearly seven years of experience with CBOR 
   in a diverse set of applications. This led to a number of editorial
   changes, including adding tables for illustration, but also
   emphasizing some aspects and de-emphasizing others.</t>
        <t indent="0" pn="section-g.3-2">A significant addition is <xref target="cbor-data-models" format="default" sectionFormat="of" derivedContent="Section 2"/>, which
discusses the CBOR data model and its small variations involved in the
processing of CBOR.  The introduction of terms for those variations (basic generic,
extended generic, specific) enables more concise language in other
places of the document and also helps to clarify expectations of
implementations and of the extensibility features of the format.</t>
        <t indent="0" pn="section-g.3-3">As a format derived from the JSON ecosystem, RFC 7049 was influenced
by the JSON number system that was in turn inherited from JavaScript
at the time.  JSON does not provide distinct integers and floating-point
values (and the latter are decimal in the format).  CBOR
provides binary representations of numbers, which do differ between
integers and floating-point values.  Experience from implementation and use
suggested that the separation between these two number
domains should be more clearly drawn in the document; language that
suggested an integer could seamlessly stand in for a floating-point
value was removed.  Also, a suggestion (based on I-JSON <xref target="RFC7493" format="default" sectionFormat="of" derivedContent="RFC7493"/>)
was added for handling these types when converting JSON to CBOR, and
the use of a specific rounding mechanism has been recommended.</t>
        <t indent="0" pn="section-g.3-4">For a single value in the data model, CBOR often provides multiple
encoding options.  A new section (<xref target="serialization-considerations" format="default" sectionFormat="of" derivedContent="Section 4"/>) introduces the term
"preferred serialization" (<xref target="preferred" format="default" sectionFormat="of" derivedContent="Section 4.1"/>) and defines it for various
kinds of data items.  On the basis of this terminology, the section
then discusses how a CBOR-based protocol can define "deterministic
encoding" (<xref target="det-enc" format="default" sectionFormat="of" derivedContent="Section 4.2"/>), which avoids terms
"canonical" and "canonicalization" from RFC 7049.  The suggestion of "Core
Deterministic Encoding Requirements" (<xref target="core-det" format="default" sectionFormat="of" derivedContent="Section 4.2.1"/>) enables generic
support for such protocol-defined encoding requirements.  This document
further eases the implementation of deterministic encoding by
simplifying the map ordering suggested in RFC 7049 to a simple
lexicographic ordering of encoded keys.  A description of the older
suggestion is kept as an alternative, now termed "length-first map key
ordering" (<xref target="length-first" format="default" sectionFormat="of" derivedContent="Section 4.2.3"/>).</t>
        <t indent="0" pn="section-g.3-5">The terminology for well-formed and valid data was sharpened and more
stringently used, avoiding less well-defined alternative terms such as
"syntax error", "decoding error", and "strict mode" outside of examples.
Also, a third level of requirements that an
application has on its input data beyond CBOR-level validity is now explicitly called out.
Well-formed (processable at all), valid (checked by a
validity-checking generic decoder), and expected input (as checked by
the application) are treated as a hierarchy of layers of
acceptability.</t>
        <t indent="0" pn="section-g.3-6">The handling of non-well-formed simple values was clarified in text
and pseudocode.  <xref target="errors" format="default" sectionFormat="of" derivedContent="Appendix F"/> was added to discuss well-formedness
errors and provide examples for them.  The pseudocode was updated to
be more portable, and some portability considerations were added.</t>
        <t indent="0" pn="section-g.3-7">The discussion of validity has been sharpened in two areas.  Map
validity (handling of duplicate keys) was clarified, and the domain of
applicability of certain implementation choices explained.  Also,
while streamlining the terminology for tags, tag numbers, and tag
content, discussion was added on tag validity, and the restrictions
were clarified on tag content, in general and specifically for tag 1.</t>
        <t indent="0" pn="section-g.3-8">An implementation note (and note for future tag definitions) was added
to <xref target="tags" format="default" sectionFormat="of" derivedContent="Section 3.4"/> about defining tags with semantics that depend on
serialization order.</t>
        <t indent="0" pn="section-g.3-9">Tag 35 is not defined by this document; the registration
based on the definition in RFC 7049 remains in place.</t>
        <t indent="0" pn="section-g.3-10">Terminology was introduced in <xref target="encoding" format="default" sectionFormat="of" derivedContent="Section 3"/> for "argument" and "head",
simplifying further discussion.</t>
        <t indent="0" pn="section-g.3-11">The security considerations (<xref target="securitycons" format="default" sectionFormat="of" derivedContent="Section 10"/>) 
were mostly rewritten and significantly
expanded; in multiple other places, the document is now more explicit
that a decoder cannot simply condone well-formedness errors.</t>
      </section>
    </section>
    <section numbered="false" anchor="acknowledgements" toc="include" removeInRFC="false" pn="section-appendix.h">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t indent="0" pn="section-appendix.h-1">CBOR was inspired by MessagePack.  MessagePack was developed and
promoted by <contact fullname="Sadayuki Furuhashi"/> ("frsyuki").  This reference to
MessagePack is solely for attribution; CBOR is not intended as a
version of, or replacement for, MessagePack, as it has different design
goals and requirements.</t>
      <t indent="0" pn="section-appendix.h-2">The need for functionality beyond the original MessagePack
specification became obvious to many people at about the same time
around the year 2012.  BinaryPack is a minor derivation of MessagePack
that was developed by <contact fullname="Eric Zhang"/> for the binaryjs project.  A similar,
but different, extension was made by <contact fullname="Tim Caswell"/> for his msgpack-js
and msgpack-js-browser projects.  Many people have contributed to the
discussion about extending MessagePack to separate text string
representation from byte string representation.</t>
      <t indent="0" pn="section-appendix.h-3">The encoding of the additional information in CBOR was inspired by the
encoding of length information designed by <contact fullname="Klaus Hartke"/> for CoAP.</t>
      <t indent="0" pn="section-appendix.h-4">This document also incorporates suggestions made by many people,
notably <contact fullname="Dan Frost"/>, <contact fullname="James Manger"/>, 
<contact fullname="Jeffrey Yasskin"/>, <contact fullname="Joe Hildebrand"/>, 
<contact fullname="Keith Moore"/>, <contact fullname="Laurence Lundblade"/>, 
<contact fullname="Matthew Lepinski"/>, <contact fullname="Michael Richardson"/>,
<contact fullname="Nico Williams"/>, <contact fullname="Peter Occil"/>, 
<contact fullname="Phillip Hallam-Baker"/>, <contact fullname="Ray Polk"/>, 
<contact fullname="Stuart Cheshire"/>, <contact fullname="Tim Bray"/>,
<contact fullname="Tony Finch"/>, <contact fullname="Tony Hansen"/>, and 
<contact fullname="Yaron Sheffer"/>.  <contact fullname="Benjamin Kaduk"/> 
provided an extensive review during IESG processing.
<contact fullname="Éric Vyncke"/>, <contact fullname="Erik Kline"/>, 
<contact fullname="Robert Wilton"/>, and <contact fullname="Roman Danyliw"/> 
provided further IESG comments, which included an IoT directorate review by 
<contact fullname="Eve Schooler"/>.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.i">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="C." surname="Bormann" fullname="Carsten Bormann">
        <organization showOnFrontPage="true">Universität Bremen TZI</organization>
        <address>
          <postal>
            <street>Postfach 330440</street>
            <city>Bremen</city>
            <code>D-28359</code>
            <country>Germany</country>
          </postal>
          <phone>+49-421-218-63921</phone>
          <email>cabo@tzi.org</email>
        </address>
      </author>
      <author initials="P." surname="Hoffman" fullname="Paul Hoffman">
        <organization showOnFrontPage="true">ICANN</organization>
        <address>
          <email>paul.hoffman@icann.org</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
