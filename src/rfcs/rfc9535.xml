<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" ipr="trust200902" docName="draft-ietf-jsonpath-base-21" number="9535" submissionType="IETF" category="std" consensus="true" xml:lang="en" tocDepth="4" tocInclude="true" sortRefs="true" symRefs="true" updates="" obsoletes="" prepTime="2024-02-21T20:42:26" indexInclude="true" scripts="Common,Latin">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-jsonpath-base-21" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9535" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="JSONPath">JSONPath: Query Expressions for JSON</title>
    <seriesInfo name="RFC" value="9535" stream="IETF"/>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner" role="editor">
      <organization showOnFrontPage="true">Fachhochschule Dortmund</organization>
      <address>
        <postal>
          <street>Sonnenstraße 96</street>
          <city>Dortmund</city>
          <code>D-44139</code>
          <country>Germany</country>
        </postal>
        <email>stefan.goessner@fh-dortmund.de</email>
      </address>
    </author>
    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization showOnFrontPage="true"/>
      <address>
        <postal>
          <street/>
          <city>Winchester</city>
          <region/>
          <code/>
          <country>United Kingdom</country>
        </postal>
        <phone/>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann" role="editor">
      <organization showOnFrontPage="true">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>
    <date month="02" year="2024"/>
    <area>art</area>
    <workgroup>jsonpath</workgroup>
    <keyword>JSON</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">JSONPath defines a string syntax for selecting and extracting JSON (RFC 8259) values from within a given JSON value.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9535" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2.1.2">
                  <li pn="section-toc.1-1.1.2.1.2.1">
                    <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.2.1.1"><xref derivedContent="1.1.1" format="counter" sectionFormat="of" target="section-1.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-json-values-as-trees-of-nod">JSON Values as Trees of Nodes</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-history">History</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.3">
                <t indent="0" pn="section-toc.1-1.1.2.3.1"><xref derivedContent="1.3" format="counter" sectionFormat="of" target="section-1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-json-values">JSON Values</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.4">
                <t indent="0" pn="section-toc.1-1.1.2.4.1"><xref derivedContent="1.4" format="counter" sectionFormat="of" target="section-1.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-overview-of-jsonpath-expres">Overview of JSONPath Expressions</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2.4.2">
                  <li pn="section-toc.1-1.1.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.1.2.4.2.1.1"><xref derivedContent="1.4.1" format="counter" sectionFormat="of" target="section-1.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-identifiers">Identifiers</xref></t>
                  </li>
                  <li pn="section-toc.1-1.1.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.1.2.4.2.2.1"><xref derivedContent="1.4.2" format="counter" sectionFormat="of" target="section-1.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-segments">Segments</xref></t>
                  </li>
                  <li pn="section-toc.1-1.1.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.1.2.4.2.3.1"><xref derivedContent="1.4.3" format="counter" sectionFormat="of" target="section-1.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-selectors">Selectors</xref></t>
                  </li>
                  <li pn="section-toc.1-1.1.2.4.2.4">
                    <t indent="0" pn="section-toc.1-1.1.2.4.2.4.1"><xref derivedContent="1.4.4" format="counter" sectionFormat="of" target="section-1.4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-summary">Summary</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.1.2.5">
                <t indent="0" pn="section-toc.1-1.1.2.5.1"><xref derivedContent="1.5" format="counter" sectionFormat="of" target="section-1.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-jsonpath-examples">JSONPath Examples</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-jsonpath-syntax-and-semanti">JSONPath Syntax and Semantics</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-overview">Overview</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.1.2">
                  <li pn="section-toc.1-1.2.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.1.2.1.1"><xref derivedContent="2.1.1" format="counter" sectionFormat="of" target="section-2.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax">Syntax</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.1.2.2.1"><xref derivedContent="2.1.2" format="counter" sectionFormat="of" target="section-2.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics">Semantics</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.1.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.1.2.3.1"><xref derivedContent="2.1.3" format="counter" sectionFormat="of" target="section-2.1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-example">Example</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-root-identifier">Root Identifier</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.2.2">
                  <li pn="section-toc.1-1.2.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.2.2.1.1"><xref derivedContent="2.2.1" format="counter" sectionFormat="of" target="section-2.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax-2">Syntax</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.2.2.2.1"><xref derivedContent="2.2.2" format="counter" sectionFormat="of" target="section-2.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics-2">Semantics</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.2.2.3.1"><xref derivedContent="2.2.3" format="counter" sectionFormat="of" target="section-2.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples">Examples</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.3">
                <t indent="0" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.3" format="counter" sectionFormat="of" target="section-2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-selectors-2">Selectors</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.3.2">
                  <li pn="section-toc.1-1.2.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.3.2.1.1"><xref derivedContent="2.3.1" format="counter" sectionFormat="of" target="section-2.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-name-selector">Name Selector</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.3.2.1.2">
                      <li pn="section-toc.1-1.2.2.3.2.1.2.1">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.1.2.1.1"><xref derivedContent="2.3.1.1" format="counter" sectionFormat="of" target="section-2.3.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax-3">Syntax</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.1.2.2">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.1.2.2.1"><xref derivedContent="2.3.1.2" format="counter" sectionFormat="of" target="section-2.3.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics-3">Semantics</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.1.2.3">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.1.2.3.1"><xref derivedContent="2.3.1.3" format="counter" sectionFormat="of" target="section-2.3.1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-2">Examples</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.2.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.3.2.2.1"><xref derivedContent="2.3.2" format="counter" sectionFormat="of" target="section-2.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-wildcard-selector">Wildcard Selector</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.3.2.2.2">
                      <li pn="section-toc.1-1.2.2.3.2.2.2.1">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.2.2.1.1"><xref derivedContent="2.3.2.1" format="counter" sectionFormat="of" target="section-2.3.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax-4">Syntax</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.2.2.2">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.2.2.2.1"><xref derivedContent="2.3.2.2" format="counter" sectionFormat="of" target="section-2.3.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics-4">Semantics</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.2.2.3">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.2.2.3.1"><xref derivedContent="2.3.2.3" format="counter" sectionFormat="of" target="section-2.3.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-3">Examples</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.2.2.3.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.3.2.3.1"><xref derivedContent="2.3.3" format="counter" sectionFormat="of" target="section-2.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-index-selector">Index Selector</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.3.2.3.2">
                      <li pn="section-toc.1-1.2.2.3.2.3.2.1">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.3.2.1.1"><xref derivedContent="2.3.3.1" format="counter" sectionFormat="of" target="section-2.3.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax-5">Syntax</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.3.2.2">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.3.2.2.1"><xref derivedContent="2.3.3.2" format="counter" sectionFormat="of" target="section-2.3.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics-5">Semantics</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.3.2.3">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.3.2.3.1"><xref derivedContent="2.3.3.3" format="counter" sectionFormat="of" target="section-2.3.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-4">Examples</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.2.2.3.2.4">
                    <t indent="0" pn="section-toc.1-1.2.2.3.2.4.1"><xref derivedContent="2.3.4" format="counter" sectionFormat="of" target="section-2.3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-array-slice-selector">Array Slice Selector</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.3.2.4.2">
                      <li pn="section-toc.1-1.2.2.3.2.4.2.1">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.4.2.1.1"><xref derivedContent="2.3.4.1" format="counter" sectionFormat="of" target="section-2.3.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax-6">Syntax</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.4.2.2">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.4.2.2.1"><xref derivedContent="2.3.4.2" format="counter" sectionFormat="of" target="section-2.3.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics-6">Semantics</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.4.2.3">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.4.2.3.1"><xref derivedContent="2.3.4.3" format="counter" sectionFormat="of" target="section-2.3.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-5">Examples</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.2.2.3.2.5">
                    <t indent="0" pn="section-toc.1-1.2.2.3.2.5.1"><xref derivedContent="2.3.5" format="counter" sectionFormat="of" target="section-2.3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-filter-selector">Filter Selector</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.3.2.5.2">
                      <li pn="section-toc.1-1.2.2.3.2.5.2.1">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.5.2.1.1"><xref derivedContent="2.3.5.1" format="counter" sectionFormat="of" target="section-2.3.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax-7">Syntax</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.5.2.2">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.5.2.2.1"><xref derivedContent="2.3.5.2" format="counter" sectionFormat="of" target="section-2.3.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics-7">Semantics</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.3.2.5.2.3">
                        <t indent="0" pn="section-toc.1-1.2.2.3.2.5.2.3.1"><xref derivedContent="2.3.5.3" format="counter" sectionFormat="of" target="section-2.3.5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-6">Examples</xref></t>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.4">
                <t indent="0" pn="section-toc.1-1.2.2.4.1"><xref derivedContent="2.4" format="counter" sectionFormat="of" target="section-2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-function-extensions">Function Extensions</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.4.2">
                  <li pn="section-toc.1-1.2.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.1.1"><xref derivedContent="2.4.1" format="counter" sectionFormat="of" target="section-2.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-type-system-for-function-ex">Type System for Function Expressions</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.2.1"><xref derivedContent="2.4.2" format="counter" sectionFormat="of" target="section-2.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-type-conversion">Type Conversion</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.3.1"><xref derivedContent="2.4.3" format="counter" sectionFormat="of" target="section-2.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-well-typedness-of-function-">Well-Typedness of Function Expressions</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.4">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.4.1"><xref derivedContent="2.4.4" format="counter" sectionFormat="of" target="section-2.4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-length-function-extension"><tt>length()</tt> Function Extension</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.5">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.5.1"><xref derivedContent="2.4.5" format="counter" sectionFormat="of" target="section-2.4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-count-function-extension"><tt>count()</tt> Function Extension</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.6">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.6.1"><xref derivedContent="2.4.6" format="counter" sectionFormat="of" target="section-2.4.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-match-function-extension"><tt>match()</tt> Function Extension</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.7">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.7.1"><xref derivedContent="2.4.7" format="counter" sectionFormat="of" target="section-2.4.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-search-function-extension"><tt>search()</tt> Function Extension</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.8">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.8.1"><xref derivedContent="2.4.8" format="counter" sectionFormat="of" target="section-2.4.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-value-function-extension"><tt>value()</tt> Function Extension</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.9">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.9.1"><xref derivedContent="2.4.9" format="counter" sectionFormat="of" target="section-2.4.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-7">Examples</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.5">
                <t indent="0" pn="section-toc.1-1.2.2.5.1"><xref derivedContent="2.5" format="counter" sectionFormat="of" target="section-2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-segments-2">Segments</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.5.2">
                  <li pn="section-toc.1-1.2.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.1.1"><xref derivedContent="2.5.1" format="counter" sectionFormat="of" target="section-2.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-child-segment">Child Segment</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.5.2.1.2">
                      <li pn="section-toc.1-1.2.2.5.2.1.2.1">
                        <t indent="0" pn="section-toc.1-1.2.2.5.2.1.2.1.1"><xref derivedContent="2.5.1.1" format="counter" sectionFormat="of" target="section-2.5.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax-8">Syntax</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.5.2.1.2.2">
                        <t indent="0" pn="section-toc.1-1.2.2.5.2.1.2.2.1"><xref derivedContent="2.5.1.2" format="counter" sectionFormat="of" target="section-2.5.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics-8">Semantics</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.5.2.1.2.3">
                        <t indent="0" pn="section-toc.1-1.2.2.5.2.1.2.3.1"><xref derivedContent="2.5.1.3" format="counter" sectionFormat="of" target="section-2.5.1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-8">Examples</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.2.2.5.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.2.1"><xref derivedContent="2.5.2" format="counter" sectionFormat="of" target="section-2.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-descendant-segment">Descendant Segment</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.5.2.2.2">
                      <li pn="section-toc.1-1.2.2.5.2.2.2.1">
                        <t indent="0" pn="section-toc.1-1.2.2.5.2.2.2.1.1"><xref derivedContent="2.5.2.1" format="counter" sectionFormat="of" target="section-2.5.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax-9">Syntax</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.5.2.2.2.2">
                        <t indent="0" pn="section-toc.1-1.2.2.5.2.2.2.2.1"><xref derivedContent="2.5.2.2" format="counter" sectionFormat="of" target="section-2.5.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics-9">Semantics</xref></t>
                      </li>
                      <li pn="section-toc.1-1.2.2.5.2.2.2.3">
                        <t indent="0" pn="section-toc.1-1.2.2.5.2.2.2.3.1"><xref derivedContent="2.5.2.3" format="counter" sectionFormat="of" target="section-2.5.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-9">Examples</xref></t>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.6">
                <t indent="0" pn="section-toc.1-1.2.2.6.1"><xref derivedContent="2.6" format="counter" sectionFormat="of" target="section-2.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-semantics-of-null">Semantics of <tt>null</tt></xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.6.2">
                  <li pn="section-toc.1-1.2.2.6.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.6.2.1.1"><xref derivedContent="2.6.1" format="counter" sectionFormat="of" target="section-2.6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-10">Examples</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.7">
                <t indent="0" pn="section-toc.1-1.2.2.7.1"><xref derivedContent="2.7" format="counter" sectionFormat="of" target="section-2.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normalized-paths">Normalized Paths</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.7.2">
                  <li pn="section-toc.1-1.2.2.7.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.7.2.1.1"><xref derivedContent="2.7.1" format="counter" sectionFormat="of" target="section-2.7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-11">Examples</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-registration-of-media-type-">Registration of Media Type application/jsonpath</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-function-extensions-subregi">Function Extensions Subregistry</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-attack-vectors-on-jsonpath-">Attack Vectors on JSONPath Implementations</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-attack-vectors-on-how-jsonp">Attack Vectors on How JSONPath Queries Are Formed</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-attacks-on-security-mechani">Attacks on Security Mechanisms That Employ JSONPath</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-collected-abnf-grammars">Collected ABNF Grammars</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-inspired-by-xpath">Inspired by XPath</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="B.1" format="counter" sectionFormat="of" target="section-appendix.b.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-jsonpath-and-xpath">JSONPath and XPath</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="Appendix C" format="default" sectionFormat="of" target="section-appendix.c"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-json-pointer">JSON Pointer</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.d"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.e"/><xref derivedContent="" format="title" sectionFormat="of" target="name-contributors">Contributors</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.f"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">JSON <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/> is a popular representation
format for structured data values.
JSONPath defines a string syntax for selecting and extracting JSON values
from within a given JSON value.</t>
      <t indent="0" pn="section-1-2">In relation to JSON Pointer <xref target="RFC6901" format="default" sectionFormat="of" derivedContent="RFC6901"/>, JSONPath is not intended as a replacement but as a more powerful
companion. See <xref target="json-pointer" format="default" sectionFormat="of" derivedContent="Appendix C"/>.</t>
      <section anchor="terminology" numbered="true" removeInRFC="false" toc="include" pn="section-1.1">
        <name slugifiedName="name-terminology">Terminology</name>
        <t indent="0" pn="section-1.1-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
        <t indent="0" pn="section-1.1-2">The grammatical rules in this document are to be interpreted as ABNF,
as described in <xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>.
ABNF terminal values in this document define Unicode scalar values rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <tt>%x2318</tt>.</t>
        <t indent="0" pn="section-1.1-3">Functions are referred to using the function name followed by a pair
of parentheses, as in <tt>fname()</tt>.</t>
        <t indent="0" pn="section-1.1-4">The terminology of <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/> applies except where clarified below.
The terms "primitive" and "structured" are used to group
different kinds of values as in <xref section="1" sectionFormat="of" target="RFC8259" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8259#section-1" derivedContent="RFC8259"/>. JSON objects and arrays are
structured; all other values are primitive.
Definitions for "object", "array", "number", and "string" remain
unchanged.
Importantly, "object" and "array" in particular do not take on a
generic meaning, such as they would in a general programming context.</t>
        <t indent="0" pn="section-1.1-5">The terminology of <xref target="RFC9485" format="default" sectionFormat="of" derivedContent="RFC9485"/> applies.</t>
        <t indent="0" pn="section-1.1-6">Additional terms used in this document are defined below.</t>
        <dl indent="3" newline="false" spacing="normal" pn="section-1.1-7">
          <dt pn="section-1.1-7.1">Value:</dt>
          <dd pn="section-1.1-7.2">
            <t indent="0" pn="section-1.1-7.2.1">As per <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/>, a data item conforming to the generic data model of JSON, i.e.,
primitive data (numbers, text strings, and the special
values null, true, and false), or structured data (JSON objects and arrays).
<xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/> focuses on the textual representation of JSON values and
does not fully define the value abstraction assumed here.</t>
          </dd>
          <dt pn="section-1.1-7.3">Member:</dt>
          <dd pn="section-1.1-7.4">
            <t indent="0" pn="section-1.1-7.4.1">A name/value pair in an object.  (A member is not itself a value.)</t>
          </dd>
          <dt pn="section-1.1-7.5">Name:</dt>
          <dd pn="section-1.1-7.6">
            <t indent="0" pn="section-1.1-7.6.1">The name (a string) in a name/value pair constituting a member.
This is also used in <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/>, but that specification does not
formally define it.
It is included here for completeness.</t>
          </dd>
          <dt pn="section-1.1-7.7">Element:</dt>
          <dd pn="section-1.1-7.8">
            <t indent="0" pn="section-1.1-7.8.1">A value in a JSON array.</t>
          </dd>
          <dt pn="section-1.1-7.9">Index:</dt>
          <dd pn="section-1.1-7.10">
            <t indent="0" pn="section-1.1-7.10.1">An integer that identifies a specific element in an array.</t>
          </dd>
          <dt pn="section-1.1-7.11">Query:</dt>
          <dd pn="section-1.1-7.12">
            <t indent="0" pn="section-1.1-7.12.1">Short name for a JSONPath expression.</t>
          </dd>
          <dt pn="section-1.1-7.13">Query Argument:</dt>
          <dd pn="section-1.1-7.14">
            <t indent="0" pn="section-1.1-7.14.1">Short name for the value a JSONPath expression is applied to.
</t>
          </dd>
          <dt pn="section-1.1-7.15">Location:</dt>
          <dd pn="section-1.1-7.16">
            <t indent="0" pn="section-1.1-7.16.1">The position of a value within the query argument. This can be thought of
as a sequence of names and indexes navigating to the value through
the objects and arrays in the query argument, with the empty sequence
indicating the query argument itself.
A location can be represented as a Normalized Path (defined below).</t>
          </dd>
          <dt pn="section-1.1-7.17">Node:</dt>
          <dd pn="section-1.1-7.18">
            <t indent="0" pn="section-1.1-7.18.1">The pair of a value along with its location within the query argument.</t>
          </dd>
          <dt pn="section-1.1-7.19">Root Node:</dt>
          <dd pn="section-1.1-7.20">
            <t indent="0" pn="section-1.1-7.20.1">The unique node whose value is the entire query argument.</t>
          </dd>
          <dt pn="section-1.1-7.21">Root Node Identifier:</dt>
          <dd pn="section-1.1-7.22">
            <t indent="0" pn="section-1.1-7.22.1">The expression <tt>$</tt>, which refers to the root node of the query argument.</t>
          </dd>
          <dt pn="section-1.1-7.23">Current Node Identifier:</dt>
          <dd pn="section-1.1-7.24">
            <t indent="0" pn="section-1.1-7.24.1">The expression <tt>@</tt>, which refers to the current node in the context
of the evaluation of a filter expression (described later).</t>
          </dd>
          <dt pn="section-1.1-7.25">Children (of a node):</dt>
          <dd pn="section-1.1-7.26">
            <t indent="0" pn="section-1.1-7.26.1">If the node is an array, the nodes of its elements; if the node is an object, the nodes of its member values.
If the node is neither an array nor an object, it has no children.</t>
          </dd>
          <dt pn="section-1.1-7.27">Descendants (of a node):</dt>
          <dd pn="section-1.1-7.28">
            <t indent="0" pn="section-1.1-7.28.1">The children of the node, together with the children of its children, and so forth
recursively. More formally, the "descendants" relation between nodes is the transitive
closure of the "children" relation.</t>
          </dd>
          <dt pn="section-1.1-7.29">Depth (of a descendant node within a value):</dt>
          <dd pn="section-1.1-7.30">
            <t indent="0" pn="section-1.1-7.30.1">The number of ancestors of the node within the value. The root node of the value has depth zero,
the children of the root node have depth one, their children have depth two, and so forth.</t>
          </dd>
          <dt pn="section-1.1-7.31">Nodelist:</dt>
          <dd pn="section-1.1-7.32">
            <t indent="0" pn="section-1.1-7.32.1">A list of nodes.
While a nodelist can be represented in JSON, e.g., as an array, this document
does not require or assume any particular representation.</t>
          </dd>
          <dt pn="section-1.1-7.33">Parameter:</dt>
          <dd pn="section-1.1-7.34">
            <t indent="0" pn="section-1.1-7.34.1">Formal parameter (of a function) that can take a function argument
(an actual parameter) in a function expression.</t>
          </dd>
          <dt pn="section-1.1-7.35">Normalized Path:</dt>
          <dd pn="section-1.1-7.36">
            <t indent="0" pn="section-1.1-7.36.1">A form of JSONPath expression that identifies a node in a value by
providing a query that results in exactly that node.  Each node in a
query argument is identified by exactly one Normalized Path (we say that the
Normalized Path is "unique" for that node), and to be a Normalized
Path for a specific query argument, the Normalized Path needs to identify
exactly one node. This is similar
to, but syntactically different from, a JSON Pointer <xref target="RFC6901" format="default" sectionFormat="of" derivedContent="RFC6901"/>.
Note: This definition is based on the syntactical definition in <xref target="normalized-paths" format="default" sectionFormat="of" derivedContent="Section 2.7"/>;
JSONPath expressions that identify a node in a value but do not conform to that
syntax are not Normalized Paths.</t>
          </dd>
          <dt pn="section-1.1-7.37">Unicode Scalar Value:</dt>
          <dd pn="section-1.1-7.38">
            <t indent="0" pn="section-1.1-7.38.1">Any Unicode <xref target="UNICODE" format="default" sectionFormat="of" derivedContent="UNICODE"/> code point except high-surrogate and low-surrogate code points (in other words, integers in the inclusive base 16 ranges, either 0 to D7FF or
E000 to 10FFFF). JSONPath queries are sequences of Unicode scalar values.</t>
          </dd>
          <dt pn="section-1.1-7.39">Segment:</dt>
          <dd pn="section-1.1-7.40">
            <t indent="0" pn="section-1.1-7.40.1">One of the constructs that selects children (<tt>[&lt;selectors&gt;]</tt>)
or descendants (<tt>..⁠[&lt;selectors&gt;]</tt>) of an input value.</t>
          </dd>
          <dt pn="section-1.1-7.41">Selector:</dt>
          <dd pn="section-1.1-7.42">
            <t indent="0" pn="section-1.1-7.42.1">A single item within a segment that takes the input value and produces a nodelist
consisting of child nodes of the input value.</t>
          </dd>
          <dt pn="section-1.1-7.43">Singular Query:</dt>
          <dd pn="section-1.1-7.44">
            <t indent="0" pn="section-1.1-7.44.1">A JSONPath expression built from segments that have been syntactically restricted in
a certain way (<xref target="filter-selector-syntax" format="default" sectionFormat="of" derivedContent="Section 2.3.5.1"/>) so that, regardless of the input
value, the expression produces a nodelist containing at most one node.
Note: JSONPath expressions that always produce a singular nodelist but do not
conform to the syntax in <xref target="filter-selector-syntax" format="default" sectionFormat="of" derivedContent="Section 2.3.5.1"/> are not singular queries.</t>
          </dd>
        </dl>
        <section anchor="json-values-as-trees-of-nodes" numbered="true" removeInRFC="false" toc="include" pn="section-1.1.1">
          <name slugifiedName="name-json-values-as-trees-of-nod">JSON Values as Trees of Nodes</name>
          <t indent="0" pn="section-1.1.1-1">This document models the query argument as a tree of JSON values, each
with its own node.
A node is either the root node or one of its descendants.</t>
          <t indent="0" pn="section-1.1.1-2">This document models the result of applying a query to the
query argument as a nodelist (a list of nodes).</t>
          <t indent="0" pn="section-1.1.1-3">Nodes are the selectable parts of the query argument.
The only parts of an object that can be selected by a query are the
member values. Member names and members (name/value pairs) cannot be
selected.
Thus, member values have nodes, but members and member names do not.
Similarly, member values are children of an object, but members and
member names are not.</t>
        </section>
      </section>
      <section anchor="history" numbered="true" removeInRFC="false" toc="include" pn="section-1.2">
        <name slugifiedName="name-history">History</name>
        <t indent="0" pn="section-1.2-1">This document is based on <contact fullname="Stefan Gössner"/>'s popular JSONPath proposal (dated 2007-02-21) <xref target="JSONPath-orig" format="default" sectionFormat="of" derivedContent="JSONPath-orig"/>, builds on the experience from the widespread
deployment of its implementations, and provides a normative specification for it.</t>
        <t indent="0" pn="section-1.2-2"><xref target="inspired-by-xpath" format="default" sectionFormat="of" derivedContent="Appendix B"/> describes how JSONPath was inspired by XML's XPath
<xref target="XPath" format="default" sectionFormat="of" derivedContent="XPath"/>.</t>
        <t indent="0" pn="section-1.2-3">JSONPath was intended as a lightweight companion to JSON
implementations in programming languages such as PHP and JavaScript,
so instead of defining its own expression language, like XPath did,
JSONPath delegated parts of a query to the underlying
runtime, e.g., JavaScript's <tt>eval()</tt> function.
As JSONPath was implemented in more environments, JSONPath
expressions became decreasingly portable.
For example, regular expression processing was often delegated to a
convenient regular expression engine.</t>
        <t indent="0" pn="section-1.2-4">This document aims to remove such implementation-specific dependencies and
serve as a common JSONPath specification that can be used across
programming languages and environments.
This means that backwards compatibility is
not always achieved; a design principle of this document is to
go with a "consensus" between implementations even if it is rough, as
long as that does not jeopardize the objective of obtaining a usable,
stable JSON query language.</t>
        <t indent="0" pn="section-1.2-5">The term <em>JSONPath</em> was chosen because of the XPath inspiration and also because
the outcome of a query consists of <em>paths</em> identifying nodes in the
JSON query argument.</t>
      </section>
      <section anchor="json-values" numbered="true" removeInRFC="false" toc="include" pn="section-1.3">
        <name slugifiedName="name-json-values">JSON Values</name>
        <t indent="0" pn="section-1.3-1">The JSON value a JSONPath query is applied to is, by definition, a
valid JSON value. A JSON value is often constructed by parsing
a JSON text.</t>
        <t indent="0" pn="section-1.3-2">The parsing of a JSON text into a JSON value and what happens if a JSON
text does not represent valid JSON are not defined by this document.
Sections <xref target="RFC8259" section="4" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8259#section-4" derivedContent="RFC8259"/> and <xref target="RFC8259" section="8" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8259#section-8" derivedContent="RFC8259"/> of <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/> identify specific situations that may
conform to the grammar for JSON texts but are not interoperable uses
of JSON, as they may cause unpredictable behavior.
This document does not attempt to define predictable
behavior for JSONPath queries in these situations.</t>
        <t indent="0" pn="section-1.3-3">Specifically, the "Semantics" subsections of Sections
<xref format="counter" target="name-selector" sectionFormat="of" derivedContent="2.3.1"/>, <xref format="counter" target="wildcard-selector" sectionFormat="of" derivedContent="2.3.2"/>,
<xref format="counter" target="filter-selector" sectionFormat="of" derivedContent="2.3.5"/>, and <xref format="counter" target="descendant-segment" sectionFormat="of" derivedContent="2.5.2"/> describe behavior that
becomes unpredictable when the JSON value for one of the objects
under consideration was constructed out of JSON text that exhibits
multiple members for a single object that share the same member name
("duplicate names"; see <xref section="4" sectionFormat="of" target="RFC8259" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8259#section-4" derivedContent="RFC8259"/>).
Also, when selecting a child by name (<xref target="name-selector" format="default" sectionFormat="of" derivedContent="Section 2.3.1"/>) and comparing strings
(<xref target="comparisons" format="default" sectionFormat="of" derivedContent="Section 2.3.5.2.2"/>), it is assumed these
strings are sequences of Unicode scalar values; the behavior becomes unpredictable
if they are not (<xref section="8.2" sectionFormat="of" target="RFC8259" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8259#section-8.2" derivedContent="RFC8259"/>).</t>
      </section>
      <section anchor="overview" numbered="true" removeInRFC="false" toc="include" pn="section-1.4">
        <name slugifiedName="name-overview-of-jsonpath-expres">Overview of JSONPath Expressions</name>
        <t indent="0" pn="section-1.4-1">A JSONPath expression is applied to a JSON value, known as the query argument.
The output is a nodelist.</t>
        <t indent="0" pn="section-1.4-2">A JSONPath expression consists of an identifier followed by a series
of zero or more segments, each of which contains one or more selectors.</t>
        <section anchor="ids" numbered="true" removeInRFC="false" toc="include" pn="section-1.4.1">
          <name slugifiedName="name-identifiers">Identifiers</name>
          <t indent="0" pn="section-1.4.1-1">The root node identifier <tt>$</tt> refers to the root node of the query argument,
i.e., to the argument as a whole.</t>
          <t indent="0" pn="section-1.4.1-2">The current node identifier <tt>@</tt> refers to the current node in the context
of the evaluation of a filter expression (<xref target="filter-selector" format="default" sectionFormat="of" derivedContent="Section 2.3.5"/>).</t>
        </section>
        <section anchor="segments" numbered="true" removeInRFC="false" toc="include" pn="section-1.4.2">
          <name slugifiedName="name-segments">Segments</name>
          <t indent="0" pn="section-1.4.2-1">Segments select children (<tt>[&lt;selectors&gt;]</tt>) or descendants (<tt>..⁠[&lt;selectors&gt;]</tt>) of an input value.</t>
          <t indent="0" pn="section-1.4.2-2">Segments can use <em>bracket notation</em>, for example:</t>
          <sourcecode type="application/jsonpath" markers="false" pn="section-1.4.2-3">
$['store']['book'][0]['title']
</sourcecode>
          <t indent="0" pn="section-1.4.2-4">or the more compact <em>dot notation</em>, for example:</t>
          <sourcecode type="application/jsonpath" markers="false" pn="section-1.4.2-5">
$.store.book[0].title
</sourcecode>
          <t indent="0" pn="section-1.4.2-6">Bracket notation contains one or more (comma-separated) selectors of any kind.
Selectors are detailed in the next section.</t>
          <t indent="0" pn="section-1.4.2-7">A JSONPath expression may use a combination of bracket and dot notations.</t>
          <t indent="0" pn="section-1.4.2-8">This document treats the bracket notations as canonical and defines the shorthand dot notation in terms
of bracket notation. Examples and descriptions use shorthand where convenient.</t>
        </section>
        <section anchor="selectors" numbered="true" removeInRFC="false" toc="include" pn="section-1.4.3">
          <name slugifiedName="name-selectors">Selectors</name>
          <t indent="0" pn="section-1.4.3-1">A name selector, e.g., <tt>'name'</tt>, selects a named child of an object.</t>
          <t indent="0" pn="section-1.4.3-2">An index selector, e.g., <tt>3</tt>, selects an indexed child of an array.</t>
          <t indent="0" pn="section-1.4.3-3">In the expression <tt>[*]</tt>, a wildcard <tt>*</tt> (<xref target="wildcard-selector" format="default" sectionFormat="of" derivedContent="Section 2.3.2"/>) selects all children of a
node, and in the expression <tt>..[*]</tt>, it selects all descendants of a node.</t>
          <t indent="0" pn="section-1.4.3-4">An array slice <tt>start:end:step</tt> (<xref target="slice" format="default" sectionFormat="of" derivedContent="Section 2.3.4"/>) selects a series of
elements from an array, giving a start position, an end position, and
an optional step value that moves the position from the start to the
	  end.</t>
          <t indent="0" pn="section-1.4.3-5">A filter expression <tt>?&lt;logical-expr&gt;</tt> selects certain children of an object or array, as in:</t>
          <sourcecode type="application/jsonpath" markers="false" pn="section-1.4.3-6">
$.store.book[?@.price &lt; 10].title
</sourcecode>
        </section>
        <section anchor="summary" numbered="true" removeInRFC="false" toc="include" pn="section-1.4.4">
          <name slugifiedName="name-summary">Summary</name>
          <t indent="0" pn="section-1.4.4-1"><xref target="tbl-overview" format="default" sectionFormat="of" derivedContent="Table 1"/> provides a brief overview of JSONPath syntax.</t>
          <table anchor="tbl-overview" align="center" pn="table-1">
            <name slugifiedName="name-overview-of-jsonpath-syntax">Overview of JSONPath Syntax</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Syntax Element</th>
                <th align="left" colspan="1" rowspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>$</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="root-identifier" format="default" sectionFormat="of" derivedContent="Section 2.2">root node identifier</xref></td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>@</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="filter-selector" format="default" sectionFormat="of" derivedContent="Section 2.3.5">current node identifier</xref> (valid only within filter selectors)</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>[&lt;selectors&gt;]</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="child-segment" format="default" sectionFormat="of" derivedContent="Section 2.5.1">child segment</xref>: selects zero or more children of a node</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>.name</tt></td>
                <td align="left" colspan="1" rowspan="1">shorthand for <tt>['name']</tt></td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>.*</tt></td>
                <td align="left" colspan="1" rowspan="1">shorthand for <tt>[*]</tt></td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>..⁠[&lt;selectors&gt;]</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="descendant-segment" format="default" sectionFormat="of" derivedContent="Section 2.5.2">descendant segment</xref>: selects zero or more descendants of a node</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>..name</tt></td>
                <td align="left" colspan="1" rowspan="1">shorthand for <tt>..['name']</tt></td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>..*</tt></td>
                <td align="left" colspan="1" rowspan="1">shorthand for <tt>..[*]</tt></td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>'name'</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="name-selector" format="default" sectionFormat="of" derivedContent="Section 2.3.1">name selector</xref>: selects a named child of an object</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>*</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="wildcard-selector" format="default" sectionFormat="of" derivedContent="Section 2.3.2">wildcard selector</xref>: selects all children of a node</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>3</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="index-selector" format="default" sectionFormat="of" derivedContent="Section 2.3.3">index selector</xref>: selects an indexed child of an array (from 0)</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>0:100:5</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="slice" format="default" sectionFormat="of" derivedContent="Section 2.3.4">array slice selector</xref>: start:end:step for arrays</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>?&lt;logical-expr&gt;</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="filter-selector" format="default" sectionFormat="of" derivedContent="Section 2.3.5">filter selector</xref>: selects particular children using a logical expression</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>length(@.foo)</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <xref target="fnex" format="default" sectionFormat="of" derivedContent="Section 2.4">function extension</xref>: invokes a function in a filter expression</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="jsonpath-examples" numbered="true" removeInRFC="false" toc="include" pn="section-1.5">
        <name slugifiedName="name-jsonpath-examples">JSONPath Examples</name>
        <t indent="0" pn="section-1.5-1">This section is informative. It provides examples of JSONPath expressions.</t>
        <t indent="0" pn="section-1.5-2">The examples are based on the simple JSON value shown in
<xref target="fig-example-value" format="default" sectionFormat="of" derivedContent="Figure 1"/>, representing a bookstore (which also has a bicycle).</t>
        <figure anchor="fig-example-value" align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-example-json-value">Example JSON Value</name>
          <sourcecode type="json" markers="false" pn="section-1.5-3.1">
{ "store": {
    "book": [
      { "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      { "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      { "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      { "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 399
    }
  }
}
</sourcecode>
        </figure>
        <t indent="0" pn="section-1.5-4"><xref target="tbl-example" format="default" sectionFormat="of" derivedContent="Table 2"/> shows some JSONPath queries that might be applied to this example and their intended results.</t>
        <table anchor="tbl-example" align="center" pn="table-2">
          <name slugifiedName="name-example-jsonpath-expression">Example JSONPath Expressions and Their Intended Results When Applied to the Example JSON Value</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">JSONPath</th>
              <th align="left" colspan="1" rowspan="1">Intended Result</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$.store.book[*].author</tt></td>
              <td align="left" colspan="1" rowspan="1">the authors of all books in the store</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..author</tt></td>
              <td align="left" colspan="1" rowspan="1">all authors</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$.store.*</tt></td>
              <td align="left" colspan="1" rowspan="1">all things in the store, which are some books and a red bicycle</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$.store..price</tt></td>
              <td align="left" colspan="1" rowspan="1">the prices of everything in the store</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[2]</tt></td>
              <td align="left" colspan="1" rowspan="1">the third book</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[2].author</tt></td>
              <td align="left" colspan="1" rowspan="1">the third book's author</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[2].publisher</tt></td>
              <td align="left" colspan="1" rowspan="1">empty result: the third book does not have a "publisher" member</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[-1]</tt></td>
              <td align="left" colspan="1" rowspan="1">the last book in order</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[0,1]</tt><br/><tt>$..book[:2]</tt></td>
              <td align="left" colspan="1" rowspan="1">the first two books</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[?@.isbn]</tt></td>
              <td align="left" colspan="1" rowspan="1">all books with an ISBN number</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[?@.price&lt;10]</tt></td>
              <td align="left" colspan="1" rowspan="1">all books cheaper than 10</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..*</tt></td>
              <td align="left" colspan="1" rowspan="1">all member values and array elements contained in the input value</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="jsonpath-syntax-and-semantics" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-jsonpath-syntax-and-semanti">JSONPath Syntax and Semantics</name>
      <section anchor="synsem-overview" numbered="true" removeInRFC="false" toc="include" pn="section-2.1">
        <name slugifiedName="name-overview">Overview</name>
        <t indent="0" pn="section-2.1-1">A JSONPath <em>expression</em> is a string that, when applied to a JSON value
(the <em>query argument</em>), selects zero or more nodes of the argument and outputs
these nodes as a nodelist.</t>
        <t indent="0" pn="section-2.1-2">A query <bcp14>MUST</bcp14> be encoded using UTF-8.
The grammar for queries given in this document assumes that its UTF-8 form is first decoded into
Unicode scalar values as described
in <xref target="RFC3629" format="default" sectionFormat="of" derivedContent="RFC3629"/>; implementation approaches that lead to an equivalent
result are possible.</t>
        <t indent="0" pn="section-2.1-3">A string to be used as a JSONPath query needs to be <em>well-formed</em> and
<em>valid</em>.
A string is a well-formed JSONPath query if it conforms to the ABNF syntax in this document.
A well-formed JSONPath query is valid if it also fulfills both semantic
requirements posed by this document, which are as follows:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-2.1-4"><li pn="section-2.1-4.1" derivedCounter="1.">Integer numbers in the JSONPath query that are relevant
to the JSONPath processing (e.g., index values and steps) <bcp14>MUST</bcp14> be
within the range of exact integer values defined in Internet JSON (I-JSON) (see <xref section="2.2" sectionFormat="of" target="RFC7493" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7493#section-2.2" derivedContent="RFC7493"/>), namely within the interval [-(2<sup>53</sup>)+1,
(2<sup>53</sup>)-1].</li>
          <li pn="section-2.1-4.2" derivedCounter="2.">Uses of function extensions <bcp14>MUST</bcp14> be <em>well-typed</em>,
as described in <xref target="well-typedness" format="default" sectionFormat="of" derivedContent="Section 2.4.3"/>.</li>
        </ol>
        <t indent="0" pn="section-2.1-5">A JSONPath implementation <bcp14>MUST</bcp14> raise an error for any query that is not
well-formed and valid.
The well-formedness and the validity of JSONPath queries are independent of
the JSON value the query is applied to. No further errors relating to the
well-formedness and the validity of a JSONPath query can be
raised during application of the query to a value.
This clearly separates well-formedness/validity errors in the query
from mismatches that may actually stem from flaws in the data.</t>
        <t indent="0" pn="section-2.1-6">Mismatches between the structure expected by a valid query
and the structure found in the data can lead to empty query results,
which may be unexpected and indicate bugs in either.
JSONPath implementations might therefore want to provide diagnostics
to the application developer that aid in finding the cause of empty
results.</t>
        <t indent="0" pn="section-2.1-7">Obviously, an implementation can still fail when executing a JSONPath
query, e.g., because of resource depletion, but this is not modeled in
this document.  However, the implementation <bcp14>MUST NOT</bcp14>
silently malfunction.  Specifically, if a valid JSONPath query is
evaluated against a structured value whose size is too large to
process the query correctly (for instance, requiring the processing of
numbers that fall outside the range of exact values), the implementation
	<bcp14>MUST</bcp14> provide an indication of overflow.</t>
        <t indent="0" pn="section-2.1-8">(Readers familiar with the HTTP error model may be reminded of 400
type errors when pondering well-formedness and validity, and they may
recognize resource depletion and related errors as comparable to 500 type
errors.)</t>
        <section anchor="syntax" numbered="true" removeInRFC="false" toc="include" pn="section-2.1.1">
          <name slugifiedName="name-syntax">Syntax</name>
          <t indent="0" pn="section-2.1.1-1">Syntactically, a JSONPath query consists of a root identifier (<tt>$</tt>), which
stands for a nodelist that contains the root node of the query argument,
followed by a possibly empty sequence of <em>segments</em>.</t>
          <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.1.1-2">
jsonpath-query      = root-identifier segments
segments            = *(S segment)

B                   = %x20 /    ; Space
                      %x09 /    ; Horizontal tab
                      %x0A /    ; Line feed or New line
                      %x0D      ; Carriage return
S                   = *B        ; optional blank space
</sourcecode>
          <t indent="0" pn="section-2.1.1-3">The syntax and semantics of segments are defined in <xref target="segments-details" format="default" sectionFormat="of" derivedContent="Section 2.5"/>.</t>
        </section>
        <section anchor="semantics" numbered="true" removeInRFC="false" toc="include" pn="section-2.1.2">
          <name slugifiedName="name-semantics">Semantics</name>
          <t indent="0" pn="section-2.1.2-1">In this document, the semantics of a JSONPath query define the
required results and do not prescribe the internal workings of an
implementation.  This document may describe semantics in a procedural
step-by-step fashion; however, such descriptions are normative only in the sense that any implementation <bcp14>MUST</bcp14> produce an identical result but not in the sense that implementers are required to use the same algorithms.</t>
          <t indent="0" pn="section-2.1.2-2">The semantics are that a valid query is executed against a value
(the <em>query argument</em>) and produces a nodelist (i.e., a list of zero or more nodes of the value).</t>
          <t indent="0" pn="section-2.1.2-3">The query is a root identifier followed by a sequence of zero or more segments, each of
which is applied to the result of the previous root identifier or segment and provides
input to the next segment.
These results and inputs take the form of nodelists.</t>
          <t indent="0" pn="section-2.1.2-4">The nodelist resulting from the root identifier contains a single node
(the query argument).
The nodelist resulting from the last segment is presented as the
result of the query. Depending on the specific API, it might be
presented as an array of the JSON values at the nodes, an array of
Normalized Paths referencing the nodes, or both -- or some other
representation as desired by the implementation.
Note: An empty nodelist is a valid query result.</t>
          <t indent="0" pn="section-2.1.2-5">A segment operates on each of the nodes in its input nodelist in turn,
and the resultant nodelists are concatenated in the order of the input
nodelist they were derived from to produce
the result of the segment. A node may be selected more than once and
appears that number of times in the nodelist. Duplicate nodes are not removed.</t>
          <t indent="0" pn="section-2.1.2-6">A syntactically valid segment <bcp14>MUST NOT</bcp14> produce errors when executing the query.
This means that some
operations that might be considered erroneous, such as using an index
lying outside the range of an array,
simply result in fewer nodes being selected.
(Additional discussion of this property can be found in the introduction of <xref target="synsem-overview" format="default" sectionFormat="of" derivedContent="Section 2.1"/>.)</t>
          <t indent="0" pn="section-2.1.2-7">As a consequence of this approach, if any of the segments
          produces an empty nodelist, then the whole query produces an empty
          nodelist.
          </t>
          <t indent="0" pn="section-2.1.2-8">If the semantics of a query give an implementation a choice of producing multiple possible orderings, a particular implementation
may produce distinct orderings in successive runs of the query.</t>
        </section>
        <section anchor="example" numbered="true" removeInRFC="false" toc="include" pn="section-2.1.3">
          <name slugifiedName="name-example">Example</name>
          <t indent="0" pn="section-2.1.3-1">Consider this example. With the query argument <tt>{"a":[{"b":0},{"b":1},{"c":2}]}</tt>, the
query <tt>$.a[*].b</tt> selects the following list of nodes (denoted here by their values): <tt>0</tt>, <tt>1</tt>.</t>
          <t indent="0" pn="section-2.1.3-2">The query consists of <tt>$</tt> followed by three segments: <tt>.a</tt>, <tt>[*]</tt>, and <tt>.b</tt>.</t>
          <t indent="0" pn="section-2.1.3-3">First, <tt>$</tt> produces a nodelist consisting of just the query argument.</t>
          <t indent="0" pn="section-2.1.3-4">Next, <tt>.a</tt> selects from any object input node and selects the
node of any
member value of the input
node corresponding to the member name <tt>"a"</tt>.
The result is again a list containing a single node: <tt>[{"b":0},{"b":1},{"c":2}]</tt>.</t>
          <t indent="0" pn="section-2.1.3-5">Next, <tt>[*]</tt> selects all the elements
from the input array node.
The result is a list of three nodes: <tt>{"b":0}</tt>, <tt>{"b":1}</tt>, and <tt>{"c":2}</tt>.</t>
          <t indent="0" pn="section-2.1.3-6">Finally, <tt>.b</tt> selects from any object input node with a member name
<tt>b</tt> and selects the node of the member value of the input node corresponding to that name.
The result is a list containing <tt>0</tt>, <tt>1</tt>.
This is the concatenation of three lists: two of length one containing
<tt>0</tt>, <tt>1</tt>, respectively, and one of length zero.</t>
        </section>
      </section>
      <section anchor="root-identifier" numbered="true" removeInRFC="false" toc="include" pn="section-2.2">
        <name slugifiedName="name-root-identifier">Root Identifier</name>
        <section anchor="syntax-1" numbered="true" removeInRFC="false" toc="include" pn="section-2.2.1">
          <name slugifiedName="name-syntax-2">Syntax</name>
          <t indent="0" pn="section-2.2.1-1">Every JSONPath query (except those inside filter expressions; see <xref target="filter-selector" format="default" sectionFormat="of" derivedContent="Section 2.3.5"/>) <bcp14>MUST</bcp14> begin with the root identifier <tt>$</tt>.</t>
          <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.2.1-2">
root-identifier     = "$"
</sourcecode>
        </section>
        <section anchor="semantics-1" numbered="true" removeInRFC="false" toc="include" pn="section-2.2.2">
          <name slugifiedName="name-semantics-2">Semantics</name>
          <t indent="0" pn="section-2.2.2-1">The root identifier <tt>$</tt> represents the root node of the query argument
and produces a nodelist consisting of that root node.</t>
        </section>
        <section anchor="examples" numbered="true" removeInRFC="false" toc="include" pn="section-2.2.3">
          <name slugifiedName="name-examples">Examples</name>
          <aside pn="section-2.2.3-1">
            <t indent="0" pn="section-2.2.3-1.1">Note: In this example and the following examples in Sections <xref format="counter" target="root-identifier" sectionFormat="of" derivedContent="2.2"/> and
<xref format="counter" target="selector-details" sectionFormat="of" derivedContent="2.3"/>, except for <xref target="tbl-comparison" format="default" sectionFormat="of" derivedContent="Table 11"/>, we will present a
JSON text to show the JSON value used as the query argument to the
queries in the examples and then a table with the following columns:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2.3-1.2">
              <li pn="section-2.2.3-1.2.1">Query: an example query to be applied to the query argument</li>
              <li pn="section-2.2.3-1.2.2">Result: the query result as a list of JSON values that were located in the query argument</li>
              <li pn="section-2.2.3-1.2.3">Result Path: the query result as a list of (normalized) paths into
the query argument, giving locations of the JSON values in the previous column</li>
              <li pn="section-2.2.3-1.2.4">Comment: descriptive information</li>
            </ul>
          </aside>
          <t indent="0" pn="section-2.2.3-2">JSON:</t>
          <sourcecode type="json" markers="false" pn="section-2.2.3-3">
{"k": "v"}
</sourcecode>
          <t indent="0" pn="section-2.2.3-4">Queries:</t>
          <table anchor="tbl-root" align="center" pn="table-3">
            <name slugifiedName="name-root-identifier-example">Root Identifier Example</name>
            <thead>
              <tr>
                <th align="center" colspan="1" rowspan="1">Query</th>
                <th align="left" colspan="1" rowspan="1">Result</th>
                <th align="center" colspan="1" rowspan="1">Result Path</th>
                <th align="left" colspan="1" rowspan="1">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>{"k": "v"}</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$</tt></td>
                <td align="left" colspan="1" rowspan="1">Root node</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="selector-details" numbered="true" removeInRFC="false" toc="include" pn="section-2.3">
        <name slugifiedName="name-selectors-2">Selectors</name>
        <t indent="0" pn="section-2.3-1">Selectors appear only inside <xref target="child-segment" format="default" sectionFormat="of" derivedContent="Section 2.5.1">child segments</xref> and
<xref target="descendant-segment" format="default" sectionFormat="of" derivedContent="Section 2.5.2">descendant segments</xref>.</t>
        <t indent="0" pn="section-2.3-2">A selector produces a nodelist consisting of zero or more children of the input value.</t>
        <t indent="0" pn="section-2.3-3">There are various kinds of selectors that produce children of objects, children of arrays,
or children of either objects or arrays.</t>
        <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3-4">
selector            = name-selector /
                      wildcard-selector /
                      slice-selector /
                      index-selector /
                      filter-selector
</sourcecode>
        <t indent="0" pn="section-2.3-5">The syntax and semantics of each kind of selector are defined below.</t>
        <section anchor="name-selector" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.1">
          <name slugifiedName="name-name-selector">Name Selector</name>
          <section anchor="syntax-name" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.1.1">
            <name slugifiedName="name-syntax-3">Syntax</name>
            <t indent="0" pn="section-2.3.1.1-1">A name selector <tt>'&lt;name&gt;'</tt> selects at most one object member value.</t>
            <t indent="0" pn="section-2.3.1.1-2">In contrast to JSON,
the JSONPath syntax allows strings to be enclosed in <em>single</em> or <em>double</em> quotes.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3.1.1-3">
name-selector       = string-literal

string-literal      = %x22 *double-quoted %x22 /     ; "string"
                      %x27 *single-quoted %x27       ; 'string'

double-quoted       = unescaped /
                      %x27      /                    ; '
                      ESC %x22  /                    ; \"
                      ESC escapable

single-quoted       = unescaped /
                      %x22      /                    ; "
                      ESC %x27  /                    ; \'
                      ESC escapable

ESC                 = %x5C                           ; \ backslash

unescaped           = %x20-21 /                      ; see RFC 8259
                         ; omit 0x22 "
                      %x23-26 /
                         ; omit 0x27 '
                      %x28-5B /
                         ; omit 0x5C \
                      %x5D-D7FF /
                         ; skip surrogate code points
                      %xE000-10FFFF

escapable           = %x62 / ; b BS backspace U+0008
                      %x66 / ; f FF form feed U+000C
                      %x6E / ; n LF line feed U+000A
                      %x72 / ; r CR carriage return U+000D
                      %x74 / ; t HT horizontal tab U+0009
                      "/"  / ; / slash (solidus) U+002F
                      "\"  / ; \ backslash (reverse solidus) U+005C
                      (%x75 hexchar) ;  uXXXX U+XXXX

hexchar             = non-surrogate /
                      (high-surrogate "\" %x75 low-surrogate)
non-surrogate       = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG) /
                      ("D" %x30-37 2HEXDIG )
high-surrogate      = "D" ("8"/"9"/"A"/"B") 2HEXDIG
low-surrogate       = "D" ("C"/"D"/"E"/"F") 2HEXDIG

HEXDIG              = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
</sourcecode>
            <t indent="0" pn="section-2.3.1.1-4">Notes:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3.1.1-5">
              <li pn="section-2.3.1.1-5.1">
                <tt>Double-quoted</tt> strings follow the JSON string syntax (<xref section="7" sectionFormat="of" target="RFC8259" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8259#section-7" derivedContent="RFC8259"/>);
		<tt>single-quoted</tt> strings follow an analogous pattern.
No attempt was made to improve on this syntax, so if it is desired to
escape characters with
scalar values above 0xFFFF, such as <u format="num-lit-name" pn="u-1">🁁</u>,
they need to be represented
by a pair of surrogate escapes (<tt>"\uD83C\uDC41"</tt> in this case).</li>
              <li pn="section-2.3.1.1-5.2">Alphabetic characters in quoted strings are case-insensitive in ABNF,
so each of the hexadecimal digits within <tt>\u</tt> escapes (as specified in rules
referenced by <tt>hexchar</tt>) can be either lowercase or uppercase,
while the <tt>u</tt> in <tt>\u</tt> needs to be lowercase (indicated as <tt>%x75</tt>).</li>
            </ul>
          </section>
          <section anchor="semantics-2" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.1.2">
            <name slugifiedName="name-semantics-3">Semantics</name>
            <t indent="0" pn="section-2.3.1.2-1">A <tt>name-selector</tt> string <bcp14>MUST</bcp14> be converted to a
member name <tt>M</tt> by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
shown in <xref target="tbl-esc" format="default" sectionFormat="of" derivedContent="Table 4"/>:</t>
            <table anchor="tbl-esc" align="center" pn="table-4">
              <name slugifiedName="name-escape-sequence-replacement">Escape Sequence Replacements</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Escape Sequence</th>
                  <th align="center" colspan="1" rowspan="1">Unicode Character</th>
                  <th align="left" colspan="1" rowspan="1">Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\b</tt></td>
                  <td align="center" colspan="1" rowspan="1">U+0008</td>
                  <td align="left" colspan="1" rowspan="1">BS backspace</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\t</tt></td>
                  <td align="center" colspan="1" rowspan="1">U+0009</td>
                  <td align="left" colspan="1" rowspan="1">HT horizontal tab</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\n</tt></td>
                  <td align="center" colspan="1" rowspan="1">U+000A</td>
                  <td align="left" colspan="1" rowspan="1">LF line feed</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\f</tt></td>
                  <td align="center" colspan="1" rowspan="1">U+000C</td>
                  <td align="left" colspan="1" rowspan="1">FF form feed</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\r</tt></td>
                  <td align="center" colspan="1" rowspan="1">U+000D</td>
                  <td align="left" colspan="1" rowspan="1">CR carriage return</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\"</tt></td>
                  <td align="center" colspan="1" rowspan="1">U+0022</td>
                  <td align="left" colspan="1" rowspan="1">quotation mark</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\'</tt></td>
                  <td align="center" colspan="1" rowspan="1">U+0027</td>
                  <td align="left" colspan="1" rowspan="1">apostrophe</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\/</tt></td>
                  <td align="center" colspan="1" rowspan="1">U+002F</td>
                  <td align="left" colspan="1" rowspan="1">slash (solidus)</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\\</tt></td>
                  <td align="center" colspan="1" rowspan="1">U+005C</td>
                  <td align="left" colspan="1" rowspan="1">backslash (reverse solidus)</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>\uXXXX</tt></td>
                  <td align="center" colspan="1" rowspan="1">see <xref target="syntax-name" format="default" sectionFormat="of" derivedContent="Section 2.3.1.1"/></td>
                  <td align="left" colspan="1" rowspan="1">hexadecimal escape</td>
                </tr>
              </tbody>
            </table>
            <t indent="0" pn="section-2.3.1.2-3">Applying the <tt>name-selector</tt> to an object node
selects a member value whose name equals the member name <tt>M</tt>
or selects nothing if there is no such member value.
Nothing is selected from a value that is not an object.</t>
            <t indent="0" pn="section-2.3.1.2-4">Note: Processing the name selector requires comparing the member name string <tt>M</tt>
with member name strings in the JSON to which the selector is being applied.
Two strings <bcp14>MUST</bcp14> be considered equal if and only if they are identical
sequences of Unicode scalar values. In other words, normalization operations
<bcp14>MUST NOT</bcp14> be applied to either the member name string <tt>M</tt> from the JSONPath or
the member name strings in the JSON prior to comparison.</t>
          </section>
          <section anchor="examples-1" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.1.3">
            <name slugifiedName="name-examples-2">Examples</name>
            <t indent="0" pn="section-2.3.1.3-1">JSON:</t>
            <sourcecode type="json" markers="false" pn="section-2.3.1.3-2">
{
  "o": {"j j": {"k.k": 3}},
  "'": {"@": 2}
}
</sourcecode>
            <t indent="0" pn="section-2.3.1.3-3">Queries:</t>
            <t indent="0" pn="section-2.3.1.3-4">The examples in <xref target="tbl-name" format="default" sectionFormat="of" derivedContent="Table 5"/> show the name selector in use by child segments.</t>
            <table anchor="tbl-name" align="center" pn="table-5">
              <name slugifiedName="name-name-selector-examples">Name Selector Examples</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Query</th>
                  <th align="left" colspan="1" rowspan="1">Result</th>
                  <th align="center" colspan="1" rowspan="1">Result Paths</th>
                  <th align="left" colspan="1" rowspan="1">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o['j j']</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"k.k": 3}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['j j']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Named <br/>value in <br/>a nested <br/>object</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o['j j']⁠['k.k']</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>3</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['j j']⁠['k.k']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Nesting <br/>further <br/>down</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o["j j"]⁠["k.k"]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>3</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['j j']⁠['k.k']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Different <br/>delimiter <br/>in the query, <br/>unchanged <br/>Normalized <br/>Path</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$["'"]["@"]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>2</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['\'']['@']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Unusual <br/>member <br/>names</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>
        <section anchor="wildcard-selector" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.2">
          <name slugifiedName="name-wildcard-selector">Wildcard Selector</name>
          <section anchor="syntax-2" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.2.1">
            <name slugifiedName="name-syntax-4">Syntax</name>
            <t indent="0" pn="section-2.3.2.1-1">The wildcard selector consists of an asterisk.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3.2.1-2">
wildcard-selector   = "*"
</sourcecode>
          </section>
          <section anchor="semantics-3" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.2.2">
            <name slugifiedName="name-semantics-4">Semantics</name>
            <t indent="0" pn="section-2.3.2.2-1">A wildcard selector selects the nodes of all children of an object or array.
The order in which the children of an object appear in the resultant nodelist is not stipulated,
since JSON objects are unordered.
	    Children of an array appear in array order in the resultant nodelist.</t>
            <t indent="0" pn="section-2.3.2.2-2">Note that the children of an object are its member values, not its member names.</t>
            <t indent="0" pn="section-2.3.2.2-3">The wildcard selector selects nothing from a primitive JSON value (that is,
a number, a string, <tt>true</tt>, <tt>false</tt>, or <tt>null</tt>).</t>
          </section>
          <section anchor="examples-2" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.2.3">
            <name slugifiedName="name-examples-3">Examples</name>
            <t indent="0" pn="section-2.3.2.3-1">JSON:</t>
            <sourcecode type="json" markers="false" pn="section-2.3.2.3-2">
{
  "o": {"j": 1, "k": 2},
  "a": [5, 3]
}
</sourcecode>
            <t indent="0" pn="section-2.3.2.3-3">Queries:</t>
            <t indent="0" pn="section-2.3.2.3-4">The examples in <xref target="tbl-wild" format="default" sectionFormat="of" derivedContent="Table 6"/> show the wildcard selector in use by a child segment.</t>
            <table anchor="tbl-wild" align="center" pn="table-6">
              <name slugifiedName="name-wildcard-selector-examples">Wildcard Selector Examples</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Query</th>
                  <th align="left" colspan="1" rowspan="1">Result</th>
                  <th align="center" colspan="1" rowspan="1">Result Paths</th>
                  <th align="left" colspan="1" rowspan="1">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[*]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"j": 1, "k": 2}</tt> <br/> <tt>[5, 3]</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']</tt> <br/> <tt>$['a']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Object values</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o[*]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>1</tt> <br/> <tt>2</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['j']</tt> <br/> <tt>$['o']['k']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Object values</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o[*]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>2</tt> <br/> <tt>1</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['k']</tt> <br/> <tt>$['o']['j']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Alternative result</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o[*, *]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>2</tt> <br/> <tt>1</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['j']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['o']['j']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Non-deterministic ordering</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[*]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>5</tt> <br/> <tt>3</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][0]</tt> <br/> <tt>$['a'][1]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Array members</td>
                </tr>
              </tbody>
            </table>
            <t indent="0" pn="section-2.3.2.3-6">The example above with the query <tt>$.o[*, *]</tt> shows that the wildcard selector may produce nodelists in distinct
orders each time it appears in the child segment when it is applied to an object node with two or more
members (but not when it is applied to object nodes with fewer than two members or to array nodes).</t>
          </section>
        </section>
        <section anchor="index-selector" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.3">
          <name slugifiedName="name-index-selector">Index Selector</name>
          <section anchor="syntax-index" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.3.1">
            <name slugifiedName="name-syntax-5">Syntax</name>
            <t indent="0" pn="section-2.3.3.1-1">An index selector <tt>&lt;index&gt;</tt> matches at most one array element value.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3.3.1-2">
index-selector      = int                        ; decimal integer

int                 = "0" /
                      (["-"] DIGIT1 *DIGIT)      ; - optional
DIGIT1              = %x31-39                    ; 1-9 non-zero digit
</sourcecode>
            <t indent="0" pn="section-2.3.3.1-3">Applying the numerical <tt>index-selector</tt> selects the corresponding
element. JSONPath allows it to be negative (see <xref target="index-semantics" format="default" sectionFormat="of" derivedContent="Section 2.3.3.2"/>).</t>
            <t indent="0" pn="section-2.3.3.1-4">To be valid, the index selector value <bcp14>MUST</bcp14> be in the I-JSON
range of exact values (see <xref target="synsem-overview" format="default" sectionFormat="of" derivedContent="Section 2.1"/>).</t>
            <t indent="0" pn="section-2.3.3.1-5">Notes:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3.3.1-6">
              <li pn="section-2.3.3.1-6.1">An <tt>index-selector</tt> is an integer (in base 10, as in JSON numbers).</li>
              <li pn="section-2.3.3.1-6.2">As in JSON numbers, the syntax does not allow octal-like integers with leading zeros, such as <tt>01</tt> or <tt>-01</tt>.</li>
            </ul>
          </section>
          <section anchor="index-semantics" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.3.2">
            <name slugifiedName="name-semantics-5">Semantics</name>
            <t indent="0" pn="section-2.3.3.2-1">A non-negative <tt>index-selector</tt> applied to an array selects an array element using a zero-based index.
For example, the selector <tt>0</tt> selects the first, and the selector <tt>4</tt> selects the fifth element of a sufficiently long array.
Nothing is selected, and it is not an error, if the index lies outside the range of the array. Nothing is selected from a value that is not an array.</t>
            <t indent="0" pn="section-2.3.3.2-2">A negative <tt>index-selector</tt> counts from the array end backwards,
obtaining an equivalent non-negative <tt>index-selector</tt> by adding the
length of the array to the negative index.
For example, the selector <tt>-1</tt> selects the last, and the selector <tt>-2</tt> selects the penultimate element of an array with at least two elements.
As with non-negative indexes, it is not an error if such an element does
not exist; this simply means that no element is selected.</t>
          </section>
          <section anchor="examples-3" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.3.3">
            <name slugifiedName="name-examples-4">Examples</name>
            <t indent="0" pn="section-2.3.3.3-1">JSON:</t>
            <sourcecode type="json" markers="false" pn="section-2.3.3.3-2">
["a","b"]
</sourcecode>
            <t indent="0" pn="section-2.3.3.3-3">Queries:</t>
            <t indent="0" pn="section-2.3.3.3-4">The examples in <xref target="tbl-index" format="default" sectionFormat="of" derivedContent="Table 7"/> show the index selector in use by a child segment.</t>
            <table anchor="tbl-index" align="center" pn="table-7">
              <name slugifiedName="name-index-selector-examples">Index Selector Examples</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Query</th>
                  <th align="left" colspan="1" rowspan="1">Result</th>
                  <th align="center" colspan="1" rowspan="1">Result Paths</th>
                  <th align="left" colspan="1" rowspan="1">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[1]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"b"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[1]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Element of array</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[-2]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"a"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[0]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Element of array, from the end</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>
        <section anchor="slice" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.4">
          <name slugifiedName="name-array-slice-selector">Array Slice Selector</name>
          <section anchor="syntax-3" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.4.1">
            <name slugifiedName="name-syntax-6">Syntax</name>
            <t indent="0" pn="section-2.3.4.1-1">The array slice selector has the form <tt>&lt;start&gt;:&lt;end&gt;:&lt;step&gt;</tt>.
It matches elements from arrays starting at index <tt>&lt;start&gt;</tt> and ending at (but
not including) <tt>&lt;end&gt;</tt>, while incrementing by <tt>step</tt> with a default of <tt>1</tt>.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3.4.1-2">
slice-selector      = [start S] ":" S [end S] [":" [S step ]]

start               = int       ; included in selection
end                 = int       ; not included in selection
step                = int       ; default: 1
</sourcecode>
            <t indent="0" pn="section-2.3.4.1-3">The slice selector consists of three optional decimal integers separated by colons.
The second colon can be omitted when the third integer is omitted.</t>
            <t indent="0" pn="section-2.3.4.1-4">To be valid, the integers provided <bcp14>MUST</bcp14> be in the I-JSON
range of exact values (see <xref target="synsem-overview" format="default" sectionFormat="of" derivedContent="Section 2.1"/>).</t>
          </section>
          <section anchor="semantics-4" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.4.2">
            <name slugifiedName="name-semantics-6">Semantics</name>
            <t indent="0" pn="section-2.3.4.2-1">The slice selector was inspired by
               the slice operator that was proposed for ECMAScript 4 (ES4), which was never released,
               and that of Python.</t>
            <section anchor="informal-introduction" numbered="true" removeInRFC="false" toc="exclude" pn="section-2.3.4.2.1">
              <name slugifiedName="name-informal-introduction">Informal Introduction</name>
              <t indent="0" pn="section-2.3.4.2.1-1">This section is informative.</t>
              <t indent="0" pn="section-2.3.4.2.1-2">Array slicing is inspired by the behavior of the <tt>Array.prototype.slice</tt> method
of the JavaScript language, as defined by the ECMA-262 standard <xref target="ECMA-262" format="default" sectionFormat="of" derivedContent="ECMA-262"/>,
with the addition of the <tt>step</tt> parameter, which is inspired by the Python slice expression.</t>
              <t indent="0" pn="section-2.3.4.2.1-3">The array slice expression <tt>start:end:step</tt> selects elements at indices starting at <tt>start</tt>,
incrementing by <tt>step</tt>, and ending with <tt>end</tt> (which is itself excluded).
So, for example, the expression <tt>1:3</tt> (where <tt>step</tt> defaults to <tt>1</tt>)
selects elements with indices <tt>1</tt> and <tt>2</tt> (in that order), whereas
<tt>1:5:2</tt> selects elements with indices <tt>1</tt> and <tt>3</tt>.</t>
              <t indent="0" pn="section-2.3.4.2.1-4">When <tt>step</tt> is negative, elements are selected in reverse order. Thus,
for example, <tt>5:1:-2</tt> selects elements with indices <tt>5</tt> and <tt>3</tt> (in
that order), and <tt>::-1</tt> selects all the elements of an array in
reverse order.</t>
              <t indent="0" pn="section-2.3.4.2.1-5">When <tt>step</tt> is <tt>0</tt>, no elements are selected.
(This is the one case that differs from the behavior of Python, which
raises an error in this case.)</t>
              <t indent="0" pn="section-2.3.4.2.1-6">The following section specifies the behavior fully, without depending on
JavaScript or Python behavior.</t>
            </section>
            <section anchor="normative-semantics" numbered="true" removeInRFC="false" toc="exclude" pn="section-2.3.4.2.2">
              <name slugifiedName="name-normative-semantics">Normative Semantics</name>
              <t indent="0" pn="section-2.3.4.2.2-1">A slice expression selects a subset of the elements of the input array in
the same order
as the array or the reverse order, depending on the sign of the <tt>step</tt> parameter.
It selects no nodes from a node that is not an array.</t>
              <t indent="0" pn="section-2.3.4.2.2-2">A slice is defined by the two slice parameters, <tt>start</tt> and <tt>end</tt>, and
an iteration delta, <tt>step</tt>.
Each of these parameters is
optional. In the rest of this section, <tt>len</tt> denotes the length of the input array.</t>
              <t indent="0" pn="section-2.3.4.2.2-3">The default value for <tt>step</tt> is <tt>1</tt>.
The default values for <tt>start</tt> and <tt>end</tt> depend on the sign of <tt>step</tt>,
as shown in <xref target="tbl-slice-start-end" format="default" sectionFormat="of" derivedContent="Table 8"/>.</t>
              <table anchor="tbl-slice-start-end" align="center" pn="table-8">
                <name slugifiedName="name-default-array-slice-start-a">Default Array Slice start and end Values</name>
                <thead>
                  <tr>
                    <th align="left" colspan="1" rowspan="1">Condition</th>
                    <th align="left" colspan="1" rowspan="1">start</th>
                    <th align="left" colspan="1" rowspan="1">end</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td align="left" colspan="1" rowspan="1">step &gt;= 0</td>
                    <td align="left" colspan="1" rowspan="1">0</td>
                    <td align="left" colspan="1" rowspan="1">len</td>
                  </tr>
                  <tr>
                    <td align="left" colspan="1" rowspan="1">step &lt; 0</td>
                    <td align="left" colspan="1" rowspan="1">len - 1</td>
                    <td align="left" colspan="1" rowspan="1">-len - 1</td>
                  </tr>
                </tbody>
              </table>
              <t indent="0" pn="section-2.3.4.2.2-5">Slice expression parameters <tt>start</tt> and <tt>end</tt> are not directly usable
as slice bounds and must first be normalized.
Normalization for this purpose is defined as:</t>
              <sourcecode type="pseudocode" markers="false" pn="section-2.3.4.2.2-6">
FUNCTION Normalize(i, len):
  IF i &gt;= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
</sourcecode>
              <t indent="0" pn="section-2.3.4.2.2-7">The result of the array index expression <tt>i</tt> applied to an array
of length <tt>len</tt> is the result of the array
slicing expression <tt>Normalize(i, len):Normalize(i, len)+1:1</tt>.</t>
              <t indent="0" pn="section-2.3.4.2.2-8">Slice expression parameters <tt>start</tt> and <tt>end</tt> are used to derive slice bounds <tt>lower</tt> and <tt>upper</tt>.
The direction of the iteration, defined
by the sign of <tt>step</tt>, determines which of the parameters is the lower bound and which
is the upper bound:</t>
              <sourcecode type="pseudocode" markers="false" pn="section-2.3.4.2.2-9">
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start, len)
  n_end = Normalize(end, len)

  IF step &gt;= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
</sourcecode>
              <t indent="0" pn="section-2.3.4.2.2-10">The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, <tt>a(i)</tt> is the <tt>i+1</tt>th element of the array <tt>a</tt>
(i.e., <tt>a(0)</tt> is the first element, <tt>a(1)</tt> the second, and so forth).</t>
              <sourcecode type="pseudocode" markers="false" pn="section-2.3.4.2.2-11">
IF step &gt; 0 THEN

  i = lower
  WHILE i &lt; upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step &lt; 0 THEN

  i = upper
  WHILE lower &lt; i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
</sourcecode>
              <t indent="0" pn="section-2.3.4.2.2-12">When <tt>step = 0</tt>, no elements are selected, and the result array is empty.</t>
            </section>
          </section>
          <section anchor="examples-4" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.4.3">
            <name slugifiedName="name-examples-5">Examples</name>
            <t indent="0" pn="section-2.3.4.3-1">JSON:</t>
            <sourcecode type="json" markers="false" pn="section-2.3.4.3-2">
["a", "b", "c", "d", "e", "f", "g"]
</sourcecode>
            <t indent="0" pn="section-2.3.4.3-3">Queries:</t>
            <t indent="0" pn="section-2.3.4.3-4">The examples in <xref target="tbl-slice" format="default" sectionFormat="of" derivedContent="Table 9"/> show the array slice selector in use by a child segment.</t>
            <table anchor="tbl-slice" align="center" pn="table-9">
              <name slugifiedName="name-array-slice-selector-exampl">Array Slice Selector Examples</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Query</th>
                  <th align="left" colspan="1" rowspan="1">Result</th>
                  <th align="center" colspan="1" rowspan="1">Result Paths</th>
                  <th align="left" colspan="1" rowspan="1">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[1:3]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"b"</tt> <br/> <tt>"c"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[1]</tt> <br/> <tt>$[2]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Slice with default step</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[5:]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"f"</tt> <br/> <tt>"g"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[5]</tt> <br/> <tt>$[6]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Slice with no end index</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[1:5:2]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"b"</tt> <br/> <tt>"d"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[1]</tt> <br/> <tt>$[3]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Slice with step 2</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[5:1:-2]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"f"</tt> <br/> <tt>"d"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[5]</tt> <br/> <tt>$[3]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Slice with negative step</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[::-1]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"g"</tt> <br/> <tt>"f"</tt> <br/> <tt>"e"</tt> <br/> <tt>"d"</tt> <br/> <tt>"c"</tt> <br/> <tt>"b"</tt> <br/> <tt>"a"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[6]</tt> <br/> <tt>$[5]</tt> <br/> <tt>$[4]</tt> <br/> <tt>$[3]</tt> <br/> <tt>$[2]</tt> <br/> <tt>$[1]</tt> <br/> <tt>$[0]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Slice in reverse order</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>
        <section anchor="filter-selector" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.5">
          <name slugifiedName="name-filter-selector">Filter Selector</name>
          <t indent="0" pn="section-2.3.5-1">Filter selectors are used to iterate over the elements or members of
structured values, i.e., JSON arrays and objects.
The structured values are identified in the nodelist offered by the
child or descendant segment using the filter selector.</t>
          <t indent="0" pn="section-2.3.5-2">For each iteration (element/member), a logical expression (the <em>filter expression</em>)
is evaluated, which decides whether the node of
the element/member is selected.
(While a logical expression evaluates to what mathematically is a
Boolean value, this specification uses the term <em>logical</em> to maintain a distinction from
the Boolean values that JSON can represent.)</t>
          <t indent="0" pn="section-2.3.5-3">During the iteration process, the filter expression receives the node
of each array element or object member value of the structured value being
filtered; this element or member value is then known as the <em>current node</em>.</t>
          <t indent="0" pn="section-2.3.5-4">The current node can be used as the start of one or more JSONPath
queries in subexpressions of the filter expression, notated
via the current-node-identifier <tt>@</tt>.
Each JSONPath query can be used either for testing existence of a
result of the query, for obtaining a specific JSON value resulting
from that query that can then be used in a comparison, or as a
<em>function argument</em>.</t>
          <t indent="0" pn="section-2.3.5-5">Filter selectors may use function extensions, which are covered in <xref target="fnex" format="default" sectionFormat="of" derivedContent="Section 2.4"/>.
Within the logical expression for a filter selector, function
expressions can be used to operate on nodelists and values.
The set of available functions is extensible, with a number of
functions predefined (see <xref target="fnex" format="default" sectionFormat="of" derivedContent="Section 2.4"/>) and the ability to register further
functions provided by the "Function Extensions" subregistry (<xref target="iana-fnex" format="default" sectionFormat="of" derivedContent="Section 3.2"/>).
When a function is defined, it is given a unique name, and its return value and each of its parameters are given a
<em>declared type</em>.
The type system is limited in scope; its purpose is to express
restrictions that, without functions, are implicit in the grammar of
filter expressions.
The type system also guides conversions (<xref target="type-conv" format="default" sectionFormat="of" derivedContent="Section 2.4.2"/>) that mimic the
way different kinds of expressions are handled in the grammar when
function expressions are not in use.</t>
          <section anchor="filter-selector-syntax" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.5.1">
            <name slugifiedName="name-syntax-7">Syntax</name>
            <t indent="0" pn="section-2.3.5.1-1">The filter selector has the form <tt>?&lt;logical-expr&gt;</tt>.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3.5.1-2">
filter-selector     = "?" S logical-expr
</sourcecode>
            <t indent="0" pn="section-2.3.5.1-3">As the filter expression is composed of constituents free of side effects,
the order of evaluation does not need to be (and is not) defined.
Similarly, for conjunction (<tt>&amp;&amp;</tt>) and disjunction (<tt>||</tt>) (defined later),
both a short-circuiting and a fully evaluating
implementation will lead to the same result; both implementation
strategies are therefore valid.</t>
            <t indent="0" pn="section-2.3.5.1-4">The current node is accessible via the current node identifier <tt>@</tt>.
This identifier addresses the current node of the filter-selector that
is directly enclosing the identifier. Note: Within nested
filter-selectors, there is no syntax to address the current node of
any other than the directly enclosing filter-selector (i.e., of
filter-selectors enclosing the filter-selector that is directly
enclosing the identifier).</t>
            <t indent="0" pn="section-2.3.5.1-5">Logical expressions offer the usual Boolean operators (<tt>||</tt> for OR,
<tt>&amp;&amp;</tt> for AND, and <tt>!</tt> for NOT).
They have the normal semantics of Boolean algebra and obey its laws
(for example, see <xref target="BOOLEAN-LAWS" format="default" sectionFormat="of" derivedContent="BOOLEAN-LAWS"/>).
Parentheses <bcp14>MAY</bcp14> be used within <tt>logical-expr</tt> for grouping.</t>
            <t indent="0" pn="section-2.3.5.1-6">It is not required that <tt>logical-expr</tt> consist of
a parenthesized expression (which was required in <xref target="JSONPath-orig" format="default" sectionFormat="of" derivedContent="JSONPath-orig"/>),
although it can be, and the semantics are the same
as without the parentheses.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3.5.1-7">
logical-expr        = logical-or-expr
logical-or-expr     = logical-and-expr *(S "||" S logical-and-expr)
                        ; disjunction
                        ; binds less tightly than conjunction
logical-and-expr    = basic-expr *(S "&amp;&amp;" S basic-expr)
                        ; conjunction
                        ; binds more tightly than disjunction

basic-expr          = paren-expr /
                      comparison-expr /
                      test-expr

paren-expr          = [logical-not-op S] "(" S logical-expr S ")"
                                        ; parenthesized expression
logical-not-op      = "!"               ; logical NOT operator
</sourcecode>
            <t indent="0" pn="section-2.3.5.1-8">A test expression
either tests the existence of a node
designated by an embedded query (see <xref target="extest" format="default" sectionFormat="of" derivedContent="Section 2.3.5.2.1"/>) or tests the
result of a function expression (see <xref target="fnex" format="default" sectionFormat="of" derivedContent="Section 2.4"/>).
In the latter case, if the function's declared result type is
<tt>LogicalType</tt> (see <xref target="typesys" format="default" sectionFormat="of" derivedContent="Section 2.4.1"/>), it tests whether the result
is <tt>LogicalTrue</tt>; if the function's declared result type is
<tt>NodesType</tt>, it tests whether the result is non-empty.
If the function's declared result type is <tt>ValueType</tt>, its use in a
test expression is not well-typed (see <xref target="well-typedness" format="default" sectionFormat="of" derivedContent="Section 2.4.3"/>).</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3.5.1-9">
test-expr           = [logical-not-op S]
                      (filter-query / ; existence/non-existence
                       function-expr) ; LogicalType or NodesType
filter-query        = rel-query / jsonpath-query
rel-query           = current-node-identifier segments
current-node-identifier = "@"
</sourcecode>
            <t indent="0" pn="section-2.3.5.1-10">Comparison expressions are available for comparisons between primitive
values (that is, numbers, strings, <tt>true</tt>, <tt>false</tt>, and <tt>null</tt>).
These can be obtained via literal values; singular queries, each of
which selects at most one node, the value of which is then used; or
function expressions (see <xref target="fnex" format="default" sectionFormat="of" derivedContent="Section 2.4"/>) of type <tt>ValueType</tt>.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3.5.1-11">
comparison-expr     = comparable S comparison-op S comparable
literal             = number / string-literal /
                      true / false / null
comparable          = literal /
                      singular-query / ; singular query value
                      function-expr    ; ValueType
comparison-op       = "==" / "!=" /
                      "&lt;=" / "&gt;=" /
                      "&lt;"  / "&gt;"

singular-query      = rel-singular-query / abs-singular-query
rel-singular-query  = current-node-identifier singular-query-segments
abs-singular-query  = root-identifier singular-query-segments
singular-query-segments = *(S (name-segment / index-segment))
name-segment        = ("[" name-selector "]") /
                      ("." member-name-shorthand)
index-segment       = "[" index-selector "]"
</sourcecode>
            <t indent="0" pn="section-2.3.5.1-12">Literals can be notated in the way that is usual for JSON (with the
extension that strings can use single-quote delimiters).</t>
            <t indent="0" pn="section-2.3.5.1-13">Note: Alphabetic characters in quoted strings are case-insensitive in ABNF, so within a
floating point number, the ABNF expression "e" can be either the character
'e' or 'E'.</t>
            <t indent="0" pn="section-2.3.5.1-14"><tt>true</tt>, <tt>false</tt>, and <tt>null</tt> are lowercase only (case-sensitive).</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.3.5.1-15">
number              = (int / "-0") [ frac ] [ exp ] ; decimal number
frac                = "." 1*DIGIT                  ; decimal fraction
exp                 = "e" [ "-" / "+" ] 1*DIGIT    ; decimal exponent
true                = %x74.72.75.65                ; true
false               = %x66.61.6c.73.65             ; false
null                = %x6e.75.6c.6c                ; null
</sourcecode>
            <t indent="0" pn="section-2.3.5.1-16"><xref target="tbl-prec" format="default" sectionFormat="of" derivedContent="Table 10"/> lists filter expression operators in order of precedence from highest (binds most tightly) to lowest (binds least tightly).</t>
            <table anchor="tbl-prec" align="center" pn="table-10">
              <name slugifiedName="name-filter-expression-operator-">Filter Expression Operator Precedence</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Precedence</th>
                  <th align="center" colspan="1" rowspan="1">Operator type</th>
                  <th align="center" colspan="1" rowspan="1">Syntax</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">5</td>
                  <td align="center" colspan="1" rowspan="1">Grouping <br/> Function Expressions</td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>(...)</tt> <br/> <em>name</em><tt>(...)</tt></td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">4</td>
                  <td align="center" colspan="1" rowspan="1">Logical NOT</td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>!</tt></td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">3</td>
                  <td align="center" colspan="1" rowspan="1">Relations</td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>==</tt> <tt>!=</tt><br/><tt>&lt;</tt> <tt>&lt;=</tt> <tt>&gt;</tt> <tt>&gt;=</tt></td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">2</td>
                  <td align="center" colspan="1" rowspan="1">Logical AND</td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>&amp;&amp;</tt></td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">1</td>
                  <td align="center" colspan="1" rowspan="1">Logical OR</td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>||</tt></td>
                </tr>
              </tbody>
            </table>
          </section>
          <section anchor="semantics-5" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.5.2">
            <name slugifiedName="name-semantics-7">Semantics</name>
            <t indent="0" pn="section-2.3.5.2-1">The filter selector works with arrays and objects exclusively. Its result is a list of (<em>zero</em>, <em>one</em>, <em>multiple</em>, or <em>all</em>) their array elements or member values, respectively.
Applied to a primitive value, it selects nothing (and therefore does
not contribute to the result of the filter selector).</t>
            <t indent="0" pn="section-2.3.5.2-2">In the resultant nodelist, children of an array are ordered by their position in the array.
The order in which the children of an object (as opposed to an array)
appear in the resultant nodelist is not stipulated,
since JSON objects are unordered.</t>
            <section anchor="extest" numbered="true" removeInRFC="false" toc="exclude" pn="section-2.3.5.2.1">
              <name slugifiedName="name-existence-tests">Existence Tests</name>
              <t indent="0" pn="section-2.3.5.2.1-1">A query by itself in a logical context is an existence test that yields true if the query selects at least one node and yields false if the query does not select any nodes.</t>
              <t indent="0" pn="section-2.3.5.2.1-2">Existence tests differ from comparisons in that:</t>
              <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3.5.2.1-3">
                <li pn="section-2.3.5.2.1-3.1">They work with arbitrary relative or absolute queries (not just singular queries).</li>
                <li pn="section-2.3.5.2.1-3.2">They work with queries that select structured values.</li>
              </ul>
              <t indent="0" pn="section-2.3.5.2.1-4">To examine the value of a node selected by a query, an explicit comparison is necessary.
For example, to test whether the node selected by the query <tt>@.foo</tt> has the value <tt>null</tt>, use <tt>@.foo == null</tt> (see <xref target="null-semantics" format="default" sectionFormat="of" derivedContent="Section 2.6"/>)
rather than the negated existence test <tt>!@.foo</tt> (which yields false if <tt>@.foo</tt> selects a node, regardless of the node's value).
Similarly, <tt>@.foo == false</tt> yields true only if <tt>@.foo</tt> selects a node and
the value of that node is <tt>false</tt>.</t>
            </section>
            <section anchor="comparisons" numbered="true" removeInRFC="false" toc="exclude" pn="section-2.3.5.2.2">
              <name slugifiedName="name-comparisons">Comparisons</name>
              <t indent="0" pn="section-2.3.5.2.2-1">The comparison operators <tt>==</tt> and <tt>&lt;</tt> are defined first, and then these are used to define <tt>!=</tt>, <tt>&lt;=</tt>, <tt>&gt;</tt>, and <tt>&gt;=</tt>.</t>
              <t indent="0" pn="section-2.3.5.2.2-2">When either side of a comparison results in an empty nodelist or the
special result <tt>Nothing</tt> (see <xref target="typesys" format="default" sectionFormat="of" derivedContent="Section 2.4.1"/>):</t>
              <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3.5.2.2-3">
                <li pn="section-2.3.5.2.2-3.1">A comparison using the operator <tt>==</tt> yields true if and only the
other side also results in an empty nodelist or the special result <tt>Nothing</tt>.</li>
                <li pn="section-2.3.5.2.2-3.2">A comparison using the operator <tt>&lt;</tt> yields false.</li>
              </ul>
              <t indent="0" pn="section-2.3.5.2.2-4">When any query or function expression on either side of a comparison results in a nodelist consisting of a single node, that side is
replaced by the value of its node and then:</t>
              <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3.5.2.2-5">
                <li pn="section-2.3.5.2.2-5.1">
                  <t indent="0" pn="section-2.3.5.2.2-5.1.1">A comparison using the operator <tt>==</tt> yields true if and only if the comparison
is between:
                  </t>
                  <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3.5.2.2-5.1.2">
                    <li pn="section-2.3.5.2.2-5.1.2.1">numbers expected to interoperate, as per <xref section="2.2" sectionFormat="of" target="RFC7493" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7493#section-2.2" derivedContent="RFC7493">I-JSON</xref>, that compare equal using normal mathematical equality,</li>
                    <li pn="section-2.3.5.2.2-5.1.2.2">numbers, at least one of which is not expected to interoperate as per I-JSON, where the numbers compare equal using an implementation-specific equality,</li>
                    <li pn="section-2.3.5.2.2-5.1.2.3">equal primitive values that are not numbers,</li>
                    <li pn="section-2.3.5.2.2-5.1.2.4">equal arrays, that is, arrays of the same length where each element of the first array is equal to the corresponding
element of the second array, or</li>
                    <li pn="section-2.3.5.2.2-5.1.2.5">
                      <t indent="0" pn="section-2.3.5.2.2-5.1.2.5.1">equal objects with no duplicate names, that is, where:
                      </t>
                      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3.5.2.2-5.1.2.5.2">
                        <li pn="section-2.3.5.2.2-5.1.2.5.2.1">both objects have the same collection of names (with no duplicates) and</li>
                        <li pn="section-2.3.5.2.2-5.1.2.5.2.2">for each of those names, the values associated with the name by the objects are equal.</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li pn="section-2.3.5.2.2-5.2">
                  <t indent="0" pn="section-2.3.5.2.2-5.2.1">A comparison using the operator <tt>&lt;</tt> yields true if and only if
the comparison is between values that are both numbers or both strings and that satisfy the comparison:  </t>
                  <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3.5.2.2-5.2.2">
                    <li pn="section-2.3.5.2.2-5.2.2.1">numbers expected to interoperate, as per <xref section="2.2" sectionFormat="of" target="RFC7493" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7493#section-2.2" derivedContent="RFC7493">I-JSON</xref>, <bcp14>MUST</bcp14> compare using the normal mathematical ordering;
numbers not expected to interoperate, as per I-JSON, <bcp14>MAY</bcp14> compare using an implementation-specific ordering,</li>
                    <li pn="section-2.3.5.2.2-5.2.2.2">the empty string compares less than any non-empty string, and</li>
                    <li pn="section-2.3.5.2.2-5.2.2.3">a non-empty string compares less than another non-empty string if and only if the first string starts with a
lower Unicode scalar value than the second string or if both strings start with the same Unicode scalar value and
the remainder of the first string compares less than the remainder of the second string.</li>
                  </ul>
                </li>
              </ul>
              <t indent="0" pn="section-2.3.5.2.2-6"><tt>!=</tt>, <tt>&lt;=</tt>, <tt>&gt;</tt>, and <tt>&gt;=</tt> are defined in terms of the other comparison operators. For any <tt>a</tt> and <tt>b</tt>:</t>
              <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3.5.2.2-7">
                <li pn="section-2.3.5.2.2-7.1">The comparison <tt>a != b</tt> yields true if and only if <tt>a == b</tt> yields false.</li>
                <li pn="section-2.3.5.2.2-7.2">The comparison <tt>a &lt;= b</tt> yields true if and only if <tt>a &lt; b</tt> yields true or <tt>a == b</tt> yields true.</li>
                <li pn="section-2.3.5.2.2-7.3">The comparison <tt>a &gt; b</tt> yields true if and only if <tt>b &lt; a</tt> yields true.</li>
                <li pn="section-2.3.5.2.2-7.4">The comparison <tt>a &gt;= b</tt> yields true if and only if <tt>b &lt; a</tt> yields true or <tt>a == b</tt> yields true.</li>
              </ul>
            </section>
          </section>
          <section anchor="examples-5" numbered="true" removeInRFC="false" toc="include" pn="section-2.3.5.3">
            <name slugifiedName="name-examples-6">Examples</name>
            <t indent="0" pn="section-2.3.5.3-1">The first set of examples shows some comparison expressions and their
result with a given JSON value as input.</t>
            <t indent="0" pn="section-2.3.5.3-2">JSON:</t>
            <sourcecode type="json" markers="false" pn="section-2.3.5.3-3">
{
  "obj": {"x": "y"},
  "arr": [2, 3]
}
</sourcecode>
            <t indent="0" pn="section-2.3.5.3-4">Comparisons:</t>
            <table anchor="tbl-comparison" align="center" pn="table-11">
              <name slugifiedName="name-comparison-examples">Comparison Examples</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Comparison</th>
                  <th align="center" colspan="1" rowspan="1">Result</th>
                  <th align="center" colspan="1" rowspan="1">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.absent1 == $.absent2</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">Empty nodelists</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.absent1 &lt;= $.absent2</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>==</tt> implies <tt>&lt;=</tt></td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.absent == 'g'</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Empty nodelist</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.absent1 != $.absent2</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Empty nodelists</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.absent != 'g'</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">Empty nodelist</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>1 &lt;= 2</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">Numeric comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>1 &gt; 2</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Numeric comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>13 == '13'</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>'a' &lt;= 'b'</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">String comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>'a' &gt; 'b'</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">String comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.obj == $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.obj != $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.obj == $.obj</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">Object comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.obj != $.obj</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Object comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.arr == $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">Array comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.arr != $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Array comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.obj == 17</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.obj != 17</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.obj &lt;= $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Objects and arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.obj &lt; $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Objects and arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.obj &lt;= $.obj</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>==</tt> implies <tt>&lt;=</tt></td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.arr &lt;= $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>==</tt> implies <tt>&lt;=</tt></td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>1 &lt;= $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>1 &gt;= $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>1 &gt; $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>1 &lt; $.arr</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>true &lt;= true</tt></td>
                  <td align="center" colspan="1" rowspan="1">true</td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>==</tt> implies <tt>&lt;=</tt></td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>true &gt; true</tt></td>
                  <td align="center" colspan="1" rowspan="1">false</td>
                  <td align="center" colspan="1" rowspan="1">Booleans do not offer <tt>&lt;</tt> comparison</td>
                </tr>
              </tbody>
            </table>
            <t indent="0" pn="section-2.3.5.3-6">The second set of examples shows some complete JSONPath queries that make use
of filter selectors and the results of evaluating these queries on a
given JSON value as input.
(Note: Two of the queries employ function extensions; please see
Sections <xref format="counter" target="match" sectionFormat="of" derivedContent="2.4.6"/> and <xref format="counter" target="search" sectionFormat="of" derivedContent="2.4.7"/> for details about these.)</t>
            <t indent="0" pn="section-2.3.5.3-7">JSON:</t>
            <sourcecode type="json" markers="false" pn="section-2.3.5.3-8">
{
  "a": [3, 5, 1, 2, 4, 6,
        {"b": "j"},
        {"b": "k"},
        {"b": {}},
        {"b": "kilo"}
       ],
  "o": {"p": 1, "q": 2, "r": 3, "s": 5, "t": {"u": 6}},
  "e": "f"
}
</sourcecode>
            <t indent="0" pn="section-2.3.5.3-9">Queries:</t>
            <t indent="0" pn="section-2.3.5.3-10">The examples in <xref target="tbl-filter" format="default" sectionFormat="of" derivedContent="Table 12"/> show the filter selector in use by a child segment.</t>
            <table anchor="tbl-filter" align="center" pn="table-12">
              <name slugifiedName="name-filter-selector-examples">Filter Selector Examples</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Query</th>
                  <th align="left" colspan="1" rowspan="1">Result</th>
                  <th align="center" colspan="1" rowspan="1">Result Paths</th>
                  <th align="left" colspan="1" rowspan="1">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[?@.b == 'kilo']</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"b": "kilo"}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][9]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Member value comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[?(@.b == 'kilo')]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"b": "kilo"}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][9]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Equivalent query with enclosing parentheses</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[?@&gt;3.5]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>5</tt> <br/> <tt>4</tt> <br/> <tt>6</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][1]</tt> <br/> <tt>$['a'][4]</tt> <br/> <tt>$['a'][5]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Array value comparison</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[?@.b]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"b": "j"}</tt> <br/> <tt>{"b": "k"}</tt> <br/> <tt>{"b": {}}</tt> <br/> <tt>{"b": "kilo"}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][6]</tt> <br/> <tt>$['a'][7]</tt> <br/> <tt>$['a'][8]</tt> <br/> <tt>$['a'][9]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Array value existence</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[?@.*]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>[3, 5, 1, 2, 4, 6, {"b": "j"}, {"b": "k"}, {"b": {}}, {"b": "kilo"}]</tt> <br/> <tt>{"p": 1, "q": 2, "r": 3, "s": 5, "t": {"u": 6}}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a']</tt> <br/> <tt>$['o']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Existence of non-singular queries</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[?@[?@.b]]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>[3, 5, 1, 2, 4, 6, {"b": "j"}, {"b": "k"}, {"b": {}}, {"b": "kilo"}]</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Nested filters</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o[?@&lt;3, ?@&lt;3]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>2</tt> <br/> <tt>1</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['p']</tt> <br/> <tt>$['o']['q']</tt> <br/> <tt>$['o']['q']</tt> <br/> <tt>$['o']['p']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Non-deterministic ordering</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[?@&lt;2 || @.b == "k"]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>1</tt> <br/> <tt>{"b": "k"}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][2]</tt> <br/> <tt>$['a'][7]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Array value logical OR</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[?match(@.b, "[jk]")]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"b": "j"}</tt> <br/> <tt>{"b": "k"}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][6]</tt> <br/> <tt>$['a'][7]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Array value regular expression match</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[?search(@.b, "[jk]")]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"b": "j"}</tt> <br/> <tt>{"b": "k"}</tt> <br/> <tt>{"b": "kilo"}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][6]</tt> <br/> <tt>$['a'][7]</tt> <br/> <tt>$['a'][9]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Array value regular expression search</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o[?@&gt;1 &amp;&amp; @&lt;4]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>2</tt> <br/> <tt>3</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['q']</tt> <br/> <tt>$['o']['r']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Object value logical AND</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o[?@&gt;1 &amp;&amp; @&lt;4]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>3</tt> <br/> <tt>2</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['r']</tt> <br/> <tt>$['o']['q']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Alternative result</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o[?@.u || @.x]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"u": 6}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['t']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Object value logical OR</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[?@.b == $.x]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>3</tt> <br/> <tt>5</tt> <br/> <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>4</tt> <br/> <tt>6</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][0]</tt> <br/><tt>$['a'][1]</tt> <br/> <tt>$['a'][2]</tt> <br/> <tt>$['a'][3]</tt> <br/> <tt>$['a'][4]</tt> <br/> <tt>$['a'][5]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Comparison of queries with no values</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a[?@ == @]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>3</tt> <br/> <tt>5</tt> <br/> <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>4</tt> <br/> <tt>6</tt> <br/> <tt>{"b": "j"}</tt> <br/> <tt>{"b": "k"}</tt> <br/> <tt>{"b": {}}</tt> <br/> <tt>{"b": "kilo"}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][0]</tt> <br/> <tt>$['a'][1]</tt> <br/><tt>$['a'][2]</tt> <br/><tt>$['a'][3]</tt> <br/><tt>$['a'][4]</tt> <br/><tt>$['a'][5]</tt> <br/><tt>$['a'][6]</tt> <br/><tt>$['a'][7]</tt> <br/><tt>$['a'][8]</tt> <br/><tt>$['a'][9]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Comparisons of primitive and of structured values</td>
                </tr>
              </tbody>
            </table>
            <t indent="0" pn="section-2.3.5.3-12">The example above with the query <tt>$.o[?@&lt;3, ?@&lt;3]</tt> shows that a filter selector may produce nodelists in distinct
orders each time it appears in the child segment.</t>
          </section>
        </section>
      </section>
      <section anchor="fnex" numbered="true" removeInRFC="false" toc="include" pn="section-2.4">
        <name slugifiedName="name-function-extensions">Function Extensions</name>
        <t indent="0" pn="section-2.4-1">Beyond the filter expression functionality defined in the preceding
subsections, JSONPath defines an extension point that can be used to
add filter expression functionality: "Function Extensions".</t>
        <t indent="0" pn="section-2.4-2">This section defines the extension point and some function
extensions that use this extension point.
While these mechanisms are designed to use the extension point,
they are an integral part of the JSONPath specification and are
expected to be implemented like any other integral part of this
specification.</t>
        <t indent="0" pn="section-2.4-3">A function extension defines a registered name (see <xref target="iana-fnex" format="default" sectionFormat="of" derivedContent="Section 3.2"/>) that
can be applied to a sequence of zero or more arguments, producing a
result. Each registered function name is unique.</t>
        <t indent="0" pn="section-2.4-4">A function extension <bcp14>MUST</bcp14> be defined such that its evaluation is
free of side effects, i.e., all possible orders of evaluation and choices
of short-circuiting or full evaluation of an expression containing it
<bcp14>MUST</bcp14> lead to the same result.
(Note: Memoization or logging are not side effects in this sense
as they are visible at the implementation level only -- they do not
influence the result of the evaluation.)</t>
        <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.4-5">
function-name       = function-name-first *function-name-char
function-name-first = LCALPHA
function-name-char  = function-name-first / "_" / DIGIT
LCALPHA             = %x61-7A  ; "a".."z"

function-expr       = function-name "(" S [function-argument
                         *(S "," S function-argument)] S ")"
function-argument   = literal /
                      filter-query / ; (includes singular-query)
                      logical-expr /
                      function-expr
</sourcecode>
        <t indent="0" pn="section-2.4-6">Any function expressions in a query must be well-formed (by conforming to the above ABNF)
and well-typed;
otherwise, the JSONPath implementation <bcp14>MUST</bcp14> raise an error
(see <xref target="synsem-overview" format="default" sectionFormat="of" derivedContent="Section 2.1"/>).
To define which function expressions are well-typed,
a type system is first introduced.</t>
        <section anchor="typesys" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.1">
          <name slugifiedName="name-type-system-for-function-ex">Type System for Function Expressions</name>
          <t indent="0" pn="section-2.4.1-1">Each parameter and the result of a function extension must have a declared type.</t>
          <t indent="0" pn="section-2.4.1-2">Declared types enable checking a JSONPath query for well-typedness
independent of any query argument the JSONPath query is applied to.</t>
          <t indent="0" pn="section-2.4.1-3"><xref target="tbl-types" format="default" sectionFormat="of" derivedContent="Table 13"/> defines the available types in terms of the instances they contain.</t>
          <table anchor="tbl-types" align="center" pn="table-13">
            <name slugifiedName="name-function-extension-type-sys">Function Extension Type System</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Type</th>
                <th align="left" colspan="1" rowspan="1">Instances</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>ValueType</tt></td>
                <td align="left" colspan="1" rowspan="1">JSON values or <tt>Nothing</tt></td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>LogicalType</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>LogicalTrue</tt> or <tt>LogicalFalse</tt></td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">
                  <tt>NodesType</tt></td>
                <td align="left" colspan="1" rowspan="1">Nodelists</td>
              </tr>
            </tbody>
          </table>
          <t indent="0" pn="section-2.4.1-5">Notes:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.1-6">
            <li pn="section-2.4.1-6.1">The only instances that can be directly represented in JSONPath syntax are certain JSON values
in <tt>ValueType</tt> expressed as literals (which, in JSONPath, are limited to primitive values).</li>
            <li pn="section-2.4.1-6.2">The special result <tt>Nothing</tt> represents the absence of a JSON value and is distinct from any JSON value, including <tt>null</tt>.</li>
            <li pn="section-2.4.1-6.3">
              <tt>LogicalTrue</tt> and <tt>LogicalFalse</tt> are unrelated to the JSON values expressed by the
literals <tt>true</tt> and <tt>false</tt>.</li>
          </ul>
        </section>
        <section anchor="type-conv" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.2">
          <name slugifiedName="name-type-conversion">Type Conversion</name>
          <t indent="0" pn="section-2.4.2-1">Just as queries can be used in logical expressions by testing for the
existence of at least one node (<xref target="extest" format="default" sectionFormat="of" derivedContent="Section 2.3.5.2.1"/>), a function expression of
declared type <tt>NodesType</tt> can be used as a function argument for a
parameter of declared type <tt>LogicalType</tt>, with the equivalent conversion rule:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.2-2">
            <li pn="section-2.4.2-2.1">If the nodelist contains one or more nodes, the conversion result is <tt>LogicalTrue</tt>.</li>
            <li pn="section-2.4.2-2.2">If the nodelist is empty, the conversion result is <tt>LogicalFalse</tt>.</li>
          </ul>
          <t indent="0" pn="section-2.4.2-3">Notes:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.2-4">
            <li pn="section-2.4.2-4.1">Extraction of a value from a nodelist can be performed in several
ways, so an implicit conversion from <tt>NodesType</tt> to <tt>ValueType</tt>
may be surprising and has therefore not been defined.</li>
            <li pn="section-2.4.2-4.2">A function expression with a declared type of <tt>NodesType</tt> can
indirectly be used as an argument for a parameter of declared type
<tt>ValueType</tt> by wrapping the expression in a call to a function extension,
such as <tt>value()</tt> (see <xref target="value" format="default" sectionFormat="of" derivedContent="Section 2.4.8"/>),
that takes a parameter of type <tt>NodesType</tt> and returns a
result of type <tt>ValueType</tt>.</li>
          </ul>
          <t indent="0" pn="section-2.4.2-5">The well-typedness of function expressions can now be defined in terms of this type system.</t>
        </section>
        <section anchor="well-typedness" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.3">
          <name slugifiedName="name-well-typedness-of-function-">Well-Typedness of Function Expressions</name>
          <t indent="0" pn="section-2.4.3-1">For a function expression to be well-typed:</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-2.4.3-2">
	    <li pn="section-2.4.3-2.1" derivedCounter="1.">
              <t indent="0" pn="section-2.4.3-2.1.1">Its declared type must be well-typed in the context in which it occurs.</t>
              <t indent="0" pn="section-2.4.3-2.1.2">As per the grammar, a function expression can occur in three different                       
immediate contexts, which lead to the following conditions for well-typedness:</t>
              <dl newline="true" indent="3" spacing="normal" pn="section-2.4.3-2.1.3">
                <dt pn="section-2.4.3-2.1.3.1">As a <tt>test-expr</tt> in a logical expression:</dt>
                <dd pn="section-2.4.3-2.1.3.2">
                  <t indent="0" pn="section-2.4.3-2.1.3.2.1">The function's declared result type is <tt>LogicalType</tt> or                              
(giving rise to conversion as per <xref target="type-conv" format="default" sectionFormat="of" derivedContent="Section 2.4.2"/>) <tt>NodesType</tt>.</t>
                </dd>
                <dt pn="section-2.4.3-2.1.3.3">As a <tt>comparable</tt> in a comparison:</dt>
                <dd pn="section-2.4.3-2.1.3.4">
                  <t indent="0" pn="section-2.4.3-2.1.3.4.1">The function's declared result type is <tt>ValueType</tt>.</t>
                </dd>
                <dt pn="section-2.4.3-2.1.3.5">As a <tt>function-argument</tt> in another function expression:</dt>
                <dd pn="section-2.4.3-2.1.3.6">
                  <t indent="0" pn="section-2.4.3-2.1.3.6.1">The function's declared result type fulfills the following rules for                         
the corresponding parameter of the enclosing function.</t>
                </dd>
              </dl>
            </li>
            <li pn="section-2.4.3-2.2" derivedCounter="2.">
              <t indent="0" pn="section-2.4.3-2.2.1">Its arguments must be well-typed for the declared type of the corresponding parameters.</t>
              <t indent="0" pn="section-2.4.3-2.2.2">The arguments of the function expression are well-typed when
each argument of the function can be used for the declared type of the
corresponding parameter, according to one of the following
conditions:</t>
              <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.3-2.2.3">
                <li pn="section-2.4.3-2.2.3.1">When the argument is a function expression with the same declared result type as the
declared type of the parameter.</li>
                <li pn="section-2.4.3-2.2.3.2">
                  <t indent="0" pn="section-2.4.3-2.2.3.2.1">When the declared type of the parameter is <tt>LogicalType</tt> and the argument is one of the following:
                  </t>
                  <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.3-2.2.3.2.2">
                    <li pn="section-2.4.3-2.2.3.2.2.1">A function expression with declared result type <tt>NodesType</tt>.
In this case, the argument is converted to LogicalType as per <xref target="type-conv" format="default" sectionFormat="of" derivedContent="Section 2.4.2"/>.</li>
                    <li pn="section-2.4.3-2.2.3.2.2.2">A <tt>logical-expr</tt> that is not a function expression.</li>
                  </ul>
                </li>
                <li pn="section-2.4.3-2.2.3.3">When the declared type of the parameter is <tt>NodesType</tt> and the argument is a query
(which includes singular query).</li>
                <li pn="section-2.4.3-2.2.3.4">
                  <t indent="0" pn="section-2.4.3-2.2.3.4.1">When the declared type of the parameter is <tt>ValueType</tt> and the argument is one of the following:
                  </t>
                  <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.3-2.2.3.4.2">
                    <li pn="section-2.4.3-2.2.3.4.2.1">A value expressed as a literal.</li>
                    <li pn="section-2.4.3-2.2.3.4.2.2">
                      <t indent="0" pn="section-2.4.3-2.2.3.4.2.2.1">A singular query. In this case:
                      </t>
                      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.3-2.2.3.4.2.2.2">
                        <li pn="section-2.4.3-2.2.3.4.2.2.2.1">If the query results in a nodelist consisting of a single node, the
argument is the value of the node.</li>
                        <li pn="section-2.4.3-2.2.3.4.2.2.2.2">If the query results in an empty nodelist, the argument is
the special result <tt>Nothing</tt>.</li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ol>
        </section>
        <section anchor="length" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.4">
          <name slugifiedName="name-length-function-extension"><tt>length()</tt> Function Extension</name>
          <dl indent="3" newline="false" spacing="normal" pn="section-2.4.4-1">
            <dt pn="section-2.4.4-1.1">Parameters:</dt>
            <dd pn="section-2.4.4-1.2">
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-2.4.4-1.2.1"><li pn="section-2.4.4-1.2.1.1" derivedCounter="1.">
                  <tt>ValueType</tt></li>
              </ol>
            </dd>
            <dt pn="section-2.4.4-1.3">Result:</dt>
            <dd pn="section-2.4.4-1.4">
              <t indent="0" pn="section-2.4.4-1.4.1"><tt>ValueType</tt> (unsigned integer or <tt>Nothing</tt>)</t>
            </dd>
          </dl>
          <t indent="0" pn="section-2.4.4-2">The <tt>length()</tt> function extension provides a way to compute the length
of a value and make that available for further processing in the
filter expression:</t>
          <sourcecode type="application/jsonpath" markers="false" pn="section-2.4.4-3">
$[?length(@.authors) &gt;= 5]
</sourcecode>
          <t indent="0" pn="section-2.4.4-4">Its only argument is an instance of <tt>ValueType</tt> (possibly taken from a
singular query, as in the example above).  The result is also an
instance of <tt>ValueType</tt>: an unsigned integer or the special result <tt>Nothing</tt>.</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.4-5">
            <li pn="section-2.4.4-5.1">If the argument value is a string, the result is the number of
Unicode scalar values in the string.</li>
            <li pn="section-2.4.4-5.2">If the argument value is an array, the result is the number of
elements in the array.</li>
            <li pn="section-2.4.4-5.3">If the argument value is an object, the result is the number of
members in the object.</li>
            <li pn="section-2.4.4-5.4">For any other argument value, the result is the special result <tt>Nothing</tt>.</li>
          </ul>
        </section>
        <section anchor="count" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.5">
          <name slugifiedName="name-count-function-extension"><tt>count()</tt> Function Extension</name>
          <dl indent="3" newline="false" spacing="normal" pn="section-2.4.5-1">
            <dt pn="section-2.4.5-1.1">Parameters:</dt>
            <dd pn="section-2.4.5-1.2">
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-2.4.5-1.2.1"><li pn="section-2.4.5-1.2.1.1" derivedCounter="1.">
                  <tt>NodesType</tt></li>
              </ol>
            </dd>
            <dt pn="section-2.4.5-1.3">Result:</dt>
            <dd pn="section-2.4.5-1.4">
              <t indent="0" pn="section-2.4.5-1.4.1"><tt>ValueType</tt> (unsigned integer)</t>
            </dd>
          </dl>
          <t indent="0" pn="section-2.4.5-2">The <tt>count()</tt> function extension provides a way to obtain the number of
nodes in a nodelist and make that available for further processing in
the filter expression:</t>
          <sourcecode type="application/jsonpath" markers="false" pn="section-2.4.5-3">
$[?count(@.*.author) &gt;= 5]
</sourcecode>
          <t indent="0" pn="section-2.4.5-4">Its only argument is a nodelist.
The result is a value (an unsigned integer) that gives the number of
nodes in the nodelist.</t>
          <t indent="0" pn="section-2.4.5-5">Notes:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.5-6">
            <li pn="section-2.4.5-6.1">There is no deduplication of the nodelist.</li>
            <li pn="section-2.4.5-6.2">The number of nodes in the nodelist is counted independent of their
values or any children they may have, e.g., the count of a non-empty
singular nodelist such as <tt>count(@)</tt> is always 1.</li>
          </ul>
        </section>
        <section anchor="match" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.6">
          <name slugifiedName="name-match-function-extension"><tt>match()</tt> Function Extension</name>
          <dl indent="3" newline="false" spacing="normal" pn="section-2.4.6-1">
            <dt pn="section-2.4.6-1.1">Parameters:</dt>
            <dd pn="section-2.4.6-1.2">
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-2.4.6-1.2.1"><li pn="section-2.4.6-1.2.1.1" derivedCounter="1.">
                  <tt>ValueType</tt> (string)</li>
                <li pn="section-2.4.6-1.2.1.2" derivedCounter="2.">
                  <tt>ValueType</tt> (string conforming to <xref target="RFC9485" format="default" sectionFormat="of" derivedContent="RFC9485"/>)</li>
              </ol>
            </dd>
            <dt pn="section-2.4.6-1.3">Result:</dt>
            <dd pn="section-2.4.6-1.4">
              <t indent="0" pn="section-2.4.6-1.4.1"><tt>LogicalType</tt></t>
            </dd>
          </dl>
          <t indent="0" pn="section-2.4.6-2">The <tt>match()</tt> function extension provides a way to check whether (the
entirety of; see <xref target="search" format="default" sectionFormat="of" derivedContent="Section 2.4.7"/>) a given
string matches a given regular expression, which is in the form described in <xref target="RFC9485" format="default" sectionFormat="of" derivedContent="RFC9485"/>.</t>
          <sourcecode type="application/jsonpath" markers="false" pn="section-2.4.6-3">
$[?match(@.date, "1974-05-..")]
</sourcecode>
          <t indent="0" pn="section-2.4.6-4">Its arguments are instances of <tt>ValueType</tt> (possibly taken from a
singular query, as for the first argument in the example above).
If the first argument is not a string or the second argument is not a
string conforming to <xref target="RFC9485" format="default" sectionFormat="of" derivedContent="RFC9485"/>, the result is <tt>LogicalFalse</tt>.
Otherwise, the string that is the first argument is matched against
the I-Regexp contained in the string that is the second argument;
the result is <tt>LogicalTrue</tt> if the string matches the I-Regexp and is
<tt>LogicalFalse</tt> otherwise.</t>
        </section>
        <section anchor="search" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.7">
          <name slugifiedName="name-search-function-extension"><tt>search()</tt> Function Extension</name>
          <dl indent="3" newline="false" spacing="normal" pn="section-2.4.7-1">
            <dt pn="section-2.4.7-1.1">Parameters:</dt>
            <dd pn="section-2.4.7-1.2">
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-2.4.7-1.2.1"><li pn="section-2.4.7-1.2.1.1" derivedCounter="1.">
                  <tt>ValueType</tt> (string)</li>
                <li pn="section-2.4.7-1.2.1.2" derivedCounter="2.">
                  <tt>ValueType</tt> (string conforming to <xref target="RFC9485" format="default" sectionFormat="of" derivedContent="RFC9485"/>)</li>
              </ol>
            </dd>
            <dt pn="section-2.4.7-1.3">Result:</dt>
            <dd pn="section-2.4.7-1.4">
              <t indent="0" pn="section-2.4.7-1.4.1"><tt>LogicalType</tt></t>
            </dd>
          </dl>
          <t indent="0" pn="section-2.4.7-2">The <tt>search()</tt> function extension provides a way to check whether a
given string contains a substring that matches a given regular
expression, which is in the form described in <xref target="RFC9485" format="default" sectionFormat="of" derivedContent="RFC9485"/>.</t>
          <sourcecode type="application/jsonpath" markers="false" pn="section-2.4.7-3">
$[?search(@.author, "[BR]ob")]
</sourcecode>
          <t indent="0" pn="section-2.4.7-4">Its arguments are instances of <tt>ValueType</tt> (possibly taken from a
singular query, as for the first argument in the example above).
If the first argument is not a string or the second argument is not a
string conforming to <xref target="RFC9485" format="default" sectionFormat="of" derivedContent="RFC9485"/>, the result is <tt>LogicalFalse</tt>.
Otherwise, the string that is the first argument is searched for a
substring that matches the I-Regexp contained in the string
that is the second argument; the result is <tt>LogicalTrue</tt> if at
least one such substring exists and is <tt>LogicalFalse</tt> otherwise.</t>
        </section>
        <section anchor="value" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.8">
          <name slugifiedName="name-value-function-extension"><tt>value()</tt> Function Extension</name>
          <dl indent="3" newline="false" spacing="normal" pn="section-2.4.8-1">
            <dt pn="section-2.4.8-1.1">Parameters:</dt>
            <dd pn="section-2.4.8-1.2">
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-2.4.8-1.2.1"><li pn="section-2.4.8-1.2.1.1" derivedCounter="1.">
                  <tt>NodesType</tt></li>
              </ol>
            </dd>
            <dt pn="section-2.4.8-1.3">Result:</dt>
            <dd pn="section-2.4.8-1.4">
              <t indent="0" pn="section-2.4.8-1.4.1"><tt>ValueType</tt></t>
            </dd>
          </dl>
          <t indent="0" pn="section-2.4.8-2">The <tt>value()</tt> function extension provides a way to convert an instance of <tt>NodesType</tt> to a value and
make that available for further processing in the filter expression:</t>
          <sourcecode type="application/jsonpath" markers="false" pn="section-2.4.8-3">
$[?value(@..color) == "red"]
</sourcecode>
          <t indent="0" pn="section-2.4.8-4">Its only argument is an instance of <tt>NodesType</tt> (possibly taken from a
<tt>filter-query</tt>, as in the example above).  The result is an
instance of <tt>ValueType</tt>.</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4.8-5">
            <li pn="section-2.4.8-5.1">If the argument contains a single node, the result is
the value of the node.</li>
            <li pn="section-2.4.8-5.2">If the argument is the empty nodelist or contains multiple nodes, the
result is <tt>Nothing</tt>.</li>
          </ul>
          <t indent="0" pn="section-2.4.8-6">Note: A singular query may be used anywhere where a ValueType is expected,
so there is no need to use the <tt>value()</tt> function extension with a singular query.</t>
        </section>
        <section anchor="examples-6" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.9">
          <name slugifiedName="name-examples-7">Examples</name>
          <table anchor="tbl-function-expr" align="center" pn="table-14">
            <name slugifiedName="name-function-expression-example">Function Expression Examples</name>
            <thead>
              <tr>
                <th align="center" colspan="1" rowspan="1">Query</th>
                <th align="left" colspan="1" rowspan="1">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?length(@) &lt; 3]</tt></td>
                <td align="left" colspan="1" rowspan="1">well-typed</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?length(@.*) &lt; 3]</tt></td>
                <td align="left" colspan="1" rowspan="1">not well-typed since <tt>@.*</tt> is a non-singular query</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?count(@.*) == 1]</tt></td>
                <td align="left" colspan="1" rowspan="1">well-typed</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?count(1) == 1]</tt></td>
                <td align="left" colspan="1" rowspan="1">not well-typed since <tt>1</tt> is not a query or function expression</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?count(foo(@.*)) == 1]</tt></td>
                <td align="left" colspan="1" rowspan="1">well-typed, where <tt>foo()</tt> is a function extension with a parameter of type <tt>NodesType</tt> and result type <tt>NodesType</tt></td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?match(@.timezone, 'Europe/.*')]</tt></td>
                <td align="left" colspan="1" rowspan="1">well-typed</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?match(@.timezone, 'Europe/.*') == true]</tt></td>
                <td align="left" colspan="1" rowspan="1">not well-typed as <tt>LogicalType</tt> may not be used in comparisons</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?value(@..color) == "red"]</tt></td>
                <td align="left" colspan="1" rowspan="1">well-typed</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?value(@..color)]</tt></td>
                <td align="left" colspan="1" rowspan="1">not well-typed as <tt>ValueType</tt> may not be used in a test expression</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?bar(@.a)]</tt></td>
                <td align="left" colspan="1" rowspan="1">well-typed for any function <tt>bar()</tt> with a parameter of any declared type and result type <tt>LogicalType</tt></td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?bnl(@.*)]</tt></td>
                <td align="left" colspan="1" rowspan="1">well-typed for any function <tt>bnl()</tt> with a parameter of declared type <tt>NodesType</tt> or <tt>LogicalType</tt> and result type <tt>LogicalType</tt></td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?blt(1==1)]</tt></td>
                <td align="left" colspan="1" rowspan="1">well-typed, where <tt>blt()</tt> is a function with a parameter of declared type <tt>LogicalType</tt> and result type <tt>LogicalType</tt></td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?blt(1)]</tt></td>
                <td align="left" colspan="1" rowspan="1">not well-typed for the same function <tt>blt()</tt>, as <tt>1</tt> is not a query, <tt>logical-expr</tt>, or function expression</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[?bal(1)]</tt></td>
                <td align="left" colspan="1" rowspan="1">well-typed, where <tt>bal()</tt> is a function with a parameter of declared type <tt>ValueType</tt> and result type <tt>LogicalType</tt></td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="segments-details" numbered="true" removeInRFC="false" toc="include" pn="section-2.5">
        <name slugifiedName="name-segments-2">Segments</name>
        <t indent="0" pn="section-2.5-1">For each node in an input nodelist,
segments apply one or more selectors to the node and concatenate the
results of each selector into per-input-node nodelists, which are then
concatenated in the order of the input nodelist to form a single
segment result nodelist.</t>
        <t indent="0" pn="section-2.5-2">It turns out that the more segments there are in a query, the greater the depth in the input value of the
nodes of the resultant nodelist:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.5-3">
          <li pn="section-2.5-3.1">A query with N segments, where N &gt;= 0, produces a nodelist
consisting of nodes at depth in the input value of N or greater.</li>
          <li pn="section-2.5-3.2">A query with N segments, where N &gt;= 0, all of which are <xref target="child-segment" format="default" sectionFormat="of" derivedContent="Section 2.5.1">child segments</xref>,
produces a nodelist consisting of nodes precisely at depth N in the input value.</li>
        </ul>
        <t indent="0" pn="section-2.5-4">There are two kinds of segments: child segments and descendant segments.</t>
        <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.5-5">
segment             = child-segment / descendant-segment
</sourcecode>
        <t indent="0" pn="section-2.5-6">The syntax and semantics of each kind of segment are defined below.</t>
        <section anchor="child-segment" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.1">
          <name slugifiedName="name-child-segment">Child Segment</name>
          <section anchor="syntax-4" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.1.1">
            <name slugifiedName="name-syntax-8">Syntax</name>
            <t indent="0" pn="section-2.5.1.1-1">The child segment consists of a non-empty, comma-separated
sequence of selectors enclosed in square brackets.</t>
            <t indent="0" pn="section-2.5.1.1-2">Shorthand notations are also provided for when there is a single
wildcard or name selector.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.5.1.1-3">
child-segment       = bracketed-selection /
                      ("."
                       (wildcard-selector /
                        member-name-shorthand))

bracketed-selection = "[" S selector *(S "," S selector) S "]"

member-name-shorthand = name-first *name-char
name-first          = ALPHA /
                      "_"   /
                      %x80-D7FF /
                         ; skip surrogate code points
                      %xE000-10FFFF
name-char           = name-first / DIGIT

DIGIT               = %x30-39              ; 0-9
ALPHA               = %x41-5A / %x61-7A    ; A-Z / a-z
</sourcecode>
            <t indent="0" pn="section-2.5.1.1-4"><tt>.*</tt>, a <tt>child-segment</tt> directly built from a <tt>wildcard-selector</tt>, is
shorthand for <tt>[*]</tt>.</t>
            <t indent="0" pn="section-2.5.1.1-5"><tt>.&lt;member-name&gt;</tt>, a <tt>child-segment</tt> built from a
 <tt>member-name-shorthand</tt>, is shorthand for <tt>['&lt;member-name&gt;']</tt>.
Note: This can only be used with member names that are composed of certain
characters, as specified in the ABNF rule <tt>member-name-shorthand</tt>.
Thus, for example, <tt>$.foo.bar</tt> is shorthand for <tt>$['foo']['bar']</tt> (but not for <tt>$['foo.bar']</tt>).</t>
          </section>
          <section anchor="semantics-6" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.1.2">
            <name slugifiedName="name-semantics-8">Semantics</name>
            <t indent="0" pn="section-2.5.1.2-1">A child segment contains a sequence of selectors, each of which
selects zero or more children of the input value.</t>
            <t indent="0" pn="section-2.5.1.2-2">Selectors of different kinds may be combined within a single child segment.</t>
            <t indent="0" pn="section-2.5.1.2-3">For each node in the input nodelist,
the resulting nodelist of a child segment is the concatenation of
the nodelists from each of its selectors in the order that the selectors
appear in the list.
Note: Any node matched by more than one selector is kept
as many times in the nodelist.</t>
            <t indent="0" pn="section-2.5.1.2-4">Where a selector can produce a nodelist in more than one possible order,
each occurrence of the selector in the child segment
	    may produce a nodelist in a distinct order.</t>
            <t indent="0" pn="section-2.5.1.2-5">In summary, a child segment drills down one more level into the structure of the input value.</t>
          </section>
          <section anchor="examples-7" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.1.3">
            <name slugifiedName="name-examples-8">Examples</name>
            <t indent="0" pn="section-2.5.1.3-1">JSON:</t>
            <sourcecode type="json" markers="false" pn="section-2.5.1.3-2">
["a", "b", "c", "d", "e", "f", "g"]
</sourcecode>
            <t indent="0" pn="section-2.5.1.3-3">Queries:</t>
            <table anchor="tbl-child-segment" align="center" pn="table-15">
              <name slugifiedName="name-child-segment-examples">Child Segment Examples</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Query</th>
                  <th align="left" colspan="1" rowspan="1">Result</th>
                  <th align="center" colspan="1" rowspan="1">Result Paths</th>
                  <th align="left" colspan="1" rowspan="1">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[0, 3]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"a"</tt> <br/> <tt>"d"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[0]</tt> <br/> <tt>$[3]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Indices</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[0:2, 5]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"a"</tt> <br/> <tt>"b"</tt> <br/> <tt>"f"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[0]</tt> <br/> <tt>$[1]</tt> <br/> <tt>$[5]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Slice and index</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[0, 0]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>"a"</tt> <br/> <tt>"a"</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$[0]</tt> <br/> <tt>$[0]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Duplicated entries</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>
        <section anchor="descendant-segment" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.2">
          <name slugifiedName="name-descendant-segment">Descendant Segment</name>
          <section anchor="syntax-5" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.2.1">
            <name slugifiedName="name-syntax-9">Syntax</name>
            <t indent="0" pn="section-2.5.2.1-1">The descendant segment consists of a double dot <tt>..</tt>
followed by a child segment (using bracket notation).</t>
            <t indent="0" pn="section-2.5.2.1-2">Shorthand notations are also provided that correspond to the shorthand forms of the child segment.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf" markers="false" pn="section-2.5.2.1-3">
descendant-segment  = ".." (bracketed-selection /
                            wildcard-selector /
                            member-name-shorthand)
</sourcecode>
            <t indent="0" pn="section-2.5.2.1-4"><tt>..*</tt>, the <tt>descendant-segment</tt> directly built from a
<tt>wildcard-selector</tt>, is shorthand for <tt>..[*]</tt>.</t>
            <t indent="0" pn="section-2.5.2.1-5"><tt>..&lt;member-name&gt;</tt>, a <tt>descendant-segment</tt> built from a
<tt>member-name-shorthand</tt>, is shorthand for <tt>..⁠['&lt;member-name&gt;']</tt>.
Note: As with the similar shorthand of a <tt>child-segment</tt>, this can
only be used with member names that are composed of certain
characters, as specified in the ABNF rule <tt>member-name-shorthand</tt>.</t>
            <t indent="0" pn="section-2.5.2.1-6">Note: On its own, <tt>..</tt> is not a valid segment.</t>
          </section>
          <section anchor="semantics-7" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.2.2">
            <name slugifiedName="name-semantics-9">Semantics</name>
            <t indent="0" pn="section-2.5.2.2-1">A descendant segment produces zero or more descendants of an input value.</t>
            <t indent="0" pn="section-2.5.2.2-2">For each node in the input nodelist,
a descendant selector visits the input node and each of
its descendants such that:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.5.2.2-3">
              <li pn="section-2.5.2.2-3.1">nodes of any array are visited in array order, and</li>
              <li pn="section-2.5.2.2-3.2">nodes are visited before their descendants.</li>
            </ul>
            <t indent="0" pn="section-2.5.2.2-4">The order in which the children of an object are visited is not stipulated, since
JSON objects are unordered.</t>
            <t indent="0" pn="section-2.5.2.2-5">Suppose the descendant segment is of the form <tt>..⁠[&lt;selectors&gt;]</tt> (after converting any shorthand
form to bracket notation),
and the nodes, in the order visited, are <tt>D1</tt>, ..., <tt>Dn</tt> (where <tt>n &gt;= 1</tt>).
Note: <tt>D1</tt> is the input value.</t>
            <t indent="0" pn="section-2.5.2.2-6">For each <tt>i</tt> such that <tt>1 &lt;= i &lt;= n</tt>, the nodelist <tt>Ri</tt> is defined to be a result of applying
the child segment <tt>[&lt;selectors&gt;]</tt> to the node <tt>Di</tt>.</t>
            <t indent="0" pn="section-2.5.2.2-7">For each node in the input nodelist,
the result of the descendant segment is the concatenation of <tt>R1</tt>,
..., <tt>Rn</tt> (in that order).
These results are then concatenated in input nodelist order to form
the result of the segment.</t>
            <t indent="0" pn="section-2.5.2.2-8">In summary, a descendant segment drills down one or more levels into the structure of each input value.</t>
          </section>
          <section anchor="examples-8" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.2.3">
            <name slugifiedName="name-examples-9">Examples</name>
            <t indent="0" pn="section-2.5.2.3-1">JSON:</t>
            <sourcecode type="json" markers="false" pn="section-2.5.2.3-2">
{
  "o": {"j": 1, "k": 2},
  "a": [5, 3, [{"j": 4}, {"k": 6}]]
}
</sourcecode>
            <t indent="0" pn="section-2.5.2.3-3">Queries:</t>
            <t indent="0" pn="section-2.5.2.3-4">(Note that the fourth example can be expressed in two equivalent
queries, shown in <xref target="tbl-descendant-segment" format="default" sectionFormat="of" derivedContent="Table 16"/> in one table row instead of two almost-identical rows.)</t>
            <table anchor="tbl-descendant-segment" align="center" pn="table-16">
              <name slugifiedName="name-descendant-segment-examples">Descendant Segment Examples</name>
              <thead>
                <tr>
                  <th align="center" colspan="1" rowspan="1">Query</th>
                  <th align="left" colspan="1" rowspan="1">Result</th>
                  <th align="center" colspan="1" rowspan="1">Result Paths</th>
                  <th align="left" colspan="1" rowspan="1">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$..j</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>1</tt> <br/> <tt>4</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['j']</tt> <br/> <tt>$['a'][2][0]['j']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Object values</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$..j</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>4</tt> <br/> <tt>1</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][2][0]['j']</tt> <br/> <tt>$['o']['j']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Alternative result</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$..[0]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>5</tt> <br/> <tt>{"j": 4}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][0]</tt> <br/> <tt>$['a'][2][0]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Array values</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$..[*]</tt> <br/>or<br/> <tt>$..*</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"j": 1, "k": 2}</tt> <br/> <tt>[5, 3, [{"j": 4}, {"k": 6}]]</tt> <br/> <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>5</tt> <br/> <tt>3</tt> <br/> <tt>[{"j": 4}, {"k": 6}]</tt> <br/> <tt>{"j": 4}</tt> <br/> <tt>{"k": 6}</tt> <br/> <tt>4</tt> <br/> <tt>6</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']</tt> <br/> <tt>$['a']</tt> <br/> <tt>$['o']['j']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['a'][0]</tt> <br/> <tt>$['a'][1]</tt> <br/> <tt>$['a'][2]</tt> <br/> <tt>$['a'][2][0]</tt> <br/> <tt>$['a'][2][1]</tt> <br/> <tt>$['a'][2][0]['j']</tt> <br/> <tt>$['a'][2][1]['k']</tt></td>
                  <td align="left" colspan="1" rowspan="1">All values</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$..o</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>{"j": 1, "k": 2}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Input value is visited</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.o..[*, *]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>2</tt> <br/> <tt>1</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['o']['j']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['o']['j']</tt></td>
                  <td align="left" colspan="1" rowspan="1">Non-deterministic ordering</td>
                </tr>
                <tr>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$.a..[0, 1]</tt></td>
                  <td align="left" colspan="1" rowspan="1">
                    <tt>5</tt> <br/> <tt>3</tt> <br/> <tt>{"j": 4}</tt> <br/> <tt>{"k": 6}</tt></td>
                  <td align="center" colspan="1" rowspan="1">
                    <tt>$['a'][0]</tt> <br/> <tt>$['a'][1]</tt> <br/> <tt>$['a'][2][0]</tt> <br/> <tt>$['a'][2][1]</tt></td>
                  <td align="left" colspan="1" rowspan="1">Multiple segments</td>
                </tr>
              </tbody>
            </table>
            <t indent="0" pn="section-2.5.2.3-6">Note: The ordering of the results for the <tt>$..[*]</tt> and <tt>$..*</tt> examples above is not guaranteed, except that:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.5.2.3-7">
              <li pn="section-2.5.2.3-7.1">
                <tt>{"j": 1, "k": 2}</tt> must appear before <tt>1</tt> and <tt>2</tt>,</li>
              <li pn="section-2.5.2.3-7.2">
                <tt>[5, 3, [{"j": 4}, {"k": 6}]]</tt> must appear before <tt>5</tt>, <tt>3</tt>, and <tt>[{"j": 4}, {"k": 6}]</tt>,</li>
              <li pn="section-2.5.2.3-7.3">
                <tt>5</tt> must appear before <tt>3</tt>, which must appear before <tt>[{"j": 4}, {"k": 6}]</tt>,</li>
              <li pn="section-2.5.2.3-7.4">
                <tt>5</tt> and <tt>3</tt> must appear before <tt>{"j": 4}</tt>, <tt>4</tt>, <tt>{"k": 6}</tt>, and <tt>6</tt>,</li>
              <li pn="section-2.5.2.3-7.5">
                <tt>[{"j": 4}, {"k": 6}]</tt> must appear before <tt>{"j": 4}</tt> and <tt>{"k": 6}</tt>,</li>
              <li pn="section-2.5.2.3-7.6">
                <tt>{"j": 4}</tt> must appear before <tt>{"k": 6}</tt>,</li>
              <li pn="section-2.5.2.3-7.7">
                <tt>{"k": 6}</tt> must appear before <tt>4</tt>, and</li>
              <li pn="section-2.5.2.3-7.8">
                <tt>4</tt> must appear before <tt>6</tt>.</li>
            </ul>
            <t indent="0" pn="section-2.5.2.3-8">The example above with the query <tt>$.o..[*, *]</tt> shows that a selector may produce nodelists in distinct orders
each time it appears in the descendant segment.</t>
            <t indent="0" pn="section-2.5.2.3-9">The example above with the query <tt>$.a..[0, 1]</tt> shows that the child segment <tt>[0, 1]</tt> is applied to each node
in turn (rather than the nodes being visited once per selector, which is the case for some JSONPath implementations
that do not conform to this specification).</t>
          </section>
        </section>
      </section>
      <section anchor="null-semantics" numbered="true" removeInRFC="false" toc="include" pn="section-2.6">
        <name slugifiedName="name-semantics-of-null">Semantics of <tt>null</tt></name>
        <t indent="0" pn="section-2.6-1">Note: JSON <tt>null</tt> is treated the same as any other JSON value, i.e., it is not taken to mean "undefined" or "missing".</t>
        <section anchor="examples-9" numbered="true" removeInRFC="false" toc="include" pn="section-2.6.1">
          <name slugifiedName="name-examples-10">Examples</name>
          <t indent="0" pn="section-2.6.1-1">JSON:</t>
          <sourcecode type="json" markers="false" pn="section-2.6.1-2">
{"a": null, "b": [null], "c": [{}], "null": 1}
</sourcecode>
          <t indent="0" pn="section-2.6.1-3">Queries:</t>
          <table anchor="tbl-null-examples" align="center" pn="table-17">
            <name slugifiedName="name-examples-involving-or-not-i">Examples Involving (or Not Involving) <tt>null</tt></name>
            <thead>
              <tr>
                <th align="center" colspan="1" rowspan="1">Query</th>
                <th align="left" colspan="1" rowspan="1">Result</th>
                <th align="center" colspan="1" rowspan="1">Result Paths</th>
                <th align="left" colspan="1" rowspan="1">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.a</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>null</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['a']</tt></td>
                <td align="left" colspan="1" rowspan="1">Object value</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.a[0]</tt></td>
                <td align="left" colspan="1" rowspan="1"> </td>
                <td align="center" colspan="1" rowspan="1"> </td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>null</tt> used as array</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.a.d</tt></td>
                <td align="left" colspan="1" rowspan="1"> </td>
                <td align="center" colspan="1" rowspan="1"> </td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>null</tt> used as object</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.b[0]</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>null</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['b'][0]</tt></td>
                <td align="left" colspan="1" rowspan="1">Array value</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.b[*]</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>null</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['b'][0]</tt></td>
                <td align="left" colspan="1" rowspan="1">Array value</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.b[?@]</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>null</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['b'][0]</tt></td>
                <td align="left" colspan="1" rowspan="1">Existence</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.b[?@==null]</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>null</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['b'][0]</tt></td>
                <td align="left" colspan="1" rowspan="1">Comparison</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.c[?@.d==null]</tt></td>
                <td align="left" colspan="1" rowspan="1"> </td>
                <td align="center" colspan="1" rowspan="1"> </td>
                <td align="left" colspan="1" rowspan="1">Comparison with "missing" value</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.null</tt></td>
                <td align="left" colspan="1" rowspan="1">
                  <tt>1</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['null']</tt></td>
                <td align="left" colspan="1" rowspan="1">Not JSON <tt>null</tt> at all, just a member name string</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="normalized-paths" numbered="true" removeInRFC="false" toc="include" pn="section-2.7">
        <name slugifiedName="name-normalized-paths">Normalized Paths</name>
        <t indent="0" pn="section-2.7-1">A Normalized Path is a unique representation of the location of a node in a value that
uniquely identifies the node in the value.
Specifically, a Normalized Path is a JSONPath query with restricted syntax (defined below),
e.g., <tt>$['book'][3]</tt>, which when applied to the value, results in a nodelist consisting
of just the node identified by the Normalized Path.
Note: A Normalized Path represents the identity of a node <em>in a specific value</em>.
There is precisely one Normalized Path identifying any particular node in a value.</t>
        <t indent="0" pn="section-2.7-2">A nodelist may be represented compactly in JSON as an array of strings, where the strings are
Normalized Paths.</t>
        <t indent="0" pn="section-2.7-3">Normalized Paths provide a predictable format that simplifies testing and post-processing
of nodelists, e.g., to remove duplicate nodes.
Normalized Paths are used in this document as result paths in examples.</t>
        <t indent="0" pn="section-2.7-4">Normalized Paths use the canonical bracket notation, rather than dot notation.</t>
        <t indent="0" pn="section-2.7-5">Single quotes are used in Normalized Paths to delimit string member names. This reduces the
number of characters that need escaping when Normalized Paths appear in
strings delimited by double quotes, e.g., in JSON texts.</t>
        <t indent="0" pn="section-2.7-6">Certain characters are escaped in Normalized Paths in one and only one way; all other
	characters are unescaped.</t>
        <aside pn="section-2.7-7">
          <t indent="0" pn="section-2.7-7.1">Note: Normalized Paths are singular queries, but not all singular queries are Normalized Paths.
For example, <tt>$[-3]</tt> is a singular query but is not a Normalized Path.
The Normalized Path equivalent to <tt>$[-3]</tt> would have an index equal to the array length minus <tt>3</tt>.
	(The array length must be at least <tt>3</tt> if <tt>$[-3]</tt> is to identify a node.)</t>
        </aside>
        <sourcecode type="abnf" name="normalized-path-collected.abnf" markers="false" pn="section-2.7-8">
normalized-path      = root-identifier *(normal-index-segment)
normal-index-segment = "[" normal-selector "]"
normal-selector      = normal-name-selector / normal-index-selector
normal-name-selector = %x27 *normal-single-quoted %x27 ; 'string'
normal-single-quoted = normal-unescaped /
                       ESC normal-escapable
normal-unescaped     =    ; omit %x0-1F control codes
                       %x20-26 /
                          ; omit 0x27 '
                       %x28-5B /
                          ; omit 0x5C \
                       %x5D-D7FF /
                          ; skip surrogate code points
                       %xE000-10FFFF

normal-escapable     = %x62 / ; b BS backspace U+0008
                       %x66 / ; f FF form feed U+000C
                       %x6E / ; n LF line feed U+000A
                       %x72 / ; r CR carriage return U+000D
                       %x74 / ; t HT horizontal tab U+0009
                       "'" /  ; ' apostrophe U+0027
                       "\" /  ; \ backslash (reverse solidus) U+005C
                       (%x75 normal-hexchar)
                                       ; certain values u00xx U+00XX
normal-hexchar       = "0" "0"
                       (
                          ("0" %x30-37) / ; "00"-"07"
                             ; omit U+0008-U+000A BS HT LF
                          ("0" %x62) /    ; "0b"
                             ; omit U+000C-U+000D FF CR
                          ("0" %x65-66) / ; "0e"-"0f"
                          ("1" normal-HEXDIG)
                       )
normal-HEXDIG        = DIGIT / %x61-66    ; "0"-"9", "a"-"f"
normal-index-selector = "0" / (DIGIT1 *DIGIT)
                        ; non-negative decimal integer
</sourcecode>
        <t indent="0" pn="section-2.7-9">Since there can only be one Normalized Path identifying a given node, the syntax
stipulates which characters are escaped and which are not.
So the definition of <tt>normal-hexchar</tt> is designed for hex escaping of characters
that are not straightforwardly printable, for example, U+000B LINE TABULATION, but
for which no standard JSON escape, such as <tt>\n</tt>, is available.</t>
        <section anchor="examples-10" numbered="true" removeInRFC="false" toc="include" pn="section-2.7.1">
          <name slugifiedName="name-examples-11">Examples</name>
          <table anchor="tbl-normalized-path-examples" align="center" pn="table-18">
            <name slugifiedName="name-normalized-path-examples">Normalized Path Examples</name>
            <thead>
              <tr>
                <th align="center" colspan="1" rowspan="1">Path</th>
                <th align="center" colspan="1" rowspan="1">Normalized Path</th>
                <th align="left" colspan="1" rowspan="1">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.a</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['a']</tt></td>
                <td align="left" colspan="1" rowspan="1">Object value</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[1]</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[1]</tt></td>
                <td align="left" colspan="1" rowspan="1">Array index</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[-3]</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$[2]</tt></td>
                <td align="left" colspan="1" rowspan="1">Negative array index for an array of length 5</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$.a.b[1:2]</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['a']['b'][1]</tt></td>
                <td align="left" colspan="1" rowspan="1">Nested structure</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$["\u000B"]</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['\u000b']</tt></td>
                <td align="left" colspan="1" rowspan="1">Unicode escape</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$["\u0061"]</tt></td>
                <td align="center" colspan="1" rowspan="1">
                  <tt>$['a']</tt></td>
                <td align="left" colspan="1" rowspan="1">Unicode character</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
    </section>
    <section anchor="IANA" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <section anchor="registration-of-media-type-applicationjsonpath" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-registration-of-media-type-">Registration of Media Type application/jsonpath</name>
        <t indent="0" pn="section-3.1-1">IANA has registered the following media type <xref target="RFC6838" format="default" sectionFormat="of" derivedContent="RFC6838"/>:</t>
        <dl indent="3" newline="false" spacing="normal" pn="section-3.1-2">
          <dt pn="section-3.1-2.1">Type name:</dt>
          <dd pn="section-3.1-2.2">
            <t indent="0" pn="section-3.1-2.2.1">application</t>
          </dd>
          <dt pn="section-3.1-2.3">Subtype name:</dt>
          <dd pn="section-3.1-2.4">
            <t indent="0" pn="section-3.1-2.4.1">jsonpath</t>
          </dd>
          <dt pn="section-3.1-2.5">Required parameters:</dt>
          <dd pn="section-3.1-2.6">
            <t indent="0" pn="section-3.1-2.6.1">N/A</t>
          </dd>
          <dt pn="section-3.1-2.7">Optional parameters:</dt>
          <dd pn="section-3.1-2.8">
            <t indent="0" pn="section-3.1-2.8.1">N/A</t>
          </dd>
          <dt pn="section-3.1-2.9">Encoding considerations:</dt>
          <dd pn="section-3.1-2.10">
            <t indent="0" pn="section-3.1-2.10.1">binary (UTF-8)</t>
          </dd>
          <dt pn="section-3.1-2.11">Security considerations:</dt>
          <dd pn="section-3.1-2.12">
            <t indent="0" pn="section-3.1-2.12.1">See the Security Considerations section of RFC 9535.</t>
          </dd>
          <dt pn="section-3.1-2.13">Interoperability considerations:</dt>
          <dd pn="section-3.1-2.14">
            <t indent="0" pn="section-3.1-2.14.1">N/A</t>
          </dd>
          <dt pn="section-3.1-2.15">Published specification:</dt>
          <dd pn="section-3.1-2.16">
            <t indent="0" pn="section-3.1-2.16.1">RFC 9535</t>
          </dd>
          <dt pn="section-3.1-2.17">Applications that use this media type:</dt>
          <dd pn="section-3.1-2.18">
            <t indent="0" pn="section-3.1-2.18.1">Applications that need to convey queries in JSON data</t>
          </dd>
          <dt pn="section-3.1-2.19">Fragment identifier considerations:</dt>
          <dd pn="section-3.1-2.20">
            <t indent="0" pn="section-3.1-2.20.1">N/A</t>
          </dd>
          <dt pn="section-3.1-2.21">Additional information:</dt>
          <dd pn="section-3.1-2.22">
            <t indent="0" pn="section-3.1-2.22.1"><br/></t>
            <dl spacing="compact" indent="3" newline="false" pn="section-3.1-2.22.2">
              <dt pn="section-3.1-2.22.2.1">Deprecated alias names for this type:</dt>
              <dd pn="section-3.1-2.22.2.2">
                <t indent="0" pn="section-3.1-2.22.2.2.1">N/A</t>
              </dd>
              <dt pn="section-3.1-2.22.2.3">Magic number(s):</dt>
              <dd pn="section-3.1-2.22.2.4">
                <t indent="0" pn="section-3.1-2.22.2.4.1">N/A</t>
              </dd>
              <dt pn="section-3.1-2.22.2.5">File extension(s):</dt>
              <dd pn="section-3.1-2.22.2.6">
                <t indent="0" pn="section-3.1-2.22.2.6.1">N/A</t>
              </dd>
              <dt pn="section-3.1-2.22.2.7">Macintosh file type code(s):</dt>
              <dd pn="section-3.1-2.22.2.8">
                <t indent="0" pn="section-3.1-2.22.2.8.1">N/A</t>
              </dd>
            </dl>
          </dd>
          <dt pn="section-3.1-2.23">Person &amp; email address to contact for further information:</dt>
          <dd pn="section-3.1-2.24">iesg@ietf.org</dd>
          <dt pn="section-3.1-2.25">Intended usage:</dt>
          <dd pn="section-3.1-2.26">
            <t indent="0" pn="section-3.1-2.26.1">COMMON</t>
          </dd>
          <dt pn="section-3.1-2.27">Restrictions on usage:</dt>
          <dd pn="section-3.1-2.28">
            <t indent="0" pn="section-3.1-2.28.1">N/A</t>
          </dd>
          <dt pn="section-3.1-2.29">Author:</dt>
          <dd pn="section-3.1-2.30">
            <t indent="0" pn="section-3.1-2.30.1">JSONPath WG</t>
          </dd>
          <dt pn="section-3.1-2.31">Change controller:</dt>
          <dd pn="section-3.1-2.32">
            <t indent="0" pn="section-3.1-2.32.1">IETF</t>
          </dd>
        </dl>
      </section>
      <section anchor="iana-fnex" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-function-extensions-subregi">Function Extensions Subregistry</name>
        <t indent="0" pn="section-3.2-1">Per this specification, IANA has created a new "Function Extensions" subregistry in
a new "JSONPath" registry. The "Function Extensions" subregistry has the policy "Expert Review"
(<xref section="4.5" sectionFormat="of" target="RFC8126" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.5" derivedContent="RFC8126"/>).</t>
        <t anchor="de-instructions" indent="0" pn="section-3.2-2">The experts are instructed to be frugal in the allocation of function
extension names that are suggestive of generally applicable semantics,
keeping them in reserve for functions that are likely to enjoy wide
use and can make good use of their conciseness.
The expert is also instructed to direct the registrant to provide a
specification (<xref section="4.6" sectionFormat="of" target="RFC8126" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.6" derivedContent="RFC8126"/>) but can make exceptions,
for instance, when a specification is not available at the time of
registration but is likely forthcoming.
If the expert becomes aware of function extensions that are deployed and
in use, they may also initiate a registration on their own if
they deem such a registration can avert potential future collisions.</t>
        <t indent="0" pn="section-3.2-3">Each entry in the subregistry must include the following:</t>
        <dl newline="true" indent="3" spacing="normal" pn="section-3.2-4">
          <dt pn="section-3.2-4.1">Function Name:</dt>
          <dd pn="section-3.2-4.2">
            <t indent="0" pn="section-3.2-4.2.1">A lowercase ASCII <xref target="RFC0020" format="default" sectionFormat="of" derivedContent="RFC0020"/> string that starts with a letter and can
contain letters, digits, and underscore characters afterwards
(<tt>[a-z][_a-z0-9]*</tt>). No other entry in the subregistry can have the
same function name.</t>
          </dd>
          <dt pn="section-3.2-4.3">Brief description:</dt>
          <dd pn="section-3.2-4.4">
            <t indent="0" pn="section-3.2-4.4.1">A brief description</t>
          </dd>
          <dt pn="section-3.2-4.5">Parameters:</dt>
          <dd pn="section-3.2-4.6">
            <t indent="0" pn="section-3.2-4.6.1">A comma-separated list of zero or more declared types, one for each of the
arguments expected for this function extension</t>
          </dd>
          <dt pn="section-3.2-4.7">Result:</dt>
          <dd pn="section-3.2-4.8">
            <t indent="0" pn="section-3.2-4.8.1">The declared type of the result for this function extension</t>
          </dd>
          <dt pn="section-3.2-4.9">Change Controller:</dt>
          <dd pn="section-3.2-4.10">
            <t indent="0" pn="section-3.2-4.10.1">See <xref section="2.3" sectionFormat="of" target="RFC8126" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-2.3" derivedContent="RFC8126"/>.</t>
          </dd>
          <dt pn="section-3.2-4.11">Reference:</dt>
          <dd pn="section-3.2-4.12">
            <t indent="0" pn="section-3.2-4.12.1">A reference document that provides a description of the function
extension</t>
          </dd>
        </dl>
        <t indent="0" pn="section-3.2-5">The initial entries in this subregistry are listed in <xref target="pre-reg" format="default" sectionFormat="of" derivedContent="Table 19"/>; the
entries in the "Change Controller" column all have the value "IETF",
and the entries in the
"Reference" column all have the value "<xref target="fnex" format="default" sectionFormat="of" derivedContent="Section 2.4"/> of RFC 9535":</t>
        <table anchor="pre-reg" align="center" pn="table-19">
          <name slugifiedName="name-initial-entries-in-the-func">Initial Entries in the Function Extensions Subregistry</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Function Name</th>
              <th align="left" colspan="1" rowspan="1">Brief Description</th>
              <th align="left" colspan="1" rowspan="1">Parameters</th>
              <th align="left" colspan="1" rowspan="1">Result</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">length</td>
              <td align="left" colspan="1" rowspan="1">length of string, array, or object</td>
              <td align="left" colspan="1" rowspan="1">
                <tt>ValueType</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>ValueType</tt></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">count</td>
              <td align="left" colspan="1" rowspan="1">size of nodelist</td>
              <td align="left" colspan="1" rowspan="1">
                <tt>NodesType</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>ValueType</tt></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">match</td>
              <td align="left" colspan="1" rowspan="1">regular expression full match</td>
              <td align="left" colspan="1" rowspan="1">
                <tt>ValueType</tt>, <tt>ValueType</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>LogicalType</tt></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">search</td>
              <td align="left" colspan="1" rowspan="1">regular expression substring match</td>
              <td align="left" colspan="1" rowspan="1">
                <tt>ValueType</tt>, <tt>ValueType</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>LogicalType</tt></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">value</td>
              <td align="left" colspan="1" rowspan="1">value of the single node in nodelist</td>
              <td align="left" colspan="1" rowspan="1">
                <tt>NodesType</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>ValueType</tt></td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="Security" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-4-1">Security considerations for JSONPath can stem from:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4-2">
        <li pn="section-4-2.1">attack vectors on JSONPath implementations,</li>
        <li pn="section-4-2.2">attack vectors on how JSONPath queries are formed, and</li>
        <li pn="section-4-2.3">the way JSONPath is used in security-relevant mechanisms.</li>
      </ul>
      <section anchor="attack-vectors-on-jsonpath-implementations" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-attack-vectors-on-jsonpath-">Attack Vectors on JSONPath Implementations</name>
        <t indent="0" pn="section-4.1-1">Historically, JSONPath has often been implemented by feeding parts of
the query to an underlying programming language engine, e.g.,
JavaScript's <tt>eval()</tt> function.
This approach is well known to lead to injection attacks and would
require perfect input validation to prevent these attacks (see
<xref section="12" sectionFormat="of" target="RFC8259" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8259#section-12" derivedContent="RFC8259"/> for similar considerations for JSON itself).
Instead, JSONPath implementations need to implement the entire syntax
of the query without relying on the parsers of programming language
engines.</t>
        <t indent="0" pn="section-4.1-2">Attacks on availability may attempt to trigger unusually expensive
runtime performance exhibited by certain implementations in certain
cases.
(See <xref section="10" sectionFormat="of" target="RFC8949" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8949#section-10" derivedContent="RFC8949"/> for issues in hash-table implementations
and <xref section="8" sectionFormat="of" target="RFC9485" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9485#section-8" derivedContent="RFC9485"/> for performance issues in regular
expression implementations.)
Implementers need to be aware that good average performance is not
sufficient as long as an attacker can choose to submit specially
crafted JSONPath queries or query arguments that trigger surprisingly high, possibly
exponential, CPU usage or, for example, via a naive recursive implementation of the descendant segment,
stack overflow. Implementations need to have appropriate resource management
to mitigate these attacks.</t>
      </section>
      <section anchor="attack-vectors-on-how-jsonpath-queries-are-formed" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-attack-vectors-on-how-jsonp">Attack Vectors on How JSONPath Queries Are Formed</name>
        <t indent="0" pn="section-4.2-1">JSONPath queries are often not static but formed from variables that
provide index values, member names, or values to compare with in a
filter expression.
These variables need to be validated (e.g., only allowing specific constructs
such as .name to be formed when the given values allow that) and translated
(e.g., by escaping string delimiters).
Not performing these validations and translations correctly can lead to unexpected
failures, which can lead to availability, confidentiality, and
integrity breaches, in particular, if an adversary has control over the
values (e.g., by entering them into a web form).
The resulting class of attacks, <em>injections</em> (e.g., SQL injections),
is consistently found among the top causes of application security
vulnerabilities and requires particular attention.</t>
      </section>
      <section anchor="attacks-on-security-mechanisms-that-employ-jsonpath" numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-attacks-on-security-mechani">Attacks on Security Mechanisms That Employ JSONPath</name>
        <t indent="0" pn="section-4.3-1">Where JSONPath is used as a part of a security mechanism, attackers
can attempt to provoke unexpected or unpredictable behavior or
take advantage of differences in behavior between JSONPath implementations.</t>
        <t indent="0" pn="section-4.3-2">Unexpected or unpredictable behavior can arise from a query argument with certain
constructs described as unpredictable by <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/>.
Predictable behavior can be expected, except in relation to the ordering
of objects, for any query argument conforming with <xref target="RFC7493" format="default" sectionFormat="of" derivedContent="RFC7493"/>.</t>
        <t indent="0" pn="section-4.3-3">Other attacks can target the behavior of underlying technologies, such as UTF-8 (see
<xref section="10" sectionFormat="of" target="RFC3629" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3629#section-10" derivedContent="RFC3629"/>) and the Unicode character set.</t>
      </section>
    </section>
  </middle>
  <back>
    <references pn="section-5">
      <name slugifiedName="name-references">References</name>
      <references anchor="sec-normative-references" pn="section-5.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC0020" target="https://www.rfc-editor.org/info/rfc20" quoteTitle="true" derivedAnchor="RFC0020">
          <front>
            <title>ASCII format for network interchange</title>
            <author fullname="V.G. Cerf" initials="V.G." surname="Cerf"/>
            <date month="October" year="1969"/>
          </front>
          <seriesInfo name="STD" value="80"/>
          <seriesInfo name="RFC" value="20"/>
          <seriesInfo name="DOI" value="10.17487/RFC0020"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3629" target="https://www.rfc-editor.org/info/rfc3629" quoteTitle="true" derivedAnchor="RFC3629">
          <front>
            <title>UTF-8, a transformation format of ISO 10646</title>
            <author fullname="F. Yergeau" initials="F." surname="Yergeau"/>
            <date month="November" year="2003"/>
            <abstract>
              <t indent="0">ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems. The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo. UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values. This memo obsoletes and replaces RFC 2279.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="63"/>
          <seriesInfo name="RFC" value="3629"/>
          <seriesInfo name="DOI" value="10.17487/RFC3629"/>
        </reference>
        <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234" quoteTitle="true" derivedAnchor="RFC5234">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <author fullname="D. Crocker" initials="D." role="editor" surname="Crocker"/>
            <author fullname="P. Overell" initials="P." surname="Overell"/>
            <date month="January" year="2008"/>
            <abstract>
              <t indent="0">Internet technical specifications often need to define a formal syntax. Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications. The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power. The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges. This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="68"/>
          <seriesInfo name="RFC" value="5234"/>
          <seriesInfo name="DOI" value="10.17487/RFC5234"/>
        </reference>
        <reference anchor="RFC6838" target="https://www.rfc-editor.org/info/rfc6838" quoteTitle="true" derivedAnchor="RFC6838">
          <front>
            <title>Media Type Specifications and Registration Procedures</title>
            <author fullname="N. Freed" initials="N." surname="Freed"/>
            <author fullname="J. Klensin" initials="J." surname="Klensin"/>
            <author fullname="T. Hansen" initials="T." surname="Hansen"/>
            <date month="January" year="2013"/>
            <abstract>
              <t indent="0">This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols. This memo documents an Internet Best Current Practice.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="13"/>
          <seriesInfo name="RFC" value="6838"/>
          <seriesInfo name="DOI" value="10.17487/RFC6838"/>
        </reference>
        <reference anchor="RFC7493" target="https://www.rfc-editor.org/info/rfc7493" quoteTitle="true" derivedAnchor="RFC7493">
          <front>
            <title>The I-JSON Message Format</title>
            <author fullname="T. Bray" initials="T." role="editor" surname="Bray"/>
            <date month="March" year="2015"/>
            <abstract>
              <t indent="0">I-JSON (short for "Internet JSON") is a restricted profile of JSON designed to maximize interoperability and increase confidence that software can process it successfully with predictable results.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7493"/>
          <seriesInfo name="DOI" value="10.17487/RFC7493"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author fullname="M. Cotton" initials="M." surname="Cotton"/>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <author fullname="T. Narten" initials="T." surname="Narten"/>
            <date month="June" year="2017"/>
            <abstract>
              <t indent="0">Many protocols make use of points of extensibility that use constants to identify various protocol parameters. To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper. For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t indent="0">To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed. This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t indent="0">This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8259" target="https://www.rfc-editor.org/info/rfc8259" quoteTitle="true" derivedAnchor="RFC8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author fullname="T. Bray" initials="T." role="editor" surname="Bray"/>
            <date month="December" year="2017"/>
            <abstract>
              <t indent="0">JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data.</t>
              <t indent="0">This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
          <seriesInfo name="DOI" value="10.17487/RFC8259"/>
        </reference>
        <reference anchor="RFC9485" target="https://www.rfc-editor.org/info/rfc9485" quoteTitle="true" derivedAnchor="RFC9485">
          <front>
            <title>I-Regexp: An Interoperable Regular Expression Format</title>
            <author fullname="C. Bormann" initials="C." surname="Bormann"/>
            <author fullname="T. Bray" initials="T." surname="Bray"/>
            <date month="October" year="2023"/>
            <abstract>
              <t indent="0">This document specifies I-Regexp, a flavor of regular expression that is limited in scope with the goal of interoperation across many different regular expression libraries.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9485"/>
          <seriesInfo name="DOI" value="10.17487/RFC9485"/>
        </reference>
        <reference anchor="UNICODE" target="https://www.unicode.org/versions/latest/" quoteTitle="true" derivedAnchor="UNICODE">
          <front>
            <title>The Unicode® Standard</title>
            <author>
              <organization showOnFrontPage="true">The Unicode Consortium</organization>
            </author>
          </front>
          <annotation>At the time of writing, <eref target="https://www.unicode.org/versions/Unicode15.0.0/UnicodeStandard-15.0.pdf" brackets="angle"/>.</annotation>
        </reference>
      </references>
      <references anchor="sec-informative-references" pn="section-5.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="BOOLEAN-LAWS" target="https://en.wikipedia.org/w/index.php?title=Boolean_algebra&amp;oldid=1191386550#Laws" quoteTitle="true" derivedAnchor="BOOLEAN-LAWS">
          <front>
            <title>Boolean algebra: Laws</title>
            <author>
              <organization showOnFrontPage="true"/>
            </author>
            <date month="December" year="2023"/>
          </front>
        </reference>
        <reference anchor="COMPARISON" target="https://cburgmer.github.io/json-path-comparison/" quoteTitle="true" derivedAnchor="COMPARISON">
          <front>
            <title>JSONPath Comparison</title>
            <author initials="C." surname="Burgmer" fullname="Christoph Burgmer">
              <organization showOnFrontPage="true">Thoughtworks</organization>
            </author>
          </front>
        </reference>
        <reference anchor="E4X" target="https://www.iso.org/standard/41002.html" quoteTitle="true" derivedAnchor="E4X">
          <front>
            <title>Information technology - ECMAScript for XML (E4X) specification</title>
            <author>
              <organization showOnFrontPage="true">ISO</organization>
            </author>
            <date year="2006" month="February"/>
          </front>
          <seriesInfo name="ISO/IEC" value="22537:2006"/>
          <refcontent>Withdrawn</refcontent>
          <annotation>An equivalent specification, also withdrawn, is available from <eref target="https://ecma-international.org/publications-and-standards/standards/ecma-357" brackets="angle"/>.</annotation>
        </reference>
        <reference anchor="ECMA-262" target="https://www.ecma-international.org/wp-content/uploads/ECMA-262_3rd_edition_december_1999.pdf" quoteTitle="true" derivedAnchor="ECMA-262">
          <front>
            <title>ECMAScript Language Specification</title>
            <author>
              <organization showOnFrontPage="true">ECMA International</organization>
            </author>
            <date year="1999" month="December"/>
          </front>
          <refcontent>Standard ECMA-262, Third Edition</refcontent>
        </reference>
        <reference anchor="JSONPath-orig" target="https://goessner.net/articles/JsonPath/" quoteTitle="true" derivedAnchor="JSONPath-orig">
          <front>
            <title>JSONPath - XPath for JSON</title>
            <author initials="S." surname="Gössner" fullname="Stefan Gössner">
              <organization showOnFrontPage="true">Fachhochschule Dortmund</organization>
            </author>
            <date year="2007" month="February"/>
          </front>
        </reference>
        <reference anchor="RFC6901" target="https://www.rfc-editor.org/info/rfc6901" quoteTitle="true" derivedAnchor="RFC6901">
          <front>
            <title>JavaScript Object Notation (JSON) Pointer</title>
            <author fullname="P. Bryan" initials="P." role="editor" surname="Bryan"/>
            <author fullname="K. Zyp" initials="K." surname="Zyp"/>
            <author fullname="M. Nottingham" initials="M." role="editor" surname="Nottingham"/>
            <date month="April" year="2013"/>
            <abstract>
              <t indent="0">JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6901"/>
          <seriesInfo name="DOI" value="10.17487/RFC6901"/>
        </reference>
        <reference anchor="RFC8949" target="https://www.rfc-editor.org/info/rfc8949" quoteTitle="true" derivedAnchor="RFC8949">
          <front>
            <title>Concise Binary Object Representation (CBOR)</title>
            <author fullname="C. Bormann" initials="C." surname="Bormann"/>
            <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
            <date month="December" year="2020"/>
            <abstract>
              <t indent="0">The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t>
              <t indent="0">This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="94"/>
          <seriesInfo name="RFC" value="8949"/>
          <seriesInfo name="DOI" value="10.17487/RFC8949"/>
        </reference>
        <reference anchor="SLICE" target="https://github.com/tc39/proposal-slice-notation" quoteTitle="true" derivedAnchor="SLICE">
          <front>
            <title>Slice notation</title>
            <author>
              <organization showOnFrontPage="true"/>
            </author>
            <date month="July" year="2022"/>
          </front>
          <refcontent>commit 82f95b4</refcontent>
        </reference>
        <reference anchor="XPath" target="https://www.w3.org/TR/2010/REC-xpath20-20101214/" quoteTitle="true" derivedAnchor="XPath">
          <front>
            <title>XML Path Language (XPath) 2.0 (Second Edition)</title>
            <author fullname="Anders Berglund" role="editor"/>
            <author fullname="Don Chamberlin" role="editor"/>
            <author fullname="Jerome Simeon" role="editor"/>
            <author fullname="Jonathan Robie" role="editor"/>
            <author fullname="Mary Fernandez" role="editor"/>
            <author fullname="Michael Kay" role="editor"/>
            <author fullname="Scott Boag" role="editor"/>
            <date day="14" month="December" year="2010"/>
          </front>
          <seriesInfo name="W3C" value="REC-xpath20-20101214"/>
        </reference>
      </references>
    </references>
    <section anchor="collected-abnf-grammars" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-collected-abnf-grammars">Collected ABNF Grammars</name>
      <t indent="0" pn="section-appendix.a-1">This appendix collects the ABNF grammar from the ABNF passages used
throughout the document.</t>
      <t indent="0" pn="section-appendix.a-2"><xref target="jsonpath-abnf" format="default" sectionFormat="of" derivedContent="Figure 2"/> contains the collected ABNF grammar that defines the
syntax of a JSONPath query.</t>
      <figure anchor="jsonpath-abnf" align="left" suppress-title="false" pn="figure-2">
        <name slugifiedName="name-collected-abnf-of-jsonpath-">Collected ABNF of JSONPath Queries</name>
        <sourcecode type="abnf" markers="false" pn="section-appendix.a-3.1">
jsonpath-query      = root-identifier segments
segments            = *(S segment)

B                   = %x20 /    ; Space
                      %x09 /    ; Horizontal tab
                      %x0A /    ; Line feed or New line
                      %x0D      ; Carriage return
S                   = *B        ; optional blank space
root-identifier     = "$"
selector            = name-selector /
                      wildcard-selector /
                      slice-selector /
                      index-selector /
                      filter-selector
name-selector       = string-literal

string-literal      = %x22 *double-quoted %x22 /     ; "string"
                      %x27 *single-quoted %x27       ; 'string'

double-quoted       = unescaped /
                      %x27      /                    ; '
                      ESC %x22  /                    ; \"
                      ESC escapable

single-quoted       = unescaped /
                      %x22      /                    ; "
                      ESC %x27  /                    ; \'
                      ESC escapable

ESC                 = %x5C                           ; \ backslash

unescaped           = %x20-21 /                      ; see RFC 8259
                         ; omit 0x22 "
                      %x23-26 /
                         ; omit 0x27 '
                      %x28-5B /
                         ; omit 0x5C \
                      %x5D-D7FF /
                         ; skip surrogate code points
                      %xE000-10FFFF

escapable           = %x62 / ; b BS backspace U+0008
                      %x66 / ; f FF form feed U+000C
                      %x6E / ; n LF line feed U+000A
                      %x72 / ; r CR carriage return U+000D
                      %x74 / ; t HT horizontal tab U+0009
                      "/"  / ; / slash (solidus) U+002F
                      "\"  / ; \ backslash (reverse solidus) U+005C
                      (%x75 hexchar) ;  uXXXX U+XXXX

hexchar             = non-surrogate /
                      (high-surrogate "\" %x75 low-surrogate)
non-surrogate       = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG) /
                      ("D" %x30-37 2HEXDIG )
high-surrogate      = "D" ("8"/"9"/"A"/"B") 2HEXDIG
low-surrogate       = "D" ("C"/"D"/"E"/"F") 2HEXDIG

HEXDIG              = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
wildcard-selector   = "*"
index-selector      = int                        ; decimal integer

int                 = "0" /
                      (["-"] DIGIT1 *DIGIT)      ; - optional
DIGIT1              = %x31-39                    ; 1-9 non-zero digit
slice-selector      = [start S] ":" S [end S] [":" [S step ]]

start               = int       ; included in selection
end                 = int       ; not included in selection
step                = int       ; default: 1
filter-selector     = "?" S logical-expr
logical-expr        = logical-or-expr
logical-or-expr     = logical-and-expr *(S "||" S logical-and-expr)
                        ; disjunction
                        ; binds less tightly than conjunction
logical-and-expr    = basic-expr *(S "&amp;&amp;" S basic-expr)
                        ; conjunction
                        ; binds more tightly than disjunction

basic-expr          = paren-expr /
                      comparison-expr /
                      test-expr

paren-expr          = [logical-not-op S] "(" S logical-expr S ")"
                                        ; parenthesized expression
logical-not-op      = "!"               ; logical NOT operator
test-expr           = [logical-not-op S]
                      (filter-query / ; existence/non-existence
                       function-expr) ; LogicalType or NodesType
filter-query        = rel-query / jsonpath-query
rel-query           = current-node-identifier segments
current-node-identifier = "@"
comparison-expr     = comparable S comparison-op S comparable
literal             = number / string-literal /
                      true / false / null
comparable          = literal /
                      singular-query / ; singular query value
                      function-expr    ; ValueType
comparison-op       = "==" / "!=" /
                      "&lt;=" / "&gt;=" /
                      "&lt;"  / "&gt;"

singular-query      = rel-singular-query / abs-singular-query
rel-singular-query  = current-node-identifier singular-query-segments
abs-singular-query  = root-identifier singular-query-segments
singular-query-segments = *(S (name-segment / index-segment))
name-segment        = ("[" name-selector "]") /
                      ("." member-name-shorthand)
index-segment       = "[" index-selector "]"
number              = (int / "-0") [ frac ] [ exp ] ; decimal number
frac                = "." 1*DIGIT                  ; decimal fraction
exp                 = "e" [ "-" / "+" ] 1*DIGIT    ; decimal exponent
true                = %x74.72.75.65                ; true
false               = %x66.61.6c.73.65             ; false
null                = %x6e.75.6c.6c                ; null
function-name       = function-name-first *function-name-char
function-name-first = LCALPHA
function-name-char  = function-name-first / "_" / DIGIT
LCALPHA             = %x61-7A  ; "a".."z"

function-expr       = function-name "(" S [function-argument
                         *(S "," S function-argument)] S ")"
function-argument   = literal /
                      filter-query / ; (includes singular-query)
                      logical-expr /
                      function-expr
segment             = child-segment / descendant-segment
child-segment       = bracketed-selection /
                      ("."
                       (wildcard-selector /
                        member-name-shorthand))

bracketed-selection = "[" S selector *(S "," S selector) S "]"

member-name-shorthand = name-first *name-char
name-first          = ALPHA /
                      "_"   /
                      %x80-D7FF /
                         ; skip surrogate code points
                      %xE000-10FFFF
name-char           = name-first / DIGIT

DIGIT               = %x30-39              ; 0-9
ALPHA               = %x41-5A / %x61-7A    ; A-Z / a-z
descendant-segment  = ".." (bracketed-selection /
                            wildcard-selector /
                            member-name-shorthand)
</sourcecode>
      </figure>
      <t indent="0" pn="section-appendix.a-4"><xref target="normalized-path-abnf" format="default" sectionFormat="of" derivedContent="Figure 3"/> contains the collected ABNF grammar that
defines the syntax of a JSONPath Normalized Path while also using the rules
<tt>root-identifier</tt>, <tt>ESC</tt>, <tt>DIGIT</tt>, and <tt>DIGIT1</tt> from <xref target="jsonpath-abnf" format="default" sectionFormat="of" derivedContent="Figure 2"/>.</t>
      <figure anchor="normalized-path-abnf" align="left" suppress-title="false" pn="figure-3">
        <name slugifiedName="name-collected-abnf-of-jsonpath-n">Collected ABNF of JSONPath Normalized Paths</name>
        <sourcecode type="abnf" markers="false" pn="section-appendix.a-5.1">
normalized-path      = root-identifier *(normal-index-segment)
normal-index-segment = "[" normal-selector "]"
normal-selector      = normal-name-selector / normal-index-selector
normal-name-selector = %x27 *normal-single-quoted %x27 ; 'string'
normal-single-quoted = normal-unescaped /
                       ESC normal-escapable
normal-unescaped     =    ; omit %x0-1F control codes
                       %x20-26 /
                          ; omit 0x27 '
                       %x28-5B /
                          ; omit 0x5C \
                       %x5D-D7FF /
                          ; skip surrogate code points
                       %xE000-10FFFF

normal-escapable     = %x62 / ; b BS backspace U+0008
                       %x66 / ; f FF form feed U+000C
                       %x6E / ; n LF line feed U+000A
                       %x72 / ; r CR carriage return U+000D
                       %x74 / ; t HT horizontal tab U+0009
                       "'" /  ; ' apostrophe U+0027
                       "\" /  ; \ backslash (reverse solidus) U+005C
                       (%x75 normal-hexchar)
                                       ; certain values u00xx U+00XX
normal-hexchar       = "0" "0"
                       (
                          ("0" %x30-37) / ; "00"-"07"
                             ; omit U+0008-U+000A BS HT LF
                          ("0" %x62) /    ; "0b"
                             ; omit U+000C-U+000D FF CR
                          ("0" %x65-66) / ; "0e"-"0f"
                          ("1" normal-HEXDIG)
                       )
normal-HEXDIG        = DIGIT / %x61-66    ; "0"-"9", "a"-"f"
normal-index-selector = "0" / (DIGIT1 *DIGIT)
                        ; non-negative decimal integer
</sourcecode>
      </figure>
    </section>
    <section anchor="inspired-by-xpath" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-inspired-by-xpath">Inspired by XPath</name>
      <t indent="0" pn="section-appendix.b-1">This appendix is informative.</t>
      <t indent="0" pn="section-appendix.b-2">At the time JSONPath was invented, XML was noted for the availability of
powerful tools to analyze, transform, and selectively extract data from
XML documents.
<xref target="XPath" format="default" sectionFormat="of" derivedContent="XPath"/> is one of these tools.</t>
      <t indent="0" pn="section-appendix.b-3">In 2007, the need for something solving the same class of problems for
the emerging JSON community became apparent, specifically for:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.b-4">
        <li pn="section-appendix.b-4.1">finding data interactively and extracting them out of
JSON values <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/> without special scripting and</li>
        <li pn="section-appendix.b-4.2">specifying the relevant parts of the JSON data in a request by a
client, so the server can reduce the amount of data in its response,
minimizing bandwidth usage.</li>
      </ul>
      <t indent="0" pn="section-appendix.b-5">(Note: XPath has evolved since 2007, and recent versions even
nominally support operating inside JSON values.
This appendix only discusses the more widely used version of XPath
that was available in 2007.)</t>
      <t indent="0" pn="section-appendix.b-6">JSONPath picks up the overall feeling of XPath but maps the concepts
to syntax (and partially semantics) that would be familiar to someone
using JSON in a dynamic language.</t>
      <t indent="0" pn="section-appendix.b-7">For example, in popular dynamic programming languages such as JavaScript,
Python, and PHP, the semantics of the XPath expression:</t>
      <sourcecode type="xpath" markers="false" pn="section-appendix.b-8">
/store/book[1]/title
</sourcecode>
      <t indent="0" pn="section-appendix.b-9">can be realized in the expression:</t>
      <sourcecode type="xpath" markers="false" pn="section-appendix.b-10">
x.store.book[0].title
</sourcecode>
      <t indent="0" pn="section-appendix.b-11">or in bracket notation:</t>
      <sourcecode type="xpath" markers="false" pn="section-appendix.b-12">
x['store']['book'][0]['title']
</sourcecode>
      <t indent="0" pn="section-appendix.b-13">with the variable x holding the query argument.</t>
      <t indent="0" pn="section-appendix.b-14">The JSONPath language was designed to:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.b-15">
        <li pn="section-appendix.b-15.1">be naturally based on those language characteristics,</li>
        <li pn="section-appendix.b-15.2">cover only the most essential parts of XPath 1.0,</li>
        <li pn="section-appendix.b-15.3">be lightweight in code size and memory consumption, and</li>
        <li pn="section-appendix.b-15.4">be runtime efficient.</li>
      </ul>
      <section anchor="xpath-overview" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.1">
        <name slugifiedName="name-jsonpath-and-xpath">JSONPath and XPath</name>
        <t indent="0" pn="section-appendix.b.1-1">JSONPath expressions apply to JSON values in the same way
as XPath expressions are used in combination with an XML document.
JSONPath uses <tt>$</tt> to refer to the root node of the query argument, similar
to XPath's <tt>/</tt> at the front.</t>
        <t indent="0" pn="section-appendix.b.1-2">JSONPath expressions move further down the hierarchy using <em>dot notation</em>
(<tt>$.store.book[0].title</tt>)
or the <em>bracket notation</em>
(<tt>$['store']['book'][0]['title']</tt>); both replace XPath's <tt>/</tt> within query expressions, where <em>dot notation</em> serves as a lightweight but limited syntax while <em>bracket notation</em> is a
heavyweight but more general syntax.</t>
        <t indent="0" pn="section-appendix.b.1-3">Both JSONPath and XPath use <tt>*</tt> for a wildcard.
JSONPath's descendant segment notation, starting with <tt>..</tt>, borrowed from <xref target="E4X" format="default" sectionFormat="of" derivedContent="E4X"/>, is similar to XPath's <tt>//</tt>.
The array slicing construct <tt>[start:end:step]</tt> is unique to JSONPath,
inspired by <xref target="SLICE" format="default" sectionFormat="of" derivedContent="SLICE"/> from ECMASCRIPT 4.</t>
        <t indent="0" pn="section-appendix.b.1-4">Filter expressions are supported via the syntax <tt>?&lt;logical-expr&gt;</tt> as in:</t>
        <sourcecode type="application/jsonpath" markers="false" pn="section-appendix.b.1-5">
$.store.book[?@.price &lt; 10].title
</sourcecode>
        <t indent="0" pn="section-appendix.b.1-6"><xref target="tbl-xpath-overview" format="default" sectionFormat="of" derivedContent="Table 20"/> extends <xref target="tbl-overview" format="default" sectionFormat="of" derivedContent="Table 1"/> by providing a comparison
with similar XPath concepts.</t>
        <table anchor="tbl-xpath-overview" align="center" pn="table-20">
          <name slugifiedName="name-xpath-syntax-compared-to-js">XPath Syntax Compared to JSONPath</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">XPath</th>
              <th align="left" colspan="1" rowspan="1">JSONPath</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>/</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$</tt></td>
              <td align="left" colspan="1" rowspan="1">the root XML element</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>.</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>@</tt></td>
              <td align="left" colspan="1" rowspan="1">the current XML element</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>/</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>.</tt> or <tt>[]</tt></td>
              <td align="left" colspan="1" rowspan="1">child operator</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>..</tt></td>
              <td align="left" colspan="1" rowspan="1">n/a</td>
              <td align="left" colspan="1" rowspan="1">parent operator</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>//</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>..name</tt>, <tt>..⁠[index]</tt>, <tt>..*</tt>, or <tt>..[*]</tt></td>
              <td align="left" colspan="1" rowspan="1">descendants (JSONPath borrows this syntax from E4X)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>*</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>*</tt></td>
              <td align="left" colspan="1" rowspan="1">wildcard: All XML elements regardless of their names</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>@</tt></td>
              <td align="left" colspan="1" rowspan="1">n/a</td>
              <td align="left" colspan="1" rowspan="1">attribute access: JSON values do not have attributes</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>[]</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>[]</tt></td>
              <td align="left" colspan="1" rowspan="1">subscript operator used to iterate over XML element collections and for predicates</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>|</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>[,]</tt></td>
              <td align="left" colspan="1" rowspan="1">Union operator (results in a combination of node sets); called list operator in JSONPath, allows combining member names, array indices, and slices</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">n/a</td>
              <td align="left" colspan="1" rowspan="1">
                <tt>[start:end:step]</tt></td>
              <td align="left" colspan="1" rowspan="1">array slice operator borrowed from ES4</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>[]</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>?</tt></td>
              <td align="left" colspan="1" rowspan="1">applies a filter (script) expression</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">seamless</td>
              <td align="left" colspan="1" rowspan="1">n/a</td>
              <td align="left" colspan="1" rowspan="1">expression engine</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>()</tt></td>
              <td align="left" colspan="1" rowspan="1">n/a</td>
              <td align="left" colspan="1" rowspan="1">grouping</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-appendix.b.1-8">For further illustration, <xref target="tbl-xpath-equivalents" format="default" sectionFormat="of" derivedContent="Table 21"/> shows some XPath expressions
and their JSONPath equivalents.</t>
        <table anchor="tbl-xpath-equivalents" align="center" pn="table-21">
          <name slugifiedName="name-example-xpath-expressions-a">Example XPath Expressions and Their JSONPath Equivalents</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">XPath</th>
              <th align="left" colspan="1" rowspan="1">JSONPath</th>
              <th align="left" colspan="1" rowspan="1">Result</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>/store/book/author</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$.store.book[*].author</tt></td>
              <td align="left" colspan="1" rowspan="1">the authors of all books in the store</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>//author</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..author</tt></td>
              <td align="left" colspan="1" rowspan="1">all authors</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>/store/*</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$.store.*</tt></td>
              <td align="left" colspan="1" rowspan="1">all things in store, which are some books and a red bicycle</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>/store//price</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$.store..price</tt></td>
              <td align="left" colspan="1" rowspan="1">the prices of everything in the store</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>//book[3]</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[2]</tt></td>
              <td align="left" colspan="1" rowspan="1">the third book</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>//book[last()]</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[-1]</tt></td>
              <td align="left" colspan="1" rowspan="1">the last book in order</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>//⁠book[position()&lt;3]</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[0,1]</tt><br/><tt>$..book[:2]</tt></td>
              <td align="left" colspan="1" rowspan="1">the first two books</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>//book[isbn]</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[?@.isbn]</tt></td>
              <td align="left" colspan="1" rowspan="1">filter all books with an ISBN number</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>//book[price&lt;10]</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..book[?@.price&lt;10]</tt></td>
              <td align="left" colspan="1" rowspan="1">filter all books cheaper than 10</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">
                <tt>//*</tt></td>
              <td align="left" colspan="1" rowspan="1">
                <tt>$..*</tt></td>
              <td align="left" colspan="1" rowspan="1">all elements in an XML document; all member values and array elements contained in input value</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-appendix.b.1-10">XPath has a lot more functionality (location paths in unabbreviated syntax,
operators, and functions) than listed in this comparison.  Moreover, there are
significant differences in how the subscript operator works in XPath and
JSONPath:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.b.1-11">
          <li pn="section-appendix.b.1-11.1">Square brackets in XPath expressions always operate on the <em>node
set</em> resulting from the previous path fragment. Indices always start
at 1.</li>
          <li pn="section-appendix.b.1-11.2">With JSONPath, square brackets operate on each of the nodes in the <em>nodelist</em>
resulting from the previous query segment. Array indices always start
at 0.</li>
        </ul>
      </section>
    </section>
    <section anchor="json-pointer" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-json-pointer">JSON Pointer</name>
      <t indent="0" pn="section-appendix.c-1">This appendix is informative.</t>
      <t indent="0" pn="section-appendix.c-2">In relation to JSON Pointer <xref target="RFC6901" format="default" sectionFormat="of" derivedContent="RFC6901"/>, JSONPath is not intended as a replacement but as a more powerful
companion. The purposes of the two standards
are different.</t>
      <t indent="0" pn="section-appendix.c-3">JSON Pointer is for identifying a single value within a JSON value whose
structure is known.</t>
      <t indent="0" pn="section-appendix.c-4">JSONPath can identify a single value within a JSON value, for example, by
using a Normalized Path. But JSONPath is also a query syntax that can be used
to search for and extract multiple values from JSON values whose structure
is known only in a general way.</t>
      <t indent="0" pn="section-appendix.c-5">A Normalized JSONPath can be converted into a JSON Pointer by converting the syntax,
without knowledge of any JSON value. The inverse is not generally true, i.e., a numeric
reference token (path component) in a JSON Pointer may identify a member value of an object or an element of an array.
For conversion to a JSONPath query, knowledge of the structure of the JSON value is
needed to distinguish these cases.</t>
    </section>
    <section numbered="false" anchor="acknowledgements" removeInRFC="false" toc="include" pn="section-appendix.d">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t indent="0" pn="section-appendix.d-1">This document is based on <contact fullname="Stefan Gössner"/>'s
original online article defining JSONPath <xref target="JSONPath-orig" format="default" sectionFormat="of" derivedContent="JSONPath-orig"/>.</t>
      <t indent="0" pn="section-appendix.d-2">The books example was taken from course material that Bielefeld University, Germany used in 2002.</t>
      <t indent="0" pn="section-appendix.d-3">This work is indebted to <contact fullname="Christoph Burgmer"/> for the superb
JSONPath comparison project <xref target="COMPARISON" format="default" sectionFormat="of" derivedContent="COMPARISON"/> that details the behavior of over forty JSONPath
implementations applied to numerous queries.</t>
    </section>
    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.e">
      <name slugifiedName="name-contributors">Contributors</name>
      <contact initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
        <organization showOnFrontPage="true">InfluxData, Inc.</organization>
        <address>
          <postal>
            <city>Pisa</city>
            <country>Italy</country>
          </postal>
          <email>mmikulicic@gmail.com</email>
        </address>
      </contact>
      <contact initials="E." surname="Surov" fullname="Edward Surov">
        <organization showOnFrontPage="true">TheSoul Publishing Ltd.</organization>
        <address>
          <postal>
            <city>Limassol</city>
            <country>Cyprus</country>
          </postal>
          <email>esurov.tsp@gmail.com</email>
        </address>
      </contact>
      <contact initials="G." surname="Dennis" fullname="Greg Dennis">
        <organization showOnFrontPage="true"/>
        <address>
          <postal>
            <city>Auckland</city>
            <country>New Zealand</country>
          </postal>
          <email>gregsdennis@yahoo.com</email>
          <uri>https://github.com/gregsdennis</uri>
        </address>
      </contact>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.f">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="S." surname="Gössner" fullname="Stefan Gössner" role="editor">
        <organization showOnFrontPage="true">Fachhochschule Dortmund</organization>
        <address>
          <postal>
            <street>Sonnenstraße 96</street>
            <city>Dortmund</city>
            <code>D-44139</code>
            <country>Germany</country>
          </postal>
          <email>stefan.goessner@fh-dortmund.de</email>
        </address>
      </author>
      <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
        <organization showOnFrontPage="true"/>
        <address>
          <postal>
            <street/>
            <city>Winchester</city>
            <region/>
            <code/>
            <country>United Kingdom</country>
          </postal>
          <phone/>
          <email>glyn.normington@gmail.com</email>
        </address>
      </author>
      <author initials="C." surname="Bormann" fullname="Carsten Bormann" role="editor">
        <organization showOnFrontPage="true">Universität Bremen TZI</organization>
        <address>
          <postal>
            <street>Postfach 330440</street>
            <city>Bremen</city>
            <code>D-28359</code>
            <country>Germany</country>
          </postal>
          <phone>+49-421-218-63921</phone>
          <email>cabo@tzi.org</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
