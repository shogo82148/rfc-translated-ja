<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" ipr="trust200902" docName="draft-ietf-dnsop-svcb-https-12" number="9460" submissionType="IETF" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true" updates="" obsoletes="" xml:lang="en" prepTime="2023-11-06T12:52:17" indexInclude="true" scripts="Common,Latin" tocDepth="3">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https-12" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9460" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="SVCB and HTTPS RRs for DNS">Service Binding and Parameter Specification via the DNS (SVCB and HTTPS Resource Records)</title>
    <seriesInfo name="RFC" value="9460" stream="IETF"/>
    <author initials="B." surname="Schwartz" fullname="Ben Schwartz">
      <organization showOnFrontPage="true">Meta Platforms, Inc.</organization>
      <address>
        <email>ietf@bemasc.net</email>
      </address>
    </author>
    <author initials="M." surname="Bishop" fullname="Mike Bishop">
      <organization showOnFrontPage="true">Akamai Technologies</organization>
      <address>
        <email>mbishop@evequefou.be</email>
      </address>
    </author>
    <author initials="E." surname="Nygren" fullname="Erik Nygren">
      <organization showOnFrontPage="true">Akamai Technologies</organization>
      <address>
        <email>erik+ietf@nygren.org</email>
      </address>
    </author>
    <date month="11" year="2023"/>
    <area>ops</area>
    <workgroup>dnsop</workgroup>
    <keyword>multi-CDN</keyword>
    <keyword>HSTS</keyword>
    <keyword>ECH</keyword>
    <keyword>CNAME</keyword>
    <keyword>apex</keyword>
    <keyword>ALPN</keyword>
    <keyword>HTTP/3</keyword>
    <keyword>alias</keyword>
    <keyword>SvcParam</keyword>
    <keyword>AliasMode</keyword>
    <keyword>ServiceMode</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This document specifies the "SVCB" ("Service Binding") and "HTTPS" DNS resource record (RR)
types to facilitate the lookup of information needed to make connections
to network services, such as for HTTP origins.  SVCB records
allow a service to be provided from multiple alternative endpoints,
each with associated parameters (such as transport protocol
configuration), and are extensible to support future uses
(such as keys for encrypting the TLS ClientHello).  They also
enable aliasing of apex domains, which is not possible with CNAME.
The HTTPS RR is a variation of SVCB for use with HTTP (see RFC 9110, "HTTP Semantics").
By providing more information to the client before it attempts to
establish a connection, these records offer potential benefits to
both performance and privacy.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9460" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2023 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-goals">Goals</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-overview-of-the-svcb-rr">Overview of the SVCB RR</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.3">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.3.1"><xref derivedContent="1.3" format="counter" sectionFormat="of" target="section-1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-the-svcb-record-type">The SVCB Record Type</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-zone-file-presentation-form">Zone-File Presentation Format</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rdata-wire-format">RDATA Wire Format</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.3">
                <t indent="0" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.3" format="counter" sectionFormat="of" target="section-2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-svcb-query-names">SVCB Query Names</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.4">
                <t indent="0" pn="section-toc.1-1.2.2.4.1"><xref derivedContent="2.4" format="counter" sectionFormat="of" target="section-2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-interpretation">Interpretation</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.4.2">
                  <li pn="section-toc.1-1.2.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.1.1"><xref derivedContent="2.4.1" format="counter" sectionFormat="of" target="section-2.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-svcpriority">SvcPriority</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.2.1"><xref derivedContent="2.4.2" format="counter" sectionFormat="of" target="section-2.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-aliasmode">AliasMode</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.3.1"><xref derivedContent="2.4.3" format="counter" sectionFormat="of" target="section-2.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-servicemode">ServiceMode</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.5">
                <t indent="0" pn="section-toc.1-1.2.2.5.1"><xref derivedContent="2.5" format="counter" sectionFormat="of" target="section-2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-special-handling-of-in-targ">Special Handling of "." in TargetName</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.5.2">
                  <li pn="section-toc.1-1.2.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.1.1"><xref derivedContent="2.5.1" format="counter" sectionFormat="of" target="section-2.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-aliasmode-2">AliasMode</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.5.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.2.1"><xref derivedContent="2.5.2" format="counter" sectionFormat="of" target="section-2.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-servicemode-2">ServiceMode</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-client-behavior">Client Behavior</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-handling-resolution-failure">Handling Resolution Failures</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-clients-using-a-proxy">Clients Using a Proxy</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dns-server-behavior">DNS Server Behavior</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authoritative-servers">Authoritative Servers</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-recursive-resolvers">Recursive Resolvers</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.2.2">
                  <li pn="section-toc.1-1.4.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.1.1"><xref derivedContent="4.2.1" format="counter" sectionFormat="of" target="section-4.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dns64">DNS64</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-general-requirements">General Requirements</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.4">
                <t indent="0" pn="section-toc.1-1.4.2.4.1"><xref derivedContent="4.4" format="counter" sectionFormat="of" target="section-4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-edns-client-subnet-ecs">EDNS Client Subnet (ECS)</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-performance-optimizations">Performance Optimizations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-optimistic-pre-connection-a">Optimistic Pre-connection and Connection Reuse</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-generating-and-using-incomp">Generating and Using Incomplete Responses</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-svcb-compatible-rr-types">SVCB-Compatible RR Types</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-initial-svcparamkeys">Initial SvcParamKeys</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-alpn-and-no-default-alpn">"alpn" and "no-default-alpn"</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2.1.2">
                  <li pn="section-toc.1-1.7.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.7.2.1.2.1.1"><xref derivedContent="7.1.1" format="counter" sectionFormat="of" target="section-7.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-representation">Representation</xref></t>
                  </li>
                  <li pn="section-toc.1-1.7.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.7.2.1.2.2.1"><xref derivedContent="7.1.2" format="counter" sectionFormat="of" target="section-7.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-use">Use</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-port">"port"</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.3">
                <t indent="0" pn="section-toc.1-1.7.2.3.1"><xref derivedContent="7.3" format="counter" sectionFormat="of" target="section-7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ipv4hint-and-ipv6hint">"ipv4hint" and "ipv6hint"</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.4">
                <t indent="0" pn="section-toc.1-1.7.2.4.1"><xref derivedContent="7.4" format="counter" sectionFormat="of" target="section-7.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-mandatory">"mandatory"</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-servicemode-rr-compatibilit">ServiceMode RR Compatibility and Mandatory Keys</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-using-service-bindings-with">Using Service Bindings with HTTP</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-query-names-for-https-rrs">Query Names for HTTPS RRs</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-comparison-with-alt-svc">Comparison with Alt-Svc</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2.2.2">
                  <li pn="section-toc.1-1.9.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.1.1"><xref derivedContent="9.2.1" format="counter" sectionFormat="of" target="section-9.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-alpn-usage">ALPN Usage</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.2.1"><xref derivedContent="9.2.2" format="counter" sectionFormat="of" target="section-9.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-untrusted-channels">Untrusted Channels</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.3.1"><xref derivedContent="9.2.3" format="counter" sectionFormat="of" target="section-9.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cache-lifetime">Cache Lifetime</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.2.2.4">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.4.1"><xref derivedContent="9.2.4" format="counter" sectionFormat="of" target="section-9.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-granularity">Granularity</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.9.2.3">
                <t indent="0" pn="section-toc.1-1.9.2.3.1"><xref derivedContent="9.3" format="counter" sectionFormat="of" target="section-9.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-interaction-with-alt-svc">Interaction with Alt-Svc</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.4">
                <t indent="0" pn="section-toc.1-1.9.2.4.1"><xref derivedContent="9.4" format="counter" sectionFormat="of" target="section-9.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requiring-server-name-indic">Requiring Server Name Indication</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.5">
                <t indent="0" pn="section-toc.1-1.9.2.5.1"><xref derivedContent="9.5" format="counter" sectionFormat="of" target="section-9.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-strict-transport-secur">HTTP Strict Transport Security (HSTS)</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.6">
                <t indent="0" pn="section-toc.1-1.9.2.6.1"><xref derivedContent="9.6" format="counter" sectionFormat="of" target="section-9.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-use-of-https-rrs-in-other-p">Use of HTTPS RRs in Other Protocols</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-zone-structures">Zone Structures</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2">
              <li pn="section-toc.1-1.10.2.1">
                <t indent="0" pn="section-toc.1-1.10.2.1.1"><xref derivedContent="10.1" format="counter" sectionFormat="of" target="section-10.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-structuring-zones-for-flexi">Structuring Zones for Flexibility</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.2">
                <t indent="0" pn="section-toc.1-1.10.2.2.1"><xref derivedContent="10.2" format="counter" sectionFormat="of" target="section-10.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-structuring-zones-for-perfo">Structuring Zones for Performance</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.3">
                <t indent="0" pn="section-toc.1-1.10.2.3.1"><xref derivedContent="10.3" format="counter" sectionFormat="of" target="section-10.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-operational-considerations">Operational Considerations</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.4">
                <t indent="0" pn="section-toc.1-1.10.2.4.1"><xref derivedContent="10.4" format="counter" sectionFormat="of" target="section-10.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples">Examples</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2.4.2">
                  <li pn="section-toc.1-1.10.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.10.2.4.2.1.1"><xref derivedContent="10.4.1" format="counter" sectionFormat="of" target="section-10.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protocol-enhancements">Protocol Enhancements</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.10.2.4.2.2.1"><xref derivedContent="10.4.2" format="counter" sectionFormat="of" target="section-10.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-apex-aliasing">Apex Aliasing</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.10.2.4.2.3.1"><xref derivedContent="10.4.3" format="counter" sectionFormat="of" target="section-10.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parameter-binding">Parameter Binding</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.4.2.4">
                    <t indent="0" pn="section-toc.1-1.10.2.4.2.4.1"><xref derivedContent="10.4.4" format="counter" sectionFormat="of" target="section-10.4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-multi-cdn-configuration">Multi-CDN Configuration</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.4.2.5">
                    <t indent="0" pn="section-toc.1-1.10.2.4.2.5.1"><xref derivedContent="10.4.5" format="counter" sectionFormat="of" target="section-10.4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-non-http-uses">Non-HTTP Uses</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-interaction-with-other-stan">Interaction with Other Standards</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="12" format="counter" sectionFormat="of" target="section-12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="13" format="counter" sectionFormat="of" target="section-13"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-privacy-considerations">Privacy Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.14">
            <t indent="0" pn="section-toc.1-1.14.1"><xref derivedContent="14" format="counter" sectionFormat="of" target="section-14"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.14.2">
              <li pn="section-toc.1-1.14.2.1">
                <t indent="0" pn="section-toc.1-1.14.2.1.1"><xref derivedContent="14.1" format="counter" sectionFormat="of" target="section-14.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-svcb-rr-type">SVCB RR Type</xref></t>
              </li>
              <li pn="section-toc.1-1.14.2.2">
                <t indent="0" pn="section-toc.1-1.14.2.2.1"><xref derivedContent="14.2" format="counter" sectionFormat="of" target="section-14.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-https-rr-type">HTTPS RR Type</xref></t>
              </li>
              <li pn="section-toc.1-1.14.2.3">
                <t indent="0" pn="section-toc.1-1.14.2.3.1"><xref derivedContent="14.3" format="counter" sectionFormat="of" target="section-14.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-new-registry-for-service-pa">New Registry for Service Parameters</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.14.2.3.2">
                  <li pn="section-toc.1-1.14.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.14.2.3.2.1.1"><xref derivedContent="14.3.1" format="counter" sectionFormat="of" target="section-14.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-procedure">Procedure</xref></t>
                  </li>
                  <li pn="section-toc.1-1.14.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.14.2.3.2.2.1"><xref derivedContent="14.3.2" format="counter" sectionFormat="of" target="section-14.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-initial-contents">Initial Contents</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.14.2.4">
                <t indent="0" pn="section-toc.1-1.14.2.4.1"><xref derivedContent="14.4" format="counter" sectionFormat="of" target="section-14.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-other-registry-updates">Other Registry Updates</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.15">
            <t indent="0" pn="section-toc.1-1.15.1"><xref derivedContent="15" format="counter" sectionFormat="of" target="section-15"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.15.2">
              <li pn="section-toc.1-1.15.2.1">
                <t indent="0" pn="section-toc.1-1.15.2.1.1"><xref derivedContent="15.1" format="counter" sectionFormat="of" target="section-15.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.15.2.2">
                <t indent="0" pn="section-toc.1-1.15.2.2.1"><xref derivedContent="15.2" format="counter" sectionFormat="of" target="section-15.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.16">
            <t indent="0" pn="section-toc.1-1.16.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-decoding-text-in-zone-files">Decoding Text in Zone Files</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2">
              <li pn="section-toc.1-1.16.2.1">
                <t indent="0" pn="section-toc.1-1.16.2.1.1"><xref derivedContent="A.1" format="counter" sectionFormat="of" target="section-appendix.a.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-decoding-a-comma-separated-">Decoding a Comma-Separated List</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.17">
            <t indent="0" pn="section-toc.1-1.17.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-mapping-summary">HTTP Mapping Summary</xref></t>
          </li>
          <li pn="section-toc.1-1.18">
            <t indent="0" pn="section-toc.1-1.18.1"><xref derivedContent="Appendix C" format="default" sectionFormat="of" target="section-appendix.c"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-comparison-with-alternative">Comparison with Alternatives</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.18.2">
              <li pn="section-toc.1-1.18.2.1">
                <t indent="0" pn="section-toc.1-1.18.2.1.1"><xref derivedContent="C.1" format="counter" sectionFormat="of" target="section-appendix.c.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-differences-from-the-srv-rr">Differences from the SRV RR Type</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.2">
                <t indent="0" pn="section-toc.1-1.18.2.2.1"><xref derivedContent="C.2" format="counter" sectionFormat="of" target="section-appendix.c.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-differences-from-the-propos">Differences from the Proposed HTTP Record</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.3">
                <t indent="0" pn="section-toc.1-1.18.2.3.1"><xref derivedContent="C.3" format="counter" sectionFormat="of" target="section-appendix.c.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-differences-from-the-propose">Differences from the Proposed ANAME Record</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.4">
                <t indent="0" pn="section-toc.1-1.18.2.4.1"><xref derivedContent="C.4" format="counter" sectionFormat="of" target="section-appendix.c.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-comparison-with-separate-rr">Comparison with Separate RR Types for AliasMode and ServiceMode</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.19">
            <t indent="0" pn="section-toc.1-1.19.1"><xref derivedContent="Appendix D" format="default" sectionFormat="of" target="section-appendix.d"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-test-vectors">Test Vectors</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.19.2">
              <li pn="section-toc.1-1.19.2.1">
                <t indent="0" pn="section-toc.1-1.19.2.1.1"><xref derivedContent="D.1" format="counter" sectionFormat="of" target="section-appendix.d.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-aliasmode-3">AliasMode</xref></t>
              </li>
              <li pn="section-toc.1-1.19.2.2">
                <t indent="0" pn="section-toc.1-1.19.2.2.1"><xref derivedContent="D.2" format="counter" sectionFormat="of" target="section-appendix.d.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-servicemode-3">ServiceMode</xref></t>
              </li>
              <li pn="section-toc.1-1.19.2.3">
                <t indent="0" pn="section-toc.1-1.19.2.3.1"><xref derivedContent="D.3" format="counter" sectionFormat="of" target="section-appendix.d.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-failure-cases">Failure Cases</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.20">
            <t indent="0" pn="section-toc.1-1.20.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.e"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments-and-related">Acknowledgments and Related Proposals</xref></t>
          </li>
          <li pn="section-toc.1-1.21">
            <t indent="0" pn="section-toc.1-1.21.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.f"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">The SVCB ("Service Binding") and HTTPS resource records (RRs) provide clients with complete instructions
for access to a service.  This information enables improved
performance and privacy by avoiding transient connections to a suboptimal
default server, negotiating a preferred protocol, and providing relevant
public keys.</t>
      <t indent="0" pn="section-1-2">For example, HTTP clients currently resolve only A and/or AAAA records for
the origin hostname, learning only its IP addresses.  If an HTTP client learns
more about the origin before connecting, it may be able to upgrade "http" URLs
to "https", enable HTTP/3 or Encrypted ClientHello <xref target="I-D.ietf-tls-esni" format="default" sectionFormat="of" derivedContent="ECH"/>,
or switch to an
operationally preferable endpoint.  It is highly desirable to minimize the
number of round trips and lookups required to
learn this additional information.</t>
      <t indent="0" pn="section-1-3">The SVCB and HTTPS RRs also help when the operator of a service
wishes to delegate operational control to one or more other domains, e.g.,
aliasing the origin "https://example.com" to a service
operator endpoint at "svc.example.net".  While this case can sometimes
be handled by a CNAME, that does not cover all use cases.  CNAME is also
inadequate when the service operator needs to provide a bound
collection of consistent configuration parameters through the DNS
(such as network location, protocol, and keying information).</t>
      <t indent="0" pn="section-1-4">This document first describes the SVCB RR as a general-purpose RR that can be applied directly and efficiently to a wide range
of services (<xref target="svcb" format="default" sectionFormat="of" derivedContent="Section 2"/>).  It also describes the rules for defining other
SVCB-compatible RR types (<xref target="svcb-compatible" format="default" sectionFormat="of" derivedContent="Section 6"/>), starting with the HTTPS
RR type (<xref target="https" format="default" sectionFormat="of" derivedContent="Section 9"/>), which provides improved efficiency and convenience
with HTTP by avoiding the need for an Attrleaf label <xref target="RFC8552" format="default" sectionFormat="of" derivedContent="Attrleaf"/>
(<xref target="httpsnames" format="default" sectionFormat="of" derivedContent="Section 9.1"/>).</t>
      <t indent="0" pn="section-1-5">The SVCB RR has two modes: 1) "AliasMode", which simply delegates operational
control for a resource and 2) "ServiceMode", which binds together
configuration information for a service endpoint.
ServiceMode provides additional key=value parameters
within each RDATA set.</t>
      <section anchor="goals" numbered="true" removeInRFC="false" toc="include" pn="section-1.1">
        <name slugifiedName="name-goals">Goals</name>
        <t indent="0" pn="section-1.1-1">The goal of the SVCB RR is to allow clients to resolve a single
additional DNS RR in a way that:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.1-2">
          <li pn="section-1.1-2.1">Provides alternative endpoints that are authoritative for the service,
along with parameters associated with each of these endpoints.</li>
          <li pn="section-1.1-2.2">Does not assume that all alternative endpoints have the same parameters
or capabilities, or are even
operated by the same entity.  This is important, as DNS does not
provide any way to tie together multiple RRsets for the same name.
For example, if "www.example.com" is a CNAME alias that switches
between one of three Content Delivery Networks (CDNs) or hosting environments, successive queries
for that name may return records that correspond to different environments.</li>
          <li pn="section-1.1-2.3">Enables CNAME-like functionality at a zone apex (such as
"example.com") for participating protocols and generally
enables extending operational authority for a service identified
by a domain name to other instances with alternate names.</li>
        </ul>
        <t indent="0" pn="section-1.1-3">Additional goals specific to HTTPS RRs and the HTTP use cases include:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.1-4">
          <li pn="section-1.1-4.1">Connecting directly to HTTP/3 (QUIC transport)
alternative endpoints <xref target="RFC9114" format="default" sectionFormat="of" derivedContent="HTTP/3"/>.</li>
          <li pn="section-1.1-4.2">Supporting non-default TCP and UDP ports.</li>
          <li pn="section-1.1-4.3">Enabling SRV-like benefits (e.g., apex aliasing, as mentioned above) for HTTP,
where SRV <xref target="RFC2782" format="default" sectionFormat="of" derivedContent="SRV"/> has not been widely adopted.</li>
          <li pn="section-1.1-4.4">Providing an indication signaling that the "https" scheme should
          be used instead of "http" for all HTTP requests to this host and port,
          similar to HTTP Strict Transport Security <xref target="RFC6797" format="default" sectionFormat="of" derivedContent="HSTS"/> (see
<xref target="hsts" format="default" sectionFormat="of" derivedContent="Section 9.5"/>).</li>
          <li pn="section-1.1-4.5">Enabling the conveyance of Encrypted ClientHello keys <xref target="I-D.ietf-tls-esni" format="default" sectionFormat="of" derivedContent="ECH"/> associated
with an alternative endpoint.</li>
        </ul>
      </section>
      <section anchor="overview-of-the-svcb-rr" numbered="true" removeInRFC="false" toc="include" pn="section-1.2">
        <name slugifiedName="name-overview-of-the-svcb-rr">Overview of the SVCB RR</name>
        <t indent="0" pn="section-1.2-1">This subsection briefly describes the SVCB RR with forward references to
the full exposition of each component.  (As discussed in <xref target="svcb-compatible" format="default" sectionFormat="of" derivedContent="Section 6"/>, this all
applies equally to the HTTPS RR, which shares
the same encoding, format, and high-level semantics.)</t>
        <t indent="0" pn="section-1.2-2">The SVCB RR has two modes: 1) AliasMode (<xref target="alias-mode" format="default" sectionFormat="of" derivedContent="Section 2.4.2"/>), which aliases a name
to another name and 2) ServiceMode (<xref target="service-mode" format="default" sectionFormat="of" derivedContent="Section 2.4.3"/>), which provides connection
information bound to a service endpoint domain.  Placing both forms in a single
RR type allows clients to
fetch the relevant information with a single query (<xref target="svcb-names" format="default" sectionFormat="of" derivedContent="Section 2.3"/>).</t>
        <t indent="0" pn="section-1.2-3">The SVCB RR has two required fields and one optional field.  The fields are:</t>
        <dl spacing="normal" newline="false" indent="3" pn="section-1.2-4">
          <dt pn="section-1.2-4.1">SvcPriority (<xref target="pri" format="default" sectionFormat="of" derivedContent="Section 2.4.1"/>):</dt>
          <dd pn="section-1.2-4.2">The priority of this record (relative to others,
with lower values preferred).  A value of 0 indicates AliasMode.</dd>
          <dt pn="section-1.2-4.3">TargetName:</dt>
          <dd pn="section-1.2-4.4">The domain name of either the alias target (for
AliasMode) or the alternative endpoint (for ServiceMode).</dd>
          <dt pn="section-1.2-4.5">SvcParams (optional):</dt>
          <dd pn="section-1.2-4.6">A list of key=value pairs
describing the alternative endpoint at
TargetName (only used in ServiceMode and otherwise ignored).
SvcParams are described in <xref target="presentation" format="default" sectionFormat="of" derivedContent="Section 2.1"/>.</dd>
        </dl>
        <t indent="0" pn="section-1.2-5">Cooperating DNS recursive resolvers will perform subsequent record
resolution (for SVCB, A, and AAAA records) and return them in the
Additional section of the response (<xref target="recursive-behavior" format="default" sectionFormat="of" derivedContent="Section 4.2"/>).  Clients either use responses
included in the Additional section returned by the recursive resolver
or perform necessary SVCB, A, and AAAA record resolutions (<xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/>).  DNS
authoritative servers can attach in-bailiwick SVCB, A, AAAA, and CNAME
records in the Additional section to responses for a SVCB query (<xref target="authoritative-behavior" format="default" sectionFormat="of" derivedContent="Section 4.1"/>).</t>
        <t indent="0" pn="section-1.2-6">In ServiceMode, the SvcParams of the SVCB RR
provide an extensible data model for describing alternative
endpoints that are authoritative for a service, along with
parameters associated with each of these alternative endpoints (<xref target="keys" format="default" sectionFormat="of" derivedContent="Section 7"/>).</t>
        <t indent="0" pn="section-1.2-7">For HTTP use cases, the HTTPS RR (<xref target="https" format="default" sectionFormat="of" derivedContent="Section 9"/>) enables many of the benefits of Alt-Svc
<xref target="RFC7838" format="default" sectionFormat="of" derivedContent="AltSvc"/>
without waiting for a full HTTP connection initiation (multiple round trips)
before learning of the preferred alternative,
and without necessarily revealing the user's
intended destination to all entities along the network path.</t>
      </section>
      <section anchor="terminology" numbered="true" removeInRFC="false" toc="include" pn="section-1.3">
        <name slugifiedName="name-terminology">Terminology</name>
        <t indent="0" pn="section-1.3-1">Terminology in this document is based on the common case where the SVCB record is used to
access a resource identified by a URI whose <tt>authority</tt> field contains a DNS
hostname as the <tt>host</tt>.</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.3-2">
          <li pn="section-1.3-2.1">The "service" is the information source identified by the <tt>authority</tt> and
<tt>scheme</tt> of the URI, capable of providing access to the resource.  For "https"
URIs, the "service" corresponds to an "origin" <xref target="RFC6454" format="default" sectionFormat="of" derivedContent="RFC6454"/>.</li>
          <li pn="section-1.3-2.2">The "service name" is the <tt>host</tt> portion of the authority.</li>
          <li pn="section-1.3-2.3">The "authority endpoint" is the authority's hostname and a port number implied
by the scheme or specified in the URI.</li>
          <li pn="section-1.3-2.4">An "alternative endpoint" is a hostname, port number, and other associated
instructions to the client on how to reach an instance of a service.</li>
        </ul>
        <t indent="0" pn="section-1.3-3">Additional DNS terminology intends to be consistent
with <xref target="RFC8499" format="default" sectionFormat="of" derivedContent="DNSTerm"/>.</t>
        <t indent="0" pn="section-1.3-4">SVCB is a contraction of "service binding".  The SVCB RR, HTTPS RR,
and future RR types that share SVCB's formats and registry are
collectively known as SVCB-compatible RR types.  The contraction "SVCB" is also
used to refer to this system as a whole.</t>
        <t indent="0" pn="section-1.3-5">The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
       "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>",
       "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>",
       "<bcp14>SHOULD NOT</bcp14>",
       "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
       "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document
       are to be interpreted as described in BCP 14
       <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only
       when, they appear in all capitals, as shown here.</t>
      </section>
    </section>
    <section anchor="svcb" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-the-svcb-record-type">The SVCB Record Type</name>
      <t indent="0" pn="section-2-1">The SVCB DNS RR type (RR type 64)
is used to locate alternative endpoints for a service.</t>
      <t indent="0" pn="section-2-2">The algorithm for resolving SVCB records and associated
address records is specified in <xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/>.</t>
      <t indent="0" pn="section-2-3">Other SVCB-compatible RR types
can also be defined as needed (see <xref target="svcb-compatible" format="default" sectionFormat="of" derivedContent="Section 6"/>).  In particular, the
HTTPS RR (RR type 65) provides special handling
for the case of "https" origins as described in <xref target="https" format="default" sectionFormat="of" derivedContent="Section 9"/>.</t>
      <t indent="0" pn="section-2-4">SVCB RRs are extensible by a list of SvcParams, which are pairs consisting of a
SvcParamKey and a SvcParamValue. Each SvcParamKey has a presentation name and a
registered number. Values are in a format specific to the SvcParamKey.  Each
SvcParam has a specified presentation format (used in zone files) and
wire encoding
(e.g., domain names, binary data, or numeric values). The initial SvcParamKeys
and their formats are defined in <xref target="keys" format="default" sectionFormat="of" derivedContent="Section 7"/>.</t>
      <section anchor="presentation" numbered="true" removeInRFC="false" toc="include" pn="section-2.1">
        <name slugifiedName="name-zone-file-presentation-form">Zone-File Presentation Format</name>
        <t indent="0" pn="section-2.1-1">The presentation format <tt>&lt;RDATA&gt;</tt> of the record (<xref section="5.1" sectionFormat="comma" target="RFC1035" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1035#section-5.1" derivedContent="RFC1035"/>) has
the form:</t>
        <sourcecode type="pseudocode" markers="false" pn="section-2.1-2">
SvcPriority TargetName SvcParams
</sourcecode>
        <t indent="0" pn="section-2.1-3">The SVCB record is defined specifically within
the Internet ("IN") Class (<xref section="3.2.4" sectionFormat="comma" target="RFC1035" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1035#section-3.2.4" derivedContent="RFC1035"/>).</t>
        <t indent="0" pn="section-2.1-4">SvcPriority is a number in the range 0-65535,
TargetName is a <tt>&lt;domain-name&gt;</tt> (<xref section="5.1" sectionFormat="comma" target="RFC1035" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1035#section-5.1" derivedContent="RFC1035"/>),
and the SvcParams are a whitespace-separated list with each SvcParam
consisting of a SvcParamKey=SvcParamValue pair or a standalone SvcParamKey.
SvcParamKeys are registered by IANA (<xref target="svcparamregistry" format="default" sectionFormat="of" derivedContent="Section 14.3"/>).</t>
        <t indent="0" pn="section-2.1-5">Each SvcParamKey <bcp14>SHALL</bcp14> appear at most once in the SvcParams.
In presentation format, SvcParamKeys are lowercase alphanumeric strings.
Key names contain 1-63 characters from the ranges "a"-"z", "0"-"9", and "-".
In ABNF <xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>,</t>
        <sourcecode name="" type="abnf" markers="false" pn="section-2.1-6">
alpha-lc      = %x61-7A   ; a-z
SvcParamKey   = 1*63(alpha-lc / DIGIT / "-")
SvcParam      = SvcParamKey ["=" SvcParamValue]
SvcParamValue = char-string ; See Appendix A.
value         = *OCTET ; Value before key-specific parsing
</sourcecode>
        <t indent="0" pn="section-2.1-7">The SvcParamValue is parsed using the
character-string decoding algorithm (<xref target="decoding" format="default" sectionFormat="of" derivedContent="Appendix A"/>), producing a <tt>value</tt>.
The <tt>value</tt> is then validated and converted into wire format in a manner
specific to each key.</t>
        <t indent="0" pn="section-2.1-8">When the optional "=" and SvcParamValue are omitted, the <tt>value</tt> is
interpreted as empty.</t>
        <t indent="0" pn="section-2.1-9">Arbitrary keys can be represented using the unknown-key presentation format
"keyNNNNN" where NNNNN is the numeric
value of the key type without leading zeros.
A SvcParam in this form <bcp14>SHALL</bcp14> be parsed as specified above, and
the decoded <tt>value</tt> <bcp14>SHALL</bcp14> be used as its wire-format encoding.</t>
        <t indent="0" pn="section-2.1-10">For some SvcParamKeys, the <tt>value</tt> corresponds to a list or set of
items.  Presentation formats for such keys <bcp14>SHOULD</bcp14> use a comma-separated list
(<xref target="value-list" format="default" sectionFormat="of" derivedContent="Appendix A.1"/>).</t>
        <t indent="0" pn="section-2.1-11">SvcParams in presentation format <bcp14>MAY</bcp14> appear in any order, but keys <bcp14>MUST NOT</bcp14> be
repeated.</t>
      </section>
      <section anchor="rdata-wire-format" numbered="true" removeInRFC="false" toc="include" pn="section-2.2">
        <name slugifiedName="name-rdata-wire-format">RDATA Wire Format</name>
        <t indent="0" pn="section-2.2-1">The RDATA for the SVCB RR consists of:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2-2">
          <li pn="section-2.2-2.1">a 2-octet field for SvcPriority as an integer in network
byte order.</li>
          <li pn="section-2.2-2.2">the uncompressed, fully qualified TargetName, represented as
a sequence of length-prefixed labels per <xref section="3.1" sectionFormat="of" target="RFC1035" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1035#section-3.1" derivedContent="RFC1035"/>.</li>
          <li pn="section-2.2-2.3">the SvcParams, consuming the remainder of the record
(so smaller than 65535 octets and constrained by the RDATA
and DNS message sizes).</li>
        </ul>
        <t indent="0" pn="section-2.2-3">When the list of SvcParams is non-empty, it contains a series of
SvcParamKey=SvcParamValue pairs, represented as:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2-4">
          <li pn="section-2.2-4.1">a 2-octet field containing the SvcParamKey as an
integer in network byte order.  (See <xref target="iana-keys" format="default" sectionFormat="of" derivedContent="Section 14.3.2"/> for the defined values.)</li>
          <li pn="section-2.2-4.2">a 2-octet field containing the length of the SvcParamValue
as an integer between 0 and 65535 in network byte order.</li>
          <li pn="section-2.2-4.3">an octet string of this length whose contents are the SvcParamValue in a
format determined by the SvcParamKey.</li>
        </ul>
        <t indent="0" pn="section-2.2-5">SvcParamKeys <bcp14>SHALL</bcp14> appear in increasing numeric order.</t>
        <t indent="0" pn="section-2.2-6">Clients <bcp14>MUST</bcp14> consider an RR malformed if:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2-7">
          <li pn="section-2.2-7.1">the end of the RDATA occurs within a SvcParam.</li>
          <li pn="section-2.2-7.2">SvcParamKeys are not in strictly increasing numeric order.</li>
          <li pn="section-2.2-7.3">the SvcParamValue for a SvcParamKey does not have the expected format.</li>
        </ul>
        <t indent="0" pn="section-2.2-8">Note that the second condition implies that there are no duplicate
SvcParamKeys.</t>
        <t indent="0" pn="section-2.2-9">If any RRs are malformed, the client <bcp14>MUST</bcp14> reject the entire RRset and
fall back to non-SVCB connection establishment.</t>
      </section>
      <section anchor="svcb-names" numbered="true" removeInRFC="false" toc="include" pn="section-2.3">
        <name slugifiedName="name-svcb-query-names">SVCB Query Names</name>
        <t indent="0" pn="section-2.3-1">When querying the SVCB RR, a service is translated into a QNAME by prepending
the service name with a label indicating the scheme, prefixed with an underscore,
resulting in a domain name like "_examplescheme.api.example.com.".  This
follows the Attrleaf naming pattern <xref target="RFC8552" format="default" sectionFormat="of" derivedContent="Attrleaf"/>, so the scheme <bcp14>MUST</bcp14> be
registered appropriately with IANA (see <xref target="other-standards" format="default" sectionFormat="of" derivedContent="Section 11"/>).</t>
        <t indent="0" pn="section-2.3-2">Protocol mapping documents <bcp14>MAY</bcp14> specify additional underscore-prefixed labels
to be prepended.  For schemes that specify a port (<xref section="3.2.3" sectionFormat="of" target="RFC3986" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.2.3" derivedContent="URI"/>), one reasonable possibility is to prepend the indicated port
number if a non-default port number is specified.  This document terms this behavior
"Port Prefix Naming" and uses it in the examples throughout.</t>
        <t indent="0" pn="section-2.3-3">See <xref target="httpsnames" format="default" sectionFormat="of" derivedContent="Section 9.1"/> for information regarding HTTPS RR behavior.</t>
        <t indent="0" pn="section-2.3-4">When a prior CNAME or SVCB record has aliased to
a SVCB record, each RR <bcp14>SHALL</bcp14> be returned under its own owner name, as in
ordinary CNAME processing (<xref section="3.6.2" sectionFormat="comma" target="RFC1034" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1034#section-3.6.2" derivedContent="RFC1034"/>).  For details, see
the recommendations regarding aliases for clients (<xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/>),
servers (<xref target="server-behavior" format="default" sectionFormat="of" derivedContent="Section 4"/>), and zones (<xref target="zone-structures" format="default" sectionFormat="of" derivedContent="Section 10"/>).</t>
        <t indent="0" pn="section-2.3-5">Note that none of these forms alter the origin or authority for validation
purposes.
For example, TLS clients <bcp14>MUST</bcp14> continue to validate TLS certificates
for the original service name.</t>
        <t indent="0" pn="section-2.3-6">As an example, the owner of "example.com" could publish this record:</t>
        <sourcecode type="dns-rr" markers="false" pn="section-2.3-7">
_8443._foo.api.example.com. 7200 IN SVCB 0 svc4.example.net.
</sourcecode>
        <t indent="0" pn="section-2.3-8">This record would indicate that "foo://api.example.com:8443" is aliased to "svc4.example.net".
The owner of "example.net", in turn, could publish this record:</t>
        <sourcecode type="dns-rr" markers="false" pn="section-2.3-9">
svc4.example.net.  7200  IN SVCB 3 svc4.example.net. (
    alpn="bar" port="8004" )
</sourcecode>
        <t indent="0" pn="section-2.3-10">This record would indicate that these services are served on port number 8004,
which supports the protocol "bar" and its associated transport in
addition to the default transport protocol for "foo://".</t>
        <t indent="0" pn="section-2.3-11">(Parentheses are used to ignore a line break in DNS zone-file presentation
format, per <xref section="5.1" sectionFormat="of" target="RFC1035" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1035#section-5.1" derivedContent="RFC1035"/>.)</t>
      </section>
      <section anchor="interpretation" numbered="true" removeInRFC="false" toc="include" pn="section-2.4">
        <name slugifiedName="name-interpretation">Interpretation</name>
        <section anchor="pri" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.1">
          <name slugifiedName="name-svcpriority">SvcPriority</name>
          <t indent="0" pn="section-2.4.1-1">When SvcPriority is 0, the SVCB record is in AliasMode (<xref target="alias-mode" format="default" sectionFormat="of" derivedContent="Section 2.4.2"/>).
Otherwise, it is in ServiceMode (<xref target="service-mode" format="default" sectionFormat="of" derivedContent="Section 2.4.3"/>).</t>
          <t indent="0" pn="section-2.4.1-2">Within a SVCB RRset,
all RRs <bcp14>SHOULD</bcp14> have the same mode.
If an RRset contains a record in AliasMode, the recipient <bcp14>MUST</bcp14> ignore
any ServiceMode records in the set.</t>
          <t indent="0" pn="section-2.4.1-3">RRsets are explicitly unordered collections, so the
SvcPriority field is used to impose an ordering on SVCB RRs.
A smaller SvcPriority indicates that the domain owner recommends the use of this
record over ServiceMode RRs with a larger SvcPriority value.</t>
          <t indent="0" pn="section-2.4.1-4">When receiving an RRset containing multiple SVCB records with the
same SvcPriority value, clients <bcp14>SHOULD</bcp14> apply a random shuffle within a
priority level to the records before using them, to ensure uniform
load balancing.</t>
        </section>
        <section anchor="alias-mode" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.2">
          <name slugifiedName="name-aliasmode">AliasMode</name>
          <t indent="0" pn="section-2.4.2-1">In AliasMode, the SVCB record aliases a service to a
TargetName.  SVCB RRsets <bcp14>SHOULD</bcp14> only have a single RR in AliasMode.  If multiple AliasMode RRs are present, clients or recursive
resolvers <bcp14>SHOULD</bcp14> pick one at random.
</t>
          <t indent="0" pn="section-2.4.2-2">The primary purpose of AliasMode is to allow aliasing at the zone
apex, where CNAME is not allowed (see, for example, <xref section="2.4" sectionFormat="comma" target="RFC1912" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1912#section-2.4" derivedContent="RFC1912"/>).
In AliasMode, the TargetName will
be the name of a domain that resolves to SVCB,
AAAA, and/or A records.  (See <xref target="svcb-compatible" format="default" sectionFormat="of" derivedContent="Section 6"/> for aliasing of SVCB-compatible RR types.)
Unlike CNAME, AliasMode records do not affect the resolution of other RR
types and apply only to a specific service, not an entire domain name.</t>
          <t indent="0" pn="section-2.4.2-3">The AliasMode TargetName <bcp14>SHOULD NOT</bcp14> be equal
to the owner name, as this would result in a loop.
In AliasMode, recipients <bcp14>MUST</bcp14> ignore any SvcParams that are present.
Zone-file parsers <bcp14>MAY</bcp14> emit a warning if an AliasMode record has SvcParams.
The use of SvcParams in AliasMode records is currently not defined, but a
future specification could extend AliasMode records to include SvcParams.</t>
          <t indent="0" pn="section-2.4.2-4">For example, the operator of "foo://example.com:8080" could
point requests to a service operating at "foosvc.example.net"
by publishing:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-2.4.2-5">
_8080._foo.example.com. 3600 IN SVCB 0 foosvc.example.net.
</sourcecode>
          <t indent="0" pn="section-2.4.2-6">Using AliasMode maintains a separation of concerns: the owner of
"foosvc.example.net" can add or remove ServiceMode SVCB records without
requiring a corresponding change to "example.com".  Note that if
"foosvc.example.net" promises to always publish a SVCB record, this AliasMode
record can be replaced by a CNAME at the same owner name.</t>
          <t indent="0" pn="section-2.4.2-7">AliasMode is especially useful for SVCB-compatible RR types that do not
require an underscore prefix, such as the HTTPS RR type.  For example,
the operator of "https://example.com" could point requests to a server
at "svc.example.net" by publishing this record at the zone apex:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-2.4.2-8">
example.com. 3600 IN HTTPS 0 svc.example.net.
</sourcecode>
          <t indent="0" pn="section-2.4.2-9">Note that the SVCB record's owner name <bcp14>MAY</bcp14> be the canonical name
of a CNAME record, and the TargetName <bcp14>MAY</bcp14> be the owner of a CNAME
record. Clients and recursive resolvers <bcp14>MUST</bcp14> follow CNAMEs as normal.</t>
          <t indent="0" pn="section-2.4.2-10">To avoid unbounded alias chains, clients and recursive resolvers <bcp14>MUST</bcp14> impose a
limit on the total number of SVCB aliases they will follow for each resolution
request.  This limit <bcp14>MUST NOT</bcp14> be zero, i.e., implementations <bcp14>MUST</bcp14> be able to
follow at least one AliasMode record.  The exact value of this limit
is left to implementations.</t>
          <t indent="0" pn="section-2.4.2-11">Zones that require following multiple AliasMode records could encounter
compatibility and performance issues.</t>
          <t indent="0" pn="section-2.4.2-12">As legacy clients will not know to use this record, service
operators will likely need to retain fallback AAAA and A records
alongside this SVCB record, although in a common case
the target of the SVCB record might offer better performance, and
therefore would be preferable for clients implementing this specification
to use.</t>
          <t indent="0" pn="section-2.4.2-13">AliasMode records only apply to queries for the specific RR type.
For example, a SVCB record cannot alias to an HTTPS record or vice versa.</t>
        </section>
        <section anchor="service-mode" numbered="true" removeInRFC="false" toc="include" pn="section-2.4.3">
          <name slugifiedName="name-servicemode">ServiceMode</name>
          <t indent="0" pn="section-2.4.3-1">In ServiceMode, the TargetName and SvcParams within each RR
associate an alternative endpoint for the service with its connection
parameters.</t>
          <t indent="0" pn="section-2.4.3-2">Each protocol scheme that uses SVCB <bcp14>MUST</bcp14> define a protocol mapping that
explains how SvcParams are applied for connections of that scheme.
Unless specified otherwise by the
protocol mapping, clients <bcp14>MUST</bcp14> ignore any SvcParam that they do
not recognize.</t>
          <t indent="0" pn="section-2.4.3-3">Some SvcParams impose requirements on other SvcParams in the RR.  A
ServiceMode RR is called "self-consistent" if its SvcParams all comply with
each other's requirements.  Clients <bcp14>MUST</bcp14> reject any RR whose recognized
SvcParams are not self-consistent and <bcp14>MAY</bcp14> reject the entire RRset.  To
help zone operators avoid this condition, zone-file implementations <bcp14>SHOULD</bcp14>
enforce self-consistency as well.</t>
        </section>
      </section>
      <section anchor="dot" numbered="true" removeInRFC="false" toc="include" pn="section-2.5">
        <name slugifiedName="name-special-handling-of-in-targ">Special Handling of "." in TargetName</name>
        <t indent="0" pn="section-2.5-1">If TargetName has the value "." (represented in the wire format as a
zero-length label), special rules apply.</t>
        <section anchor="aliasdot" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.1">
          <name slugifiedName="name-aliasmode-2">AliasMode</name>
          <t indent="0" pn="section-2.5.1-1">For AliasMode SVCB RRs, a TargetName of "." indicates that the service
is not available or does not exist.  This indication is advisory:
clients encountering this indication <bcp14>MAY</bcp14> ignore it and attempt to connect
without the use of SVCB.</t>
        </section>
        <section anchor="servicemode" numbered="true" removeInRFC="false" toc="include" pn="section-2.5.2">
          <name slugifiedName="name-servicemode-2">ServiceMode</name>
          <t indent="0" pn="section-2.5.2-1">For ServiceMode SVCB RRs, if TargetName has the value ".", then the
owner name of this record <bcp14>MUST</bcp14> be used as the effective TargetName.
If the record has a wildcard owner name in the zone file, the recipient
<bcp14>SHALL</bcp14> use the response's synthesized owner name as the effective TargetName.</t>
          <t indent="0" pn="section-2.5.2-2">Here, for example, "svc2.example.net" is the effective TargetName:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-2.5.2-3">
example.com.      7200  IN HTTPS 0 svc.example.net.
svc.example.net.  7200  IN CNAME svc2.example.net.
svc2.example.net. 7200  IN HTTPS 1 . port=8002
svc2.example.net. 300   IN A     192.0.2.2
svc2.example.net. 300   IN AAAA  2001:db8::2
</sourcecode>
        </section>
      </section>
    </section>
    <section anchor="client-behavior" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-client-behavior">Client Behavior</name>
      <t indent="0" pn="section-3-1">"SVCB resolution" is the process of enumerating and ordering the available endpoints
for a service, as performed by the client.  SVCB resolution is implemented as follows:</t>
      <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-3-2"><li pn="section-3-2.1" derivedCounter="1.">Let $QNAME be the service name plus appropriate prefixes for the
scheme (see <xref target="svcb-names" format="default" sectionFormat="of" derivedContent="Section 2.3"/>).</li>
        <li pn="section-3-2.2" derivedCounter="2.">Issue a SVCB query for $QNAME.</li>
        <li pn="section-3-2.3" derivedCounter="3.">If an AliasMode SVCB record is returned for $QNAME (after following CNAMEs
as normal), set $QNAME to its TargetName (without
additional prefixes) and loop back to Step 2,
subject to chain length limits and loop detection heuristics (see
<xref target="client-failures" format="default" sectionFormat="of" derivedContent="Section 3.1"/>).</li>
        <li pn="section-3-2.4" derivedCounter="4.">If one or more "compatible" (<xref target="mandatory" format="default" sectionFormat="of" derivedContent="Section 8"/>) ServiceMode records are returned,
these represent the alternative endpoints. Sort the records by ascending SvcPriority.</li>
        <li pn="section-3-2.5" derivedCounter="5.">Otherwise, SVCB resolution has failed, and the list of available endpoints is
empty.</li>
      </ol>
      <t indent="0" pn="section-3-3">This procedure does not rely on any recursive or authoritative DNS server to
comply with this specification or have any awareness of SVCB.</t>
      <t indent="0" pn="section-3-4">A client is called "SVCB-optional" if it can connect without the use of
ServiceMode records; otherwise, it is called "SVCB-reliant".  Clients for pre-existing
protocols (e.g., HTTP) <bcp14>SHALL</bcp14> implement SVCB-optional behavior (except as
noted in <xref target="client-failures" format="default" sectionFormat="of" derivedContent="Section 3.1"/> or when modified by future specifications).</t>
      <t indent="0" pn="section-3-5">SVCB-optional clients <bcp14>SHOULD</bcp14> issue in parallel any other DNS queries that might
be needed for connection establishment if the SVCB record is absent, in order to minimize delay
in that case and enable the optimizations discussed in <xref target="optimizations" format="default" sectionFormat="of" derivedContent="Section 5"/>.</t>
      <t indent="0" pn="section-3-6">Once SVCB resolution has concluded, whether successful or not,
if at least one AliasMode record was processed,
SVCB-optional clients <bcp14>SHALL</bcp14> append to the list of endpoints an
endpoint consisting of the final value of $QNAME, the authority
endpoint's port number, and no SvcParams.  (This endpoint will be
attempted before falling back to non-SVCB connection modes.  This ensures that
SVCB-optional clients will make use of an AliasMode record whose TargetName has
A and/or AAAA records but no SVCB records.)</t>
      <t indent="0" pn="section-3-7">The client proceeds with connection establishment using this list of
endpoints.  Clients <bcp14>SHOULD</bcp14> try higher-priority alternatives first, with
fallback to lower-priority alternatives.  Clients resolve AAAA and/or A
records for the selected TargetName and <bcp14>MAY</bcp14> choose between them using an
approach such as Happy Eyeballs <xref target="RFC8305" format="default" sectionFormat="of" derivedContent="HappyEyeballsV2"/>.</t>
      <t indent="0" pn="section-3-8">If the client is SVCB-optional and connecting using this list of endpoints has
failed, the client now attempts to use non-SVCB connection modes.</t>
      <t indent="0" pn="section-3-9">Some important optimizations are discussed in <xref target="optimizations" format="default" sectionFormat="of" derivedContent="Section 5"/>
to avoid additional latency in comparison to ordinary AAAA/A lookups.</t>
      <section anchor="client-failures" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-handling-resolution-failure">Handling Resolution Failures</name>
        <t indent="0" pn="section-3.1-1">If DNS responses are cryptographically protected (e.g., using DNSSEC or
TLS <xref target="RFC7858" format="default" sectionFormat="of" derivedContent="DoT"/> <xref target="RFC8484" format="default" sectionFormat="of" derivedContent="DoH"/>) and SVCB resolution fails
due to an authentication error, SERVFAIL response, transport error, or
timeout, the client <bcp14>SHOULD</bcp14> abandon its attempt to reach the service, even
if the client is SVCB-optional.  Otherwise, an active attacker
could mount a downgrade attack by denying the user access to the SvcParams.</t>
        <t indent="0" pn="section-3.1-2">A SERVFAIL error can occur if the domain is DNSSEC-signed, the recursive
resolver is DNSSEC-validating, and the attacker is between the recursive
resolver and the authoritative DNS server.  A transport error or timeout can
occur if an active attacker between the client and the recursive resolver is
selectively dropping SVCB queries or responses, based on their size or
other observable patterns.</t>
        <t indent="0" pn="section-3.1-3">If the client enforces DNSSEC validation on A/AAAA responses, it <bcp14>SHOULD</bcp14>
apply the same validation policy to SVCB.  Otherwise, an attacker could
defeat the A/AAAA protection by forging SVCB responses that direct the
client to other IP addresses.</t>
        <t indent="0" pn="section-3.1-4">If DNS responses are not cryptographically protected, clients <bcp14>MAY</bcp14> treat
SVCB resolution failure as fatal or nonfatal.</t>
        <t indent="0" pn="section-3.1-5">If the client is unable to complete SVCB resolution due to its chain length
limit, the client <bcp14>MUST</bcp14> fall back to the authority endpoint, as if the
service's SVCB record did not exist.</t>
      </section>
      <section anchor="clients-using-a-proxy" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-clients-using-a-proxy">Clients Using a Proxy</name>
        <t indent="0" pn="section-3.2-1">Clients using a domain-oriented transport proxy like HTTP CONNECT
(<xref section="4.3.6" sectionFormat="comma" target="RFC7231" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7231#section-4.3.6" derivedContent="RFC7231"/>) or SOCKS5 <xref target="RFC1928" format="default" sectionFormat="of" derivedContent="RFC1928"/> have the option of
using named destinations, in which case the client does not perform
any A or AAAA queries for destination domains.  If the client is configured
to use named
destinations with a proxy that does not provide SVCB query capability
(e.g., through an affiliated DNS resolver), the client would have to perform
SVCB resolution separately, likely disclosing the destinations to additional parties and not just the proxy.
Clients in this configuration <bcp14>SHOULD</bcp14> arrange for a separate SVCB resolution
procedure with appropriate privacy properties.  If this is not possible,
SVCB-optional clients <bcp14>MUST</bcp14> disable SVCB resolution entirely, and SVCB-reliant
clients <bcp14>MUST</bcp14> treat the configuration as invalid.</t>
        <t indent="0" pn="section-3.2-2">If the client does use SVCB and named destinations, the client <bcp14>SHOULD</bcp14> follow
the standard SVCB resolution process, selecting the smallest-SvcPriority
option that is compatible with the client and the proxy.  When connecting
using a SVCB record, clients <bcp14>MUST</bcp14> provide the final TargetName and port to the
proxy, which will perform any required A and AAAA lookups.</t>
        <t indent="0" pn="section-3.2-3">This arrangement has several benefits:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.2-4">
          <li pn="section-3.2-4.1">
            <t indent="0" pn="section-3.2-4.1.1">Compared to disabling SVCB:
            </t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.2-4.1.2">
              <li pn="section-3.2-4.1.2.1">It allows the client to use the SvcParams, if present, which are
only usable with a specific TargetName.  The SvcParams may
include information that enhances performance (e.g., supported protocols) and privacy.</li>
              <li pn="section-3.2-4.1.2.2">It allows a service on an apex domain to use aliasing.</li>
            </ul>
          </li>
          <li pn="section-3.2-4.2">
            <t indent="0" pn="section-3.2-4.2.1">Compared to providing the proxy with an IP address:
            </t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.2-4.2.2">
              <li pn="section-3.2-4.2.2.1">It allows the proxy to select between IPv4 and IPv6 addresses for the
server according to its configuration.</li>
              <li pn="section-3.2-4.2.2.2">It ensures that the proxy receives addresses based on its network
geolocation, not the client's.</li>
              <li pn="section-3.2-4.2.2.3">It enables faster fallback for TCP destinations with multiple addresses
of the same family.</li>
            </ul>
          </li>
        </ul>
      </section>
    </section>
    <section anchor="server-behavior" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-dns-server-behavior">DNS Server Behavior</name>
      <section anchor="authoritative-behavior" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-authoritative-servers">Authoritative Servers</name>
        <t indent="0" pn="section-4.1-1">When replying to a SVCB query, authoritative DNS servers <bcp14>SHOULD</bcp14> return
A, AAAA, and SVCB records in the Additional section for any TargetNames
that are in the zone.  If the zone is signed, the server <bcp14>SHOULD</bcp14> also
include DNSSEC records authenticating the existence or nonexistence of these records
in the Additional section.</t>
        <t indent="0" pn="section-4.1-2">See <xref target="ecs" format="default" sectionFormat="of" derivedContent="Section 4.4"/> for exceptions.</t>
      </section>
      <section anchor="recursive-behavior" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-recursive-resolvers">Recursive Resolvers</name>
        <t indent="0" pn="section-4.2-1">Whether the recursive resolver is aware of SVCB or not, the normal response
construction process used for unknown RR types <xref target="RFC3597" format="default" sectionFormat="of" derivedContent="RFC3597"/>
generates the Answer section of the response.
Recursive resolvers that are aware of SVCB <bcp14>SHOULD</bcp14> help the client to
execute the procedure in <xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/> with minimum overall
latency by incorporating additional useful information into the
Additional section of the response as follows:
</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2-2"><li pn="section-4.2-2.1" derivedCounter="1.">Incorporate the results of SVCB resolution.  If the recursive resolver's
local chain length limit (which may be different from the client's limit) has
been reached, terminate.</li>
          <li pn="section-4.2-2.2" derivedCounter="2.">
            <t indent="0" pn="section-4.2-2.2.1">If any of the resolved SVCB records are in AliasMode, choose one of them
at random, and resolve SVCB, A, and AAAA records for its
TargetName.  </t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2-2.2.2">
              <li pn="section-4.2-2.2.2.1">If any SVCB records are resolved, go to Step 1.</li>
              <li pn="section-4.2-2.2.2.2">Otherwise, incorporate the results of A and AAAA resolution, and
terminate.</li>
            </ul>
          </li>
          <li pn="section-4.2-2.3" derivedCounter="3.">All the resolved SVCB records are in ServiceMode.  Resolve A and AAAA
queries for each TargetName (or for the owner name if TargetName
is "."), incorporate all the results, and terminate.</li>
        </ol>
        <t indent="0" pn="section-4.2-3">In this procedure, "resolve" means the resolver's ordinary recursive
resolution procedure, as if processing a query for that RRset.
This includes following any aliases that the resolver would ordinarily
follow (e.g., CNAME, DNAME <xref target="RFC6672" format="default" sectionFormat="of" derivedContent="DNAME"/>).  Errors or anomalies in
obtaining additional records <bcp14>MAY</bcp14> cause this process to terminate but
<bcp14>MUST NOT</bcp14> themselves cause the resolver to send a failure response.</t>
        <t indent="0" pn="section-4.2-4">See <xref target="alias-mode" format="default" sectionFormat="of" derivedContent="Section 2.4.2"/> for additional safeguards for recursive resolvers
to implement to mitigate loops.</t>
        <t indent="0" pn="section-4.2-5">See <xref target="incomplete-response" format="default" sectionFormat="of" derivedContent="Section 5.2"/> for possible optimizations of this procedure.</t>
        <section anchor="dns64" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.1">
          <name slugifiedName="name-dns64">DNS64</name>
          <t indent="0" pn="section-4.2.1-1">DNS64 resolvers synthesize responses to AAAA queries for names that only
have an A record (<xref section="5.1.7" sectionFormat="of" target="RFC6147" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6147#section-5.1.7" derivedContent="RFC6147"/>).  SVCB-aware DNS64
resolvers <bcp14>SHOULD</bcp14> apply the same synthesis logic when resolving AAAA
records for the TargetName for inclusion in the Additional section (Step 2 in
<xref target="recursive-behavior" format="default" sectionFormat="of" derivedContent="Section 4.2"/>) and <bcp14>MAY</bcp14> omit the A records from this section.</t>
          <t indent="0" pn="section-4.2.1-2">DNS64 resolvers <bcp14>MUST NOT</bcp14> extrapolate the AAAA synthesis logic to the IP
hints in the SvcParams (<xref target="svcparamkeys-iphints" format="default" sectionFormat="of" derivedContent="Section 7.3"/>).  Modifying the IP hints
would break DNSSEC validation for the SVCB record and would not improve
performance when the above recommendation is implemented.</t>
        </section>
      </section>
      <section anchor="general-requirements" numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-general-requirements">General Requirements</name>
        <t indent="0" pn="section-4.3-1">Recursive resolvers <bcp14>MUST</bcp14> be able to convey SVCB records with unrecognized
SvcParamKeys.  Resolvers <bcp14>MAY</bcp14> accomplish this by treating
the entire SvcParams portion of the record as opaque, even if the contents
are invalid.  If a recognized SvcParamKey is followed by a value that is
invalid according to the SvcParam's specification, a recursive resolver
<bcp14>MAY</bcp14> report an error such as SERVFAIL instead of returning
the record.
For complex value types whose interpretation might differ
between implementations or have additional future
allowed values added (e.g., URIs or "alpn"), resolvers
<bcp14>SHOULD</bcp14> limit validation to specified constraints.</t>
        <t indent="0" pn="section-4.3-2">When responding to a query that includes the DNSSEC OK bit <xref target="RFC3225" format="default" sectionFormat="of" derivedContent="RFC3225"/>,
DNSSEC-capable recursive and authoritative DNS servers <bcp14>MUST</bcp14> accompany
each RRset in the Additional section with the same DNSSEC-related records
that they would send when providing that RRset as an Answer (e.g., RRSIG, NSEC,
NSEC3).</t>
        <t indent="0" pn="section-4.3-3">According to <xref section="5.4.1" sectionFormat="of" target="RFC2181" format="default" derivedLink="https://rfc-editor.org/rfc/rfc2181#section-5.4.1" derivedContent="RFC2181"/>, "Unauthenticated RRs received
and cached from ... the additional data section ... should not be cached in
such a way that they would ever be returned as answers to a received query.
They may be returned as additional information where appropriate."
Recursive resolvers therefore <bcp14>MAY</bcp14> cache records from the Additional section
for use in populating Additional section responses and <bcp14>MAY</bcp14> cache them
for general use if they are authenticated by DNSSEC.</t>
      </section>
      <section anchor="ecs" numbered="true" removeInRFC="false" toc="include" pn="section-4.4">
        <name slugifiedName="name-edns-client-subnet-ecs">EDNS Client Subnet (ECS)</name>
        <t indent="0" pn="section-4.4-1">The EDNS Client Subnet (ECS) option <xref target="RFC7871" format="default" sectionFormat="of" derivedContent="RFC7871"/> allows recursive
resolvers to request IP addresses that are suitable for a particular client
IP range.  SVCB records may contain IP addresses (in ipv*hint SvcParams)
or direct users to a subnet-specific TargetName, so recursive resolvers
<bcp14>SHOULD</bcp14> include the same ECS option in SVCB queries as in A/AAAA queries.</t>
        <t indent="0" pn="section-4.4-2">According to <xref section="7.3.1" sectionFormat="of" target="RFC7871" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7871#section-7.3.1" derivedContent="RFC7871"/>, "Any records from [the
Additional section] <bcp14>MUST NOT</bcp14> be tied to a network."  Accordingly,
when processing a response whose QTYPE is SVCB-compatible,
resolvers <bcp14>SHOULD</bcp14> treat any records in the Additional section as having
SOURCE PREFIX-LENGTH set to zero and SCOPE PREFIX-LENGTH as specified
in the ECS option.  Authoritative servers <bcp14>MUST</bcp14> omit such records if they are
not suitable for use by any stub resolvers that set SOURCE PREFIX-LENGTH to
zero.  This will cause the resolver to perform a follow-up query that can
receive a properly tailored ECS.  (This is similar to the usage of CNAME with
the ECS option as discussed in <xref section="7.2.1" sectionFormat="comma" target="RFC7871" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7871#section-7.2.1" derivedContent="RFC7871"/>.)</t>
        <t indent="0" pn="section-4.4-3">Authoritative servers that omit Additional records can avoid the added
latency of a follow-up query by following the advice in <xref target="zone-performance" format="default" sectionFormat="of" derivedContent="Section 10.2"/>.</t>
      </section>
    </section>
    <section anchor="optimizations" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-performance-optimizations">Performance Optimizations</name>
      <t indent="0" pn="section-5-1">For optimal performance (i.e., minimum connection setup time), clients
<bcp14>SHOULD</bcp14> implement a client-side DNS cache.
Responses in the Additional section of a SVCB response <bcp14>SHOULD</bcp14> be placed
in cache before performing any follow-up queries.
With this behavior, and with conforming DNS servers,
using SVCB does not add network latency to connection setup.</t>
      <t indent="0" pn="section-5-2">To improve performance when using a non-conforming recursive resolver, clients
<bcp14>SHOULD</bcp14> issue speculative A and/or AAAA queries in parallel with each SVCB
query, based on a predicted value of TargetName (see <xref target="zone-performance" format="default" sectionFormat="of" derivedContent="Section 10.2"/>).</t>
      <t indent="0" pn="section-5-3">After a ServiceMode RRset is received, clients <bcp14>MAY</bcp14> try more than one option
in parallel and <bcp14>MAY</bcp14> prefetch A and AAAA records for multiple TargetNames.</t>
      <section anchor="optimistic-pre-connection-and-connection-reuse" numbered="true" removeInRFC="false" toc="include" pn="section-5.1">
        <name slugifiedName="name-optimistic-pre-connection-a">Optimistic Pre-connection and Connection Reuse</name>
        <t indent="0" pn="section-5.1-1">If an address response arrives before the corresponding SVCB response, the
client <bcp14>MAY</bcp14> initiate a connection as if the SVCB query returned NODATA but
<bcp14>MUST NOT</bcp14> transmit any information that could be altered by the SVCB response
until it arrives.  For example, future SvcParamKeys could be defined that
alter the TLS ClientHello.</t>
        <t indent="0" pn="section-5.1-2">Clients
implementing this optimization <bcp14>SHOULD</bcp14> wait for 50 milliseconds before
starting optimistic pre-connection, as per the guidance in
<xref target="RFC8305" format="default" sectionFormat="of" derivedContent="HappyEyeballsV2"/>.</t>
        <t indent="0" pn="section-5.1-3">A SVCB record is consistent with a connection
if the client would attempt an equivalent connection when making use of
that record. If a SVCB record is consistent with an active or in-progress
connection C, the client <bcp14>MAY</bcp14> prefer that record and use C as its connection.
For example, suppose the client receives this SVCB RRset for a protocol
that uses TLS over TCP:</t>
        <sourcecode type="dns-rr" markers="false" pn="section-5.1-4">
_1234._bar.example.com. 300 IN SVCB 1 svc1.example.net. (
    ipv6hint=2001:db8::1 port=1234 )
                               SVCB 2 svc2.example.net. (
    ipv6hint=2001:db8::2 port=1234 )
</sourcecode>
        <t indent="0" pn="section-5.1-5">If the client has an in-progress TCP connection to <tt>[2001:db8::2]:1234</tt>,
it <bcp14>MAY</bcp14> proceed with TLS on that connection, even
though the other record in the RRset has higher priority.</t>
        <t indent="0" pn="section-5.1-6">If none of the SVCB records are consistent
with any active or in-progress connection,
clients proceed with connection establishment as described in
<xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/>.</t>
      </section>
      <section anchor="incomplete-response" numbered="true" removeInRFC="false" toc="include" pn="section-5.2">
        <name slugifiedName="name-generating-and-using-incomp">Generating and Using Incomplete Responses</name>
        <t indent="0" pn="section-5.2-1">When following the procedure in <xref target="recursive-behavior" format="default" sectionFormat="of" derivedContent="Section 4.2"/>, recursive
resolvers <bcp14>MAY</bcp14> terminate the procedure early and produce a reply that omits
some of the associated RRsets.  This is <bcp14>REQUIRED</bcp14> when the chain length limit
is reached (Step 1 in <xref target="recursive-behavior" format="default" sectionFormat="of" derivedContent="Section 4.2"/>) but might also be appropriate
when the maximum response size is reached or when responding before fully
chasing dependencies would improve performance.  When omitting certain
RRsets, recursive resolvers <bcp14>SHOULD</bcp14> prioritize information for
smaller-SvcPriority records.</t>
        <t indent="0" pn="section-5.2-2">As discussed in <xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/>, clients <bcp14>MUST</bcp14> be able to fetch additional
information that is required to use a SVCB record, if it is not included
in the initial response.  As a performance optimization, if some of the SVCB
records in the response can be used without requiring additional DNS queries,
the client <bcp14>MAY</bcp14> prefer those records, regardless of their priorities.</t>
      </section>
    </section>
    <section anchor="svcb-compatible" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-svcb-compatible-rr-types">SVCB-Compatible RR Types</name>
      <t indent="0" pn="section-6-1">An RR type is called "SVCB-compatible" if it permits an implementation that is
identical to SVCB in its:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6-2">
        <li pn="section-6-2.1">RDATA presentation format</li>
        <li pn="section-6-2.2">RDATA wire format</li>
        <li pn="section-6-2.3">IANA registry used for SvcParamKeys</li>
        <li pn="section-6-2.4">Authoritative server Additional section processing</li>
        <li pn="section-6-2.5">Recursive resolution process</li>
        <li pn="section-6-2.6">Relevant Class (i.e., Internet ("IN") <xref target="RFC1035" format="default" sectionFormat="of" derivedContent="RFC1035"/>)</li>
      </ul>
      <t indent="0" pn="section-6-3">This allows authoritative and recursive DNS servers to apply identical
processing to all SVCB-compatible RR types.</t>
      <t indent="0" pn="section-6-4">All other behaviors described as applying to the SVCB RR also apply
to all SVCB-compatible RR types unless explicitly stated otherwise.
When following an AliasMode record (<xref target="alias-mode" format="default" sectionFormat="of" derivedContent="Section 2.4.2"/>) of RR type $T, the
follow-up query to the TargetName <bcp14>MUST</bcp14> also be for type $T.</t>
      <t indent="0" pn="section-6-5">This document defines one SVCB-compatible RR type (other than SVCB itself):
the HTTPS RR type (<xref target="https" format="default" sectionFormat="of" derivedContent="Section 9"/>), which avoids Attrleaf label prefixes <xref target="RFC8552" format="default" sectionFormat="of" derivedContent="Attrleaf"/> in order to improve
compatibility with wildcards and CNAMEs, which are widely used with HTTP.</t>
      <t indent="0" pn="section-6-6">Standards authors should consider carefully whether to use SVCB or define a
new SVCB-compatible RR type, as this choice cannot easily be reversed after
deployment.</t>
    </section>
    <section anchor="keys" numbered="true" removeInRFC="false" toc="include" pn="section-7">
      <name slugifiedName="name-initial-svcparamkeys">Initial SvcParamKeys</name>
      <t indent="0" pn="section-7-1">A few initial SvcParamKeys are defined here.  These keys are useful for the
"https" scheme, and most are expected to be generally applicable to other
schemes as well.</t>
      <t indent="0" pn="section-7-2">Each new protocol
mapping document <bcp14>MUST</bcp14> specify which keys are applicable and safe to use.
Protocol mappings <bcp14>MAY</bcp14> alter the interpretation of SvcParamKeys but <bcp14>MUST NOT</bcp14>
alter their presentation or wire formats.</t>
      <section anchor="alpn-key" numbered="true" removeInRFC="false" toc="include" pn="section-7.1">
        <name slugifiedName="name-alpn-and-no-default-alpn">"alpn" and "no-default-alpn"</name>
        <t indent="0" pn="section-7.1-1">The "alpn" and "no-default-alpn" SvcParamKeys together
indicate the set of Application-Layer Protocol Negotiation (ALPN)
protocol identifiers <xref target="RFC7301" format="default" sectionFormat="of" derivedContent="ALPN"/>
and associated transport protocols supported by this service endpoint (the
"SVCB ALPN set").</t>
        <t indent="0" pn="section-7.1-2">As with Alt-Svc <xref target="RFC7838" format="default" sectionFormat="of" derivedContent="AltSvc"/>, each ALPN protocol identifier is used to
identify the application protocol and associated suite
of protocols supported by the endpoint (the "protocol suite").
The presence of an ALPN protocol identifier in the SVCB ALPN set indicates that this
service endpoint, described by TargetName and the other parameters (e.g.,
"port"), offers service with the protocol suite associated with this ALPN identifier.</t>
        <t indent="0" pn="section-7.1-3">Clients filter the set of ALPN identifiers to match the protocol suites they
support, and this informs the underlying transport protocol used (such
as QUIC over UDP or TLS over TCP).  ALPN protocol identifiers that do not uniquely
identify a protocol suite (e.g., an Identification Sequence that
can be used with both TLS and DTLS) are not compatible with this
SvcParamKey and <bcp14>MUST NOT</bcp14> be included in the SVCB ALPN set.</t>
        <section anchor="representation" numbered="true" removeInRFC="false" toc="include" pn="section-7.1.1">
          <name slugifiedName="name-representation">Representation</name>
          <t indent="0" pn="section-7.1.1-1">ALPNs are identified by their registered "Identification Sequence"
(<tt>alpn-id</tt>), which is a sequence of 1-255 octets.</t>
          <sourcecode name="" type="abnf" markers="false" pn="section-7.1.1-2">
alpn-id = 1*255OCTET
</sourcecode>
          <t indent="0" pn="section-7.1.1-3">For "alpn", the presentation <tt>value</tt> <bcp14>SHALL</bcp14> be
a comma-separated list (<xref target="value-list" format="default" sectionFormat="of" derivedContent="Appendix A.1"/>)
of one or more <tt>alpn-id</tt>s.  Zone-file implementations <bcp14>MAY</bcp14> disallow the
"," and "\" characters in ALPN IDs instead of implementing the <tt>value-list</tt> escaping
procedure, relying on the opaque key format (e.g., <tt>key1=\002h2</tt>) in the
event that these characters are needed.</t>
          <t indent="0" pn="section-7.1.1-4">The wire-format value for "alpn" consists of at least one
<tt>alpn-id</tt> prefixed by its length as a single octet, and these length-value
pairs are concatenated to form the SvcParamValue.  These pairs <bcp14>MUST</bcp14> exactly
fill the SvcParamValue; otherwise, the SvcParamValue is malformed.</t>
          <t indent="0" pn="section-7.1.1-5">For "no-default-alpn", the presentation and wire-format values <bcp14>MUST</bcp14> be
empty.  When "no-default-alpn" is specified in an RR,
"alpn" must also be specified in order for the RR
to be "self-consistent" (<xref target="service-mode" format="default" sectionFormat="of" derivedContent="Section 2.4.3"/>).</t>
          <t indent="0" pn="section-7.1.1-6">Each scheme that uses this SvcParamKey defines a "default set" of ALPN IDs
that are supported by nearly all clients and servers; this set <bcp14>MAY</bcp14>
be empty.  To determine the SVCB ALPN set, the client starts with the list of
<tt>alpn-id</tt>s from the "alpn" SvcParamKey, and it adds the default set unless the
"no-default-alpn" SvcParamKey is present.</t>
        </section>
        <section anchor="use" numbered="true" removeInRFC="false" toc="include" pn="section-7.1.2">
          <name slugifiedName="name-use">Use</name>
          <t indent="0" pn="section-7.1.2-1">To establish a connection to the endpoint, clients <bcp14>MUST</bcp14></t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-7.1.2-2"><li pn="section-7.1.2-2.1" derivedCounter="1.">Let SVCB-ALPN-Intersection be the set of protocols in the SVCB ALPN set
that the client supports.</li>
            <li pn="section-7.1.2-2.2" derivedCounter="2.">Let Intersection-Transports be the set of transports (e.g., TLS, DTLS, QUIC)
implied by the protocols in SVCB-ALPN-Intersection.</li>
            <li pn="section-7.1.2-2.3" derivedCounter="3.">For each transport in Intersection-Transports, construct a ProtocolNameList
containing the Identification Sequences of all the client's supported ALPN
protocols for that transport, without regard to the SVCB ALPN set.</li>
          </ol>
          <t indent="0" pn="section-7.1.2-3">For example, if the SVCB ALPN set is ["http/1.1", "h3"] and the client
supports HTTP/1.1, HTTP/2, and HTTP/3, the client could attempt to connect using
TLS over TCP with a ProtocolNameList of ["http/1.1", "h2"] and could also
attempt a connection using QUIC with a ProtocolNameList of ["h3"].</t>
          <t indent="0" pn="section-7.1.2-4">Once the client has constructed a ClientHello, protocol negotiation in that
handshake proceeds as specified in <xref target="RFC7301" format="default" sectionFormat="of" derivedContent="ALPN"/>, without regard to the SVCB ALPN
set.</t>
          <t indent="0" pn="section-7.1.2-5">Clients <bcp14>MAY</bcp14> implement a fallback procedure, using a less-preferred transport
if more-preferred transports fail to connect.  This fallback behavior is
vulnerable to manipulation by a network attacker who blocks the more-preferred
transports, but it may be necessary for compatibility with existing networks.</t>
          <t indent="0" pn="section-7.1.2-6">With this procedure in place, an attacker who can modify DNS and network
traffic can prevent a successful transport connection but cannot otherwise
interfere with ALPN protocol selection.  This procedure also ensures that
each ProtocolNameList includes at least one protocol from the SVCB ALPN set.</t>
          <t indent="0" pn="section-7.1.2-7">Clients <bcp14>SHOULD NOT</bcp14> attempt connection to a service endpoint whose SVCB
ALPN set does not contain any supported protocols.</t>
          <t indent="0" pn="section-7.1.2-8">To ensure
consistency of behavior, clients <bcp14>MAY</bcp14> reject the entire SVCB RRset and fall
back to basic connection establishment if all of the compatible RRs indicate
"no-default-alpn", even if connection could have succeeded using a
non-default ALPN protocol.</t>
          <t indent="0" pn="section-7.1.2-9">Zone operators <bcp14>SHOULD</bcp14> ensure that at least one RR in each RRset supports the
default transports.  This enables compatibility with the greatest number of
clients.</t>
        </section>
      </section>
      <section anchor="svcparamkeys-port" numbered="true" removeInRFC="false" toc="include" pn="section-7.2">
        <name slugifiedName="name-port">"port"</name>
        <t indent="0" pn="section-7.2-1">The "port" SvcParamKey defines the TCP or UDP port
that should be used to reach this alternative endpoint.
If this key is not present, clients <bcp14>SHALL</bcp14> use the authority endpoint's port
number.</t>
        <t indent="0" pn="section-7.2-2">The presentation <tt>value</tt> of the SvcParamValue is a single decimal integer
between 0 and 65535 in ASCII.  Any other <tt>value</tt> (e.g., an empty value)
is a syntax error.  To enable simpler parsing, this SvcParamValue <bcp14>MUST NOT</bcp14> contain
escape sequences.</t>
        <t indent="0" pn="section-7.2-3">The wire format of the SvcParamValue
is the corresponding 2-octet numeric value in network byte order.</t>
        <t indent="0" pn="section-7.2-4">If a port-restricting firewall is in place between some client and the service
endpoint, changing the port number might cause that client to lose access to
the service, so operators should exercise caution when using this SvcParamKey
to specify a non-default port.</t>
      </section>
      <section anchor="svcparamkeys-iphints" numbered="true" removeInRFC="false" toc="include" pn="section-7.3">
        <name slugifiedName="name-ipv4hint-and-ipv6hint">"ipv4hint" and "ipv6hint"</name>
        <t indent="0" pn="section-7.3-1">The "ipv4hint" and "ipv6hint" keys convey IP addresses that clients <bcp14>MAY</bcp14> use to
reach the service.  If A and AAAA records for TargetName are locally
available, the client <bcp14>SHOULD</bcp14> ignore these hints.  Otherwise, clients
<bcp14>SHOULD</bcp14> perform A and/or AAAA queries for TargetName per
<xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/>, and clients <bcp14>SHOULD</bcp14> use the IP address in those
responses for future connections. Clients <bcp14>MAY</bcp14> opt to terminate any
connections using the addresses in hints and instead switch to the
addresses in response to the TargetName query. Failure to use A and/or
AAAA response addresses could negatively impact load balancing or other
geo-aware features and thereby degrade client performance.</t>
        <t indent="0" pn="section-7.3-2">The presentation <tt>value</tt> <bcp14>SHALL</bcp14> be a comma-separated list (<xref target="value-list" format="default" sectionFormat="of" derivedContent="Appendix A.1"/>)
of one or more IP addresses of the appropriate
family in standard textual format <xref target="RFC5952" format="default" sectionFormat="of" derivedContent="RFC5952"/> <xref target="RFC4001" format="default" sectionFormat="of" derivedContent="RFC4001"/>.  To enable simpler parsing,
this SvcParamValue <bcp14>MUST NOT</bcp14> contain escape sequences.</t>
        <t indent="0" pn="section-7.3-3">The wire format for each parameter is a sequence of IP addresses in network
byte order (for the respective address family).
Like an A or AAAA RRset, the list of addresses represents an
unordered collection, and clients <bcp14>SHOULD</bcp14> pick addresses to use in a random order.
An empty list of addresses is invalid.</t>
        <t indent="0" pn="section-7.3-4">When selecting between IPv4 and IPv6 addresses to use, clients may use an
approach such as Happy Eyeballs <xref target="RFC8305" format="default" sectionFormat="of" derivedContent="HappyEyeballsV2"/>.
When only "ipv4hint" is present, NAT64 clients may synthesize
IPv6 addresses as specified in <xref target="RFC7050" format="default" sectionFormat="of" derivedContent="RFC7050"/> or ignore the "ipv4hint" key and
wait for AAAA resolution (<xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/>).
For best performance, server operators <bcp14>SHOULD</bcp14> include an "ipv6hint" parameter
whenever they include an "ipv4hint" parameter.</t>
        <t indent="0" pn="section-7.3-5">These parameters are intended to minimize additional connection latency
when a recursive resolver is not compliant with the requirements in
<xref target="server-behavior" format="default" sectionFormat="of" derivedContent="Section 4"/> and <bcp14>SHOULD NOT</bcp14> be included if most clients are using
compliant recursive resolvers.  When TargetName is the service name
or the owner name (which can be written as "."), server operators
<bcp14>SHOULD NOT</bcp14> include these hints, because they are unlikely to convey any
performance benefit.</t>
      </section>
      <section anchor="svcparamkey-mandatory" numbered="true" removeInRFC="false" toc="include" pn="section-7.4">
        <name slugifiedName="name-mandatory">"mandatory"</name>
        <t indent="0" pn="section-7.4-1">See <xref target="mandatory" format="default" sectionFormat="of" derivedContent="Section 8"/>.</t>
      </section>
    </section>
    <section anchor="mandatory" numbered="true" removeInRFC="false" toc="include" pn="section-8">
      <name slugifiedName="name-servicemode-rr-compatibilit">ServiceMode RR Compatibility and Mandatory Keys</name>
      <t indent="0" pn="section-8-1">In a ServiceMode RR, a SvcParamKey is considered "mandatory" if the RR will not
function correctly for clients that ignore this SvcParamKey.  Each SVCB
protocol mapping <bcp14>SHOULD</bcp14> specify a set of keys that are "automatically
mandatory", i.e., mandatory if they are present in an RR.  The SvcParamKey
"mandatory" is used to indicate any mandatory keys for this RR, in addition to
any automatically mandatory keys that are present.</t>
      <t indent="0" pn="section-8-2">A ServiceMode RR is considered "compatible" by a client if the client
recognizes all the mandatory keys and their values indicate that successful
connection establishment is possible.  Incompatible RRs are ignored (see step 5 of the procedure defined in <xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/>).</t>
      <t indent="0" pn="section-8-3">The presentation <tt>value</tt> <bcp14>SHALL</bcp14> be a comma-separated list
(<xref target="value-list" format="default" sectionFormat="of" derivedContent="Appendix A.1"/>) of one or more valid
SvcParamKeys, either by their registered name or in the unknown-key format
(<xref target="presentation" format="default" sectionFormat="of" derivedContent="Section 2.1"/>).  Keys <bcp14>MAY</bcp14> appear in any order but <bcp14>MUST NOT</bcp14> appear more
than once.  For self-consistency (<xref target="service-mode" format="default" sectionFormat="of" derivedContent="Section 2.4.3"/>), listed keys <bcp14>MUST</bcp14> also
appear in the SvcParams.</t>
      <t indent="0" pn="section-8-4">To enable simpler parsing, this
SvcParamValue <bcp14>MUST NOT</bcp14> contain escape sequences.</t>
      <t indent="0" pn="section-8-5">For example, the following is a valid list of SvcParams:</t>
      <sourcecode markers="false" pn="section-8-6">
ipv6hint=... key65333=ex1 key65444=ex2 mandatory=key65444,ipv6hint
</sourcecode>
      <t indent="0" pn="section-8-7">In wire format, the keys are represented by their numeric values in
network byte order, concatenated in strictly increasing numeric order.</t>
      <t indent="0" pn="section-8-8">This SvcParamKey is always automatically mandatory and <bcp14>MUST NOT</bcp14> appear in its
own value-list.  Other automatically mandatory keys <bcp14>SHOULD NOT</bcp14> appear in the
list either.  (Including them wastes space and otherwise has no effect.)</t>
    </section>
    <section anchor="https" numbered="true" removeInRFC="false" toc="include" pn="section-9">
      <name slugifiedName="name-using-service-bindings-with">Using Service Bindings with HTTP</name>
      <t indent="0" pn="section-9-1">The use of any protocol with SVCB requires a protocol-specific mapping
specification.  This section specifies the mapping for the "http" and "https"
URI schemes <xref target="RFC9110" format="default" sectionFormat="of" derivedContent="HTTP"/>.</t>
      <t indent="0" pn="section-9-2">To enable special handling for HTTP use cases,
the HTTPS RR type is defined as a SVCB-compatible RR type,
specific to the "https" and "http" schemes.  Clients <bcp14>MUST NOT</bcp14>
perform SVCB queries or accept SVCB responses for "https"
or "http" schemes.</t>
      <t indent="0" pn="section-9-3">The presentation format of the record is:</t>
      <sourcecode markers="false" pn="section-9-4">
Name TTL IN HTTPS SvcPriority TargetName SvcParams
</sourcecode>
      <t indent="0" pn="section-9-5">All the SvcParamKeys defined in <xref target="keys" format="default" sectionFormat="of" derivedContent="Section 7"/> are permitted for use in
HTTPS RRs.  The default set of ALPN IDs is the single value "http/1.1".
The "automatically mandatory" keys (<xref target="mandatory" format="default" sectionFormat="of" derivedContent="Section 8"/>) are "port"
and "no-default-alpn".  (As described in <xref target="mandatory" format="default" sectionFormat="of" derivedContent="Section 8"/>, clients must
either implement these keys or ignore any RR in which they appear.)
Clients that restrict the destination port in "https" URIs
(e.g., using the "bad ports" list from <xref target="FETCH" format="default" sectionFormat="of" derivedContent="FETCH"/>) <bcp14>SHOULD</bcp14> apply the
same restriction to the "port" SvcParam.</t>
      <t indent="0" pn="section-9-6">The presence of an HTTPS RR for an origin also indicates
that clients should connect securely and use the "https" scheme, as
discussed in <xref target="hsts" format="default" sectionFormat="of" derivedContent="Section 9.5"/>.  This allows HTTPS RRs to apply to
pre-existing "http" scheme URLs, while ensuring that the client uses a
secure and authenticated connection.</t>
      <t indent="0" pn="section-9-7">The HTTPS RR parallels the concepts
introduced in "HTTP Alternative Services" <xref target="RFC7838" format="default" sectionFormat="of" derivedContent="AltSvc"/>.  Clients and servers that implement HTTPS RRs are
not required to implement Alt-Svc.</t>
      <section anchor="httpsnames" numbered="true" removeInRFC="false" toc="include" pn="section-9.1">
        <name slugifiedName="name-query-names-for-https-rrs">Query Names for HTTPS RRs</name>
        <t indent="0" pn="section-9.1-1">The HTTPS RR uses Port Prefix Naming (<xref target="svcb-names" format="default" sectionFormat="of" derivedContent="Section 2.3"/>),
with one modification: if the scheme is "https" and the port is 443,
then the client's original QNAME is
equal to the service name (i.e., the origin's hostname),
without any prefix labels.</t>
        <t indent="0" pn="section-9.1-2">By removing the Attrleaf labels <xref target="RFC8552" format="default" sectionFormat="of" derivedContent="Attrleaf"/>
used in SVCB, this construction enables offline DNSSEC signing of
wildcard domains, which are commonly used with HTTP.  Using the
service name as the owner name of the HTTPS record, without prefixes,
also allows the targets of existing CNAME chains
(e.g., CDN hosts) to start returning HTTPS RR responses without
requiring origin domains to configure and maintain an additional
delegation.</t>
        <t indent="0" pn="section-9.1-3">The procedure for following HTTPS AliasMode RRs and CNAME aliases is unchanged from SVCB (as described in Sections <xref target="alias-mode" format="counter" sectionFormat="of" derivedContent="2.4.2"/> and <xref target="client-behavior" format="counter" sectionFormat="of" derivedContent="3"/>).</t>
        <t indent="0" pn="section-9.1-4">Clients always convert "http" URLs to "https" before performing an
HTTPS RR query using the process described in <xref target="hsts" format="default" sectionFormat="of" derivedContent="Section 9.5"/>, so domain owners
<bcp14>MUST NOT</bcp14> publish HTTPS RRs with a prefix of "_http".</t>
        <t indent="0" pn="section-9.1-5">Note that none of these forms alter the HTTPS origin or authority.
For example, clients <bcp14>MUST</bcp14> continue to validate TLS certificate
hostnames based on the origin.</t>
      </section>
      <section anchor="comparison-with-alt-svc" numbered="true" removeInRFC="false" toc="include" pn="section-9.2">
        <name slugifiedName="name-comparison-with-alt-svc">Comparison with Alt-Svc</name>
        <t indent="0" pn="section-9.2-1">Publishing a ServiceMode HTTPS RR in DNS is intended
to be similar to transmitting an Alt-Svc field value over
HTTP, and receiving an HTTPS RR is intended to be similar to
receiving that field value over HTTP.  However, there are some
differences in the intended client and server behavior.</t>
        <section anchor="alpn-usage" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.1">
          <name slugifiedName="name-alpn-usage">ALPN Usage</name>
          <t indent="0" pn="section-9.2.1-1">Unlike Alt-Svc field values, HTTPS RRs can contain multiple ALPN IDs.  The
meaning and use of these IDs are discussed in <xref target="use" format="default" sectionFormat="of" derivedContent="Section 7.1.2"/>.</t>
        </section>
        <section anchor="untrusted-channel" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.2">
          <name slugifiedName="name-untrusted-channels">Untrusted Channels</name>
          <t indent="0" pn="section-9.2.2-1">HTTPS records do not require or provide any assurance of authenticity.  (DNSSEC
signing and verification, which would provide such assurance, are <bcp14>OPTIONAL</bcp14>.)
The DNS resolution process is modeled as an untrusted channel that might be
controlled by an attacker, so
Alt-Svc parameters that cannot be safely received in this model <bcp14>MUST NOT</bcp14>
have a corresponding defined SvcParamKey.  For example, there is no
SvcParamKey corresponding to the Alt-Svc "persist" parameter, because
this parameter is not safe to accept over an untrusted channel.</t>
        </section>
        <section anchor="cache-lifetime" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.3">
          <name slugifiedName="name-cache-lifetime">Cache Lifetime</name>
          <t indent="0" pn="section-9.2.3-1">There is no SvcParamKey corresponding to the Alt-Svc "ma" (max age) parameter.
Instead, server operators encode the expiration time in the DNS TTL.</t>
          <t indent="0" pn="section-9.2.3-2">The appropriate TTL value might be different from the "ma" value
used for Alt-Svc, depending on the desired efficiency and
agility.  Some DNS caches incorrectly extend the lifetime of DNS
records beyond the stated TTL, so server operators cannot rely on
HTTPS RRs expiring on time.  Shortening the TTL to compensate
for incorrect caching is <bcp14>NOT RECOMMENDED</bcp14>, as this practice impairs the
performance of correctly functioning caches and does not guarantee
faster expiration from incorrect caches.  Instead, server operators
<bcp14>SHOULD</bcp14> maintain compatibility with expired records until they observe
that nearly all connections have migrated to the new configuration.</t>
        </section>
        <section anchor="granularity" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.4">
          <name slugifiedName="name-granularity">Granularity</name>
          <t indent="0" pn="section-9.2.4-1">Sending Alt-Svc over HTTP allows the server to tailor the Alt-Svc
field value specifically to the client.  When using an HTTPS RR,
groups of clients will necessarily receive the same SvcParams.
Therefore, HTTPS RRs are not suitable for uses that require
single-client granularity.</t>
        </section>
      </section>
      <section anchor="interaction-with-alt-svc" numbered="true" removeInRFC="false" toc="include" pn="section-9.3">
        <name slugifiedName="name-interaction-with-alt-svc">Interaction with Alt-Svc</name>
        <t indent="0" pn="section-9.3-1">Clients that implement support for both Alt-Svc and HTTPS records and
are making a connection based on a cached Alt-Svc response <bcp14>SHOULD</bcp14>
retrieve any HTTPS records for the Alt-Svc alt-authority and ensure that
their connection attempts are consistent with both the Alt-Svc parameters
and any received HTTPS SvcParams.  If present, the HTTPS record's TargetName
and port are used for connection establishment (per <xref target="client-behavior" format="default" sectionFormat="of" derivedContent="Section 3"/>).
For example, suppose that
"https://example.com" sends an Alt-Svc field value of:</t>
        <sourcecode type="http-message" markers="false" pn="section-9.3-2">
Alt-Svc: h2="alt.example:443", h2="alt2.example:443", h3=":8443"
</sourcecode>
        <t indent="0" pn="section-9.3-3">The client would retrieve the following HTTPS records:</t>
        <sourcecode type="dns-rr" markers="false" pn="section-9.3-4">
alt.example.              IN HTTPS 1 . alpn=h2,h3 foo=...
alt2.example.             IN HTTPS 1 alt2b.example. alpn=h3 foo=...
_8443._https.example.com. IN HTTPS 1 alt3.example. (
    port=9443 alpn=h2,h3 foo=... )
</sourcecode>
        <t indent="0" pn="section-9.3-5">Based on these inputs, the following connection attempts would always be
allowed:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-9.3-6">
          <li pn="section-9.3-6.1">HTTP/2 to <tt>alt.example:443</tt></li>
          <li pn="section-9.3-6.2">HTTP/3 to <tt>alt3.example:9443</tt></li>
          <li pn="section-9.3-6.3">Fallback to the client's non-Alt-Svc connection behavior</li>
        </ul>
        <t indent="0" pn="section-9.3-7">The following connection attempts would not be allowed:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-9.3-8">
          <li pn="section-9.3-8.1">HTTP/3 to <tt>alt.example:443</tt> (not consistent with Alt-Svc)</li>
          <li pn="section-9.3-8.2">Any connection to <tt>alt2b.example</tt> (no ALPN ID consistent with both the HTTPS
record and Alt-Svc)</li>
          <li pn="section-9.3-8.3">HTTPS over TCP to any port on <tt>alt3.example</tt> (not consistent with Alt-Svc)</li>
        </ul>
        <t indent="0" pn="section-9.3-9">Suppose that "foo" is a SvcParamKey that renders the client SVCB-reliant.
The following Alt-Svc-only connection attempts would be allowed only if
the client does not support "foo", as they rely on SVCB-optional fallback
behavior:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-9.3-10">
          <li pn="section-9.3-10.1">HTTP/2 to <tt>alt2.example:443</tt></li>
          <li pn="section-9.3-10.2">HTTP/3 to <tt>example.com:8443</tt></li>
        </ul>
        <t indent="0" pn="section-9.3-11">Alt-authorities <bcp14>SHOULD</bcp14> carry the same SvcParams as the origin unless
a deviation is specifically known to be safe.
As noted in <xref section="2.4" sectionFormat="of" target="RFC7838" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7838#section-2.4" derivedContent="AltSvc"/>, clients <bcp14>MAY</bcp14> disallow any Alt-Svc
connection according to their own criteria, e.g., disallowing Alt-Svc
connections that lack support for privacy features that are available on
the authority endpoint.</t>
      </section>
      <section anchor="requiring-server-name-indication" numbered="true" removeInRFC="false" toc="include" pn="section-9.4">
        <name slugifiedName="name-requiring-server-name-indic">Requiring Server Name Indication</name>
        <t indent="0" pn="section-9.4-1">Clients <bcp14>MUST NOT</bcp14> use an HTTPS RR response unless the
client supports the TLS Server Name Indication (SNI) extension and
indicates the origin name in the TLS ClientHello (which might be
encrypted via a future specification such as <xref target="I-D.ietf-tls-esni" format="default" sectionFormat="of" derivedContent="ECH"/>).
This supports the conservation of IP addresses.</t>
        <t indent="0" pn="section-9.4-2">Note that the TLS SNI (and also the HTTP "Host" or ":authority") will indicate
the origin, not the TargetName.</t>
      </section>
      <section anchor="hsts" numbered="true" removeInRFC="false" toc="include" pn="section-9.5">
        <name slugifiedName="name-http-strict-transport-secur">HTTP Strict Transport Security (HSTS)</name>
        <t indent="0" pn="section-9.5-1">An HTTPS RR directs the client to communicate with this host only over a
secure transport, similar to HSTS <xref target="RFC6797" format="default" sectionFormat="of" derivedContent="HSTS"/>.
Prior to making an "http" scheme request, the client <bcp14>SHOULD</bcp14> perform a lookup
to determine if any HTTPS RRs exist for that origin.  To do so,
the client <bcp14>SHOULD</bcp14> construct a corresponding "https" URL as follows:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-9.5-2"><li pn="section-9.5-2.1" derivedCounter="1.">Replace the "http" scheme with "https".</li>
          <li pn="section-9.5-2.2" derivedCounter="2.">If the "http" URL explicitly specifies port 80, specify port 443.</li>
          <li pn="section-9.5-2.3" derivedCounter="3.">Do not alter any other aspect of the URL.</li>
        </ol>
        <t indent="0" pn="section-9.5-3">This construction is equivalent to <xref section="8.3" sectionFormat="of" target="RFC6797" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6797#section-8.3" derivedContent="HSTS"/>, Step 5.</t>
        <t indent="0" pn="section-9.5-4">If an HTTPS RR query for this "https" URL returns any AliasMode HTTPS RRs
or any compatible ServiceMode HTTPS RRs (see <xref target="mandatory" format="default" sectionFormat="of" derivedContent="Section 8"/>), the client
<bcp14>SHOULD</bcp14> behave as if it has received an HTTP 307 (Temporary Redirect) status code
with this "https" URL in the "Location" field.  (Receipt of an incompatible ServiceMode RR does not
trigger the redirect behavior.)
Because HTTPS RRs are received over an often-insecure channel (DNS),
clients <bcp14>MUST NOT</bcp14> place any more trust in this signal than if they
had received a 307 (Temporary Redirect) response over cleartext HTTP.</t>
        <t indent="0" pn="section-9.5-5">Publishing an HTTPS RR can potentially lead to unexpected results
or a loss in functionality in cases where the "http" resource neither
redirects to the "https" resource nor references the same underlying resource.</t>
        <t indent="0" pn="section-9.5-6">When an "https" connection fails due to an error in the underlying secure
transport, such as an error in certificate validation, some clients
currently offer a "user recourse" that allows the user to bypass the
security error and connect anyway.
When making an "https" scheme request to an origin with an HTTPS RR,
either directly or via the above redirect, such a client <bcp14>MAY</bcp14> remove the user
recourse option.  Origins that publish HTTPS RRs therefore <bcp14>MUST NOT</bcp14> rely
on user recourse for access.  For more information, see Sections <xref target="RFC6797" section="8.4" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6797#section-8.4" derivedContent="HSTS"/> and <xref target="RFC6797" section="12.1" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6797#section-12.1" derivedContent="HSTS"/> of <xref target="RFC6797" format="default" sectionFormat="of" derivedContent="HSTS"/>.</t>
      </section>
      <section anchor="use-of-https-rrs-in-other-protocols" numbered="true" removeInRFC="false" toc="include" pn="section-9.6">
        <name slugifiedName="name-use-of-https-rrs-in-other-p">Use of HTTPS RRs in Other Protocols</name>
        <t indent="0" pn="section-9.6-1">All HTTP connections to named origins are eligible to use HTTPS RRs, even
when HTTP is used as part of another protocol or without an explicit HTTP-related URI
scheme (<xref target="RFC9110" section="4.2" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-4.2" derivedContent="HTTP"/>).  For example, clients that
support HTTPS RRs and implement <xref target="RFC6455" format="default" sectionFormat="of" derivedContent="WebSocket"/> using the altered
opening handshake from <xref target="FETCH-WEBSOCKETS" format="default" sectionFormat="of" derivedContent="FETCH-WEBSOCKETS"/> <bcp14>SHOULD</bcp14> use HTTPS RRs
for the <tt>requestURL</tt>.</t>
        <t indent="0" pn="section-9.6-2">When HTTP is used in a context where URLs or redirects are not applicable
(e.g., connections to an HTTP proxy), clients that find a corresponding HTTPS RR
<bcp14>SHOULD</bcp14> implement security upgrade behavior equivalent to that
specified in
<xref target="hsts" format="default" sectionFormat="of" derivedContent="Section 9.5"/>.</t>
        <t indent="0" pn="section-9.6-3">Such protocols <bcp14>MAY</bcp14> define their own SVCB mappings, which <bcp14>MAY</bcp14>
be defined to take precedence over HTTPS RRs.</t>
      </section>
    </section>
    <section anchor="zone-structures" numbered="true" removeInRFC="false" toc="include" pn="section-10">
      <name slugifiedName="name-zone-structures">Zone Structures</name>
      <section anchor="structuring-zones-for-flexibility" numbered="true" removeInRFC="false" toc="include" pn="section-10.1">
        <name slugifiedName="name-structuring-zones-for-flexi">Structuring Zones for Flexibility</name>
        <t indent="0" pn="section-10.1-1">Each ServiceMode RRset can only serve a single scheme.  The scheme is indicated
by the owner name and the RR type.  For the generic SVCB RR type, this means that
each owner name can only be used for a single scheme.  The underscore prefixing
requirement (<xref target="svcb-names" format="default" sectionFormat="of" derivedContent="Section 2.3"/>) ensures that this is true for the initial query,
but it is the responsibility of zone owners to choose names that satisfy this
constraint when using aliases, including CNAME and AliasMode records.</t>
        <t indent="0" pn="section-10.1-2">When using the generic SVCB RR type with aliasing, zone owners <bcp14>SHOULD</bcp14> choose alias
target names that indicate the scheme in use (e.g., "foosvc.example.net" for
"foo" schemes).  This will help to avoid confusion when another scheme needs to
be added to the configuration.  When multiple port numbers are in use, it may be
helpful to repeat the prefix labels in the alias target name (e.g.,
"_1234._foo.svc.example.net").</t>
      </section>
      <section anchor="zone-performance" numbered="true" removeInRFC="false" toc="include" pn="section-10.2">
        <name slugifiedName="name-structuring-zones-for-perfo">Structuring Zones for Performance</name>
        <t indent="0" pn="section-10.2-1">To avoid a delay for clients using a non-conforming recursive resolver,
domain owners <bcp14>SHOULD</bcp14> minimize the use of AliasMode records and <bcp14>SHOULD</bcp14>
choose TargetName according to a predictable convention that is known
to the client, so that clients can issue A and/or AAAA queries for TargetName
in advance (see <xref target="optimizations" format="default" sectionFormat="of" derivedContent="Section 5"/>).  Unless otherwise specified, the
convention is to set TargetName to the service name for an initial
ServiceMode record, or to "." if it is reached via an alias.</t>
        <figure align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-foo-fooexamplecom8080-is-av">"foo://foo.example.com:8080" Is Available at "foosvc.example.net", but "bar://bar.example.com:9090" Is Served Locally</name>
          <sourcecode type="dns-rr" markers="false" pn="section-10.2-2.1">
$ORIGIN example.com. ; Origin
foo                  3600 IN CNAME foosvc.example.net.
_8080._foo.foo       3600 IN CNAME foosvc.example.net.
bar                   300 IN AAAA 2001:db8::2
_9090._bar.bar       3600 IN SVCB 1 bar key65444=...

$ORIGIN example.net. ; Service provider zone
foosvc               3600 IN SVCB 1 . key65333=...
foosvc                300 IN AAAA 2001:db8::1
</sourcecode>
        </figure>
        <t indent="0" pn="section-10.2-3">Domain owners <bcp14>SHOULD</bcp14> avoid using a TargetName that is below a DNAME, as
this is likely unnecessary and makes responses slower and larger.
Also, zone structures that require following more than eight aliases
(counting both AliasMode and CNAME records) are <bcp14>NOT RECOMMENDED</bcp14>.</t>
      </section>
      <section anchor="operational-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-10.3">
        <name slugifiedName="name-operational-considerations">Operational Considerations</name>
        <t indent="0" pn="section-10.3-1">Some authoritative DNS servers may not allow A or AAAA records on names
starting with an underscore (e.g., <xref target="BIND-CHECK-NAMES" format="default" sectionFormat="of" derivedContent="BIND-CHECK-NAMES"/>).
This could create an operational issue when the TargetName contains an Attrleaf label,
or when using a TargetName of "." if the owner name contains an Attrleaf label.</t>
      </section>
      <section anchor="examples" numbered="true" removeInRFC="false" toc="include" pn="section-10.4">
        <name slugifiedName="name-examples">Examples</name>
        <section anchor="protocol-enhancements" numbered="true" removeInRFC="false" toc="include" pn="section-10.4.1">
          <name slugifiedName="name-protocol-enhancements">Protocol Enhancements</name>
          <t indent="0" pn="section-10.4.1-1">Consider a simple zone of the form:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-10.4.1-2">
$ORIGIN simple.example. ; Simple example zone
@ 300 IN A    192.0.2.1
         AAAA 2001:db8::1
</sourcecode>
          <t indent="0" pn="section-10.4.1-3">The domain owner could add this record:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-10.4.1-4">
@ 7200 IN HTTPS 1 . alpn=h3
</sourcecode>
          <t indent="0" pn="section-10.4.1-5">This record would indicate that "https://simple.example" supports QUIC
in addition to HTTP/1.1 over TLS over TCP (the implicit default).
The record could also include other information (e.g., a non-standard port).
For "https://simple.example:8443", the record would be:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-10.4.1-6">
_8443._https 7200 IN HTTPS 1 . alpn=h3
</sourcecode>
          <t indent="0" pn="section-10.4.1-7">These records also respectively tell clients to replace the scheme with "https" when
loading "http://simple.example" or "http://simple.example:8443".</t>
        </section>
        <section anchor="apex-aliasing" numbered="true" removeInRFC="false" toc="include" pn="section-10.4.2">
          <name slugifiedName="name-apex-aliasing">Apex Aliasing</name>
          <t indent="0" pn="section-10.4.2-1">Consider a zone that is using CNAME aliasing:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-10.4.2-2">
$ORIGIN aliased.example. ; A zone that is using a hosting service
; Subdomain aliased to a high-performance server pool
www             7200 IN CNAME pool.svc.example.
; Apex domain on fixed IPs because CNAME is not allowed at the apex
@                300 IN A     192.0.2.1
                     IN AAAA  2001:db8::1
</sourcecode>
          <t indent="0" pn="section-10.4.2-3">With HTTPS RRs, the owner of aliased.example could alias the apex by
adding one additional record:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-10.4.2-4">
@               7200 IN HTTPS 0 pool.svc.example.
</sourcecode>
          <t indent="0" pn="section-10.4.2-5">With this record in place, HTTPS-RR-aware clients will use the same
server pool for aliased.example and www.aliased.example.  (They will
also upgrade "http://aliased.example/..." to "https".)  Non-HTTPS-RR-aware
clients will just ignore the new record.</t>
          <t indent="0" pn="section-10.4.2-6">Similar to CNAME, HTTPS RRs have no impact on the origin name.
When connecting, clients will continue to treat the authoritative
origins as "https://www.aliased.example" and "https://aliased.example",
respectively, and will validate TLS server certificates accordingly.</t>
        </section>
        <section anchor="parameter-binding" numbered="true" removeInRFC="false" toc="include" pn="section-10.4.3">
          <name slugifiedName="name-parameter-binding">Parameter Binding</name>
          <t indent="0" pn="section-10.4.3-1">Suppose that svc.example's primary server pool supports HTTP/3 but its
backup server pool does not.  This can be expressed in the following form:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-10.4.3-2">
$ORIGIN svc.example. ; A hosting provider
pool  7200 IN HTTPS 1 . alpn=h2,h3
              HTTPS 2 backup alpn=h2 port=8443
pool   300 IN A        192.0.2.2
              AAAA     2001:db8::2
backup 300 IN A        192.0.2.3
              AAAA     2001:db8::3
</sourcecode>
          <t indent="0" pn="section-10.4.3-3">This configuration is entirely compatible with the "apex aliasing" example,
whether the client supports HTTPS RRs or not.  If the client does support
HTTPS RRs, all connections will be upgraded to HTTPS, and clients will
use HTTP/3 if they can.  Parameters are "bound" to each server pool, so
each server pool can have its own protocol, port number, etc.</t>
        </section>
        <section anchor="multicdn" numbered="true" removeInRFC="false" toc="include" pn="section-10.4.4">
          <name slugifiedName="name-multi-cdn-configuration">Multi-CDN Configuration</name>
          <t indent="0" pn="section-10.4.4-1">The HTTPS RR is intended to support HTTPS services operated by
multiple independent entities, such as different CDNs or different hosting providers.  This includes
the case where a service is migrated from one operator to another,
as well as the case where the service is multiplexed between
multiple operators for performance, redundancy, etc.</t>
          <t indent="0" pn="section-10.4.4-2">This example shows such a configuration, with www.customer.example
having different DNS responses to different queries, either over time
or due to logic within the authoritative DNS server:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-10.4.4-3">
 ; This zone contains/returns different CNAME records
 ; at different points in time.  The RRset for "www" can
 ; only ever contain a single CNAME.

 ; Sometimes the zone has:
 $ORIGIN customer.example.  ; A multi-CDN customer domain
 www 900 IN CNAME cdn1.svc1.example.

 ; and other times it contains:
 $ORIGIN customer.example.
 www 900 IN CNAME customer.svc2.example.

 ; and yet other times it contains:
 $ORIGIN customer.example.
 www 900 IN CNAME cdn3.svc3.example.

 ; With the following remaining constant and always included:
 $ORIGIN customer.example.  ; A multi-CDN customer domain
 ; The apex is also aliased to www to match its configuration.
 @     7200 IN HTTPS 0 www
 ; Non-HTTPS-aware clients use non-CDN IPs.
               A    203.0.113.82
               AAAA 2001:db8:203::2

 ; Resolutions following the cdn1.svc1.example
 ; path use these records.
 ; This CDN uses a different alternative service for HTTP/3.
 $ORIGIN svc1.example.  ; domain for CDN 1
 cdn1     1800 IN HTTPS 1 h3pool alpn=h3
                  HTTPS 2 . alpn=h2
                  A    192.0.2.2
                  AAAA 2001:db8:192::4
 h3pool 300 IN A 192.0.2.3
            AAAA 2001:db8:192:7::3

 ; Resolutions following the customer.svc2.example
 ; path use these records.
 ; Note that this CDN only supports HTTP/2.
 $ORIGIN svc2.example. ; domain operated by CDN 2
 customer 300 IN HTTPS 1 . alpn=h2
           60 IN A    198.51.100.2
                 A    198.51.100.3
                 A    198.51.100.4
                 AAAA 2001:db8:198::7
                 AAAA 2001:db8:198::12

 ; Resolutions following the cdn3.svc3.example
 ; path use these records.
 ; Note that this CDN has no HTTPS records.
 $ORIGIN svc3.example. ; domain operated by CDN 3
 cdn3      60 IN A    203.0.113.8
                 AAAA 2001:db8:113::8
</sourcecode>
          <t indent="0" pn="section-10.4.4-4">Note that in the above example, the different CDNs have different
configurations and different capabilities, but clients will use HTTPS RRs
as a bound-together unit.</t>
          <t indent="0" pn="section-10.4.4-5">Domain owners should be cautious when using a multi-CDN configuration, as it
introduces a number of complexities highlighted by this example:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-10.4.4-6">
            <li pn="section-10.4.4-6.1">If CDN 1 supports a desired protocol or feature and CDN 2 does not, the
client is vulnerable to
downgrade by a network adversary who forces clients to get CDN 2 records.</li>
            <li pn="section-10.4.4-6.2">Aliasing the apex to its subdomain simplifies the zone file but likely
increases resolution latency, especially when using a non-HTTPS-aware
recursive resolver.  An alternative would be to alias the zone
apex directly to a name managed by a CDN.</li>
            <li pn="section-10.4.4-6.3">The A, AAAA, and HTTPS resolutions are independent lookups, so resolvers may
observe and follow different CNAMEs to different CDNs.
Clients may thus find that the A and AAAA responses do not correspond to the
TargetName in the HTTPS response; these clients will need to perform additional
queries to retrieve the correct IP addresses.
Including ipv6hint and ipv4hint will reduce the performance
impact of this case.</li>
            <li pn="section-10.4.4-6.4">If not all CDNs publish HTTPS records, clients will sometimes
receive NODATA for HTTPS queries (as with cdn3.svc3.example above)
but could receive A/AAAA records from a different CDN.  Clients will
attempt to connect to this CDN without the benefit of its HTTPS
records.</li>
          </ul>
        </section>
        <section anchor="non-http-uses" numbered="true" removeInRFC="false" toc="include" pn="section-10.4.5">
          <name slugifiedName="name-non-http-uses">Non-HTTP Uses</name>
          <t indent="0" pn="section-10.4.5-1">For protocols other than HTTP, the SVCB RR and an Attrleaf label <xref target="RFC8552" format="default" sectionFormat="of" derivedContent="Attrleaf"/>
will be used.  For example, to reach an example resource of
"baz://api.example.com:8765", the following SVCB
record would be used to alias it to "svc4-baz.example.net.",
which in turn could return AAAA/A records and/or SVCB
records in ServiceMode:</t>
          <sourcecode type="dns-rr" markers="false" pn="section-10.4.5-2">
_8765._baz.api.example.com. 7200 IN SVCB 0 svc4-baz.example.net.
</sourcecode>
          <t indent="0" pn="section-10.4.5-3">HTTPS RRs use similar Attrleaf labels if the origin contains
a non-default port.</t>
        </section>
      </section>
    </section>
    <section anchor="other-standards" numbered="true" removeInRFC="false" toc="include" pn="section-11">
      <name slugifiedName="name-interaction-with-other-stan">Interaction with Other Standards</name>
      <t indent="0" pn="section-11-1">This standard is intended to reduce connection latency and
improve user privacy.  Server operators implementing this standard
<bcp14>SHOULD</bcp14> also implement TLS 1.3 <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/> and
Online Certificate Status Protocol (OCSP) Stapling (i.e., Certificate Status
Request in <xref target="RFC6066" section="8" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6066#section-8" derivedContent="RFC6066"/>),
both of which confer substantial performance and privacy
benefits when used in combination with SVCB records.</t>
      <t indent="0" pn="section-11-2">To realize the greatest privacy benefits, this proposal is intended for
use over a privacy-preserving DNS transport (like DNS over TLS
<xref target="RFC7858" format="default" sectionFormat="of" derivedContent="DoT"/> or DNS over HTTPS <xref target="RFC8484" format="default" sectionFormat="of" derivedContent="DoH"/>).
However, performance improvements, and some modest privacy improvements,
are possible without the use of those standards.</t>
      <t indent="0" pn="section-11-3">Any specification for the use of SVCB with a protocol <bcp14>MUST</bcp14> have an entry for its
scheme under the SVCB RR type in the IANA DNS "Underscored and Globally Scoped DNS Node Names" registry <xref target="RFC8552" format="default" sectionFormat="of" derivedContent="Attrleaf"/>.  The scheme <bcp14>MUST</bcp14> have an entry in the "Uniform Resource Identifier (URI) Schemes" registry <xref target="RFC7595" format="default" sectionFormat="of" derivedContent="RFC7595"/> and <bcp14>MUST</bcp14> have a defined specification for use
with SVCB.</t>
    </section>
    <section anchor="security-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-12">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-12-1">SVCB/HTTPS RRs permit distribution over untrusted
channels, and clients are <bcp14>REQUIRED</bcp14> to verify that the alternative endpoint
is authoritative for the service (similar to <xref section="2.1" sectionFormat="of" target="RFC7838" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7838#section-2.1" derivedContent="AltSvc"/>).
Therefore, DNSSEC signing and validation are <bcp14>OPTIONAL</bcp14> for publishing
and using SVCB and HTTPS RRs.</t>
      <t indent="0" pn="section-12-2">Clients <bcp14>MUST</bcp14> ensure that their DNS cache is partitioned for each local
network, or flushed on network changes, to prevent a local adversary in one
network from implanting a forged DNS record that allows them to
track users or hinder their connections after they leave that network.</t>
      <t indent="0" pn="section-12-3">An attacker who can prevent SVCB resolution can deny clients any associated
security benefits.  A hostile recursive resolver can always deny service to
SVCB queries, but network intermediaries can often prevent resolution as well,
even when the client and recursive resolver validate DNSSEC and use a secure
transport.  These downgrade attacks can prevent the "https" upgrade provided by
the HTTPS RR (<xref target="hsts" format="default" sectionFormat="of" derivedContent="Section 9.5"/>) and can disable any other protections coordinated via
SvcParams.  To prevent downgrades, <xref target="client-failures" format="default" sectionFormat="of" derivedContent="Section 3.1"/>
recommends that clients abandon the connection attempt when such an attack is
detected.</t>
      <t indent="0" pn="section-12-4">A hostile DNS intermediary might forge AliasMode "." records (<xref target="aliasdot" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>) as
a way to block clients from accessing particular services.  Such an adversary
could already block entire domains by forging erroneous responses, but this
mechanism allows them to target particular protocols or ports within a domain.
Clients that might be subject to such attacks <bcp14>SHOULD</bcp14> ignore AliasMode "."
records.</t>
      <t indent="0" pn="section-12-5">A hostile DNS intermediary or authoritative server can return SVCB records indicating any IP
address and port number, including IP addresses inside the local network and
port numbers assigned to internal services.  If the attacker can influence the
client's payload (e.g., TLS session ticket contents) and an internal service
has a sufficiently lax parser, the attacker could gain access to the
internal service.  (The same concerns apply to SRV records, HTTP Alt-Svc,
and HTTP redirects.)  As a mitigation, SVCB mapping documents <bcp14>SHOULD</bcp14> indicate
any port number restrictions that are appropriate for the supported transports.</t>
    </section>
    <section anchor="privacy-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-13">
      <name slugifiedName="name-privacy-considerations">Privacy Considerations</name>
      <t indent="0" pn="section-13-1">Standard address queries reveal the user's intent to access a particular
domain.  This information is visible to the recursive resolver, and to
many other parties when plaintext DNS transport is used.  SVCB queries,
like queries for SRV records and other specific RR types, additionally
reveal the user's intent to use a particular protocol.  This is not
normally sensitive information, but it should be considered when adding
SVCB support in a new context.</t>
    </section>
    <section anchor="iana-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-14">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <section anchor="svcb-rrtype" numbered="true" removeInRFC="false" toc="include" pn="section-14.1">
        <name slugifiedName="name-svcb-rr-type">SVCB RR Type</name>
        <t indent="0" pn="section-14.1-1">IANA has registered the following new DNS RR type in the "Resource Record (RR) TYPEs"
registry on the "Domain Name System (DNS) Parameters" page:</t>
        <dl spacing="compact" indent="3" newline="false" pn="section-14.1-2">
          <dt pn="section-14.1-2.1">Type:</dt>
          <dd pn="section-14.1-2.2">SVCB</dd>
          <dt pn="section-14.1-2.3">Value:</dt>
          <dd pn="section-14.1-2.4">64</dd>
          <dt pn="section-14.1-2.5">Meaning:</dt>
          <dd pn="section-14.1-2.6">General-purpose service binding</dd>
          <dt pn="section-14.1-2.7">Reference:</dt>
          <dd pn="section-14.1-2.8">RFC 9460</dd>
        </dl>
      </section>
      <section anchor="https-rrtype" numbered="true" removeInRFC="false" toc="include" pn="section-14.2">
        <name slugifiedName="name-https-rr-type">HTTPS RR Type</name>
        <t indent="0" pn="section-14.2-1">IANA has registered the following new DNS RR type
   in the "Resource Record (RR) TYPEs" registry
   on the "Domain Name System (DNS) Parameters" page:</t>
        <dl spacing="compact" indent="3" newline="false" pn="section-14.2-2">
          <dt pn="section-14.2-2.1">Type:</dt>
          <dd pn="section-14.2-2.2">HTTPS</dd>
          <dt pn="section-14.2-2.3">Value:</dt>
          <dd pn="section-14.2-2.4">65</dd>
          <dt pn="section-14.2-2.5">Meaning:</dt>
          <dd pn="section-14.2-2.6">SVCB-compatible type for use with HTTP</dd>
          <dt pn="section-14.2-2.7">Reference:</dt>
          <dd pn="section-14.2-2.8">RFC 9460</dd>
        </dl>
      </section>
      <section anchor="svcparamregistry" numbered="true" removeInRFC="false" toc="include" pn="section-14.3">
        <name slugifiedName="name-new-registry-for-service-pa">New Registry for Service Parameters</name>
        <t indent="0" pn="section-14.3-1">IANA has created the "Service Parameter Keys (SvcParamKeys)"
registry in the "Domain Name System (DNS) Parameters" category
on a new page entitled "DNS Service Bindings (SVCB)".  This registry
defines the namespace
for parameters, including string representations and numeric
SvcParamKey values.  This registry is shared with other SVCB-compatible
RR types, such as the HTTPS RR.</t>
        <section anchor="procedure" numbered="true" removeInRFC="false" toc="include" pn="section-14.3.1">
          <name slugifiedName="name-procedure">Procedure</name>
          <t indent="0" pn="section-14.3.1-1">A registration <bcp14>MUST</bcp14> include the following fields:</t>
          <dl spacing="compact" indent="3" newline="false" pn="section-14.3.1-2">
            <dt pn="section-14.3.1-2.1">Number:</dt>
            <dd pn="section-14.3.1-2.2">Wire-format numeric identifier (range 0-65535)</dd>
            <dt pn="section-14.3.1-2.3">Name:</dt>
            <dd pn="section-14.3.1-2.4">Unique presentation name</dd>
            <dt pn="section-14.3.1-2.5">Meaning:</dt>
            <dd pn="section-14.3.1-2.6">A short description</dd>
            <dt pn="section-14.3.1-2.7">Reference:</dt>
            <dd pn="section-14.3.1-2.8">Location of specification or registration source</dd>
            <dt pn="section-14.3.1-2.9">Change Controller:</dt>
            <dd pn="section-14.3.1-2.10">Person or entity, with contact information if appropriate</dd>
          </dl>
          <t indent="0" pn="section-14.3.1-3">The characters in the registered Name field entry <bcp14>MUST</bcp14> be lowercase alphanumeric or "-"
(<xref target="presentation" format="default" sectionFormat="of" derivedContent="Section 2.1"/>).  The name <bcp14>MUST NOT</bcp14> start with "key" or "invalid".</t>
          <t indent="0" pn="section-14.3.1-4">The registration policy for new entries is Expert Review (<xref section="4.5" sectionFormat="comma" target="RFC8126" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.5" derivedContent="RFC8126"/>).  The designated expert <bcp14>MUST</bcp14> ensure that
the reference is stable and publicly available and that it specifies
how to convert the SvcParamValue's presentation format to wire format.  The
reference <bcp14>MAY</bcp14> be any individual's Internet-Draft or a document from
any other source with similar assurances of stability and availability.
An entry <bcp14>MAY</bcp14> specify a reference of
the form "Same as (other key name)" if it uses the same presentation and wire
formats as an existing key.
</t>
          <t indent="0" pn="section-14.3.1-5">This arrangement supports the development of new parameters while ensuring that
zone files can be made interoperable.</t>
        </section>
        <section anchor="iana-keys" numbered="true" removeInRFC="false" toc="include" pn="section-14.3.2">
          <name slugifiedName="name-initial-contents">Initial Contents</name>
          <t indent="0" pn="section-14.3.2-1">The "Service Parameter Keys (SvcParamKeys)" registry has been
populated with the following initial registrations:</t>
          <table align="center" pn="table-1">
            <thead>
              <tr>
                <th align="center" colspan="1" rowspan="1">Number</th>
                <th align="left" colspan="1" rowspan="1">Name</th>
                <th align="left" colspan="1" rowspan="1">Meaning</th>
                <th align="left" colspan="1" rowspan="1">Reference</th>
                <th align="left" colspan="1" rowspan="1">Change Controller</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" colspan="1" rowspan="1">0</td>
                <td align="left" colspan="1" rowspan="1">mandatory</td>
                <td align="left" colspan="1" rowspan="1">Mandatory keys in this RR</td>
                <td align="left" colspan="1" rowspan="1">RFC 9460, <xref target="mandatory" format="default" sectionFormat="of" derivedContent="Section 8"/></td>
                <td align="left" colspan="1" rowspan="1">IETF</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">1</td>
                <td align="left" colspan="1" rowspan="1">alpn</td>
                <td align="left" colspan="1" rowspan="1">Additional supported protocols</td>
                <td align="left" colspan="1" rowspan="1">RFC 9460, <xref target="alpn-key" format="default" sectionFormat="of" derivedContent="Section 7.1"/></td>
                <td align="left" colspan="1" rowspan="1">IETF</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">2</td>
                <td align="left" colspan="1" rowspan="1">no-default-alpn</td>
                <td align="left" colspan="1" rowspan="1">No support for default protocol</td>
                <td align="left" colspan="1" rowspan="1">RFC 9460, <xref target="alpn-key" format="default" sectionFormat="of" derivedContent="Section 7.1"/></td>
                <td align="left" colspan="1" rowspan="1">IETF</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">3</td>
                <td align="left" colspan="1" rowspan="1">port</td>
                <td align="left" colspan="1" rowspan="1">Port for alternative endpoint</td>
                <td align="left" colspan="1" rowspan="1">RFC 9460, <xref target="svcparamkeys-port" format="default" sectionFormat="of" derivedContent="Section 7.2"/></td>
                <td align="left" colspan="1" rowspan="1">IETF</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">4</td>
                <td align="left" colspan="1" rowspan="1">ipv4hint</td>
                <td align="left" colspan="1" rowspan="1">IPv4 address hints</td>
                <td align="left" colspan="1" rowspan="1">RFC 9460, <xref target="svcparamkeys-iphints" format="default" sectionFormat="of" derivedContent="Section 7.3"/></td>
                <td align="left" colspan="1" rowspan="1">IETF</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">5</td>
                <td align="left" colspan="1" rowspan="1">ech</td>
                <td align="left" colspan="1" rowspan="1">RESERVED (held for Encrypted ClientHello)</td>
                <td align="left" colspan="1" rowspan="1">N/A</td>
                <td align="left" colspan="1" rowspan="1">IETF</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">6</td>
                <td align="left" colspan="1" rowspan="1">ipv6hint</td>
                <td align="left" colspan="1" rowspan="1">IPv6 address hints</td>
                <td align="left" colspan="1" rowspan="1">RFC 9460, <xref target="svcparamkeys-iphints" format="default" sectionFormat="of" derivedContent="Section 7.3"/></td>
                <td align="left" colspan="1" rowspan="1">IETF</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">65280-65534</td>
                <td align="left" colspan="1" rowspan="1">N/A</td>
                <td align="left" colspan="1" rowspan="1">Reserved for Private Use</td>
                <td align="left" colspan="1" rowspan="1">RFC 9460</td>
                <td align="left" colspan="1" rowspan="1">IETF</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">65535</td>
                <td align="left" colspan="1" rowspan="1">N/A</td>
                <td align="left" colspan="1" rowspan="1">Reserved ("Invalid key")</td>
                <td align="left" colspan="1" rowspan="1">RFC 9460</td>
                <td align="left" colspan="1" rowspan="1">IETF</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="other-registry-updates" numbered="true" removeInRFC="false" toc="include" pn="section-14.4">
        <name slugifiedName="name-other-registry-updates">Other Registry Updates</name>
        <t indent="0" pn="section-14.4-1">Per <xref target="RFC8552" format="default" sectionFormat="of" derivedContent="Attrleaf"/>, the following entry has been added to the DNS "Underscored and Globally Scoped DNS Node Names" registry:</t>
        <table align="center" pn="table-2">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">RR Type</th>
              <th align="left" colspan="1" rowspan="1">_NODE NAME</th>
              <th align="left" colspan="1" rowspan="1">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTPS</td>
              <td align="left" colspan="1" rowspan="1">_https</td>
              <td align="left" colspan="1" rowspan="1">RFC 9460</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target="RFC9110" to="HTTP"/>
    <displayreference target="RFC8552" to="Attrleaf"/>
    <displayreference target="RFC8305" to="HappyEyeballsV2"/>
    <displayreference target="RFC7858" to="DoT"/>
    <displayreference target="RFC8484" to="DoH"/>
    <displayreference target="RFC7301" to="ALPN"/>
    <displayreference target="RFC6455" to="WebSocket"/>
    <displayreference target="I-D.ietf-tls-esni" to="ECH"/>
    <displayreference target="RFC9114" to="HTTP/3"/>
    <displayreference target="RFC2782" to="SRV"/>
    <displayreference target="RFC6797" to="HSTS"/>
    <displayreference target="RFC7838" to="AltSvc"/>
    <displayreference target="RFC8499" to="DNSTerm"/>
    <displayreference target="RFC3986" to="URI"/>
    <displayreference target="RFC6672" to="DNAME"/>
    <displayreference target="I-D.bellis-dnsop-http-record" to="HTTP-DNS-RR"/>
    <displayreference target="I-D.ietf-dnsop-aname" to="ANAME-DNS-RR"/>
    <references pn="section-15">
      <name slugifiedName="name-references">References</name>
      <references pn="section-15.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC7301" target="https://www.rfc-editor.org/info/rfc7301" quoteTitle="true" derivedAnchor="ALPN">
          <front>
            <title>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</title>
            <author fullname="S. Friedl" initials="S." surname="Friedl"/>
            <author fullname="A. Popov" initials="A." surname="Popov"/>
            <author fullname="A. Langley" initials="A." surname="Langley"/>
            <author fullname="E. Stephan" initials="E." surname="Stephan"/>
            <date month="July" year="2014"/>
            <abstract>
              <t indent="0">This document describes a Transport Layer Security (TLS) extension for application-layer protocol negotiation within the TLS handshake. For instances in which multiple application protocols are supported on the same TCP or UDP port, this extension allows the application layer to negotiate which protocol will be used within the TLS connection.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7301"/>
          <seriesInfo name="DOI" value="10.17487/RFC7301"/>
        </reference>
        <reference anchor="RFC8552" target="https://www.rfc-editor.org/info/rfc8552" quoteTitle="true" derivedAnchor="Attrleaf">
          <front>
            <title>Scoped Interpretation of DNS Resource Records through "Underscored" Naming of Attribute Leaves</title>
            <author fullname="D. Crocker" initials="D." surname="Crocker"/>
            <date month="March" year="2019"/>
            <abstract>
              <t indent="0">Formally, any DNS Resource Record (RR) may occur under any domain name. However, some services use an operational convention for defining specific interpretations of an RRset by locating the records in a DNS branch under the parent domain to which the RRset actually applies. The top of this subordinate branch is defined by a naming convention that uses a reserved node name, which begins with the underscore character (e.g., "_name"). The underscored naming construct defines a semantic scope for DNS record types that are associated with the parent domain above the underscored branch. This specification explores the nature of this DNS usage and defines the "Underscored and Globally Scoped DNS Node Names" registry with IANA. The purpose of this registry is to avoid collisions resulting from the use of the same underscored name for different services.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="222"/>
          <seriesInfo name="RFC" value="8552"/>
          <seriesInfo name="DOI" value="10.17487/RFC8552"/>
        </reference>
        <reference anchor="RFC8484" target="https://www.rfc-editor.org/info/rfc8484" quoteTitle="true" derivedAnchor="DoH">
          <front>
            <title>DNS Queries over HTTPS (DoH)</title>
            <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
            <author fullname="P. McManus" initials="P." surname="McManus"/>
            <date month="October" year="2018"/>
            <abstract>
              <t indent="0">This document defines a protocol for sending DNS queries and getting DNS responses over HTTPS. Each DNS query-response pair is mapped into an HTTP exchange.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8484"/>
          <seriesInfo name="DOI" value="10.17487/RFC8484"/>
        </reference>
        <reference anchor="RFC7858" target="https://www.rfc-editor.org/info/rfc7858" quoteTitle="true" derivedAnchor="DoT">
          <front>
            <title>Specification for DNS over Transport Layer Security (TLS)</title>
            <author fullname="Z. Hu" initials="Z." surname="Hu"/>
            <author fullname="L. Zhu" initials="L." surname="Zhu"/>
            <author fullname="J. Heidemann" initials="J." surname="Heidemann"/>
            <author fullname="A. Mankin" initials="A." surname="Mankin"/>
            <author fullname="D. Wessels" initials="D." surname="Wessels"/>
            <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
            <date month="May" year="2016"/>
            <abstract>
              <t indent="0">This document describes the use of Transport Layer Security (TLS) to provide privacy for DNS. Encryption provided by TLS eliminates opportunities for eavesdropping and on-path tampering with DNS queries in the network, such as discussed in RFC 7626. In addition, this document specifies two usage profiles for DNS over TLS and provides advice on performance considerations to minimize overhead from using TCP and TLS with DNS.</t>
              <t indent="0">This document focuses on securing stub-to-recursive traffic, as per the charter of the DPRIVE Working Group. It does not prevent future applications of the protocol to recursive-to-authoritative traffic.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7858"/>
          <seriesInfo name="DOI" value="10.17487/RFC7858"/>
        </reference>
        <reference anchor="RFC8305" target="https://www.rfc-editor.org/info/rfc8305" quoteTitle="true" derivedAnchor="HappyEyeballsV2">
          <front>
            <title>Happy Eyeballs Version 2: Better Connectivity Using Concurrency</title>
            <author fullname="D. Schinazi" initials="D." surname="Schinazi"/>
            <author fullname="T. Pauly" initials="T." surname="Pauly"/>
            <date month="December" year="2017"/>
            <abstract>
              <t indent="0">Many communication protocols operating over the modern Internet use hostnames. These often resolve to multiple IP addresses, each of which may have different performance and connectivity characteristics. Since specific addresses or address families (IPv4 or IPv6) may be blocked, broken, or sub-optimal on a network, clients that attempt multiple connections in parallel have a chance of establishing a connection more quickly. This document specifies requirements for algorithms that reduce this user-visible delay and provides an example algorithm, referred to as "Happy Eyeballs". This document obsoletes the original algorithm description in RFC 6555.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8305"/>
          <seriesInfo name="DOI" value="10.17487/RFC8305"/>
        </reference>
        <reference anchor="RFC9110" target="https://www.rfc-editor.org/info/rfc9110" quoteTitle="true" derivedAnchor="HTTP">
          <front>
            <title>HTTP Semantics</title>
            <author fullname="R. Fielding" initials="R." role="editor" surname="Fielding"/>
            <author fullname="M. Nottingham" initials="M." role="editor" surname="Nottingham"/>
            <author fullname="J. Reschke" initials="J." role="editor" surname="Reschke"/>
            <date month="June" year="2022"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document describes the overall architecture of HTTP, establishes common terminology, and defines aspects of the protocol that are shared by all versions. In this definition are core protocol elements, extensibility mechanisms, and the "http" and "https" Uniform Resource Identifier (URI) schemes.</t>
              <t indent="0">This document updates RFC 3864 and obsoletes RFCs 2818, 7231, 7232, 7233, 7235, 7538, 7615, 7694, and portions of 7230.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="97"/>
          <seriesInfo name="RFC" value="9110"/>
          <seriesInfo name="DOI" value="10.17487/RFC9110"/>
        </reference>
        <reference anchor="RFC1034" target="https://www.rfc-editor.org/info/rfc1034" quoteTitle="true" derivedAnchor="RFC1034">
          <front>
            <title>Domain names - concepts and facilities</title>
            <author fullname="P. Mockapetris" initials="P." surname="Mockapetris"/>
            <date month="November" year="1987"/>
            <abstract>
              <t indent="0">This RFC is the revised basic definition of The Domain Name System. It obsoletes RFC-882. This memo describes the domain style names and their used for host address look up and electronic mail forwarding. It discusses the clients and servers in the domain name system and the protocol used between them.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="13"/>
          <seriesInfo name="RFC" value="1034"/>
          <seriesInfo name="DOI" value="10.17487/RFC1034"/>
        </reference>
        <reference anchor="RFC1035" target="https://www.rfc-editor.org/info/rfc1035" quoteTitle="true" derivedAnchor="RFC1035">
          <front>
            <title>Domain names - implementation and specification</title>
            <author fullname="P. Mockapetris" initials="P." surname="Mockapetris"/>
            <date month="November" year="1987"/>
            <abstract>
              <t indent="0">This RFC is the revised specification of the protocol and format used in the implementation of the Domain Name System. It obsoletes RFC-883. This memo documents the details of the domain name client - server communication.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="13"/>
          <seriesInfo name="RFC" value="1035"/>
          <seriesInfo name="DOI" value="10.17487/RFC1035"/>
        </reference>
        <reference anchor="RFC1928" target="https://www.rfc-editor.org/info/rfc1928" quoteTitle="true" derivedAnchor="RFC1928">
          <front>
            <title>SOCKS Protocol Version 5</title>
            <author fullname="M. Leech" initials="M." surname="Leech"/>
            <author fullname="M. Ganis" initials="M." surname="Ganis"/>
            <author fullname="Y. Lee" initials="Y." surname="Lee"/>
            <author fullname="R. Kuris" initials="R." surname="Kuris"/>
            <author fullname="D. Koblas" initials="D." surname="Koblas"/>
            <author fullname="L. Jones" initials="L." surname="Jones"/>
            <date month="March" year="1996"/>
            <abstract>
              <t indent="0">This memo describes a protocol that is an evolution of the previous version of the protocol, version 4 [1]. This new protocol stems from active discussions and prototype implementations. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1928"/>
          <seriesInfo name="DOI" value="10.17487/RFC1928"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC2181" target="https://www.rfc-editor.org/info/rfc2181" quoteTitle="true" derivedAnchor="RFC2181">
          <front>
            <title>Clarifications to the DNS Specification</title>
            <author fullname="R. Elz" initials="R." surname="Elz"/>
            <author fullname="R. Bush" initials="R." surname="Bush"/>
            <date month="July" year="1997"/>
            <abstract>
              <t indent="0">This document considers some areas that have been identified as problems with the specification of the Domain Name System, and proposes remedies for the defects identified. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2181"/>
          <seriesInfo name="DOI" value="10.17487/RFC2181"/>
        </reference>
        <reference anchor="RFC3225" target="https://www.rfc-editor.org/info/rfc3225" quoteTitle="true" derivedAnchor="RFC3225">
          <front>
            <title>Indicating Resolver Support of DNSSEC</title>
            <author fullname="D. Conrad" initials="D." surname="Conrad"/>
            <date month="December" year="2001"/>
            <abstract>
              <t indent="0">In order to deploy DNSSEC (Domain Name System Security Extensions) operationally, DNSSEC aware servers should only perform automatic inclusion of DNSSEC RRs when there is an explicit indication that the resolver can understand those RRs. This document proposes the use of a bit in the EDNS0 header to provide that explicit indication and describes the necessary protocol changes to implement that notification. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3225"/>
          <seriesInfo name="DOI" value="10.17487/RFC3225"/>
        </reference>
        <reference anchor="RFC3597" target="https://www.rfc-editor.org/info/rfc3597" quoteTitle="true" derivedAnchor="RFC3597">
          <front>
            <title>Handling of Unknown DNS Resource Record (RR) Types</title>
            <author fullname="A. Gustafsson" initials="A." surname="Gustafsson"/>
            <date month="September" year="2003"/>
            <abstract>
              <t indent="0">Extending the Domain Name System (DNS) with new Resource Record (RR) types currently requires changes to name server software. This document specifies the changes necessary to allow future DNS implementations to handle new RR types transparently. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3597"/>
          <seriesInfo name="DOI" value="10.17487/RFC3597"/>
        </reference>
        <reference anchor="RFC4001" target="https://www.rfc-editor.org/info/rfc4001" quoteTitle="true" derivedAnchor="RFC4001">
          <front>
            <title>Textual Conventions for Internet Network Addresses</title>
            <author fullname="M. Daniele" initials="M." surname="Daniele"/>
            <author fullname="B. Haberman" initials="B." surname="Haberman"/>
            <author fullname="S. Routhier" initials="S." surname="Routhier"/>
            <author fullname="J. Schoenwaelder" initials="J." surname="Schoenwaelder"/>
            <date month="February" year="2005"/>
            <abstract>
              <t indent="0">This MIB module defines textual conventions to represent commonly used Internet network layer addressing information. The intent is that these textual conventions will be imported and used in MIB modules that would otherwise define their own representations. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4001"/>
          <seriesInfo name="DOI" value="10.17487/RFC4001"/>
        </reference>
        <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234" quoteTitle="true" derivedAnchor="RFC5234">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <author fullname="D. Crocker" initials="D." role="editor" surname="Crocker"/>
            <author fullname="P. Overell" initials="P." surname="Overell"/>
            <date month="January" year="2008"/>
            <abstract>
              <t indent="0">Internet technical specifications often need to define a formal syntax. Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications. The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power. The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges. This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="68"/>
          <seriesInfo name="RFC" value="5234"/>
          <seriesInfo name="DOI" value="10.17487/RFC5234"/>
        </reference>
        <reference anchor="RFC5952" target="https://www.rfc-editor.org/info/rfc5952" quoteTitle="true" derivedAnchor="RFC5952">
          <front>
            <title>A Recommendation for IPv6 Address Text Representation</title>
            <author fullname="S. Kawamura" initials="S." surname="Kawamura"/>
            <author fullname="M. Kawashima" initials="M." surname="Kawashima"/>
            <date month="August" year="2010"/>
            <abstract>
              <t indent="0">As IPv6 deployment increases, there will be a dramatic increase in the need to use IPv6 addresses in text. While the IPv6 address architecture in Section 2.2 of RFC 4291 describes a flexible model for text representation of an IPv6 address, this flexibility has been causing problems for operators, system engineers, and users. This document defines a canonical textual representation format. It does not define a format for internal storage, such as within an application or database. It is expected that the canonical format will be followed by humans and systems when representing IPv6 addresses as text, but all implementations must accept and be able to handle any legitimate RFC 4291 format. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5952"/>
          <seriesInfo name="DOI" value="10.17487/RFC5952"/>
        </reference>
        <reference anchor="RFC6066" target="https://www.rfc-editor.org/info/rfc6066" quoteTitle="true" derivedAnchor="RFC6066">
          <front>
            <title>Transport Layer Security (TLS) Extensions: Extension Definitions</title>
            <author fullname="D. Eastlake 3rd" initials="D." surname="Eastlake 3rd"/>
            <date month="January" year="2011"/>
            <abstract>
              <t indent="0">This document provides specifications for existing TLS extensions. It is a companion document for RFC 5246, "The Transport Layer Security (TLS) Protocol Version 1.2". The extensions specified are server_name, max_fragment_length, client_certificate_url, trusted_ca_keys, truncated_hmac, and status_request. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6066"/>
          <seriesInfo name="DOI" value="10.17487/RFC6066"/>
        </reference>
        <reference anchor="RFC6147" target="https://www.rfc-editor.org/info/rfc6147" quoteTitle="true" derivedAnchor="RFC6147">
          <front>
            <title>DNS64: DNS Extensions for Network Address Translation from IPv6 Clients to IPv4 Servers</title>
            <author fullname="M. Bagnulo" initials="M." surname="Bagnulo"/>
            <author fullname="A. Sullivan" initials="A." surname="Sullivan"/>
            <author fullname="P. Matthews" initials="P." surname="Matthews"/>
            <author fullname="I. van Beijnum" initials="I." surname="van Beijnum"/>
            <date month="April" year="2011"/>
            <abstract>
              <t indent="0">DNS64 is a mechanism for synthesizing AAAA records from A records. DNS64 is used with an IPv6/IPv4 translator to enable client-server communication between an IPv6-only client and an IPv4-only server, without requiring any changes to either the IPv6 or the IPv4 node, for the class of applications that work through NATs. This document specifies DNS64, and provides suggestions on how it should be deployed in conjunction with IPv6/IPv4 translators. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6147"/>
          <seriesInfo name="DOI" value="10.17487/RFC6147"/>
        </reference>
        <reference anchor="RFC7050" target="https://www.rfc-editor.org/info/rfc7050" quoteTitle="true" derivedAnchor="RFC7050">
          <front>
            <title>Discovery of the IPv6 Prefix Used for IPv6 Address Synthesis</title>
            <author fullname="T. Savolainen" initials="T." surname="Savolainen"/>
            <author fullname="J. Korhonen" initials="J." surname="Korhonen"/>
            <author fullname="D. Wing" initials="D." surname="Wing"/>
            <date month="November" year="2013"/>
            <abstract>
              <t indent="0">This document describes a method for detecting the presence of DNS64 and for learning the IPv6 prefix used for protocol translation on an access network. The method depends on the existence of a well-known IPv4-only fully qualified domain name "ipv4only.arpa.". The information learned enables nodes to perform local IPv6 address synthesis and to potentially avoid NAT64 on dual-stack and multi-interface deployments.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7050"/>
          <seriesInfo name="DOI" value="10.17487/RFC7050"/>
        </reference>
        <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231" quoteTitle="true" derivedAnchor="RFC7231">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
            <author fullname="R. Fielding" initials="R." role="editor" surname="Fielding"/>
            <author fullname="J. Reschke" initials="J." role="editor" surname="Reschke"/>
            <date month="June" year="2014"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems. This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7231"/>
          <seriesInfo name="DOI" value="10.17487/RFC7231"/>
        </reference>
        <reference anchor="RFC7595" target="https://www.rfc-editor.org/info/rfc7595" quoteTitle="true" derivedAnchor="RFC7595">
          <front>
            <title>Guidelines and Registration Procedures for URI Schemes</title>
            <author fullname="D. Thaler" initials="D." role="editor" surname="Thaler"/>
            <author fullname="T. Hansen" initials="T." surname="Hansen"/>
            <author fullname="T. Hardie" initials="T." surname="Hardie"/>
            <date month="June" year="2015"/>
            <abstract>
              <t indent="0">This document updates the guidelines and recommendations, as well as the IANA registration processes, for the definition of Uniform Resource Identifier (URI) schemes. It obsoletes RFC 4395.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="35"/>
          <seriesInfo name="RFC" value="7595"/>
          <seriesInfo name="DOI" value="10.17487/RFC7595"/>
        </reference>
        <reference anchor="RFC7871" target="https://www.rfc-editor.org/info/rfc7871" quoteTitle="true" derivedAnchor="RFC7871">
          <front>
            <title>Client Subnet in DNS Queries</title>
            <author fullname="C. Contavalli" initials="C." surname="Contavalli"/>
            <author fullname="W. van der Gaast" initials="W." surname="van der Gaast"/>
            <author fullname="D. Lawrence" initials="D." surname="Lawrence"/>
            <author fullname="W. Kumari" initials="W." surname="Kumari"/>
            <date month="May" year="2016"/>
            <abstract>
              <t indent="0">This document describes an Extension Mechanisms for DNS (EDNS0) option that is in active use to carry information about the network that originated a DNS query and the network for which the subsequent response can be cached. Since it has some known operational and privacy shortcomings, a revision will be worked through the IETF for improvement.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7871"/>
          <seriesInfo name="DOI" value="10.17487/RFC7871"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author fullname="M. Cotton" initials="M." surname="Cotton"/>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <author fullname="T. Narten" initials="T." surname="Narten"/>
            <date month="June" year="2017"/>
            <abstract>
              <t indent="0">Many protocols make use of points of extensibility that use constants to identify various protocol parameters. To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper. For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t indent="0">To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed. This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t indent="0">This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
            <date month="August" year="2018"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC6455" target="https://www.rfc-editor.org/info/rfc6455" quoteTitle="true" derivedAnchor="WebSocket">
          <front>
            <title>The WebSocket Protocol</title>
            <author fullname="I. Fette" initials="I." surname="Fette"/>
            <author fullname="A. Melnikov" initials="A." surname="Melnikov"/>
            <date month="December" year="2011"/>
            <abstract>
              <t indent="0">The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the origin-based security model commonly used by web browsers. The protocol consists of an opening handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest or s and long polling). [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6455"/>
          <seriesInfo name="DOI" value="10.17487/RFC6455"/>
        </reference>
      </references>
      <references pn="section-15.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="RFC7838" target="https://www.rfc-editor.org/info/rfc7838" quoteTitle="true" derivedAnchor="AltSvc">
          <front>
            <title>HTTP Alternative Services</title>
            <author fullname="M. Nottingham" initials="M." surname="Nottingham"/>
            <author fullname="P. McManus" initials="P." surname="McManus"/>
            <author fullname="J. Reschke" initials="J." surname="Reschke"/>
            <date month="April" year="2016"/>
            <abstract>
              <t indent="0">This document specifies "Alternative Services" for HTTP, which allow an origin's resources to be authoritatively available at a separate network location, possibly accessed with a different protocol configuration.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7838"/>
          <seriesInfo name="DOI" value="10.17487/RFC7838"/>
        </reference>
        <reference anchor="I-D.ietf-dnsop-aname" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-aname-04" derivedAnchor="ANAME-DNS-RR">
          <front>
            <title>Address-specific DNS aliases (ANAME)</title>
            <author initials="T." surname="Finch" fullname="Tony Finch">
              <organization showOnFrontPage="true">University of Cambridge</organization>
            </author>
            <author initials="E." surname="Hunt" fullname="Evan Hunt">
              <organization showOnFrontPage="true">ISC</organization>
            </author>
            <author initials="P." surname="van Dijk" fullname="Peter van Dijk">
              <organization showOnFrontPage="true">PowerDNS</organization>
            </author>
            <author initials="A." surname="Eden" fullname="Anthony Eden">
              <organization showOnFrontPage="true">DNSimple</organization>
            </author>
            <author initials="W." surname="Mekking" fullname="Matthijs Mekking">
              <organization showOnFrontPage="true">ISC</organization>
            </author>
            <date month="July" day="8" year="2019"/>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-dnsop-aname-04"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="BIND-CHECK-NAMES" target="https://bind9.readthedocs.io/en/v9.19.11/reference.html#namedconf-statement-check-names" quoteTitle="true" derivedAnchor="BIND-CHECK-NAMES">
          <front>
            <title>BIND v9.19.11 Configuration Reference: "check-names"</title>
            <author>
              <organization showOnFrontPage="true">Internet Systems Consortium</organization>
            </author>
            <date year="2023" month="September"/>
          </front>
        </reference>
        <reference anchor="RFC6672" target="https://www.rfc-editor.org/info/rfc6672" quoteTitle="true" derivedAnchor="DNAME">
          <front>
            <title>DNAME Redirection in the DNS</title>
            <author fullname="S. Rose" initials="S." surname="Rose"/>
            <author fullname="W. Wijngaards" initials="W." surname="Wijngaards"/>
            <date month="June" year="2012"/>
            <abstract>
              <t indent="0">The DNAME record provides redirection for a subtree of the domain name tree in the DNS. That is, all names that end with a particular suffix are redirected to another part of the DNS. This document obsoletes the original specification in RFC 2672 as well as updates the document on representing IPv6 addresses in DNS (RFC 3363). [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6672"/>
          <seriesInfo name="DOI" value="10.17487/RFC6672"/>
        </reference>
        <reference anchor="RFC8499" target="https://www.rfc-editor.org/info/rfc8499" quoteTitle="true" derivedAnchor="DNSTerm">
          <front>
            <title>DNS Terminology</title>
            <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
            <author fullname="A. Sullivan" initials="A." surname="Sullivan"/>
            <author fullname="K. Fujiwara" initials="K." surname="Fujiwara"/>
            <date month="January" year="2019"/>
            <abstract>
              <t indent="0">The Domain Name System (DNS) is defined in literally dozens of different RFCs. The terminology used by implementers and developers of DNS protocols, and by operators of DNS systems, has sometimes changed in the decades since the DNS was first defined. This document gives current definitions for many of the terms used in the DNS in a single document.</t>
              <t indent="0">This document obsoletes RFC 7719 and updates RFC 2308.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="219"/>
          <seriesInfo name="RFC" value="8499"/>
          <seriesInfo name="DOI" value="10.17487/RFC8499"/>
        </reference>
        <reference anchor="I-D.ietf-tls-esni" target="https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-17" quoteTitle="true" derivedAnchor="ECH">
          <front>
            <title>TLS Encrypted Client Hello</title>
            <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
              <organization showOnFrontPage="true">RTFM, Inc.</organization>
            </author>
            <author fullname="Kazuho Oku" initials="K." surname="Oku">
              <organization showOnFrontPage="true">Fastly</organization>
            </author>
            <author fullname="Nick Sullivan" initials="N." surname="Sullivan">
              <organization showOnFrontPage="true">Cloudflare</organization>
            </author>
            <author fullname="Christopher A. Wood" initials="C. A." surname="Wood">
              <organization showOnFrontPage="true">Cloudflare</organization>
            </author>
            <date day="9" month="October" year="2023"/>
            <abstract>
              <t indent="0">This document describes a mechanism in Transport Layer Security (TLS) for encrypting a ClientHello message under a server public key. Discussion Venues This note is to be removed before publishing as an RFC. Source for this draft and an issue tracker can be found at https://github.com/tlswg/draft-ietf-tls-esni (https://github.com/tlswg/draft-ietf-tls-esni).</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-tls-esni-17"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="FETCH" target="https://fetch.spec.whatwg.org/" quoteTitle="true" derivedAnchor="FETCH">
          <front>
            <title>Fetch Living Standard</title>
            <author>
              <organization showOnFrontPage="true">WHATWG</organization>
            </author>
            <date year="2023" month="October"/>
          </front>
        </reference>
        <reference anchor="FETCH-WEBSOCKETS" target="https://websockets.spec.whatwg.org/" quoteTitle="true" derivedAnchor="FETCH-WEBSOCKETS">
          <front>
            <title>WebSockets Living Standard</title>
            <author>
              <organization showOnFrontPage="true">WHATWG</organization>
            </author>
            <date year="2023" month="September"/>
          </front>
        </reference>
        <reference anchor="RFC6797" target="https://www.rfc-editor.org/info/rfc6797" quoteTitle="true" derivedAnchor="HSTS">
          <front>
            <title>HTTP Strict Transport Security (HSTS)</title>
            <author fullname="J. Hodges" initials="J." surname="Hodges"/>
            <author fullname="C. Jackson" initials="C." surname="Jackson"/>
            <author fullname="A. Barth" initials="A." surname="Barth"/>
            <date month="November" year="2012"/>
            <abstract>
              <t indent="0">This specification defines a mechanism enabling web sites to declare themselves accessible only via secure connections and/or for users to be able to direct their user agent(s) to interact with given sites only over secure connections. This overall policy is referred to as HTTP Strict Transport Security (HSTS). The policy is declared by web sites via the Strict-Transport-Security HTTP response header field and/or by other means, such as user agent configuration, for example. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6797"/>
          <seriesInfo name="DOI" value="10.17487/RFC6797"/>
        </reference>
        <reference anchor="I-D.bellis-dnsop-http-record" target="https://datatracker.ietf.org/doc/html/draft-bellis-dnsop-http-record-00" quoteTitle="true" derivedAnchor="HTTP-DNS-RR">
          <front>
            <title>A DNS Resource Record for HTTP</title>
            <author fullname="Ray Bellis" initials="R." surname="Bellis">
              <organization showOnFrontPage="true">Internet Systems Consortium, Inc.</organization>
            </author>
            <date day="3" month="November" year="2018"/>
            <abstract>
              <t indent="0">This document specifies an "HTTP" resource record type for the DNS to facilitate the lookup of the server hostname of HTTP(s) URIs. It is intended to replace the use of CNAME records for this purpose, and in the process provides a solution for the inability of the DNS to allow a CNAME to be placed at the apex of a domain name.</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-bellis-dnsop-http-record-00"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC9114" target="https://www.rfc-editor.org/info/rfc9114" quoteTitle="true" derivedAnchor="HTTP/3">
          <front>
            <title>HTTP/3</title>
            <author fullname="M. Bishop" initials="M." role="editor" surname="Bishop"/>
            <date month="June" year="2022"/>
            <abstract>
              <t indent="0">The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment. This document describes a mapping of HTTP semantics over QUIC. This document also identifies HTTP/2 features that are subsumed by QUIC and describes how HTTP/2 extensions can be ported to HTTP/3.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9114"/>
          <seriesInfo name="DOI" value="10.17487/RFC9114"/>
        </reference>
        <reference anchor="RFC1912" target="https://www.rfc-editor.org/info/rfc1912" quoteTitle="true" derivedAnchor="RFC1912">
          <front>
            <title>Common DNS Operational and Configuration Errors</title>
            <author fullname="D. Barr" initials="D." surname="Barr"/>
            <date month="February" year="1996"/>
            <abstract>
              <t indent="0">This memo describes errors often found in both the operation of Domain Name System (DNS) servers, and in the data that these DNS servers contain. This memo provides information for the Internet community. This memo does not specify an Internet standard of any kind.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1912"/>
          <seriesInfo name="DOI" value="10.17487/RFC1912"/>
        </reference>
        <reference anchor="RFC6454" target="https://www.rfc-editor.org/info/rfc6454" quoteTitle="true" derivedAnchor="RFC6454">
          <front>
            <title>The Web Origin Concept</title>
            <author fullname="A. Barth" initials="A." surname="Barth"/>
            <date month="December" year="2011"/>
            <abstract>
              <t indent="0">This document defines the concept of an "origin", which is often used as the scope of authority or privilege by user agents. Typically, user agents isolate content retrieved from different origins to prevent malicious web site operators from interfering with the operation of benign web sites. In addition to outlining the principles that underlie the concept of origin, this document details how to determine the origin of a URI and how to serialize an origin into a string. It also defines an HTTP header field, named "Origin", that indicates which origins are associated with an HTTP request. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6454"/>
          <seriesInfo name="DOI" value="10.17487/RFC6454"/>
        </reference>
        <reference anchor="RFC2782" target="https://www.rfc-editor.org/info/rfc2782" quoteTitle="true" derivedAnchor="SRV">
          <front>
            <title>A DNS RR for specifying the location of services (DNS SRV)</title>
            <author fullname="A. Gulbrandsen" initials="A." surname="Gulbrandsen"/>
            <author fullname="P. Vixie" initials="P." surname="Vixie"/>
            <author fullname="L. Esibov" initials="L." surname="Esibov"/>
            <date month="February" year="2000"/>
            <abstract>
              <t indent="0">This document describes a DNS RR which specifies the location of the server(s) for a specific protocol and domain. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2782"/>
          <seriesInfo name="DOI" value="10.17487/RFC2782"/>
        </reference>
        <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986" quoteTitle="true" derivedAnchor="URI">
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author fullname="T. Berners-Lee" initials="T." surname="Berners-Lee"/>
            <author fullname="R. Fielding" initials="R." surname="Fielding"/>
            <author fullname="L. Masinter" initials="L." surname="Masinter"/>
            <date month="January" year="2005"/>
            <abstract>
              <t indent="0">A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource. This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet. The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier. This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="66"/>
          <seriesInfo name="RFC" value="3986"/>
          <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
      </references>
    </references>
    <section anchor="decoding" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-decoding-text-in-zone-files">Decoding Text in Zone Files</name>
      <t indent="0" pn="section-appendix.a-1">DNS zone files are capable of representing arbitrary octet sequences in
basic ASCII text, using various delimiters and encodings, according to an algorithm
defined in <xref section="5.1" sectionFormat="of" target="RFC1035" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1035#section-5.1" derivedContent="RFC1035"/>.
The following summarizes some allowed inputs to that algorithm, using ABNF:</t>
      <sourcecode name="" type="abnf" markers="false" pn="section-appendix.a-2">
; non-special is VCHAR minus DQUOTE, ";", "(", ")", and "\".
non-special = %x21 / %x23-27 / %x2A-3A / %x3C-5B / %x5D-7E
; non-digit is VCHAR minus DIGIT.
non-digit   = %x21-2F / %x3A-7E
; dec-octet is a number 0-255 as a three-digit decimal number.
dec-octet   = ( "0" / "1" ) 2DIGIT /
              "2" ( ( %x30-34 DIGIT ) / ( "5" %x30-35 ) )
escaped     = "\" ( non-digit / dec-octet )
contiguous  = 1*( non-special / escaped )
quoted      = DQUOTE *( contiguous / ( ["\"] WSP ) ) DQUOTE
char-string = contiguous / quoted
</sourcecode>
      <t indent="0" pn="section-appendix.a-3">The decoding algorithm allows <tt>char-string</tt> to represent any <tt>*OCTET</tt>,
using quoting to group values (e.g., those with internal whitespace), and
escaping to represent each non-printable octet as a single <tt>escaped</tt> sequence.
In this document, this algorithm is referred to as "character-string decoding", because
<xref target="RFC1035" sectionFormat="of" section="5.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1035#section-5.1" derivedContent="RFC1035"/> uses this
algorithm to produce a <tt>&lt;character-string&gt;</tt>.  Note that while
the length of a <tt>&lt;character-string&gt;</tt> is limited to 255 octets, the
character-string decoding algorithm can produce output of any length.</t>
      <section anchor="value-list" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a.1">
        <name slugifiedName="name-decoding-a-comma-separated-">Decoding a Comma-Separated List</name>
        <t indent="0" pn="section-appendix.a.1-1">In order to represent lists of items in zone files, this specification uses
comma-separated lists.  When the allowed items in the list cannot contain ","
or "\", this is trivial.  (For simplicity, empty items are not allowed.)
A value-list parser that splits on "," and prohibits items containing "\"
is sufficient to comply with all requirements in this document.  This
corresponds to the <tt>simple-comma-separated</tt> syntax:</t>
        <sourcecode name="" type="abnf" markers="false" pn="section-appendix.a.1-2">
; item-allowed is OCTET minus "," and "\".
item-allowed           = %x00-2B / %x2D-5B / %x5D-FF
simple-item            = 1*item-allowed
simple-comma-separated = [simple-item *("," simple-item)]
</sourcecode>
        <t indent="0" pn="section-appendix.a.1-3">For implementations that allow "," and "\" in item values, the following
escaping syntax applies:</t>
        <sourcecode name="" type="abnf" markers="false" pn="section-appendix.a.1-4">
item            = 1*OCTET
escaped-item    = 1*(item-allowed / "\," / "\\")
comma-separated = [escaped-item *("," escaped-item)]
</sourcecode>
        <t indent="0" pn="section-appendix.a.1-5">Decoding of value-lists happens after character-string decoding.
For example, consider these <tt>char-string</tt> SvcParamValues:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-appendix.a.1-6">
"part1,part2,part3\\,part4\\\\"
part1\,\p\a\r\t2\044part3\092,part4\092\\
</sourcecode>
        <t indent="0" pn="section-appendix.a.1-7">These inputs are equivalent: character-string decoding either of them would
produce the same <tt>value</tt>:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-appendix.a.1-8">
part1,part2,part3\,part4\\
</sourcecode>
        <t indent="0" pn="section-appendix.a.1-9">Applying comma-separated list decoding to this <tt>value</tt> would produce a list
of three <tt>item</tt>s:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-appendix.a.1-10">
part1
part2
part3,part4\
</sourcecode>
      </section>
    </section>
    <section anchor="http-mapping-summary" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-http-mapping-summary">HTTP Mapping Summary</name>
      <t indent="0" pn="section-appendix.b-1">This table serves as a non-normative summary of the HTTP mapping for SVCB
(<xref target="https" format="default" sectionFormat="of" derivedContent="Section 9"/>).  Future protocol mappings may provide a similar summary table.</t>
      <table align="center" pn="table-3">
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">
              <strong>Mapped scheme</strong></td>
            <td align="left" colspan="1" rowspan="1">"https"</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">
              <strong>Other affected schemes</strong></td>
            <td align="left" colspan="1" rowspan="1">"http", "wss", "ws", (other HTTP-based)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">
              <strong>RR type</strong></td>
            <td align="left" colspan="1" rowspan="1">HTTPS (65)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">
              <strong>Name prefix</strong></td>
            <td align="left" colspan="1" rowspan="1">None for port 443, else <tt>_$PORT._https</tt></td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">
              <strong>Automatically mandatory keys</strong></td>
            <td align="left" colspan="1" rowspan="1">
              <tt>port</tt>, <tt>no-default-alpn</tt></td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">
              <strong>SvcParam defaults</strong></td>
            <td align="left" colspan="1" rowspan="1">
              <tt>alpn</tt>: ["http/1.1"]</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">
              <strong>Special behaviors</strong></td>
            <td align="left" colspan="1" rowspan="1">Upgrade from HTTP to HTTPS</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">
              <strong>Keys that records must include</strong></td>
            <td align="left" colspan="1" rowspan="1">None</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="comparison-with-alternatives" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-comparison-with-alternative">Comparison with Alternatives</name>
      <t indent="0" pn="section-appendix.c-1">The SVCB and HTTPS RR types closely resemble,
and are inspired by, some existing
record types and proposals.  One complaint regarding all of the alternatives
is that web clients have seemed unenthusiastic about implementing
them.  The hope here is that an extensible solution that
solves multiple problems will overcome this inertia and have a path
to achieve client implementation.</t>
      <section anchor="differences-from-the-srv-rr-type" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.c.1">
        <name slugifiedName="name-differences-from-the-srv-rr">Differences from the SRV RR Type</name>
        <t indent="0" pn="section-appendix.c.1-1">An SRV record <xref target="RFC2782" format="default" sectionFormat="of" derivedContent="SRV"/> can perform a function similar
to that of the SVCB record,
informing a client to look in a different location for a service.
However, there are several differences:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.c.1-2">
          <li pn="section-appendix.c.1-2.1">SRV records are typically mandatory, whereas SVCB is intended to be optional
when used with pre-existing protocols.</li>
          <li pn="section-appendix.c.1-2.2">SRV records cannot instruct the client to switch or upgrade
protocols, whereas SVCB can signal such an upgrade (e.g., to
HTTP/2).</li>
          <li pn="section-appendix.c.1-2.3">SRV records are not extensible, whereas SVCB and HTTPS RRs
can be extended with new parameters.</li>
          <li pn="section-appendix.c.1-2.4">SRV records specify a "weight" for unbalanced randomized load balancing.
SVCB only supports balanced randomized load balancing, although weights
could be added via a future SvcParam.</li>
        </ul>
      </section>
      <section anchor="differences-from-the-proposed-http-record" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.c.2">
        <name slugifiedName="name-differences-from-the-propos">Differences from the Proposed HTTP Record</name>
        <t indent="0" pn="section-appendix.c.2-1">Unlike <xref target="I-D.bellis-dnsop-http-record" format="default" sectionFormat="of" derivedContent="HTTP-DNS-RR"/>, this approach is
extensible to cover Alt-Svc and Encrypted ClientHello use cases.  Like that
proposal, this addresses the zone-apex CNAME challenge.</t>
        <t indent="0" pn="section-appendix.c.2-2">Like that proposal, it remains necessary to continue to include
address records at the zone apex for legacy clients.</t>
      </section>
      <section anchor="differences-from-the-proposed-aname-record" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.c.3">
        <name slugifiedName="name-differences-from-the-propose">Differences from the Proposed ANAME Record</name>
        <t indent="0" pn="section-appendix.c.3-1">Unlike <xref target="I-D.ietf-dnsop-aname" format="default" sectionFormat="of" derivedContent="ANAME-DNS-RR"/>, this approach is extensible to
cover Alt-Svc and Encrypted ClientHello use cases.  This approach also does not
require any changes or special handling on either authoritative or
primary servers, beyond optionally returning in-bailiwick additional records.</t>
        <t indent="0" pn="section-appendix.c.3-2">Like that proposal, this addresses the zone-apex CNAME challenge
for clients that implement this.</t>
        <t indent="0" pn="section-appendix.c.3-3">However, with this SVCB proposal, it remains necessary to continue
to include address records at the zone apex for legacy clients.
If deployment of this standard is successful, the number of legacy clients
will fall over time.  As the number of legacy clients declines, the operational
effort required to serve these users without the benefit of SVCB indirection
should fall.  Server operators can easily observe how much traffic reaches this
legacy endpoint and may remove the apex's address records if the observed legacy
traffic has fallen to negligible levels.</t>
      </section>
      <section anchor="comparison-with-separate-rr-types-for-aliasmode-and-servicemode" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.c.4">
        <name slugifiedName="name-comparison-with-separate-rr">Comparison with Separate RR Types for AliasMode and ServiceMode</name>
        <t indent="0" pn="section-appendix.c.4-1">Abstractly, functions of AliasMode and ServiceMode are independent,
so it might be tempting to specify them as separate RR types.  However,
this would result in serious performance impairment, because clients
cannot rely on their recursive resolver to follow SVCB aliases (unlike
CNAME).  Thus, clients would have to issue queries for both RR types
in parallel, potentially at each step of the alias chain.  Recursive
resolvers that implement the specification would, upon receipt of a
ServiceMode query, emit both a ServiceMode query and an AliasMode query to
the authoritative DNS server.  Thus, splitting the RR type would double, or in
some cases triple, the load on clients and servers, and would not
reduce implementation complexity.</t>
      </section>
    </section>
    <section anchor="test-vectors" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.d">
      <name slugifiedName="name-test-vectors">Test Vectors</name>
      <t indent="0" pn="section-appendix.d-1">These test vectors only contain the RDATA portion of SVCB/HTTPS records in
presentation format, generic format <xref target="RFC3597" format="default" sectionFormat="of" derivedContent="RFC3597"/>, and wire format. The wire
format uses hexadecimal (\xNN) for each non-ASCII byte. As the wire format is
long, it is broken into several lines.</t>
      <section anchor="aliasmode" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.d.1">
        <name slugifiedName="name-aliasmode-3">AliasMode</name>
        <figure align="left" suppress-title="false" pn="figure-2">
          <name slugifiedName="name-aliasmode-4">AliasMode</name>
          <sourcecode type="test-vectors" markers="false" pn="section-appendix.d.1-1.1">
example.com.   HTTPS   0 foo.example.com.

\# 19 (
00 00                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
)

\x00\x00                                           # priority
\x03foo\x07example\x03com\x00                      # target
</sourcecode>
        </figure>
      </section>
      <section anchor="servicemode-1" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.d.2">
        <name slugifiedName="name-servicemode-3">ServiceMode</name>
        <figure align="left" suppress-title="false" pn="figure-3">
          <name slugifiedName="name-targetname-is">TargetName Is "."</name>
          <sourcecode type="test-vectors" markers="false" pn="section-appendix.d.2-1.1">
example.com.   SVCB   1 .

\# 3 (
00 01      ; priority
00         ; target (root label)
)

\x00\x01   # priority
\x00       # target (root label)
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-4">
          <name slugifiedName="name-specifies-a-port">Specifies a Port</name>
          <sourcecode type="test-vectors" markers="false" pn="section-appendix.d.2-2.1">
example.com.   SVCB   16 foo.example.com. port=53

\# 25 (
00 10                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
00 03                                              ; key 3
00 02                                              ; length 2
00 35                                              ; value
)

\x00\x10                                           # priority
\x03foo\x07example\x03com\x00                      # target
\x00\x03                                           # key 3
\x00\x02                                           # length 2
\x00\x35                                           # value
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-5">
          <name slugifiedName="name-a-generic-key-and-unquoted-">A Generic Key and Unquoted Value</name>
          <sourcecode type="test-vectors" markers="false" pn="section-appendix.d.2-3.1">
example.com.   SVCB   1 foo.example.com. key667=hello

\# 28 (
00 01                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
02 9b                                              ; key 667
00 05                                              ; length 5
68 65 6c 6c 6f                                     ; value
)

\x00\x01                                           # priority
\x03foo\x07example\x03com\x00                      # target
\x02\x9b                                           # key 667
\x00\x05                                           # length 5
hello                                              # value
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-6">
          <name slugifiedName="name-a-generic-key-and-quoted-va">A Generic Key and Quoted Value with a Decimal Escape</name>
          <sourcecode type="test-vectors" markers="false" pn="section-appendix.d.2-4.1">
example.com.   SVCB   1 foo.example.com. key667="hello\210qoo"

\# 32 (
00 01                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
02 9b                                              ; key 667
00 09                                              ; length 9
68 65 6c 6c 6f d2 71 6f 6f                         ; value
)

\x00\x01                                           # priority
\x03foo\x07example\x03com\x00                      # target
\x02\x9b                                           # key 667
\x00\x09                                           # length 9
hello\xd2qoo                                       # value
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-7">
          <name slugifiedName="name-two-quoted-ipv6-hints">Two Quoted IPv6 Hints</name>
          <sourcecode type="test-vectors" markers="false" pn="section-appendix.d.2-5.1">
example.com.   SVCB   1 foo.example.com. (
                      ipv6hint="2001:db8::1,2001:db8::53:1"
                      )

\# 55 (
00 01                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
00 06                                              ; key 6
00 20                                              ; length 32
20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01    ; first address
20 01 0d b8 00 00 00 00 00 00 00 00 00 53 00 01    ; second address
)

\x00\x01                                           # priority
\x03foo\x07example\x03com\x00                      # target
\x00\x06                                           # key 6
\x00\x20                                           # length 32
\x20\x01\x0d\xb8\x00\x00\x00\x00
     \x00\x00\x00\x00\x00\x00\x00\x01              # first address
\x20\x01\x0d\xb8\x00\x00\x00\x00
     \x00\x00\x00\x00\x00\x53\x00\x01              # second address
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-8">
          <name slugifiedName="name-an-ipv6-hint-using-the-embe">An IPv6 Hint Using the Embedded IPv4 Syntax</name>
          <sourcecode type="test-vectors" markers="false" pn="section-appendix.d.2-6.1">
example.com.   SVCB   1 example.com. (
                        ipv6hint="2001:db8:122:344::192.0.2.33"
                        )
\# 35 (
00 01                                              ; priority
07 65 78 61 6d 70 6c 65 03 63 6f 6d 00             ; target
00 06                                              ; key 6
00 10                                              ; length 16
20 01 0d b8 01 22 03 44 00 00 00 00 c0 00 02 21    ; address
)

\x00\x01                                           # priority
\x07example\x03com\x00                             # target
\x00\x06                                           # key 6
\x00\x10                                           # length 16
\x20\x01\x0d\xb8\x01\x22\x03\x44
     \x00\x00\x00\x00\xc0\x00\x02\x21              # address
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-9">
          <name slugifiedName="name-svcparamkey-ordering-is-arb">SvcParamKey Ordering Is Arbitrary in Presentation Format but Sorted in Wire Format</name>
          <sourcecode type="test-vectors" markers="false" pn="section-appendix.d.2-7.1">
example.com.   SVCB   16 foo.example.org. (
                      alpn=h2,h3-19 mandatory=ipv4hint,alpn
                      ipv4hint=192.0.2.1
                      )

\# 48 (
00 10                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 6f 72 67 00 ; target
00 00                                              ; key 0
00 04                                              ; param length 4
00 01                                              ; value: key 1
00 04                                              ; value: key 4
00 01                                              ; key 1
00 09                                              ; param length 9
02                                                 ; alpn length 2
68 32                                              ; alpn value
05                                                 ; alpn length 5
68 33 2d 31 39                                     ; alpn value
00 04                                              ; key 4
00 04                                              ; param length 4
c0 00 02 01                                        ; param value
)

\x00\x10                                           # priority
\x03foo\x07example\x03org\x00                      # target
\x00\x00                                           # key 0
\x00\x04                                           # param length 4
\x00\x01                                           # value: key 1
\x00\x04                                           # value: key 4
\x00\x01                                           # key 1
\x00\x09                                           # param length 9
\x02                                               # alpn length 2
h2                                                 # alpn value
\x05                                               # alpn length 5
h3-19                                              # alpn value
\x00\x04                                           # key 4
\x00\x04                                           # param length 4
\xc0\x00\x02\x01                                   # param value
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-10">
          <name slugifiedName="name-an-alpn-value-with-an-escap">An "alpn" Value with an Escaped Comma and an Escaped Backslash in Two Presentation Formats</name>
          <sourcecode type="test-vectors" markers="false" pn="section-appendix.d.2-8.1">
example.com.   SVCB   16 foo.example.org. alpn="f\\\\oo\\,bar,h2"
example.com.   SVCB   16 foo.example.org. alpn=f\\\092oo\092,bar,h2

\# 35 (
00 10                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 6f 72 67 00 ; target
00 01                                              ; key 1
00 0c                                              ; param length 12
08                                                 ; alpn length 8
66 5c 6f 6f 2c 62 61 72                            ; alpn value
02                                                 ; alpn length 2
68 32                                              ; alpn value
)

\x00\x10                                           # priority
\x03foo\x07example\x03org\x00                      # target
\x00\x01                                           # key 1
\x00\x0c                                           # param length 12
\x08                                               # alpn length 8
f\oo,bar                                           # alpn value
\x02                                               # alpn length 2
h2                                                 # alpn value
</sourcecode>
        </figure>
      </section>
      <section anchor="failure-cases" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.d.3">
        <name slugifiedName="name-failure-cases">Failure Cases</name>
        <t indent="0" pn="section-appendix.d.3-1">This subsection contains test vectors that are not
compliant with this document. The various reasons for non-compliance
are explained with each example.</t>
        <figure align="left" suppress-title="false" pn="figure-11">
          <name slugifiedName="name-multiple-instances-of-the-s">Multiple Instances of the Same SvcParamKey</name>
          <sourcecode type="dns-rr" markers="false" pn="section-appendix.d.3-2.1">
example.com.   SVCB   1 foo.example.com. (
                       key123=abc key123=def
                       )
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-12">
          <name slugifiedName="name-missing-svcparamvalues-that">Missing SvcParamValues That Must Be Non-Empty</name>
          <sourcecode type="dns-rr" markers="false" pn="section-appendix.d.3-3.1">
example.com.   SVCB   1 foo.example.com. mandatory
example.com.   SVCB   1 foo.example.com. alpn
example.com.   SVCB   1 foo.example.com. port
example.com.   SVCB   1 foo.example.com. ipv4hint
example.com.   SVCB   1 foo.example.com. ipv6hint
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-13">
          <name slugifiedName="name-the-no-default-alpn-svcpara">The "no-default-alpn" SvcParamKey Value Must Be Empty</name>
          <sourcecode type="dns-rr" markers="false" pn="section-appendix.d.3-4.1">
example.com.   SVCB   1 foo.example.com. no-default-alpn=abc
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-14">
          <name slugifiedName="name-a-mandatory-svcparam-is-mis">A Mandatory SvcParam Is Missing</name>
          <sourcecode type="dns-rr" markers="false" pn="section-appendix.d.3-5.1">
example.com.   SVCB   1 foo.example.com. mandatory=key123
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-15">
          <name slugifiedName="name-the-mandatory-svcparamkey-m">The "mandatory" SvcParamKey Must Not Be Included in the Mandatory List</name>
          <sourcecode type="dns-rr" markers="false" pn="section-appendix.d.3-6.1">
example.com.   SVCB   1 foo.example.com. mandatory=mandatory
</sourcecode>
        </figure>
        <figure align="left" suppress-title="false" pn="figure-16">
          <name slugifiedName="name-multiple-instances-of-the-sa">Multiple Instances of the Same SvcParamKey in the Mandatory List</name>
          <sourcecode type="dns-rr" markers="false" pn="section-appendix.d.3-7.1">
example.com.   SVCB   1 foo.example.com. (
                      mandatory=key123,key123 key123=abc
                      )
</sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="acknowledgments-and-related-proposals" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.e">
      <name slugifiedName="name-acknowledgments-and-related">Acknowledgments and Related Proposals</name>
      <t indent="0" pn="section-appendix.e-1">Over the years, IETF participants have proposed a wide range of solutions to
the "CNAME at the zone apex" challenge, including
<xref target="I-D.bellis-dnsop-http-record" format="default" sectionFormat="of" derivedContent="HTTP-DNS-RR"/>,
<xref target="I-D.ietf-dnsop-aname" format="default" sectionFormat="of" derivedContent="ANAME-DNS-RR"/>, and others.  The authors are grateful
for their work to elucidate the problem and identify promising strategies to
address it, some of which are reflected in this document.</t>
      <t indent="0" pn="section-appendix.e-2">Thank you to <contact fullname="Ian Swett"/>, <contact fullname="Ralf Weber"/>, <contact fullname="Jon Reed"/>,
<contact fullname="Martin Thomson"/>, <contact fullname="Lucas Pardue"/>, <contact fullname="Ilari Liusvaara"/>,
<contact fullname="Tim Wicinski"/>, <contact fullname="Tommy Pauly"/>, <contact fullname="Chris Wood"/>, <contact fullname="David Benjamin"/>,
<contact fullname="Mark Andrews"/>, <contact fullname="Emily Stark"/>, <contact fullname="Eric Orth"/>, <contact fullname="Kyle Rose"/>,
<contact fullname="Craig Taylor"/>, <contact fullname="Dan McArdle"/>, <contact fullname="Brian Dickson"/>,
<contact fullname="Willem Toorop"/>, <contact fullname="Pieter Lexis"/>, <contact fullname="Puneet Sood"/>,
<contact fullname="Olivier Poitrey"/>, <contact fullname="Mashooq Muhaimen"/>,
<contact fullname="Tom Carpay"/>, and many others for their feedback
and suggestions on this document.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.f">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="B." surname="Schwartz" fullname="Ben Schwartz">
        <organization showOnFrontPage="true">Meta Platforms, Inc.</organization>
        <address>
          <email>ietf@bemasc.net</email>
        </address>
      </author>
      <author initials="M." surname="Bishop" fullname="Mike Bishop">
        <organization showOnFrontPage="true">Akamai Technologies</organization>
        <address>
          <email>mbishop@evequefou.be</email>
        </address>
      </author>
      <author initials="E." surname="Nygren" fullname="Erik Nygren">
        <organization showOnFrontPage="true">Akamai Technologies</organization>
        <address>
          <email>erik+ietf@nygren.org</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
