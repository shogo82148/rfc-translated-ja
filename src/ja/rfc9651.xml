<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" ipr="trust200902" docName="draft-ietf-httpbis-sfbis-06" number="9651" submissionType="IETF" category="std" consensus="true" obsoletes="8941" updates="" tocInclude="true" sortRefs="true" symRefs="true" xml:lang="en" prepTime="2024-09-30T15:06:33" indexInclude="true" scripts="Common,Latin" tocDepth="3">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-sfbis-06" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9651" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title>HTTPのための構造化フィールド値</title>
    <seriesInfo name="RFC" value="9651" stream="IETF"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization showOnFrontPage="true">Cloudflare</organization>
      <address>
        <postal>
          <city>Prahran</city>
          <region>VIC</region>
          <country>Australia</country>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <author initials="P-H." surname="Kamp" fullname="Poul-Henning Kamp">
      <organization showOnFrontPage="true">The Varnish Cache Project</organization>
      <address>
        <email>phk@varnish-cache.org</email>
      </address>
    </author>
    <date month="09" year="2024"/>
    <area>WIT</area>
    <workgroup>httpbis</workgroup>
    <keyword>trailer</keyword>
    <keyword>header</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">この文書は、「構造化フィールド」、「構造化ヘッダー」、または「構造化トレーラー」として知られるHTTPヘッダーおよびトレーラーフィールドを定義および処理することを容易かつ安全にするための一連のデータ型および関連するアルゴリズムについて説明します。これは、新しいHTTPフィールドの仕様で使用することを意図しています。</t>
      <t indent="0" pn="section-abstract-2">この文書はRFC 8941を廃止します。</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">このメモのステータス</name>
        <t indent="0" pn="section-boilerplate.1-1">
            これはインターネット標準化団体（Internet Standards Track）の文章です。
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            この文書は、インターネット技術タスクフォース（IETF）の成果物です。
            この文書は、IETFコミュニティのコンセンサスを代表するものです。
            この文書は公開レビューを受けており、インターネット技術運営グループ（IESG）により発行が承認されています。
            インターネット標準に関する詳しい情報は、RFC 7841のセクション2に記載されています。
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            この文書の現在の状態、正誤表、それに対するフィードバックの提供方法に関する情報は、
            <eref target="https://www.rfc-editor.org/info/rfc9651" brackets="none"/> で入手できます。
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">著作権表示</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            この文書は、この文書の発行日に有効なBCP 78およびIETFトラストのIETF文書に関する法的規定
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>)に従うものとします。
            これらの文書は、この文書に関するあなたの権利と制限を記述しているので、注意深く確認してください。
            この文書から抽出されたコードコンポーネントには、信託の法的規定のセクション4.eに記載されているように、
            簡易BSDライセンステキストを含める必要があります。簡易BSDライセンスに記載されているように、保証なしに提供されます。
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">目次</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-intentionally-strict-proces">Intentionally Strict Processing</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-notational-conventions">Notational Conventions</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-defining-new-structured-fie">Defining New Structured Fields</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-example">Example</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-error-handling">Error Handling</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.3">
                <t indent="0" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.3" format="counter" sectionFormat="of" target="section-2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-preserving-extensibility">Preserving Extensibility</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.4">
                <t indent="0" pn="section-toc.1-1.2.2.4.1"><xref derivedContent="2.4" format="counter" sectionFormat="of" target="section-2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-using-new-structured-types-">Using New Structured Types in Extensions</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-structured-data-types">Structured Data Types</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-lists">Lists</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.1.2">
                  <li pn="section-toc.1-1.3.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.1.2.1.1"><xref derivedContent="3.1.1" format="counter" sectionFormat="of" target="section-3.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-inner-lists">Inner Lists</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.1.2.2.1"><xref derivedContent="3.1.2" format="counter" sectionFormat="of" target="section-3.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parameters">Parameters</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dictionaries">Dictionaries</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-items">Items</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.3.2">
                  <li pn="section-toc.1-1.3.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.1.1"><xref derivedContent="3.3.1" format="counter" sectionFormat="of" target="section-3.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-integers">Integers</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.2.1"><xref derivedContent="3.3.2" format="counter" sectionFormat="of" target="section-3.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-decimals">Decimals</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.3">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.3.1"><xref derivedContent="3.3.3" format="counter" sectionFormat="of" target="section-3.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-strings">Strings</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.4">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.4.1"><xref derivedContent="3.3.4" format="counter" sectionFormat="of" target="section-3.3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tokens">Tokens</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.5">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.5.1"><xref derivedContent="3.3.5" format="counter" sectionFormat="of" target="section-3.3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-byte-sequences">Byte Sequences</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.6">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.6.1"><xref derivedContent="3.3.6" format="counter" sectionFormat="of" target="section-3.3.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-booleans">Booleans</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.7">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.7.1"><xref derivedContent="3.3.7" format="counter" sectionFormat="of" target="section-3.3.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dates">Dates</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.8">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.8.1"><xref derivedContent="3.3.8" format="counter" sectionFormat="of" target="section-3.3.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-display-strings">Display Strings</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-working-with-structured-fie">Working with Structured Fields in HTTP</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-structured-fiel">Serializing Structured Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.1.2">
                  <li pn="section-toc.1-1.4.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.1.1"><xref derivedContent="4.1.1" format="counter" sectionFormat="of" target="section-4.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-list">Serializing a List</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.2.1"><xref derivedContent="4.1.2" format="counter" sectionFormat="of" target="section-4.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-dictionary">Serializing a Dictionary</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.3">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.3.1"><xref derivedContent="4.1.3" format="counter" sectionFormat="of" target="section-4.1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-an-item">Serializing an Item</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.4">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.4.1"><xref derivedContent="4.1.4" format="counter" sectionFormat="of" target="section-4.1.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-an-integer">Serializing an Integer</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.5">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.5.1"><xref derivedContent="4.1.5" format="counter" sectionFormat="of" target="section-4.1.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-decimal">Serializing a Decimal</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.6">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.6.1"><xref derivedContent="4.1.6" format="counter" sectionFormat="of" target="section-4.1.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-string">Serializing a String</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.7">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.7.1"><xref derivedContent="4.1.7" format="counter" sectionFormat="of" target="section-4.1.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-token">Serializing a Token</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.8">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.8.1"><xref derivedContent="4.1.8" format="counter" sectionFormat="of" target="section-4.1.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-byte-sequence">Serializing a Byte Sequence</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.9">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.9.1"><xref derivedContent="4.1.9" format="counter" sectionFormat="of" target="section-4.1.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-boolean">Serializing a Boolean</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.10">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.10.1"><xref derivedContent="4.1.10" format="counter" sectionFormat="of" target="section-4.1.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-date">Serializing a Date</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.11">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.11.1"><xref derivedContent="4.1.11" format="counter" sectionFormat="of" target="section-4.1.11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-display-strin">Serializing a Display String</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-structured-fields">Parsing Structured Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.2.2">
                  <li pn="section-toc.1-1.4.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.1.1"><xref derivedContent="4.2.1" format="counter" sectionFormat="of" target="section-4.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-list">Parsing a List</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.2.1"><xref derivedContent="4.2.2" format="counter" sectionFormat="of" target="section-4.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-dictionary">Parsing a Dictionary</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.3.1"><xref derivedContent="4.2.3" format="counter" sectionFormat="of" target="section-4.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-an-item">Parsing an Item</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.4">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.4.1"><xref derivedContent="4.2.4" format="counter" sectionFormat="of" target="section-4.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-an-integer-or-decim">Parsing an Integer or Decimal</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.5">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.5.1"><xref derivedContent="4.2.5" format="counter" sectionFormat="of" target="section-4.2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-string">Parsing a String</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.6">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.6.1"><xref derivedContent="4.2.6" format="counter" sectionFormat="of" target="section-4.2.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-token">Parsing a Token</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.7">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.7.1"><xref derivedContent="4.2.7" format="counter" sectionFormat="of" target="section-4.2.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-byte-sequence">Parsing a Byte Sequence</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.8">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.8.1"><xref derivedContent="4.2.8" format="counter" sectionFormat="of" target="section-4.2.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-boolean">Parsing a Boolean</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.9">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.9.1"><xref derivedContent="4.2.9" format="counter" sectionFormat="of" target="section-4.2.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-date">Parsing a Date</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.10">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.10.1"><xref derivedContent="4.2.10" format="counter" sectionFormat="of" target="section-4.2.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-display-string">Parsing a Display String</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-frequently-asked-questions">Frequently Asked Questions</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="A.1" format="counter" sectionFormat="of" target="section-appendix.a.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-why-not-json">Why Not JSON?</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-implementation-notes">Implementation Notes</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="Appendix C" format="default" sectionFormat="of" target="section-appendix.c"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-abnf">ABNF</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="Appendix D" format="default" sectionFormat="of" target="section-appendix.d"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-8941">Changes from RFC 8941</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.e"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.f"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">はじめに</name>
      <t indent="0" pn="section-1-1">新しいHTTPヘッダー（とトレーラー）フィールドの構文を指定するのは大変な作業です。<xref section="16.3.2" sectionFormat="of" target="RFC9110" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-16.3.2" derivedContent="HTTP"/>のガイダンスがあったとしても、 これからHTTPフィールドを作ろうとする人にとっては多くの決定事項や落とし穴があります。</t>
      <t indent="0" pn="section-1-2">フィールドが定義されると、特注のパーサーやシリアライザーを作成することが多くあります。 なぜなら、一般的な構文に見えるものであっても、それぞれのフィールドの値は少しことなった扱いをするからです。</t>
      <t indent="0" pn="section-1-3">この文書ではこれらの問題に対処するために、 新しいHTTPフィールド値の定義で使用するための一連の共通データ構造を導入します。とくに、HTTP <xref target="RFC9110" format="default" sectionFormat="of" derivedContent="HTTP"/> のヘッダーとトレーラーフィールドで、 そのモデルを表現するための具体的なシリアライズとともに、それらのための一般的で抽象的なモデルを定義しています。</t>
      <t indent="0" pn="section-1-4">構造化ヘッダー "または "構造化トレーラー "として定義されるHTTPフィールド(どちらにもなりうる場合、それは "構造化フィールド")は、その構文と基本処理規則を定義するためにこの仕様で定義される型を使用し、それによって仕様作成者による定義と実装による処理の両方を単純化します。</t>
      <t indent="0" pn="section-1-5">さらに、将来のバージョンのHTTPでは、これらの構造の抽象モデルの代替シリアライゼーションを定義することができ、そのモデルを使用するフィールドを再定義することなく、より効率的に伝送することができます。</t>
      <t indent="0" pn="section-1-6">既存のHTTPフィールドの構文を再定義することは、この文書の目的ではないことに注意してください。ここで説明するメカニズムは、明示的にそれらを選択するフィールドでのみ使用することを意図しています。</t>
      <t indent="0" pn="section-1-7"><xref target="specify" format="default" sectionFormat="of" derivedContent="Section 2"/> は、構造化フィールドの指定方法について説明しています。</t>
      <t indent="0" pn="section-1-8"><xref target="types" format="default" sectionFormat="of" derivedContent="Section 3"/> は、構造化フィールドで使用できる多くの抽象的なデータ型を定義しています。</t>
      <t indent="0" pn="section-1-9">これらの抽象型は、<xref target="text" format="default" sectionFormat="of" derivedContent="Section 4"/>で説明されているアルゴリズムを使って、HTTP フィールド値にシリアライズしたり、HTTP フィールド値からパースしたりすることができます。</t>
      <section anchor="strict" numbered="true" removeInRFC="false" toc="include" pn="section-1.1">
        <name slugifiedName="name-intentionally-strict-proces">意図的に厳密な処理</name>
        <t indent="0" pn="section-1.1-1">この仕様では、段階的なアルゴリズムによる厳密な解析と直列化の動作を意図的に定義しており、 定義された唯一のエラー処理は操作を完全に失敗させることです。</t>
        <t indent="0" pn="section-1.1-2">これは、忠実な実装と良好な相互運用性を奨励するために設計されています。 したがって、入力に対してより寛容になることで役に立とうとする実装は、 他の実装に同様の（しかしおそらく微妙に異なる）回避策を実装するように圧力をかけることになり、 相互運用性を悪化させることになります。</t>
        <t indent="0" pn="section-1.1-3">つまり、厳密な処理は、この仕様の意図的な機能です。準拠していない入力を生産者が早期に発見して修正し、相互運用性やセキュリティー上の問題を回避できます。</t>
        <t indent="0" pn="section-1.1-4">この厳格さの結果、あるフィールドが複数の関係者（たとえば、仲介者や送信者内の異なるコンポーネント）によって付加される場合、ある関係者の値にエラーがあると、フィールド値全体のパースに失敗する可能性が高いことに注意する必要があります。</t>
      </section>
      <section anchor="notational-conventions" numbered="true" removeInRFC="false" toc="include" pn="section-1.2">
        <name slugifiedName="name-notational-conventions">表記上の注意事項</name>
        <t indent="0" pn="section-1.2-1">キーワード「<bcp14>しなければなりません（MUST）</bcp14>」、「<bcp14>してはなりません（MUST NOT）</bcp14>」、
「<bcp14>要求されています（REQUIRED）</bcp14>」、
「<bcp14>することになります（SHALL）</bcp14>」、「<bcp14>することはありません（SHALL NOT）</bcp14>」、
「<bcp14>すべきです（SHOULD）</bcp14>」、「<bcp14>すべきではありません（SHOULD NOT）</bcp14>」、
「<bcp14>推奨されます（RECOMMENDED）</bcp14>」、「<bcp14>推奨されません（NOT RECOMMENDED）</bcp14>」、
「<bcp14>してもよいです（MAY）</bcp14>」、「<bcp14>選択できます（OPTIONAL）</bcp14>」は、
BCP 14<xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> に記載されているとおりに解釈されるものとします。
ただし、ここに示すようにすべて大文字で表示される場合に限ります。</t>
        <t indent="0" pn="section-1.2-2">この文書では、<xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>からVCHAR、SP、DIGIT、ALPHA、およびDQUOTEルールを使用して、文脈に応じて文字および/またはそれに対応するASCIIバイトを指定します。同じ目的で、<xref target="RFC9110" format="default" sectionFormat="of" derivedContent="HTTP"/>からtcharおよびOWSルールを使用します。</t>
        <t indent="0" pn="section-1.2-3">この文書では、解析およびシリアル化の動作を指定するためにアルゴリズムを使用します。HTTPフィールドから解析する場合、実装はアルゴリズムに従うのと区別がつかない動作を<bcp14>しなければなりません（MUST）</bcp14>。</t>
        <t indent="0" pn="section-1.2-4">HTTPフィールドへのシリアル化については、アルゴリズムはそれらを生成する推奨方法を定義します。実装は、<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/>で説明されている解析アルゴリズムによって出力が正しく処理される限り、指定された動作から変化<bcp14>してもよいです（MAY）</bcp14>。</t>
      </section>
    </section>
    <section anchor="specify" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-defining-new-structured-fie">新しい構造化フィールドを定義する</name>
      <t indent="0" pn="section-2-1">HTTP フィールドを Structured Field として指定するために、その作者は以下のことを行う必要があります。</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2-2">
        <li pn="section-2-2.1">
          <t indent="0" pn="section-2-2.1.1">本仕様書を規範的に参照する。現場の受信者及び生成者は、この文書の要求事項が有効であることを知る必要があります。</t>
        </li>
        <li pn="section-2-2.2">
          <t indent="0" pn="section-2-2.2.1">そのフィールドが Structured Header (すなわち、ヘッダーセクションでのみ使用可能。一般的なケース)、 Structured Trailer (トレーラーセクションのみ)、または Structured Field (両方)のいずれであるかを特定する。</t>
        </li>
        <li pn="section-2-2.3">
          <t indent="0" pn="section-2-2.3.1">フィールド値の型を指定する。 リスト(<xref target="list" format="default" sectionFormat="of" derivedContent="Section 3.1"/>)、辞書(<xref target="dictionary" format="default" sectionFormat="of" derivedContent="Section 3.2"/>)、アイテム(<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/>)のいずれかです。</t>
        </li>
        <li pn="section-2-2.4">
          <t indent="0" pn="section-2-2.4.1">フィールド値のセマンティクスを定義する。</t>
        </li>
        <li pn="section-2-2.5">
          <t indent="0" pn="section-2-2.5.1">フィールド値に対する追加制約を指定する。同様に制約に違反した場合の結果も指定します。</t>
        </li>
      </ul>
      <t indent="0" pn="section-2-3">一般的に、これはフィールド定義が最上位の型（リスト、辞書、アイテム）を指定し、次に許容される型とそれに対する制約を定義することを意味します。 たとえば、リストとして定義されたヘッダーは、すべての整数のメンバを持つか、またはそれらの型が混在するかもしれません。 アイテムとして定義されたヘッダーは、文字列のみを許可し、さらに文字「Q」で始まる文字列や、小文字の文字列のみを許可するかもしれません。同様に、内部リスト (<xref target="inner-list" format="default" sectionFormat="of" derivedContent="Section 3.1.1"/>) は、 フィールド定義で明示的に許可されている場合にのみ有効です。</t>
      <t indent="0" pn="section-2-4">表示文字列タイプを使用するフィールドは、許可されるUnicodeコードポイントを慎重に指定することが推奨されます。例えば、<xref target="RFC8264" format="default" sectionFormat="of" derivedContent="PRECIS"/>のプロファイルの使用を指定することが考えられます。</t>
      <t indent="0" pn="section-2-5">フィールド定義は、フィールド値全体に対してのみこの仕様を使用でき、一部に対しては使用できません。</t>
      <t indent="0" pn="section-2-6">仕様書では、フィールド名を必要に応じて 「構造化ヘッダー名（structured header name）」、「構造化トレーラー名（structured trailer name）」、 「構造化フィールド名（structured field name）」と表記することができます。 同様に必要に応じて、そのフィールド値を「構造化ヘッダー値（structured header value）」、 「構造化トレーラー値（structured trailer value）」または「構造化フィールド値（structured field value）」として参照することができます。</t>
      <t indent="0" pn="section-2-7">この仕様では、実装によってサポートされる様々な構造体の長さや数の最小値を定義しています。 ほとんどの場合、最大サイズは指定しません。しかしHTTPの実装では個々のフィールドのサイズやフィールドの総数、 ヘッダーやトレーラーセクション全体のサイズに様々な制限があることを、作者は知っておくべきです。</t>
      <section anchor="example" numbered="true" removeInRFC="false" toc="include" pn="section-2.1">
        <name slugifiedName="name-example">例</name>
        <t indent="0" pn="section-2.1-1">架空のFoo-Exampleヘッダーフィールドは次のように指定されるかもしれません。</t>
        <blockquote pn="section-2.1-2">
          <t indent="0" pn="section-2.1-2.1">42. Foo-Example ヘッダーフィールド</t>
          <t indent="0" pn="section-2.1-2.2">Foo-Example HTTPヘッダーフィールドは、メッセージにどれだけのFooがあるかという情報を伝えます。</t>
          <t indent="0" pn="section-2.1-2.3">Foo-Example は Item Structured Header [RFC9651] である。その値は整数(Integer)である<bcp14>必要があります（MUST）</bcp14> ([RFC9651] の Section 3.3.1 参照)。</t>
          <t indent="0" pn="section-2.1-2.4">その値はメッセージ中のFooの量を表し、0から10の間（両端を含む）である<bcp14>必要があります（MUST）</bcp14>。           他の値は、ヘッダーフィールド全体を無視する<bcp14>必要があります（MUST）</bcp14>。</t>
          <t indent="0" pn="section-2.1-2.5">以下のパラメーターが定義されています。</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2.1-2.6">
            <li pn="section-2.1-2.6.1">キー「foourl」を持つパラメーターの値は文字列（String）([RFC9651] の Section 3.3.3)です。
            メッセージのFoo URLを伝えるために使用されます。処理の要件は以下を参照してください。</li>
          </ul>
          <t indent="0" pn="section-2.1-2.7">「foourl」はURIリファレンス（[RFC3986]のSection 4.1）。 その値が有効なURIリファレンスでない場合、そのヘッダーフィールド全体は無視される<bcp14>必要があります（MUST）</bcp14>。 その値が相対リファレンス（[RFC3986]のSection 5）の場合、使用される前に解決されなければなりません。</t>
          <t indent="0" pn="section-2.1-2.8">例を以下に示します:</t>
          <artwork align="left" pn="section-2.1-2.9">
  Foo-Example: 2; foourl="https://foo.example.com/"
</artwork>
        </blockquote>
      </section>
      <section anchor="error-handling" numbered="true" removeInRFC="false" toc="include" pn="section-2.2">
        <name slugifiedName="name-error-handling">エラーハンドリング</name>
        <t indent="0" pn="section-2.2-1">パースに失敗すると、フィールド全体が無視されます (<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/>参照)。フィールド定義はこれを上書きすることはできません。なぜなら、それを行うと汎用ソフトウェアによる処理ができなくなるからです。フィールド定義は追加の制約を加えることしかできません（例えば、整数や小数の数値範囲、文字列やトークンの形式、辞書の値に許可される型、リスト内の項目数など）。</t>
        <t indent="0" pn="section-2.2-2">フィールド固有の制約が違反された場合、フィールド定義が他の処理要件を定義していない限り、フィールド全体も無視されます。例えば、ヘッダーフィールドがアイテムとして定義され、整数であることが要求されているが、文字列が受信された場合、そのフィールドの定義が明示的に他の処理を指定していない限り、それは無視されるべきです。</t>
      </section>
      <section anchor="preserving-extensibility" numbered="true" removeInRFC="false" toc="include" pn="section-2.3">
        <name slugifiedName="name-preserving-extensibility">拡張性の保持</name>
        <t indent="0" pn="section-2.3-1">構造化フィールドは、経験上、予見されていない場合でも、フィールドの許容される構文と意味を制御された方法で変更および追加する必要があることが多いため、拡張可能に設計されています。</t>
        <t indent="0" pn="section-2.3-2">アイテムと内部リストの両方が拡張メカニズムとしてパラメータを許可します。これは、必要に応じて後でその値を拡張してより多くの情報を収容できることを意味します。将来の互換性を維持するために、フィールド仕様では認識されないパラメータの存在をエラー条件として定義することは推奨されません。</t>
        <t indent="0" pn="section-2.3-3">フィールド仕様は、拡張性を保持するために、アイテム、リスト、または辞書のいずれかである必要があります。誤って他のタイプ（例：整数）として定義されたフィールドは、アイテムと見なされます（つまり、パラメータを許可します）。</t>
        <t indent="0" pn="section-2.3-4">将来にわたってこの拡張性が利用可能であることをさらに保証し、消費者が完全なパーサー実装を使用することを奨励するために、フィールド定義では送信者によって「グリース」パラメータが追加されることを指定できます。仕様では、定義されたパターンに適合するすべてのパラメータがこの使用のために予約されていることを規定し、それらが一部のリクエストで送信されることを奨励することができます。これにより、受信者がパラメータを考慮しないパーサーを作成することを防ぐのに役立ちます。</t>
        <t indent="0" pn="section-2.3-5">辞書を使用する仕様は、未知のキーの存在、およびそれに関連する値とタイプを無視することを要求することで、将来の互換性を確保することもできます。その後の仕様で追加のキーを追加し、それに適した制約を指定することができます。</t>
        <t indent="0" pn="section-2.3-6">構造化フィールドの拡張は、定義された値の制約が満たされない場合に、そのフィールド値全体を理解する受信者によって無視することを要求できます。</t>
      </section>
      <section anchor="using-new-structured-types-in-extensions" numbered="true" removeInRFC="false" toc="include" pn="section-2.4">
        <name slugifiedName="name-using-new-structured-types-">新しい構造化タイプの拡張での使用</name>
        <t indent="0" pn="section-2.4-1">フィールド定義が構造化フィールドの特定のRFCを参照する必要があるため、その値に使用できるタイプはそのRFCで定義されたものに限定されます。例えば、この文書を参照するフィールド定義は、Dateタイプ（<xref target="date" format="default" sectionFormat="of" derivedContent="Section 3.3.7"/>）を使用する値を持つことができますが、RFC 8941を参照するフィールド定義は、その仕様の実装によって無効（したがって破棄）と見なされるため、使用できません。</t>
        <t indent="0" pn="section-2.4-2">この制限は、フィールドの将来の拡張にも適用されます。例えば、RFC 8941を参照して定義されたフィールドは、Dateタイプを使用できません。なぜなら、一部の受信者は依然としてRFC 8941に基づいたパーサーを使用してそれを処理している可能性があるからです。</t>
        <t indent="0" pn="section-2.4-3">ただし、この文書はRFC 8941との後方互換性を持つように設計されています。ここでの要件を実装するパーサーは、RFC 8941を参照する定義の有効な構造化フィールドも解析できます。</t>
        <t indent="0" pn="section-2.4-4">構造化フィールドの実装を新しい改訂版の仕様（この文書など）に対応するようにアップグレードすると、以前のRFCでは無効とされていたフィールド値が処理時に有効になる可能性があります。</t>
        <t indent="0" pn="section-2.4-5">例えば、フィールドインスタンスが構文的に有効なDate（<xref target="date" format="default" sectionFormat="of" derivedContent="Section 3.3.7"/>）を含む場合、そのフィールドの定義がDateを受け入れないにもかかわらずです。RFC 8941に基づく実装は、その仕様で定義されていないため、そのようなフィールドインスタンスの解析に失敗します。その実装がこの仕様にアップグレードされた場合、解析は成功します。一部のケースでは、結果として得られるDate値はフィールド固有のロジックによって拒否されますが、拡張パラメータなどの他のフィールドで無視される値は検出されず、そのフィールドが受け入れられ処理される可能性があります。</t>
      </section>
    </section>
    <section anchor="types" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-structured-data-types">構造化データ型</name>
      <t indent="0" pn="section-3-1">このセクションでは、構造化フィールドが使用する抽象型の概要を示し、それぞれの型がテキストHTTPフィールドにシリアル化される方法の簡単な説明と例を示します。<xref target="text" format="default" sectionFormat="of" derivedContent="Section 4"/>では、それらがテキストHTTPフィールドから解析され、シリアル化される方法の詳細を指定しています。</t>
      <t indent="0" pn="section-3-2">まとめると</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3-3">
        <li pn="section-3-3.1">
          <t indent="0" pn="section-3-3.1.1">HTTPフィールドが定義できるトップレベルの型は3つあります。リスト、ディクショナリ、そしてアイテムです。</t>
        </li>
        <li pn="section-3-3.2">
          <t indent="0" pn="section-3-3.2.1">リストとディクショナリはコンテナであり、そのメンバはアイテムまたはインナーリスト（それ自体がアイテムの配列である）であることができます。</t>
        </li>
        <li pn="section-3-3.3">
          <t indent="0" pn="section-3-3.3.1">アイテムもインナーリストも、キーと値のペアでパラメーター化することができます。</t>
        </li>
      </ul>
      <section anchor="list" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-lists">リスト（List）</name>
        <t indent="0" pn="section-3.1-1">リスト（List）は0個以上のメンバーからなる配列で、 それぞれがアイテム(<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/>)またはインナーリスト(<xref target="inner-list" format="default" sectionFormat="of" derivedContent="Section 3.1.1"/>)になります。 どちらもパラメーター化(<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>)することが可能です。</t>
        <t indent="0" pn="section-3.1-2">空のリストは、フィールドを全くシリアライズしないことで示されます。 これは、リストとして定義されたフィールドは、デフォルトで空の値を持つことを意味します。</t>
        <t indent="0" pn="section-3.1-3">テキストHTTPフィールドとしてシリアル化されると、各メンバーはカンマとオプションの空白で区切られます。例えば、値がトークンのリストとして定義されているフィールドは次のようになります:</t>
        <sourcecode type="http-message" markers="false" pn="section-3.1-4">
Example-List: sugar, tea, rum
</sourcecode>
        <t indent="0" pn="section-3.1-5">リストは、<xref section="5.3" sectionFormat="of" target="RFC9110" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5.3" derivedContent="HTTP"/>のように， そのメンバを同じヘッダーやトレーラーセクション内の複数の行に、分割することができることに注意してください。たとえば、以下は等価です:</t>
        <sourcecode type="http-message" markers="false" pn="section-3.1-6">
Example-List: sugar, tea, rum
</sourcecode>
        <t indent="0" pn="section-3.1-7">と</t>
        <sourcecode type="http-message" markers="false" pn="section-3.1-8">
Example-List: sugar, tea
Example-List: rum
</sourcecode>
        <t indent="0" pn="section-3.1-9">ただし、Listの個々のメンバを安全に行に分割することはできません。 詳しくは、<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/>を参照してください。</t>
        <t indent="0" pn="section-3.1-10">パーサーは、少なくとも1024個のメンバーを含むListをサポート<bcp14>しなければなりません（MUST）</bcp14>。 フィールドの仕様は、必要に応じて個々のリスト値の型と要素数を制限することができます。</t>
        <section anchor="inner-list" numbered="true" removeInRFC="false" toc="include" pn="section-3.1.1">
          <name slugifiedName="name-inner-lists">インナーリスト（Inner Lists）</name>
          <t indent="0" pn="section-3.1.1-1">インナーリスト（Inner List）は、0個以上のアイテム（<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/>)です。個々のItemもInner List自体もパラメーター化することができます(<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>）からなる配列です。</t>
          <t indent="0" pn="section-3.1.1-2">テキストHTTPフィールドとしてシリアル化されると、内部リストは括弧で囲まれ、その値は1つ以上のスペースで区切られます。値が文字列の内部リストのリストとして定義されているフィールドは次のようになります:</t>
          <sourcecode type="http-message" markers="false" pn="section-3.1.1-3">
Example-List: ("foo" "bar"), ("baz"), ("bat" "one"), ()
</sourcecode>
          <t indent="0" pn="section-3.1.1-4">この例で、最後のメンバーは空のインナーリストであることに注意してください。</t>
          <t indent="0" pn="section-3.1.1-5">あるヘッダーフィールドがインナーリストのリストとして定義されるとき、 どのレベルでもパラメーターを持つ可能性があります：</t>
          <sourcecode type="http-message" markers="false" pn="section-3.1.1-6">
Example-List: ("foo"; a=1;b=2);lvl=5, ("bar" "baz");lvl=1
</sourcecode>
          <t indent="0" pn="section-3.1.1-7">パーサーは、少なくとも256のメンバーを含むインナーリストをサポート<bcp14>しなければなりません（MUST）</bcp14>。
フィールド仕様は、個々のインナーリストのメンバー型と要素数を、必要に応じて制限することができます。</t>
        </section>
        <section anchor="param" numbered="true" removeInRFC="false" toc="include" pn="section-3.1.2">
          <name slugifiedName="name-parameters">パラメーター（Parameter）</name>
          <t indent="0" pn="section-3.1.2-1">パラメーター（Parameter）は、アイテム（<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/> ）または
インナーリスト（<xref target="inner-list" format="default" sectionFormat="of" derivedContent="Section 3.1.1"/> ）と関連付けられた、キーと値のペアの順序付きマップです。
キーはパラメーターの範囲内で一意であり、値は裸のアイテムです（つまり、それ自体をパラメーター化することはできません。<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/> を参照してください）。</t>
          <t indent="0" pn="section-3.1.2-2">実装は、パラメーターへのアクセス方法として、インデックスとキーの両方を提供<bcp14>しなければなりません（MUST）</bcp14>。
仕様は、どちらかの方法でアクセス<bcp14>してもよいです（MAY）</bcp14>。</t>
          <t indent="0" pn="section-3.1.2-3">パラメーターはシリアライズされた順番で順序付けされ、 パラメーターのキーに大文字を含めることができないことに注意してください。</t>
          <t indent="0" pn="section-3.1.2-4">テキストHTTPフィールドとしてシリアル化されると、パラメータはそのアイテムまたは内部リストおよび他のパラメータとセミコロンで区切られます。例えば:</t>
          <sourcecode type="http-message" markers="false" pn="section-3.1.2-5">
Example-List: abc;a=1;b=2; cde_456, (ghi;jk=4 l);q="9";r=w
</sourcecode>
          <t indent="0" pn="section-3.1.2-6">値が真偽値（<xref target="boolean" format="default" sectionFormat="of" derivedContent="Section 3.3.6"/> 参照）であるパラメーターは、
シリアライズ時にその値を省略<bcp14>しなければなりません（MUST）</bcp14>。
たとえば、ここで "a "パラメーターはtrueであり、"b "パラメーターはfalseです。</t>
          <sourcecode type="http-message" markers="false" pn="section-3.1.2-7">
Example-Integer: 1; a; b=?0
</sourcecode>
          <t indent="0" pn="section-3.1.2-8">この要件はシリアライズに関するものであることに注意してください。
パーサーは、真の値がパラメーターに現れたときに正しく処理することを依然として要求されます</t>
          <t indent="0" pn="section-3.1.2-9">パーサはItemまたはInner Listで少なくとも256個のパラメーターをサポートし、
少なくとも64文字のパラメーターキーをサポート<bcp14>しなければなりません（MUST）</bcp14>。
フィールド指定は、必要に応じて個々のパラメーターの順序やその値の型を制約することができます。</t>
        </section>
      </section>
      <section anchor="dictionary" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-dictionaries">辞書（Dictionary）</name>
        <t indent="0" pn="section-3.2-1">辞書（Dictionary）はキーと値のペアの順序付きマップであり、
キーは短いテキスト文字列、値はアイテム (<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/>) またはアイテムの配列で、
どちらもパラメーター化 (<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>) が可能です。
メンバーは0個以上存在でき、そのキーは辞書のスコープ内で一意です。</t>
        <t indent="0" pn="section-3.2-2">実装は辞書へのアクセス方法として、インデックスとキーの両方を提供<bcp14>しなければなりません（MUST）</bcp14>。
仕様は、メンバーへのアクセスにどちらかの手段を使用<bcp14>してもよいです（MAY）</bcp14>。</t>
        <t indent="0" pn="section-3.2-3">リストと同様に、空の辞書はフィールド全体を省略することで表現されます。 これは、ディクショナリとして定義されたフィールドはデフォルトで空の値を持つことを意味します。</t>
        <t indent="0" pn="section-3.2-4">一般的に、フィールド仕様は、キーによって個々のメンバーに許可される型と、
その存在が必須か任意かを指定することによって、辞書のセマンティクスを定義します。
受信者は、フィールドの仕様でとくに禁止されていない限り、キーが未定義または不明のメンバーを無視<bcp14>しなければなりません（MUST）</bcp14>。</t>
        <t indent="0" pn="section-3.2-5">テキストHTTPフィールドとしてシリアル化されると、メンバーはシリアル化された順序で並べられ、カンマとオプションの空白で区切られます。メンバーキーには大文字を含めることはできません。キーと値は"="（空白なし）で区切られます。例えば:</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-6">
Example-Dict: en="Applepie", da=:w4ZibGV0w6ZydGU=:
</sourcecode>
        <t indent="0" pn="section-3.2-7">この例では、最後の"="はバイト列（<xref target="binary" format="default" sectionFormat="of" derivedContent="Section 3.3.5"/> を参照）を含むためであることに注意してください。</t>
        <t indent="0" pn="section-3.2-8">値が真偽値（<xref target="boolean" format="default" sectionFormat="of" derivedContent="Section 3.3.6"/> を参照）であるメンバーは、
シリアライズ時にその値を省略<bcp14>しなければなりません（MUST）</bcp14>。たとえば、以下の例では「b」と「c」の両方がtrueです。</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-9">
Example-Dict: a=?0, b, c; foo=bar
</sourcecode>
        <t indent="0" pn="section-3.2-10">この要件はシリアライズに関するものであることに注意してください。
パーサは、辞書の値に現れる真の真偽値を正しく処理することが、依然として要求されます。</t>
        <t indent="0" pn="section-3.2-11">以下は、トークンのインナーリストを値とするメンバーを持つ辞書です：</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-12">
Example-Dict: rating=1.5, feelings=(joy sadness)
</sourcecode>
        <t indent="0" pn="section-3.2-13">以下は、アイテムとインナーリストが混在する辞書で、一部のメンバーはパラメーターを持ちます：</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-14">
Example-Dict: a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid
</sourcecode>
        <t indent="0" pn="section-3.2-15">なお、辞書は、そのメンバを同じヘッダーやトレーラーセクションの複数の行に分割することができます。
たとえば、次のものは同等です：</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-16">
Example-Dict: foo=1, bar=2
</sourcecode>
        <t indent="0" pn="section-3.2-17">と</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-18">
Example-Dict: foo=1
Example-Dict: bar=2
</sourcecode>
        <t indent="0" pn="section-3.2-19">ただし、辞書の個々のメンバーを安全に行に分割することはできません。
詳しくは<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/> を参照してください。</t>
        <t indent="0" pn="section-3.2-20">パーサーは、少なくとも1024のキー/値ペアと、
少なくとも64文字のキーを含む辞書をサポート<bcp14>しなければなりません（MUST）</bcp14>。
フィールド指定は、必要に応じて値の型と、個々の辞書メンバーの順序を制限することができます。</t>
      </section>
      <section anchor="item" numbered="true" removeInRFC="false" toc="include" pn="section-3.3">
        <name slugifiedName="name-items">アイテム（Item）</name>
        <t indent="0" pn="section-3.3-1">アイテム（Item）は、 整数(<xref target="integer" format="default" sectionFormat="of" derivedContent="Section 3.3.1"/>)、小数(<xref target="decimal" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>)、文字列(<xref target="string" format="default" sectionFormat="of" derivedContent="Section 3.3.3"/>)、トークン(<xref target="token" format="default" sectionFormat="of" derivedContent="Section 3.3.4"/>)、バイト列(<xref target="binary" format="default" sectionFormat="of" derivedContent="Section 3.3.5"/>)、真偽値(<xref target="boolean" format="default" sectionFormat="of" derivedContent="Section 3.3.6"/>)、日付(<xref target="date" format="default" sectionFormat="of" derivedContent="Section 3.3.7"/>)のいずれかを表します。また、関連するパラメーター(<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>)を持つことも可能です。</t>
        <t indent="0" pn="section-3.3-2">たとえば、アイテムが整数であると定義されたヘッダーフィールドは、以下のようになります。</t>
        <sourcecode type="http-message" markers="false" pn="section-3.3-3">
Example-Integer: 5
</sourcecode>
        <t indent="0" pn="section-3.3-4">また、パラメーターで指定した場合です：</t>
        <sourcecode type="http-message" markers="false" pn="section-3.3-5">
Example-Integer: 5; foo=bar
</sourcecode>
        <section anchor="integer" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.1">
          <name slugifiedName="name-integers">整数（Integer）</name>
          <t indent="0" pn="section-3.3.1-1">整数（Integer）は、IEEE754互換<xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/>のため、
  -999,999,999,999～999,999,999の範囲（すなわち最大15桁、符号あり）を持ちます。</t>
          <t indent="0" pn="section-3.3.1-2">以下に例を示します：</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.1-3">
Example-Integer: 42
</sourcecode>
          <t indent="0" pn="section-3.3.1-4">15桁より大きい整数については、
様々な方法でサポートすることができます。
たとえば、文字列(<xref target="string" format="default" sectionFormat="of" derivedContent="Section 3.3.3"/>)、
バイト列(<xref target="binary" format="default" sectionFormat="of" derivedContent="Section 3.3.5"/>)、
またはスケーリングファクターとして機能する整数のパラメーターを使用することで対応できます。</t>
          <t indent="0" pn="section-3.3.1-5">整数を先行ゼロ（「0002」、「-01」など）や符号付きゼロ（「-0」）でシリアライズすることは可能ですが、
実装によってはこれらの区別が保持されない可能性があります。</t>
          <t indent="0" pn="section-3.3.1-6">整数のカンマは、本セクションの文中では読みやすくするためにのみ使用していることに注意してください。wireフォーマットでは無効です。</t>
        </section>
        <section anchor="decimal" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.2">
          <name slugifiedName="name-decimals">小数（Decimal）</name>
          <t indent="0" pn="section-3.3.2-1">小数（Decimal）は、整数部と小数部を持つ数です。 整数部は最大12桁、小数部は最大3桁です。</t>
          <t indent="0" pn="section-3.3.2-2">たとえば、値が小数として定義されているヘッダーは、以下のようになります。</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.2-3">
Example-Decimal: 4.5
</sourcecode>
          <t indent="0" pn="section-3.3.2-4">先行するゼロ（たとえば、「0002.5」、「-01.334」）、後続するゼロ(たとえば、「5.230」「-0.40」) および符号付きゼロ (たとえば「-0.0」) は
小数へシリアライズできる一方で、実装によってこれらの区別が維持されない可能性があります。</t>
          <t indent="0" pn="section-3.3.2-5">シリアライズアルゴリズム(<xref target="ser-decimal" format="default" sectionFormat="of" derivedContent="Section 4.1.5"/>)は、
小数部の精度が3桁以上の入力を丸めることに注意してください。
もし別の丸め方をしたい場合は、ヘッダー定義でシリアライズの前に指定する必要があります。</t>
        </section>
        <section anchor="string" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.3">
          <name slugifiedName="name-strings">文字列（String）</name>
          <t indent="0" pn="section-3.3.3-1">文字列（String）は、0個以上の印刷可能なASCII<xref target="RFC0020" format="default" sectionFormat="of" derivedContent="RFC0020"/> 文字（すなわち、%x20 から %x7E の範囲）です。
タブ、改行、キャリッジリターンなどは含まれないことに注意してください。</t>
          <t indent="0" pn="section-3.3.3-2">非ASCII文字は、いくつかの相互運用性の問題を引き起こすため、文字列では直接サポートされていません。そして、いくつかの例外を除いて、フィールド値はそれらを必要としません。</t>
          <t indent="0" pn="section-3.3.3-3">フィールド値が非ASCIIコンテンツを伝える必要がある場合、表示文字列（<xref target="displaystring" format="default" sectionFormat="of" derivedContent="Section 3.3.8"/>)を指定できます。</t>
          <t indent="0" pn="section-3.3.3-4">テキストHTTPフィールドとしてシリアル化されると、文字列は二重引用符で区切られ、バックスラッシュ（"\"）を使用して二重引用符とバックスラッシュをエスケープします。例えば:</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.3-5">
Example-String: "hello world"
</sourcecode>
          <t indent="0" pn="section-3.3.3-6">文字列の区切り文字はDQUOTEのみで、シングルクォートでは区切りらないので注意してください。
また、エスケープできるのはDQUOTEと「\」だけで、それ以外の文字はパースに失敗<bcp14>しなければなりません（MUST）</bcp14></t>
          <t indent="0" pn="section-3.3.3-7">パーサーは、少なくとも1024文字の文字列（デコード後）をサポート<bcp14>しなければなりません（MUST）</bcp14>。</t>
        </section>
        <section anchor="token" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.4">
          <name slugifiedName="name-tokens">トークン（Token）</name>
          <t indent="0" pn="section-3.3.4-1">トークンは、アルファベット文字または"*"で始まり、その後にゼロ個以上のトークン文字が続く短いテキスト単語です。トークン文字は、<xref target="RFC9110" format="default" sectionFormat="of" derivedContent="HTTP"/>で定義された"token" ABNFルールで許可される文字に加えて、":"および"/"文字も含まれます。</t>
          <t indent="0" pn="section-3.3.4-2">例えば:</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.4-3">
Example-Token: foo123/456
</sourcecode>
          <t indent="0" pn="section-3.3.4-4">パーサーは少なくとも512文字のトークンをサポート<bcp14>しなければなりません（MUST）</bcp14>。</t>
          <t indent="0" pn="section-3.3.4-5">トークンは、既存のHTTPフィールドのデータモデルとの互換性のために定義されており、一部の実装では使用するために追加の手順が必要になる場合があります。その結果、新しいフィールドは文字列を使用することが推奨されます。</t>
        </section>
        <section anchor="binary" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.5">
          <name slugifiedName="name-byte-sequences">バイト列（Byte Sequence）</name>
          <t indent="0" pn="section-3.3.5-1">バイト列（Byte Sequence）を、構造化フィールドで伝えることができます。</t>
          <t indent="0" pn="section-3.3.5-2">テキストHTTPフィールドとしてシリアル化されると、バイトシーケンスはコロンで区切られ、base64（<xref section="4" sectionFormat="comma" target="RFC4648" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-4" derivedContent="RFC4648"/>）を使用してエンコードされます。例えば:</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.5-3">
Example-ByteSequence: :cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==:
</sourcecode>
          <t indent="0" pn="section-3.3.5-4">パーサーは、デコード後に少なくとも16384オクテットのバイト列をサポート<bcp14>しなければなりません（MUST）</bcp14>。</t>
        </section>
        <section anchor="boolean" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.6">
          <name slugifiedName="name-booleans">真偽値（Boolean）</name>
          <t indent="0" pn="section-3.3.6-1">真偽値（Boolean）を構造化フィールドで伝えることができます。</t>
          <t indent="0" pn="section-3.3.6-2">テキストHTTPフィールドとしてシリアル化されると、ブール値は先頭に"?"文字が付き、trueの場合は"1"、falseの場合は"0"が続きます。例えば:</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.6-3">
Example-Boolean: ?1
</sourcecode>
          <t indent="0" pn="section-3.3.6-4">なお、辞書(<xref target="dictionary" format="default" sectionFormat="of" derivedContent="Section 3.2"/>)およびパラメーター(<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>)の値では、
ブール値の真は値を省略することで表されます。</t>
        </section>
        <section anchor="date" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.7">
          <name slugifiedName="name-dates">日付（Date）</name>
          <t indent="0" pn="section-3.3.7-1">日付（Date）を構造化フィールドで伝えることができます。</t>
          <t indent="0" pn="section-3.3.7-2">日付は整数に似たデータモデルを持ち、1970-01-01T00:00:00Zからの秒単位の（場合によっては負の）差分を表し、うるう秒を除きます。したがって、テキストHTTPフィールドでのシリアル化は整数に似ていますが、先頭に"@"が付いていることで区別されます。</t>
          <t indent="0" pn="section-3.3.7-3">たとえば：</t>
          <sourcecode type="http-message-new" markers="false" pn="section-3.3.7-4">
Example-Date: @1659578233
</sourcecode>
          <t indent="0" pn="section-3.3.7-5">パーサーは、値が1年から9999年のすべての日を含む日付をサポート<bcp14>しなければなりません（MUST）</bcp14>（つまり、1970-01-01T00:00:00Zからのデルタ秒が-62,135,596,800から253,402,214,400まで）。</t>
        </section>
        <section anchor="displaystring" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.8">
          <name slugifiedName="name-display-strings">表示文字列（Display String）</name>
          <t indent="0" pn="section-3.3.8-1">表示文字列は文字列に似ており、ゼロ個以上の文字で構成されますが、文字列とは異なり、Unicodeスカラー値（つまり、サロゲートを除くすべてのUnicodeコードポイント）を許可します。</t>
          <t indent="0" pn="section-3.3.8-2">表示文字列は、値がエンドユーザーに表示される場合に使用されることを意図しており、非ASCIIコンテンツを含む必要がある場合があります。文字列（<xref target="string" format="default" sectionFormat="of" derivedContent="Section 3.3.3"/>)やトークン（<xref target="token" format="default" sectionFormat="of" derivedContent="Section 3.3.4"/>)で十分な場合には、表示文字列を使用することは<bcp14>推奨されません（NOT RECOMMENDED）</bcp14>。なぜなら、Unicodeには処理上の考慮事項（例：正規化）やセキュリティ上の考慮事項（例：同形異義攻撃）があり、正しく処理するのが難しいからです。</t>
          <t indent="0" pn="section-3.3.8-3">表示文字列は、値に使用されている言語を示すものではないことに注意してください。必要に応じて、別途（例えば、パラメータで）行うことができます。</t>
          <t indent="0" pn="section-3.3.8-4">テキストHTTPフィールドでは、表示文字列は文字列と同様に表現されますが、非ASCII文字はパーセントエンコードされます。文字列と区別するために先頭に"%"が付きます。</t>
          <t indent="0" pn="section-3.3.8-5">たとえば：</t>
          <sourcecode type="http-message-new" markers="false" pn="section-3.3.8-6">
Example-DisplayString: %"This is intended for display to %c3%bcsers."
</sourcecode>
          <t indent="0" pn="section-3.3.8-7">表示文字列を扱う際の追加のセキュリティ考慮事項については、<xref target="security" format="default" sectionFormat="of" derivedContent="Section 6"/>を参照してください。</t>
        </section>
      </section>
    </section>
    <section anchor="text" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-working-with-structured-fie">HTTPにおける構造化フィールドとの連携</name>
      <t indent="0" pn="section-4-1">このセクションでは、<xref target="types" format="default" sectionFormat="of" derivedContent="Section 3"/>で定義された抽象型をテキストHTTPフィールド値およびそれらと互換性のある他のエンコーディング（例：HTTP/2 <xref target="RFC9113" format="default" sectionFormat="of" derivedContent="HTTP/2"/>でのHPACK <xref target="RFC7541" format="default" sectionFormat="of" derivedContent="HPACK"/>による圧縮前）にシリアライズおよびパースする方法を定義します。</t>
      <section anchor="text-serialize" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-serializing-structured-fiel">構造化フィールドのシリアライズ</name>
        <t indent="0" pn="section-4.1-1">本仕様書で定義された構造体が与えられた場合、HTTPフィールド値として使用するのに適したASCII文字列を返します。</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1-2"><li pn="section-4.1-2.1" derivedCounter="1.">
            <t indent="0" pn="section-4.1-2.1.1">構造体が辞書またはリストであり、その値が空である場合（つまり、メンバーを持たない場合）、 そのフィールドは一切シリアライズしません（つまりfield-nameとfield-valueの両方を省略します）。</t>
          </li>
          <li pn="section-4.1-2.2" derivedCounter="2.">
            <t indent="0" pn="section-4.1-2.2.1">構造体がリストの場合、 その構造体に対して、リストのシリアライズ（<xref target="ser-list" format="default" sectionFormat="of" derivedContent="Section 4.1.1"/>）を実行した結果を、output_stringとします。</t>
          </li>
          <li pn="section-4.1-2.3" derivedCounter="3.">
            <t indent="0" pn="section-4.1-2.3.1">構造体が辞書の場合、 その構造体に対して、辞書のシリアライズ（<xref target="ser-dictionary" format="default" sectionFormat="of" derivedContent="Section 4.1.2"/>）を実行した結果を、output_stringとします。</t>
          </li>
          <li pn="section-4.1-2.4" derivedCounter="4.">
            <t indent="0" pn="section-4.1-2.4.1">構造体がアイテムの場合、 その構造体に対して、アイテムのシリアライズ（<xref target="ser-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3"/>）を実行した結果を、output_stringとします。</t>
          </li>
          <li pn="section-4.1-2.5" derivedCounter="5.">
            <t indent="0" pn="section-4.1-2.5.1">それ以外の場合は失敗します。</t>
          </li>
          <li pn="section-4.1-2.6" derivedCounter="6.">
            <t indent="0" pn="section-4.1-2.6.1">output_stringをASCIIエンコーディング<xref target="RFC0020" format="default" sectionFormat="of" derivedContent="RFC0020"/>を用いて、 バイト配列に変換した結果を返します。</t>
          </li>
        </ol>
        <section anchor="ser-list" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.1">
          <name slugifiedName="name-serializing-a-list">リストのシリアライズ</name>
          <t indent="0" pn="section-4.1.1-1">input_list として (member_value, parameters) タプルの配列が与えられた場合、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.1-2"><li pn="section-4.1.1-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.1-2.1.1">outputに空文字列を代入します。</t>
            </li>
            <li pn="section-4.1.1-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.1-2.2.1">input_list の各（member_value, parameters）に対して：
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.1-2.2.2"><li pn="section-4.1.1-2.2.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.1.1-2.2.2.1.1">member_valueが配列の場合、 (member_value, parameters)に対して、インナーリストのシリアライズ（<xref target="ser-innerlist" format="default" sectionFormat="of" derivedContent="Section 4.1.1.1"/>） を実行した結果を、outputに追加します。</t>
                </li>
                <li pn="section-4.1.1-2.2.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.1.1-2.2.2.2.1">それ以外の場合、 (member_value, parameters)に対して、アイテムのシリアライズ（<xref target="ser-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3"/>） を実行した結果を、outputに追加します。</t>
                </li>
                <li pn="section-4.1.1-2.2.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.1.1-2.2.2.3.1">input_list にさらに member_value が残っている場合：
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.1-2.2.2.3.2"><li pn="section-4.1.1-2.2.2.3.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.1.1-2.2.2.3.2.1.1">「,」をoutputに追加します。</t>
                    </li>
                    <li pn="section-4.1.1-2.2.2.3.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.1.1-2.2.2.3.2.2.1">ひとつのSPをoutput追加します。</t>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li pn="section-4.1.1-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.1-2.3.1">outputを返します。</t>
            </li>
          </ol>
          <section anchor="ser-innerlist" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.1.1.1">
            <name slugifiedName="name-serializing-an-inner-list">インナーリストのシリアライズ</name>
            <t indent="0" pn="section-4.1.1.1-1">(member_value, parameters) タプルの配列を inner_list、 パラメーターを list_parameters として与えたとき、HTTP フィールドの値として使用するのに適したASCII文字列を返します。</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.1.1-2"><li pn="section-4.1.1.1-2.1" derivedCounter="1.">
                <t indent="0" pn="section-4.1.1.1-2.1.1">outputに「(」を代入します。</t>
              </li>
              <li pn="section-4.1.1.1-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.1.1.1-2.2.1">inner_listの各(member_value, parameters)に対して：
                </t>
                <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.1.1-2.2.2"><li pn="section-4.1.1.1-2.2.2.1" derivedCounter="1.">
                    <t indent="0" pn="section-4.1.1.1-2.2.2.1.1">(member_value, parameters)に対して、 アイテムのシリアライズ（<xref target="ser-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3"/>）を実行した結果を、 outputに追加します。</t>
                  </li>
                  <li pn="section-4.1.1.1-2.2.2.2" derivedCounter="2.">
                    <t indent="0" pn="section-4.1.1.1-2.2.2.2.1">まだinner_listに要素が残っている場合、outputにSPをひとつ追加します。</t>
                  </li>
                </ol>
              </li>
              <li pn="section-4.1.1.1-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.1.1.1-2.3.1">outputに「)」を追加します。</t>
              </li>
              <li pn="section-4.1.1.1-2.4" derivedCounter="4.">
                <t indent="0" pn="section-4.1.1.1-2.4.1">list_parametersに対して、 パラメーターのシリアライズ（<xref target="ser-params" format="default" sectionFormat="of" derivedContent="Section 4.1.1.2"/>）を実行した結果を、 outputに追加します。</t>
              </li>
              <li pn="section-4.1.1.1-2.5" derivedCounter="5.">
                <t indent="0" pn="section-4.1.1.1-2.5.1">outputを返します。</t>
              </li>
            </ol>
          </section>
          <section anchor="ser-params" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.1.1.2">
            <name slugifiedName="name-serializing-parameters">パラメーターのシリアライズ</name>
            <t indent="0" pn="section-4.1.1.2-1">input_parametersとして順序付き辞書（各メンバーはparam_keyとparam_valueを持ちます）を与え、 HTTPフィールドの値として使用するのに適したASCII 文字列を返します。</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.1.2-2"><li pn="section-4.1.1.2-2.1" derivedCounter="1.">
                <t indent="0" pn="section-4.1.1.2-2.1.1">outputに空文字列を代入します。</t>
              </li>
              <li pn="section-4.1.1.2-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.1.1.2-2.2.1">input_parameters中でparam_keyの値がparam_valueであるものについて：
                </t>
                <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.1.2-2.2.2"><li pn="section-4.1.1.2-2.2.2.1" derivedCounter="1.">
                    <t indent="0" pn="section-4.1.1.2-2.2.2.1.1">「;」をoutputに追加します。</t>
                  </li>
                  <li pn="section-4.1.1.2-2.2.2.2" derivedCounter="2.">
                    <t indent="0" pn="section-4.1.1.2-2.2.2.2.1">param_keyに対して、 キーのシリアライズ（<xref target="ser-key" format="default" sectionFormat="of" derivedContent="Section 4.1.1.3"/>）を実行した結果を、 outputに追加します。</t>
                  </li>
                  <li pn="section-4.1.1.2-2.2.2.3" derivedCounter="3.">
                    <t indent="0" pn="section-4.1.1.2-2.2.2.3.1">param_valueが真偽値の真でない場合：
                    </t>
                    <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.1.2-2.2.2.3.2"><li pn="section-4.1.1.2-2.2.2.3.2.1" derivedCounter="1.">
                        <t indent="0" pn="section-4.1.1.2-2.2.2.3.2.1.1">「=」をoutputに追加します。</t>
                      </li>
                      <li pn="section-4.1.1.2-2.2.2.3.2.2" derivedCounter="2.">
                        <t indent="0" pn="section-4.1.1.2-2.2.2.3.2.2.1">param_valueに対して、 裸のアイテムのシリアライズ（<xref target="ser-bare-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3.1"/>）を実行した結果を、 outputに追加します。</t>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li pn="section-4.1.1.2-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.1.1.2-2.3.1">outputを返します。</t>
              </li>
            </ol>
          </section>
          <section anchor="ser-key" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.1.1.3">
            <name slugifiedName="name-serializing-a-key">キーのシリアライズ</name>
            <t indent="0" pn="section-4.1.1.3-1">キーをinput_keyとして渡すと、HTTPフィールドの値として適切なASCII文字列を返します。</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.1.3-2"><li pn="section-4.1.1.3-2.1" derivedCounter="1.">
                <t indent="0" pn="section-4.1.1.3-2.1.1">input_keyをASCII文字の列に変換します；この変換が失敗した場合、シリアライズも失敗します。</t>
              </li>
              <li pn="section-4.1.1.3-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.1.1.3-2.2.1">input_keyがlcalpha、DIGIT、「_」、「-」、「.」、「*」に含まれない文字を含んでいる場合、シリアライズに失敗します。</t>
              </li>
              <li pn="section-4.1.1.3-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.1.1.3-2.3.1">input_keyの最初の文字がlcalphaまたは「*」でない場合、シリアライズに失敗します。</t>
              </li>
              <li pn="section-4.1.1.3-2.4" derivedCounter="4.">
                <t indent="0" pn="section-4.1.1.3-2.4.1">outputに空文字列を代入します。</t>
              </li>
              <li pn="section-4.1.1.3-2.5" derivedCounter="5.">
                <t indent="0" pn="section-4.1.1.3-2.5.1">input_keyをoutputに代入します。</t>
              </li>
              <li pn="section-4.1.1.3-2.6" derivedCounter="6.">
                <t indent="0" pn="section-4.1.1.3-2.6.1">outputを返します。</t>
              </li>
            </ol>
          </section>
        </section>
        <section anchor="ser-dictionary" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.2">
          <name slugifiedName="name-serializing-a-dictionary">辞書のシリアライズ</name>
          <t indent="0" pn="section-4.1.2-1">input_dictionary として順序付き辞書（各メンバーはmember_keyと(member_value, parameters)のタプル値）が与えられたとき、 HTTP フィールド値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.2-2"><li pn="section-4.1.2-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.2-2.1.1">outputに空文字列を代入します。</t>
            </li>
            <li pn="section-4.1.2-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.2-2.2.1">input_dictionary の、値が (member_value, parameters) である member_key について、その値を取得します。 
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.2-2.2.2"><li pn="section-4.1.2-2.2.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.1.2-2.2.2.1.1">メンバーのmember_keyに対して、 キーのシリアライズ（<xref target="ser-key" format="default" sectionFormat="of" derivedContent="Section 4.1.1.3"/>）を実行した結果を、 outputに追加します。</t>
                </li>
                <li pn="section-4.1.2-2.2.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.1.2-2.2.2.2.1">member_value が真偽値の真の場合：
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.2-2.2.2.2.2"><li pn="section-4.1.2-2.2.2.2.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.1.2-2.2.2.2.2.1.1">parametersに対して、 パラメーターのシリアライズ（<xref target="ser-params" format="default" sectionFormat="of" derivedContent="Section 4.1.1.2"/>）を実行した結果を、 outputに追加します。</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.1.2-2.2.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.1.2-2.2.2.3.1">それ以外の場合：
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.2-2.2.2.3.2"><li pn="section-4.1.2-2.2.2.3.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.1.2-2.2.2.3.2.1.1">outputに「=」を追加します。</t>
                    </li>
                    <li pn="section-4.1.2-2.2.2.3.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.1.2-2.2.2.3.2.2.1">もしmember_valueが配列ならば、 (member_value, parameters)に対して、 インナーリストのシリアライズ（<xref target="ser-innerlist" format="default" sectionFormat="of" derivedContent="Section 4.1.1.1"/>）を実行した結果を、 outputに追加します。</t>
                    </li>
                    <li pn="section-4.1.2-2.2.2.3.2.3" derivedCounter="3.">
                      <t indent="0" pn="section-4.1.2-2.2.2.3.2.3.1">配列でなければ、 (member_value, parameters)に対して、 アイテムのシリアライズ（<xref target="ser-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3"/>）を実行した結果を、 outputに追加します。</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.1.2-2.2.2.4" derivedCounter="4.">
                  <t indent="0" pn="section-4.1.2-2.2.2.4.1">input_dictionary にさらにメンバーが残っている場合：
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.2-2.2.2.4.2"><li pn="section-4.1.2-2.2.2.4.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.1.2-2.2.2.4.2.1.1">outputに「,」を追加します。</t>
                    </li>
                    <li pn="section-4.1.2-2.2.2.4.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.1.2-2.2.2.4.2.2.1">outputにSPをひとつ追加します。</t>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li pn="section-4.1.2-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.2-2.3.1">outputを返します。</t>
            </li>
          </ol>
        </section>
        <section anchor="ser-item" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.3">
          <name slugifiedName="name-serializing-an-item">アイテムのシリアライズ</name>
          <t indent="0" pn="section-4.1.3-1">bare_itemとしてアイテムを、item_parameters としてパラメーターを与えられたとき、 HTTP フィールド値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.3-2"><li pn="section-4.1.3-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.3-2.1.1">outputに空文字列を代入します。</t>
            </li>
            <li pn="section-4.1.3-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.3-2.2.1">bare_itemに対して、 裸のアイテムのシリアライズ（<xref target="ser-bare-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3.1"/>）を実行した結果を、 outputに追加します。</t>
            </li>
            <li pn="section-4.1.3-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.3-2.3.1">item_parametersに対して、 パラメーターのシリアライズ（<xref target="ser-params" format="default" sectionFormat="of" derivedContent="Section 4.1.1.2"/>）を実行した結果を、 outputに追加します。</t>
            </li>
            <li pn="section-4.1.3-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.1.3-2.4.1">outputを返します。</t>
            </li>
          </ol>
          <section anchor="ser-bare-item" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.1.3.1">
            <name slugifiedName="name-serializing-a-bare-item">裸のアイテムのシリアライズ</name>
            <t indent="0" pn="section-4.1.3.1-1">input_itemとしてアイテムを与えられたとき、 HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.3.1-2"><li pn="section-4.1.3.1-2.1" derivedCounter="1.">
                <t indent="0" pn="section-4.1.3.1-2.1.1">もしinput_itemが整数ならば、input_itemに対して、 整数のシリアライズ（<xref target="ser-integer" format="default" sectionFormat="of" derivedContent="Section 4.1.4"/>）を実行した結果を返します。</t>
              </li>
              <li pn="section-4.1.3.1-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.1.3.1-2.2.1">もしinput_itemが小数ならば、input_itemに対して、 小数のシリアライズ（<xref target="ser-decimal" format="default" sectionFormat="of" derivedContent="Section 4.1.5"/>）を実行した結果を返します。</t>
              </li>
              <li pn="section-4.1.3.1-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.1.3.1-2.3.1">もしinput_itemが文字列ならば、input_itemに対して、 文字列のシリアライズ（<xref target="ser-string" format="default" sectionFormat="of" derivedContent="Section 4.1.6"/>）を実行した結果を返します。</t>
              </li>
              <li pn="section-4.1.3.1-2.4" derivedCounter="4.">
                <t indent="0" pn="section-4.1.3.1-2.4.1">もしinput_itemがトークンならば、input_itemに対して、 トークンのシリアライズ（<xref target="ser-token" format="default" sectionFormat="of" derivedContent="Section 4.1.7"/>）を実行した結果を返します。</t>
              </li>
              <li pn="section-4.1.3.1-2.5" derivedCounter="5.">
                <t indent="0" pn="section-4.1.3.1-2.5.1">もしinput_itemがバイト列ならば、input_itemに対して、 バイト列のシリアライズ（<xref target="ser-binary" format="default" sectionFormat="of" derivedContent="Section 4.1.8"/>）を実行した結果を返します。</t>
              </li>
              <li pn="section-4.1.3.1-2.6" derivedCounter="6.">
                <t indent="0" pn="section-4.1.3.1-2.6.1">もしinput_itemが真偽値ならば、input_itemに対して、 真偽値のシリアライズ（<xref target="ser-boolean" format="default" sectionFormat="of" derivedContent="Section 4.1.9"/>）を実行した結果を返します。</t>
              </li>
              <li pn="section-4.1.3.1-2.7" derivedCounter="7.">
                <t indent="0" pn="section-4.1.3.1-2.7.1">もしinput_itemが日付ならば、input_itemに対して、 日付のシリアライズ（<xref target="ser-date" format="default" sectionFormat="of" derivedContent="Section 4.1.10"/>）を実行した結果を返します。</t>
              </li>
              <li pn="section-4.1.3.1-2.8" derivedCounter="8.">
                <t indent="0" pn="section-4.1.3.1-2.8.1">もしinput_itemが表示文字列ならば、input_itemに対して、 表示文字列のシリアライズ（<xref target="ser-display" format="default" sectionFormat="of" derivedContent="Section 4.1.11"/>）を実行した結果を返します。</t>
              </li>
              <li pn="section-4.1.3.1-2.9" derivedCounter="9.">
                <t indent="0" pn="section-4.1.3.1-2.9.1">それ以外の場合は、シリアライズに失敗します。</t>
              </li>
            </ol>
          </section>
        </section>
        <section anchor="ser-integer" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.4">
          <name slugifiedName="name-serializing-an-integer">整数のシリアライズ</name>
          <t indent="0" pn="section-4.1.4-1">整数をinput_integerとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.4-2"><li pn="section-4.1.4-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.4-2.1.1">もしinput_integerが-999,999,999,999,999から999,999,999,999,999までの両端を含む範囲の整数でなければ、 シリアライズに失敗します。</t>
            </li>
            <li pn="section-4.1.4-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.4-2.2.1">outputに空文字を代入します。</t>
            </li>
            <li pn="section-4.1.4-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.4-2.3.1">もしinput_integerが0未満（0は除く）の場合、outputに「-」を追加します。</t>
            </li>
            <li pn="section-4.1.4-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.1.4-2.4.1">0から9までの数字だけをもちいて、input_integerを10進数で表現した結果を、outputに追加します。</t>
            </li>
            <li pn="section-4.1.4-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.1.4-2.5.1">outputを返します。</t>
            </li>
          </ol>
        </section>
        <section anchor="ser-decimal" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.5">
          <name slugifiedName="name-serializing-a-decimal">小数のシリアライズ</name>
          <t indent="0" pn="section-4.1.5-1">小数をinput_decimalとして与えると、HTTP フィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.5-2"><li pn="section-4.1.5-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.5-2.1.1">input_decimalが小数でない場合、シリアライズに失敗します。</t>
            </li>
            <li pn="section-4.1.5-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.5-2.2.1">input_decimalの小数点以下の桁数が3桁より多い場合、もっとも近い3桁に丸めます。 等距離の場合は偶数へ丸めます。</t>
            </li>
            <li pn="section-4.1.5-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.5-2.3.1">丸めを行ったあとに、小数点の右側に12桁より多くの桁がある場合は、シリアライズに失敗します。</t>
            </li>
            <li pn="section-4.1.5-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.1.5-2.4.1">outputに空文字列を代入します。</t>
            </li>
            <li pn="section-4.1.5-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.1.5-2.5.1">もしinput_decimalが0未満（0は除く）の場合、outputに「-」を追加します。</t>
            </li>
            <li pn="section-4.1.5-2.6" derivedCounter="6.">
              <t indent="0" pn="section-4.1.5-2.6.1">input_decimalの整数部を10進数で表した結果（0から9までの数字のみを使います）をoutputに追加します； つまり整数部がゼロの場合は「0」を追加します。</t>
            </li>
            <li pn="section-4.1.5-2.7" derivedCounter="7.">
              <t indent="0" pn="section-4.1.5-2.7.1">「.」をoutputに追加します。</t>
            </li>
            <li pn="section-4.1.5-2.8" derivedCounter="8.">
              <t indent="0" pn="section-4.1.5-2.8.1">input_decimalの小数部がゼロの場合、「0」をoutputに追加します。</t>
            </li>
            <li pn="section-4.1.5-2.9" derivedCounter="9.">
              <t indent="0" pn="section-4.1.5-2.9.1">そうでない場合、input_decimalの小数部をoutputに追加します（0から9までの数字のみを使います）。</t>
            </li>
            <li pn="section-4.1.5-2.10" derivedCounter="10.">
              <t indent="0" pn="section-4.1.5-2.10.1">outputを返します。</t>
            </li>
          </ol>
        </section>
        <section anchor="ser-string" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.6">
          <name slugifiedName="name-serializing-a-string">文字列のシリアライズ</name>
          <t indent="0" pn="section-4.1.6-1">文字列をinput_stringとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.6-2"><li pn="section-4.1.6-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.6-2.1.1">文字列をinput_stringとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
            </li>
            <li pn="section-4.1.6-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.6-2.2.1">input_stringが%x00-1fまたは%x7f-ffの範囲の文字を含んでいる場合（つまり、VCHARやSPは含みません）、シリアライズに失敗します。</t>
            </li>
            <li pn="section-4.1.6-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.6-2.3.1">outputに文字列DQUOTEを代入します。</t>
            </li>
            <li pn="section-4.1.6-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.1.6-2.4.1">input_stringの各文字charについて：
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.6-2.4.2"><li pn="section-4.1.6-2.4.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.1.6-2.4.2.1.1">charが「\」またはDQUOTEの場合
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.6-2.4.2.1.2"><li pn="section-4.1.6-2.4.2.1.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.1.6-2.4.2.1.2.1.1">「\」をoutputに追加します。</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.1.6-2.4.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.1.6-2.4.2.2.1">charをoutputに追加します。</t>
                </li>
              </ol>
            </li>
            <li pn="section-4.1.6-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.1.6-2.5.1">DQUOTEをoutputに追加します。</t>
            </li>
            <li pn="section-4.1.6-2.6" derivedCounter="6.">
              <t indent="0" pn="section-4.1.6-2.6.1">outputを返します。</t>
            </li>
          </ol>
        </section>
        <section anchor="ser-token" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.7">
          <name slugifiedName="name-serializing-a-token">トークンのシリアライズ</name>
          <t indent="0" pn="section-4.1.7-1">トークンをinput_tokenとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.7-2"><li pn="section-4.1.7-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.7-2.1.1">input_tokenをASCII文字の列に変換します。変換に失敗した場合、シリアライズに失敗します。</t>
            </li>
            <li pn="section-4.1.7-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.7-2.2.1">input_tokenの最初の文字がALPHAまたは「*」でない場合、シリアライズに失敗します。 残りの文字がtchar、「:」「/」でない場合、シリアライズに失敗します。</t>
            </li>
            <li pn="section-4.1.7-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.7-2.3.1">outputに空文字列を代入します。</t>
            </li>
            <li pn="section-4.1.7-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.1.7-2.4.1">outputにinput_tokenを追加します。</t>
            </li>
            <li pn="section-4.1.7-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.1.7-2.5.1">outputを返します。</t>
            </li>
          </ol>
        </section>
        <section anchor="ser-binary" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.8">
          <name slugifiedName="name-serializing-a-byte-sequence">バイト列のシリアライズ</name>
          <t indent="0" pn="section-4.1.8-1">バイト列をinput_bytesとして与え、HTTP のフィールド値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.8-2"><li pn="section-4.1.8-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.8-2.1.1">もしinput_bytesがバイト列でない場合、シリアライズに失敗します。</t>
            </li>
            <li pn="section-4.1.8-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.8-2.2.1">outputに空文字列を代入します。</t>
            </li>
            <li pn="section-4.1.8-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.8-2.3.1">「:」をoutputに追加します。</t>
            </li>
            <li pn="section-4.1.8-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.1.8-2.4.1">input_bytesを<xref section="4" sectionFormat="comma" target="RFC4648" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-4" derivedContent="RFC4648"/>にしたがってbase64エンコードをた結果を追加します。 このとき以下の要件を考慮してください。</t>
            </li>
            <li pn="section-4.1.8-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.1.8-2.5.1">「:」をoutputに追加します。</t>
            </li>
            <li pn="section-4.1.8-2.6" derivedCounter="6.">
              <t indent="0" pn="section-4.1.8-2.6.1">outputを返します。</t>
            </li>
          </ol>
          <t indent="0" pn="section-4.1.8-3">エンコードされたデータは、<xref section="3.2" sectionFormat="comma" target="RFC4648" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.2" derivedContent="RFC4648"/>にしたがって、「=」でパディングすることが要求されます。</t>
          <t indent="0" pn="section-4.1.8-4">同様に、エンコードされたデータは、実装上の制約から不可能な場合を除き、<xref section="3.5" sectionFormat="comma" target="RFC4648" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.5" derivedContent="RFC4648"/>にしたがってパッドビットをゼロに設定<bcp14>すべきです（SHOULD）</bcp14>。</t>
        </section>
        <section anchor="ser-boolean" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.9">
          <name slugifiedName="name-serializing-a-boolean">真偽値のシリアライズ</name>
          <t indent="0" pn="section-4.1.9-1">真偽値をinput_booleanとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.9-2"><li pn="section-4.1.9-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.9-2.1.1">input_booleanが真偽値でない場合、シリアライズに失敗します。</t>
            </li>
            <li pn="section-4.1.9-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.9-2.2.1">outputに空文字列を代入します。</t>
            </li>
            <li pn="section-4.1.9-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.9-2.3.1">「?」をoutputに追加します。</t>
            </li>
            <li pn="section-4.1.9-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.1.9-2.4.1">もしinput_booleanが真であれば、「1」をoutputに追加します。</t>
            </li>
            <li pn="section-4.1.9-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.1.9-2.5.1">もしinput_booleanが偽であれば、「0」をoutputに追加します。</t>
            </li>
            <li pn="section-4.1.9-2.6" derivedCounter="6.">
              <t indent="0" pn="section-4.1.9-2.6.1">outputを返します。</t>
            </li>
          </ol>
        </section>
        <section anchor="ser-date" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.10">
          <name slugifiedName="name-serializing-a-date">日付のシリアライズ</name>
          <t indent="0" pn="section-4.1.10-1">日付をinput_dateとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.10-2"><li pn="section-4.1.10-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.10-2.1.1">outputに「@」を代入します。</t>
            </li>
            <li pn="section-4.1.10-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.10-2.2.1">input_dateを使用して整数のシリアライズ (<xref target="ser-integer" format="default" sectionFormat="of" derivedContent="Section 4.1.4"/>)を実行した結果を出力に追加します。</t>
            </li>
            <li pn="section-4.1.10-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.10-2.3.1">outputを返します。</t>
            </li>
          </ol>
        </section>
        <section anchor="ser-display" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.11">
          <name slugifiedName="name-serializing-a-display-strin">表示文字列のシリアライズ</name>
          <t indent="0" pn="section-4.1.11-1">Unicodeコードポイント列をinput_sequenceとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.11-2"><li pn="section-4.1.11-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.1.11-2.1.1">input_sequenceがUnicodeコードポイント列でない場合、シリアライズに失敗します。</t>
            </li>
            <li pn="section-4.1.11-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.11-2.2.1">byte_arrayに、input_sequenceにUTF-8エンコーディング (<xref section="3" sectionFormat="of" target="RFC3629" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3629#section-3" derivedContent="UTF8"/>)を適用した結果を代入します。エンコーディングが失敗した場合、シリアル化は失敗します。</t>
            </li>
            <li pn="section-4.1.11-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.1.11-2.3.1">encoded_stringに、DQUOTEの前に「%」を含む文字列を代入します。</t>
            </li>
            <li pn="section-4.1.11-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.1.11-2.4.1">byte_arrayの各バイトbyteについて：
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.11-2.4.2"><li pn="section-4.1.11-2.4.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.1.11-2.4.2.1.1">byteが%x25（"%"）、%x22（DQUOTE）、または%x00-1fまたは%x7f-ffの範囲内の場合:</t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.1.11-2.4.2.1.2"><li pn="section-4.1.11-2.4.2.1.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.1.11-2.4.2.1.2.1.1">encoded_stringに「%」を追加します。</t>
                    </li>
                    <li pn="section-4.1.11-2.4.2.1.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.1.11-2.4.2.1.2.2.1">byteにbase16エンコーディング(<xref section="8" sectionFormat="of" target="RFC4648" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-8" derivedContent="RFC4648"/>)を適用し、アルファベット文字を小文字に変換した結果を、encoded_byteに代入します。</t>
                    </li>
                    <li pn="section-4.1.11-2.4.2.1.2.3" derivedCounter="3.">
                      <t indent="0" pn="section-4.1.11-2.4.2.1.2.3.1">encoded_byteをencoded_stringに追加します。</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.1.11-2.4.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.1.11-2.4.2.2.1">そうでない場合、byteをASCII文字としてデコードし、結果をencoded_stringに追加します。</t>
                </li>
              </ol>
            </li>
            <li pn="section-4.1.11-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.1.11-2.5.1">encoded_stringにDQUOTEを追加します。</t>
            </li>
            <li pn="section-4.1.11-2.6" derivedCounter="6.">
              <t indent="0" pn="section-4.1.11-2.6.1">encoded_stringを返します。</t>
            </li>
          </ol>
          <t indent="0" pn="section-4.1.11-3"> <xref target="RFC3629" format="default" sectionFormat="of" derivedContent="UTF8"/>はU+D800からU+DFFF（サロゲート）の間のコードポイントのエンコードを禁止していることに注意してください。これらがinput_sequenceに含まれている場合、シリアル化は失敗します。</t>
        </section>
      </section>
      <section anchor="text-parse" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-parsing-structured-fields">Structured Fieldsのパース</name>
        <t indent="0" pn="section-4.2-1">受け取り側の実装が、Structured Fieldsであることが分かっているHTTPフィールドを解析するとき、 相互運用性やセキュリティーの問題を引き起こす可能性のある多くのエッジケースがあるため、注意を払うことが重要です。 このセクションでは、そのためのアルゴリズムを規定します。</t>
        <t indent="0" pn="section-4.2-2">選択されたフィールドのフィールド値（そのフィールドが存在しない場合は空）と field_type（dictionary, list, item のいずれか）を表すバイト列を input_bytes として与え、 解析されたヘッダー値を返します。</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2-3"><li pn="section-4.2-3.1" derivedCounter="1.">
            <t indent="0" pn="section-4.2-3.1.1">input_bytesをASCII文字列input_stringに変換します。変換に失敗した場合、パースに失敗します。</t>
          </li>
          <li pn="section-4.2-3.2" derivedCounter="2.">
            <t indent="0" pn="section-4.2-3.2.1">input_stringの先頭のSPを無視します。.</t>
          </li>
          <li pn="section-4.2-3.3" derivedCounter="3.">
            <t indent="0" pn="section-4.2-3.3.1">もしfield_typeが「リスト」の場合、input_stringについて、 リストのパース（<xref target="parse-list" format="default" sectionFormat="of" derivedContent="Section 4.2.1"/>）を実行した結果を、outputに代入します。</t>
          </li>
          <li pn="section-4.2-3.4" derivedCounter="4.">
            <t indent="0" pn="section-4.2-3.4.1">もしfield_typeが「辞書」の場合、input_stringについて、 辞書のパース（<xref target="parse-dictionary" format="default" sectionFormat="of" derivedContent="Section 4.2.2"/>）を実行した結果を、outputに代入します。</t>
          </li>
          <li pn="section-4.2-3.5" derivedCounter="5.">
            <t indent="0" pn="section-4.2-3.5.1">もしfield_typeが「アイテム」の場合、input_stringについて、 アイテムのパース（<xref target="parse-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3"/>）を実行した結果を、outputに代入します。</t>
          </li>
          <li pn="section-4.2-3.6" derivedCounter="6.">
            <t indent="0" pn="section-4.2-3.6.1">input_stringの先頭のSPを無視します。.</t>
          </li>
          <li pn="section-4.2-3.7" derivedCounter="7.">
            <t indent="0" pn="section-4.2-3.7.1">もし、input_stringが空文字列でない場合は、パースに失敗します。</t>
          </li>
          <li pn="section-4.2-3.8" derivedCounter="8.">
            <t indent="0" pn="section-4.2-3.8.1">そうでなければ、outputを返します。</t>
          </li>
        </ol>
        <t indent="0" pn="section-4.2-4">input_bytesを生成するとき、パーサーは、<xref section="5.2" sectionFormat="of" target="RFC9110" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5.2" derivedContent="HTTP"/>にしたがって、 大文字小文字を区別せずにフィールド名と一致する同じセクション（ヘッダーまたはトレーラー）のすべてのフィールド行を1つのカンマ区切りフィールド値に結合<bcp14>しなければなりません（MUST）</bcp14>。 これは、フィールド値全体が正しく処理されることを確実にするものです。</t>
        <t indent="0" pn="section-4.2-5">リストと辞書の場合、トップレベルのデータ構造の個々のメンバーが複数のヘッダーインスタンスにまたがって分割されていない限り、 これはフィールドのすべての行を正しく連結する効果があります。 両タイプの解析アルゴリズムでは、タブ文字を許容しています。 これは、実装によってはフィールドの行を結合するためにタブ文字が使用される可能性があるためです。</t>
        <t indent="0" pn="section-4.2-6">複数のフィールド行にまたがる文字列は、予測できない結果をもたらします。 なぜなら、1つ以上のカンマ(オプションの空白文字)がパーサーによって出力される文字列の一部になってしまうからです。 連結は上流の仲介者によって行われる可能性があるため、シリアライザーとパーサーの両方が同じ制御下にある場合でも、その結果はシリアライザーの制御下にはありません。</t>
        <t indent="0" pn="section-4.2-7">トークン、整数、小数、バイト列は、挿入されたカンマによってパースに失敗するため、複数のフィールド行に分割することはできません。</t>
        <t indent="0" pn="section-4.2-8">パーサーは、複数のフィールド行にまたがるフィールド値を処理するときに、それらの行の1つがそのフィールドとしてパースされない場合、失敗<bcp14>してもよいです（MAY）</bcp14>。 たとえば、sf-stringとして定義されたExample-Stringフィールドを処理するパーサーは、このフィールドセクションを処理する際に失敗しても構いません。</t>
        <sourcecode type="http-message" markers="false" pn="section-4.2-9">
Example-String: "foo
Example-String: bar"
</sourcecode>
        <t indent="0" pn="section-4.2-10">解析に失敗した場合、フィールド値全体を無視（つまり、セクションにフィールドが存在しないかのように扱う）<bcp14>しなければなりません（MUST）</bcp14>。あるいは、完全なHTTPメッセージを不正な形式として扱う<bcp14>必要があります（MUST）</bcp14>。これは相互運用性と安全性を向上させるために意図的に厳格にしており、構造化フィールドを使用するフィールド仕様はこの要件を緩和することは許可されていません。</t>
        <t indent="0" pn="section-4.2-11">この要件は、フィールドを解析していない実装には適用されないことに注意してください。 たとえば、仲介者は転送する前に、メッセージから失敗したフィールドを取り除くことを要求されません。</t>
        <section anchor="parse-list" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.1">
          <name slugifiedName="name-parsing-a-list">リストのパース</name>
          <t indent="0" pn="section-4.2.1-1">ASCII文字列をinput_stringとして与え、(item_or_inner_list, parameters) タプルの配列を返します。 input_stringは解析済みの値を除去するために変更されます。</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.1-2"><li pn="section-4.2.1-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.1-2.1.1">membersに空の配列を代入します。</t>
            </li>
            <li pn="section-4.2.1-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.1-2.2.1">input_stringが空でない間:
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.1-2.2.2"><li pn="section-4.2.1-2.2.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.2.1-2.2.2.1.1">input_stringに対して、アイテムまたはインナーリストのパース（<xref target="parse-item-or-list" format="default" sectionFormat="of" derivedContent="Section 4.2.1.1"/>）を実行した結果を、 membersに追加します。</t>
                </li>
                <li pn="section-4.2.1-2.2.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.2.1-2.2.2.2.1">input_stringの先頭のOWSを無視します。</t>
                </li>
                <li pn="section-4.2.1-2.2.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.2.1-2.2.2.3.1">もしinput_stringが空なら、membersを返します。</t>
                </li>
                <li pn="section-4.2.1-2.2.2.4" derivedCounter="4.">
                  <t indent="0" pn="section-4.2.1-2.2.2.4.1">input_stringの最初の一文字を取り除きます。 取り除いた文字が「,」でない場合、パースに失敗します。</t>
                </li>
                <li pn="section-4.2.1-2.2.2.5" derivedCounter="5.">
                  <t indent="0" pn="section-4.2.1-2.2.2.5.1">input_stringの先頭のOWSを無視します。</t>
                </li>
                <li pn="section-4.2.1-2.2.2.6" derivedCounter="6.">
                  <t indent="0" pn="section-4.2.1-2.2.2.6.1">もしinput_stringが空なら、末尾にカンマがあります。その場合、パースに失敗します。</t>
                </li>
              </ol>
            </li>
            <li pn="section-4.2.1-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.1-2.3.1">構造化データが見つからない場合、（空の）membersを返します。</t>
            </li>
          </ol>
          <section anchor="parse-item-or-list" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.1.1">
            <name slugifiedName="name-parsing-an-item-or-inner-li">アイテムまたはインナーリストのパース</name>
            <t indent="0" pn="section-4.2.1.1-1">ASCII文字列をinput_stringとして与えると、タプル (item_or_inner_list, parameters) を返します。 ここで item_or_inner_list は単一の裸のアイテムか、 (bare_item, parameters) タプルの配列のいずれかです。</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.1.1-2"><li pn="section-4.2.1.1-2.1" derivedCounter="1.">
                <t indent="0" pn="section-4.2.1.1-2.1.1">もしinput_stringの先頭一文字が「(」の場合、 input_stringに対して、インナーリストのパース（<xref target="parse-innerlist" format="default" sectionFormat="of" derivedContent="Section 4.2.1.2"/>）を実行した結果を返します。</t>
              </li>
              <li pn="section-4.2.1.1-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.2.1.1-2.2.1">input_stringに対して、 アイテムのパース(<xref target="parse-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3"/>）を実行した結果を返します。</t>
              </li>
            </ol>
          </section>
          <section anchor="parse-innerlist" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.1.2">
            <name slugifiedName="name-parsing-an-inner-list">インナーリストのパース</name>
            <t indent="0" pn="section-4.2.1.2-1">ASCII文字列をinput_stringとして与え、inner_listを(bare_item, parameters)の配列としたタプルを返します。 input_stringは解析済みの値を除去するために変更されます。</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.1.2-2"><li pn="section-4.2.1.2-2.1" derivedCounter="1.">
                <t indent="0" pn="section-4.2.1.2-2.1.1">input_stringの最初の一文字を取り除きます。 取り除いた文字が「(」でない場合、パースに失敗します。</t>
              </li>
              <li pn="section-4.2.1.2-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.2.1.2-2.2.1">inner_listに空配列を代入します。</t>
              </li>
              <li pn="section-4.2.1.2-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.2.1.2-2.3.1">input_stringが空でない間:
                </t>
                <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.1.2-2.3.2"><li pn="section-4.2.1.2-2.3.2.1" derivedCounter="1.">
                    <t indent="0" pn="section-4.2.1.2-2.3.2.1.1">input_stringの先頭のSPを無視します。</t>
                  </li>
                  <li pn="section-4.2.1.2-2.3.2.2" derivedCounter="2.">
                    <t indent="0" pn="section-4.2.1.2-2.3.2.2.1">もしinput_stringの先頭一文字が「)」である場合:
                    </t>
                    <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.1.2-2.3.2.2.2"><li pn="section-4.2.1.2-2.3.2.2.2.1" derivedCounter="1.">
                        <t indent="0" pn="section-4.2.1.2-2.3.2.2.2.1.1">input_stringの最初の文字を取り除きます。</t>
                      </li>
                      <li pn="section-4.2.1.2-2.3.2.2.2.2" derivedCounter="2.">
                        <t indent="0" pn="section-4.2.1.2-2.3.2.2.2.2.1">input_stringに対して、 パラメーターのパース（<xref target="parse-param" format="default" sectionFormat="of" derivedContent="Section 4.2.3.2"/>）を実行した結果を、parametersに代入します。</t>
                      </li>
                      <li pn="section-4.2.1.2-2.3.2.2.2.3" derivedCounter="3.">
                        <t indent="0" pn="section-4.2.1.2-2.3.2.2.2.3.1">タプル(inner_list, parameters)を返します。</t>
                      </li>
                    </ol>
                  </li>
                  <li pn="section-4.2.1.2-2.3.2.3" derivedCounter="3.">
                    <t indent="0" pn="section-4.2.1.2-2.3.2.3.1">input_stringに対して、 アイテムのパース（<xref target="parse-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3"/>）を実行した結果を、 itemに代入します。</t>
                  </li>
                  <li pn="section-4.2.1.2-2.3.2.4" derivedCounter="4.">
                    <t indent="0" pn="section-4.2.1.2-2.3.2.4.1">itemをinner_listに追加します。</t>
                  </li>
                  <li pn="section-4.2.1.2-2.3.2.5" derivedCounter="5.">
                    <t indent="0" pn="section-4.2.1.2-2.3.2.5.1">もしinput_stringの先頭一文字がSPまたは「)」でない場合、パースに失敗します。</t>
                  </li>
                </ol>
              </li>
              <li pn="section-4.2.1.2-2.4" derivedCounter="4.">
                <t indent="0" pn="section-4.2.1.2-2.4.1">インナーリストの終わりを見つけられなかったため、パースに失敗します。</t>
              </li>
            </ol>
          </section>
        </section>
        <section anchor="parse-dictionary" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.2">
          <name slugifiedName="name-parsing-a-dictionary">Parsing a Dictionary</name>
          <t indent="0" pn="section-4.2.2-1">Given an ASCII string as input_string, return an ordered map whose values are (item_or_inner_list, parameters) tuples. input_string is modified to remove the parsed value.</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.2-2"><li pn="section-4.2.2-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.2-2.1.1">Let dictionary be an empty, ordered map.</t>
            </li>
            <li pn="section-4.2.2-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.2-2.2.1">While input_string is not empty:
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.2-2.2.2"><li pn="section-4.2.2-2.2.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.2.2-2.2.2.1.1">Let this_key be the result of running Parsing a Key (<xref target="parse-key" format="default" sectionFormat="of" derivedContent="Section 4.2.3.3"/>) with input_string.</t>
                </li>
                <li pn="section-4.2.2-2.2.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.2.2-2.2.2.2.1">If the first character of input_string is "=":
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.2-2.2.2.2.2"><li pn="section-4.2.2-2.2.2.2.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.2.2-2.2.2.2.2.1.1">Consume the first character of input_string.</t>
                    </li>
                    <li pn="section-4.2.2-2.2.2.2.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.2.2-2.2.2.2.2.2.1">Let member be the result of running Parsing an Item or Inner List (<xref target="parse-item-or-list" format="default" sectionFormat="of" derivedContent="Section 4.2.1.1"/>) with input_string.</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.2.2-2.2.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.2.2-2.2.2.3.1">Otherwise:
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.2-2.2.2.3.2"><li pn="section-4.2.2-2.2.2.3.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.2.2-2.2.2.3.2.1.1">Let value be Boolean true.</t>
                    </li>
                    <li pn="section-4.2.2-2.2.2.3.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.2.2-2.2.2.3.2.2.1">Let parameters be the result of running Parsing Parameters (<xref target="parse-param" format="default" sectionFormat="of" derivedContent="Section 4.2.3.2"/>) with input_string.</t>
                    </li>
                    <li pn="section-4.2.2-2.2.2.3.2.3" derivedCounter="3.">
                      <t indent="0" pn="section-4.2.2-2.2.2.3.2.3.1">Let member be the tuple (value, parameters).</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.2.2-2.2.2.4" derivedCounter="4.">
                  <t indent="0" pn="section-4.2.2-2.2.2.4.1">If dictionary already contains a key this_key (comparing character for character), overwrite its value with member.</t>
                </li>
                <li pn="section-4.2.2-2.2.2.5" derivedCounter="5.">
                  <t indent="0" pn="section-4.2.2-2.2.2.5.1">Otherwise, append key this_key with value member to dictionary.</t>
                </li>
                <li pn="section-4.2.2-2.2.2.6" derivedCounter="6.">
                  <t indent="0" pn="section-4.2.2-2.2.2.6.1">Discard any leading OWS characters from input_string.</t>
                </li>
                <li pn="section-4.2.2-2.2.2.7" derivedCounter="7.">
                  <t indent="0" pn="section-4.2.2-2.2.2.7.1">If input_string is empty, return dictionary.</t>
                </li>
                <li pn="section-4.2.2-2.2.2.8" derivedCounter="8.">
                  <t indent="0" pn="section-4.2.2-2.2.2.8.1">Consume the first character of input_string; if it is not ",", fail parsing.</t>
                </li>
                <li pn="section-4.2.2-2.2.2.9" derivedCounter="9.">
                  <t indent="0" pn="section-4.2.2-2.2.2.9.1">Discard any leading OWS characters from input_string.</t>
                </li>
                <li pn="section-4.2.2-2.2.2.10" derivedCounter="10.">
                  <t indent="0" pn="section-4.2.2-2.2.2.10.1">If input_string is empty, there is a trailing comma; fail parsing.</t>
                </li>
              </ol>
            </li>
            <li pn="section-4.2.2-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.2-2.3.1">No structured data has been found; return dictionary (which is empty).</t>
            </li>
          </ol>
          <t indent="0" pn="section-4.2.2-3">Note that when duplicate Dictionary keys are encountered, all but the last instance are ignored.</t>
        </section>
        <section anchor="parse-item" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.3">
          <name slugifiedName="name-parsing-an-item">Parsing an Item</name>
          <t indent="0" pn="section-4.2.3-1">Given an ASCII string as input_string, return a (bare_item, parameters) tuple. input_string is modified to remove the parsed value.</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.3-2"><li pn="section-4.2.3-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.3-2.1.1">Let bare_item be the result of running Parsing a Bare Item (<xref target="parse-bare-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3.1"/>) with input_string.</t>
            </li>
            <li pn="section-4.2.3-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.3-2.2.1">Let parameters be the result of running Parsing Parameters (<xref target="parse-param" format="default" sectionFormat="of" derivedContent="Section 4.2.3.2"/>) with input_string.</t>
            </li>
            <li pn="section-4.2.3-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.3-2.3.1">Return the tuple (bare_item, parameters).</t>
            </li>
          </ol>
          <section anchor="parse-bare-item" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.3.1">
            <name slugifiedName="name-parsing-a-bare-item">Parsing a Bare Item</name>
            <t indent="0" pn="section-4.2.3.1-1">Given an ASCII string as input_string, return a bare Item. input_string is modified to remove the parsed value.</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.3.1-2"><li pn="section-4.2.3.1-2.1" derivedCounter="1.">
                <t indent="0" pn="section-4.2.3.1-2.1.1">If the first character of input_string is a "-" or a DIGIT, return the result of running Parsing an Integer or Decimal (<xref target="parse-number" format="default" sectionFormat="of" derivedContent="Section 4.2.4"/>) with input_string.</t>
              </li>
              <li pn="section-4.2.3.1-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.2.3.1-2.2.1">If the first character of input_string is a DQUOTE, return the result of running Parsing a String (<xref target="parse-string" format="default" sectionFormat="of" derivedContent="Section 4.2.5"/>) with input_string.</t>
              </li>
              <li pn="section-4.2.3.1-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.2.3.1-2.3.1">If the first character of input_string is an ALPHA or "*", return the result of running Parsing a Token (<xref target="parse-token" format="default" sectionFormat="of" derivedContent="Section 4.2.6"/>) with input_string.</t>
              </li>
              <li pn="section-4.2.3.1-2.4" derivedCounter="4.">
                <t indent="0" pn="section-4.2.3.1-2.4.1">If the first character of input_string is ":", return the result of running Parsing a Byte Sequence (<xref target="parse-binary" format="default" sectionFormat="of" derivedContent="Section 4.2.7"/>) with input_string.</t>
              </li>
              <li pn="section-4.2.3.1-2.5" derivedCounter="5.">
                <t indent="0" pn="section-4.2.3.1-2.5.1">If the first character of input_string is "?", return the result of running Parsing a Boolean (<xref target="parse-boolean" format="default" sectionFormat="of" derivedContent="Section 4.2.8"/>) with input_string.</t>
              </li>
              <li pn="section-4.2.3.1-2.6" derivedCounter="6.">
                <t indent="0" pn="section-4.2.3.1-2.6.1">If the first character of input_string is "@", return the result of running Parsing a Date (<xref target="parse-date" format="default" sectionFormat="of" derivedContent="Section 4.2.9"/>) with input_string.</t>
              </li>
              <li pn="section-4.2.3.1-2.7" derivedCounter="7.">
                <t indent="0" pn="section-4.2.3.1-2.7.1">If the first character of input_string is "%", return the result of running Parsing a Display String (<xref target="parse-display" format="default" sectionFormat="of" derivedContent="Section 4.2.10"/>) with input_string.</t>
              </li>
              <li pn="section-4.2.3.1-2.8" derivedCounter="8.">
                <t indent="0" pn="section-4.2.3.1-2.8.1">Otherwise, the item type is unrecognized; fail parsing.</t>
              </li>
            </ol>
          </section>
          <section anchor="parse-param" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.3.2">
            <name slugifiedName="name-parsing-parameters">Parsing Parameters</name>
            <t indent="0" pn="section-4.2.3.2-1">Given an ASCII string as input_string, return an ordered map whose values are bare Items. input_string is modified to remove the parsed value.</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.3.2-2"><li pn="section-4.2.3.2-2.1" derivedCounter="1.">
                <t indent="0" pn="section-4.2.3.2-2.1.1">Let parameters be an empty, ordered map.</t>
              </li>
              <li pn="section-4.2.3.2-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.2.3.2-2.2.1">While input_string is not empty:
                </t>
                <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.3.2-2.2.2"><li pn="section-4.2.3.2-2.2.2.1" derivedCounter="1.">
                    <t indent="0" pn="section-4.2.3.2-2.2.2.1.1">If the first character of input_string is not ";", exit the loop.</t>
                  </li>
                  <li pn="section-4.2.3.2-2.2.2.2" derivedCounter="2.">
                    <t indent="0" pn="section-4.2.3.2-2.2.2.2.1">Consume the ";" character from the beginning of input_string.</t>
                  </li>
                  <li pn="section-4.2.3.2-2.2.2.3" derivedCounter="3.">
                    <t indent="0" pn="section-4.2.3.2-2.2.2.3.1">Discard any leading SP characters from input_string.</t>
                  </li>
                  <li pn="section-4.2.3.2-2.2.2.4" derivedCounter="4.">
                    <t indent="0" pn="section-4.2.3.2-2.2.2.4.1">Let param_key be the result of running Parsing a Key (<xref target="parse-key" format="default" sectionFormat="of" derivedContent="Section 4.2.3.3"/>) with input_string.</t>
                  </li>
                  <li pn="section-4.2.3.2-2.2.2.5" derivedCounter="5.">
                    <t indent="0" pn="section-4.2.3.2-2.2.2.5.1">Let param_value be Boolean true.</t>
                  </li>
                  <li pn="section-4.2.3.2-2.2.2.6" derivedCounter="6.">
                    <t indent="0" pn="section-4.2.3.2-2.2.2.6.1">If the first character of input_string is "=":
                    </t>
                    <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.3.2-2.2.2.6.2"><li pn="section-4.2.3.2-2.2.2.6.2.1" derivedCounter="1.">
                        <t indent="0" pn="section-4.2.3.2-2.2.2.6.2.1.1">Consume the "=" character at the beginning of input_string.</t>
                      </li>
                      <li pn="section-4.2.3.2-2.2.2.6.2.2" derivedCounter="2.">
                        <t indent="0" pn="section-4.2.3.2-2.2.2.6.2.2.1">Let param_value be the result of running Parsing a Bare Item (<xref target="parse-bare-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3.1"/>) with input_string.</t>
                      </li>
                    </ol>
                  </li>
                  <li pn="section-4.2.3.2-2.2.2.7" derivedCounter="7.">
                    <t indent="0" pn="section-4.2.3.2-2.2.2.7.1">If parameters already contains a key param_key (comparing character for character), overwrite its value with param_value.</t>
                  </li>
                  <li pn="section-4.2.3.2-2.2.2.8" derivedCounter="8.">
                    <t indent="0" pn="section-4.2.3.2-2.2.2.8.1">Otherwise, append key param_key with value param_value to parameters.</t>
                  </li>
                </ol>
              </li>
              <li pn="section-4.2.3.2-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.2.3.2-2.3.1">Return parameters.</t>
              </li>
            </ol>
            <t indent="0" pn="section-4.2.3.2-3">Note that when duplicate parameter keys are encountered, all but the last instance are ignored.</t>
          </section>
          <section anchor="parse-key" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.3.3">
            <name slugifiedName="name-parsing-a-key">Parsing a Key</name>
            <t indent="0" pn="section-4.2.3.3-1">Given an ASCII string as input_string, return a key. input_string is modified to remove the parsed value.</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.3.3-2"><li pn="section-4.2.3.3-2.1" derivedCounter="1.">
                <t indent="0" pn="section-4.2.3.3-2.1.1">If the first character of input_string is not lcalpha or "*", fail parsing.</t>
              </li>
              <li pn="section-4.2.3.3-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.2.3.3-2.2.1">Let output_string be an empty string.</t>
              </li>
              <li pn="section-4.2.3.3-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.2.3.3-2.3.1">While input_string is not empty:
                </t>
                <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.3.3-2.3.2"><li pn="section-4.2.3.3-2.3.2.1" derivedCounter="1.">
                    <t indent="0" pn="section-4.2.3.3-2.3.2.1.1">If the first character of input_string is not one of lcalpha, DIGIT, "_", "-", ".", or "*", return output_string.</t>
                  </li>
                  <li pn="section-4.2.3.3-2.3.2.2" derivedCounter="2.">
                    <t indent="0" pn="section-4.2.3.3-2.3.2.2.1">Let char be the result of consuming the first character of input_string.</t>
                  </li>
                  <li pn="section-4.2.3.3-2.3.2.3" derivedCounter="3.">
                    <t indent="0" pn="section-4.2.3.3-2.3.2.3.1">Append char to output_string.</t>
                  </li>
                </ol>
              </li>
              <li pn="section-4.2.3.3-2.4" derivedCounter="4.">
                <t indent="0" pn="section-4.2.3.3-2.4.1">Return output_string.</t>
              </li>
            </ol>
          </section>
        </section>
        <section anchor="parse-number" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.4">
          <name slugifiedName="name-parsing-an-integer-or-decim">Parsing an Integer or Decimal</name>
          <t indent="0" pn="section-4.2.4-1">Given an ASCII string as input_string, return an Integer or Decimal. input_string is modified to remove the parsed value.</t>
          <t indent="0" pn="section-4.2.4-2">NOTE: This algorithm parses both Integers (<xref target="integer" format="default" sectionFormat="of" derivedContent="Section 3.3.1"/>) and Decimals (<xref target="decimal" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>), and returns the corresponding structure.</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.4-3"><li pn="section-4.2.4-3.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.4-3.1.1">Let type be "integer".</t>
            </li>
            <li pn="section-4.2.4-3.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.4-3.2.1">Let sign be 1.</t>
            </li>
            <li pn="section-4.2.4-3.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.4-3.3.1">Let input_number be an empty string.</t>
            </li>
            <li pn="section-4.2.4-3.4" derivedCounter="4.">
              <t indent="0" pn="section-4.2.4-3.4.1">If the first character of input_string is "-", consume it and set sign to -1.</t>
            </li>
            <li pn="section-4.2.4-3.5" derivedCounter="5.">
              <t indent="0" pn="section-4.2.4-3.5.1">If input_string is empty, there is an empty integer; fail parsing.</t>
            </li>
            <li pn="section-4.2.4-3.6" derivedCounter="6.">
              <t indent="0" pn="section-4.2.4-3.6.1">If the first character of input_string is not a DIGIT, fail parsing.</t>
            </li>
            <li pn="section-4.2.4-3.7" derivedCounter="7.">
              <t indent="0" pn="section-4.2.4-3.7.1">While input_string is not empty:
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.4-3.7.2"><li pn="section-4.2.4-3.7.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.2.4-3.7.2.1.1">Let char be the result of consuming the first character of input_string.</t>
                </li>
                <li pn="section-4.2.4-3.7.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.2.4-3.7.2.2.1">If char is a DIGIT, append it to input_number.</t>
                </li>
                <li pn="section-4.2.4-3.7.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.2.4-3.7.2.3.1">Else, if type is "integer" and char is ".":
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.4-3.7.2.3.2"><li pn="section-4.2.4-3.7.2.3.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.2.4-3.7.2.3.2.1.1">If input_number contains more than 12 characters, fail parsing.</t>
                    </li>
                    <li pn="section-4.2.4-3.7.2.3.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.2.4-3.7.2.3.2.2.1">Otherwise, append char to input_number and set type to "decimal".</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.2.4-3.7.2.4" derivedCounter="4.">
                  <t indent="0" pn="section-4.2.4-3.7.2.4.1">Otherwise, prepend char to input_string, and exit the loop.</t>
                </li>
                <li pn="section-4.2.4-3.7.2.5" derivedCounter="5.">
                  <t indent="0" pn="section-4.2.4-3.7.2.5.1">If type is "integer" and input_number contains more than 15 characters, fail parsing.</t>
                </li>
                <li pn="section-4.2.4-3.7.2.6" derivedCounter="6.">
                  <t indent="0" pn="section-4.2.4-3.7.2.6.1">If type is "decimal" and input_number contains more than 16 characters, fail parsing.</t>
                </li>
              </ol>
            </li>
            <li pn="section-4.2.4-3.8" derivedCounter="8.">
              <t indent="0" pn="section-4.2.4-3.8.1">If type is "integer":
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.4-3.8.2"><li pn="section-4.2.4-3.8.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.2.4-3.8.2.1.1">Let output_number be an Integer that is the result of parsing input_number as an integer.</t>
                </li>
              </ol>
            </li>
            <li pn="section-4.2.4-3.9" derivedCounter="9.">
              <t indent="0" pn="section-4.2.4-3.9.1">Otherwise:
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.4-3.9.2"><li pn="section-4.2.4-3.9.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.2.4-3.9.2.1.1">If the final character of input_number is ".", fail parsing.</t>
                </li>
                <li pn="section-4.2.4-3.9.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.2.4-3.9.2.2.1">If the number of characters after "." in input_number is greater than three, fail parsing.</t>
                </li>
                <li pn="section-4.2.4-3.9.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.2.4-3.9.2.3.1">Let output_number be a Decimal that is the result of parsing input_number as a decimal number.</t>
                </li>
              </ol>
            </li>
            <li pn="section-4.2.4-3.10" derivedCounter="10.">
              <t indent="0" pn="section-4.2.4-3.10.1">Let output_number be the product of output_number and sign.</t>
            </li>
            <li pn="section-4.2.4-3.11" derivedCounter="11.">
              <t indent="0" pn="section-4.2.4-3.11.1">Return output_number.</t>
            </li>
          </ol>
        </section>
        <section anchor="parse-string" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.5">
          <name slugifiedName="name-parsing-a-string">Parsing a String</name>
          <t indent="0" pn="section-4.2.5-1">Given an ASCII string as input_string, return an unquoted String. input_string is modified to remove the parsed value.</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.5-2"><li pn="section-4.2.5-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.5-2.1.1">Let output_string be an empty string.</t>
            </li>
            <li pn="section-4.2.5-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.5-2.2.1">If the first character of input_string is not DQUOTE, fail parsing.</t>
            </li>
            <li pn="section-4.2.5-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.5-2.3.1">Discard the first character of input_string.</t>
            </li>
            <li pn="section-4.2.5-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.2.5-2.4.1">While input_string is not empty:
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.5-2.4.2"><li pn="section-4.2.5-2.4.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.2.5-2.4.2.1.1">Let char be the result of consuming the first character of input_string.</t>
                </li>
                <li pn="section-4.2.5-2.4.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.2.5-2.4.2.2.1">If char is a backslash ("\"):
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.5-2.4.2.2.2"><li pn="section-4.2.5-2.4.2.2.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.2.5-2.4.2.2.2.1.1">If input_string is now empty, fail parsing.</t>
                    </li>
                    <li pn="section-4.2.5-2.4.2.2.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.2.5-2.4.2.2.2.2.1">Let next_char be the result of consuming the first character of input_string.</t>
                    </li>
                    <li pn="section-4.2.5-2.4.2.2.2.3" derivedCounter="3.">
                      <t indent="0" pn="section-4.2.5-2.4.2.2.2.3.1">If next_char is not DQUOTE or "\", fail parsing.</t>
                    </li>
                    <li pn="section-4.2.5-2.4.2.2.2.4" derivedCounter="4.">
                      <t indent="0" pn="section-4.2.5-2.4.2.2.2.4.1">Append next_char to output_string.</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.2.5-2.4.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.2.5-2.4.2.3.1">Else, if char is DQUOTE, return output_string.</t>
                </li>
                <li pn="section-4.2.5-2.4.2.4" derivedCounter="4.">
                  <t indent="0" pn="section-4.2.5-2.4.2.4.1">Else, if char is in the range %x00-1f or %x7f-ff (i.e., it is not in VCHAR or SP), fail parsing.</t>
                </li>
                <li pn="section-4.2.5-2.4.2.5" derivedCounter="5.">
                  <t indent="0" pn="section-4.2.5-2.4.2.5.1">Else, append char to output_string.</t>
                </li>
              </ol>
            </li>
            <li pn="section-4.2.5-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.2.5-2.5.1">Reached the end of input_string without finding a closing DQUOTE; fail parsing.</t>
            </li>
          </ol>
        </section>
        <section anchor="parse-token" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.6">
          <name slugifiedName="name-parsing-a-token">Parsing a Token</name>
          <t indent="0" pn="section-4.2.6-1">Given an ASCII string as input_string, return a Token. input_string is modified to remove the parsed value.</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.6-2"><li pn="section-4.2.6-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.6-2.1.1">If the first character of input_string is not ALPHA or "*", fail parsing.</t>
            </li>
            <li pn="section-4.2.6-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.6-2.2.1">Let output_string be an empty string.</t>
            </li>
            <li pn="section-4.2.6-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.6-2.3.1">While input_string is not empty:
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.6-2.3.2"><li pn="section-4.2.6-2.3.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.2.6-2.3.2.1.1">If the first character of input_string is not in tchar, ":", or "/", return output_string.</t>
                </li>
                <li pn="section-4.2.6-2.3.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.2.6-2.3.2.2.1">Let char be the result of consuming the first character of input_string.</t>
                </li>
                <li pn="section-4.2.6-2.3.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.2.6-2.3.2.3.1">Append char to output_string.</t>
                </li>
              </ol>
            </li>
            <li pn="section-4.2.6-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.2.6-2.4.1">Return output_string.</t>
            </li>
          </ol>
        </section>
        <section anchor="parse-binary" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.7">
          <name slugifiedName="name-parsing-a-byte-sequence">Parsing a Byte Sequence</name>
          <t indent="0" pn="section-4.2.7-1">Given an ASCII string as input_string, return a Byte Sequence. input_string is modified to remove the parsed value.</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.7-2"><li pn="section-4.2.7-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.7-2.1.1">If the first character of input_string is not ":", fail parsing.</t>
            </li>
            <li pn="section-4.2.7-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.7-2.2.1">Discard the first character of input_string.</t>
            </li>
            <li pn="section-4.2.7-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.7-2.3.1">If there is not a ":" character before the end of input_string, fail parsing.</t>
            </li>
            <li pn="section-4.2.7-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.2.7-2.4.1">Let b64_content be the result of consuming content of input_string up to but not including the first instance of the character ":".</t>
            </li>
            <li pn="section-4.2.7-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.2.7-2.5.1">Consume the ":" character at the beginning of input_string.</t>
            </li>
            <li pn="section-4.2.7-2.6" derivedCounter="6.">
              <t indent="0" pn="section-4.2.7-2.6.1">If b64_content contains a character not included in ALPHA, DIGIT, "+", "/", and "=", fail parsing.</t>
            </li>
            <li pn="section-4.2.7-2.7" derivedCounter="7.">
              <t indent="0" pn="section-4.2.7-2.7.1">Let binary_content be the result of base64-decoding <xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/> b64_content, synthesizing padding if necessary (note the requirements about recipient behavior below). If base64 decoding fails, parsing fails.</t>
            </li>
            <li pn="section-4.2.7-2.8" derivedCounter="8.">
              <t indent="0" pn="section-4.2.7-2.8.1">Return binary_content.</t>
            </li>
          </ol>
          <t indent="0" pn="section-4.2.7-3">Because some implementations of base64 do not allow rejection of encoded data that is not properly "=" padded (see <xref section="3.2" sectionFormat="comma" target="RFC4648" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.2" derivedContent="RFC4648"/>), parsers <bcp14>SHOULD NOT</bcp14> fail when "=" padding is not present, unless they cannot be configured to do so.</t>
          <t indent="0" pn="section-4.2.7-4">Because some implementations of base64 do not allow rejection of encoded data that has non-zero pad bits (see <xref section="3.5" sectionFormat="comma" target="RFC4648" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.5" derivedContent="RFC4648"/>), parsers <bcp14>SHOULD NOT</bcp14> fail when non-zero pad bits are present, unless they cannot be configured to do so.</t>
          <t indent="0" pn="section-4.2.7-5">This specification does not relax the requirements in Sections <xref target="RFC4648" section="3.1" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.1" derivedContent="RFC4648"/> and <xref target="RFC4648" section="3.3" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.3" derivedContent="RFC4648"/> of <xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/>; therefore, parsers <bcp14>MUST</bcp14> fail on characters outside the base64 alphabet and on line feeds in encoded data.</t>
        </section>
        <section anchor="parse-boolean" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.8">
          <name slugifiedName="name-parsing-a-boolean">Parsing a Boolean</name>
          <t indent="0" pn="section-4.2.8-1">Given an ASCII string as input_string, return a Boolean. input_string is modified to remove the parsed value.</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.8-2"><li pn="section-4.2.8-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.8-2.1.1">If the first character of input_string is not "?", fail parsing.</t>
            </li>
            <li pn="section-4.2.8-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.8-2.2.1">Discard the first character of input_string.</t>
            </li>
            <li pn="section-4.2.8-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.8-2.3.1">If the first character of input_string matches "1", discard the first character, and return true.</t>
            </li>
            <li pn="section-4.2.8-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.2.8-2.4.1">If the first character of input_string matches "0", discard the first character, and return false.</t>
            </li>
            <li pn="section-4.2.8-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.2.8-2.5.1">No value has matched; fail parsing.</t>
            </li>
          </ol>
        </section>
        <section anchor="parse-date" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.9">
          <name slugifiedName="name-parsing-a-date">Parsing a Date</name>
          <t indent="0" pn="section-4.2.9-1">Given an ASCII string as input_string, return a Date. input_string is modified to remove the parsed value.</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.9-2"><li pn="section-4.2.9-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.9-2.1.1">If the first character of input_string is not "@", fail parsing.</t>
            </li>
            <li pn="section-4.2.9-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.9-2.2.1">Discard the first character of input_string.</t>
            </li>
            <li pn="section-4.2.9-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.9-2.3.1">Let output_date be the result of running Parsing an Integer or Decimal (<xref target="parse-number" format="default" sectionFormat="of" derivedContent="Section 4.2.4"/>) with input_string.</t>
            </li>
            <li pn="section-4.2.9-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.2.9-2.4.1">If output_date is a Decimal, fail parsing.</t>
            </li>
            <li pn="section-4.2.9-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.2.9-2.5.1">Return output_date.</t>
            </li>
          </ol>
        </section>
        <section anchor="parse-display" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.10">
          <name slugifiedName="name-parsing-a-display-string">Parsing a Display String</name>
          <t indent="0" pn="section-4.2.10-1">Given an ASCII string as input_string, return a sequence of Unicode code points. input_string is modified to remove the parsed value.</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.10-2"><li pn="section-4.2.10-2.1" derivedCounter="1.">
              <t indent="0" pn="section-4.2.10-2.1.1">If the first two characters of input_string are not "%" followed by DQUOTE, fail parsing.</t>
            </li>
            <li pn="section-4.2.10-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.10-2.2.1">Discard the first two characters of input_string.</t>
            </li>
            <li pn="section-4.2.10-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.10-2.3.1">Let byte_array be an empty byte array.</t>
            </li>
            <li pn="section-4.2.10-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.2.10-2.4.1">While input_string is not empty:
              </t>
              <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.10-2.4.2"><li pn="section-4.2.10-2.4.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.2.10-2.4.2.1.1">Let char be the result of consuming the first character of input_string.</t>
                </li>
                <li pn="section-4.2.10-2.4.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.2.10-2.4.2.2.1">If char is in the range %x00-1f or %x7f-ff (i.e., it is not in VCHAR or SP), fail parsing.</t>
                </li>
                <li pn="section-4.2.10-2.4.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.2.10-2.4.2.3.1">If char is "%":
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.10-2.4.2.3.2"><li pn="section-4.2.10-2.4.2.3.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.2.10-2.4.2.3.2.1.1">Let octet_hex be the result of consuming two characters from input_string. If there are not two characters, fail parsing.</t>
                    </li>
                    <li pn="section-4.2.10-2.4.2.3.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.2.10-2.4.2.3.2.2.1">If octet_hex contains characters outside the range %x30-39 or %x61-66 (i.e., it is not in 0-9 or lowercase a-f), fail parsing.</t>
                    </li>
                    <li pn="section-4.2.10-2.4.2.3.2.3" derivedCounter="3.">
                      <t indent="0" pn="section-4.2.10-2.4.2.3.2.3.1">Let octet be the result of hex decoding octet_hex (<xref section="8" sectionFormat="of" target="RFC4648" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-8" derivedContent="RFC4648"/>).</t>
                    </li>
                    <li pn="section-4.2.10-2.4.2.3.2.4" derivedCounter="4.">
                      <t indent="0" pn="section-4.2.10-2.4.2.3.2.4.1">Append octet to byte_array.</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.2.10-2.4.2.4" derivedCounter="4.">
                  <t indent="0" pn="section-4.2.10-2.4.2.4.1">If char is DQUOTE:
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.10-2.4.2.4.2"><li pn="section-4.2.10-2.4.2.4.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.2.10-2.4.2.4.2.1.1">Let unicode_sequence be the result of decoding byte_array as a UTF-8 string (<xref section="3" sectionFormat="of" target="RFC3629" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3629#section-3" derivedContent="UTF8"/>). Fail parsing if decoding fails.</t>
                    </li>
                    <li pn="section-4.2.10-2.4.2.4.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.2.10-2.4.2.4.2.2.1">Return unicode_sequence.</t>
                    </li>
                  </ol>
                </li>
                <li pn="section-4.2.10-2.4.2.5" derivedCounter="5.">
                  <t indent="0" pn="section-4.2.10-2.4.2.5.1">Otherwise, if char is not "%" or DQUOTE:
                  </t>
                  <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2.10-2.4.2.5.2"><li pn="section-4.2.10-2.4.2.5.2.1" derivedCounter="1.">
                      <t indent="0" pn="section-4.2.10-2.4.2.5.2.1.1">Let byte be the result of applying ASCII encoding to char.</t>
                    </li>
                    <li pn="section-4.2.10-2.4.2.5.2.2" derivedCounter="2.">
                      <t indent="0" pn="section-4.2.10-2.4.2.5.2.2.1">Append byte to byte_array.</t>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li pn="section-4.2.10-2.5" derivedCounter="5.">
              <t indent="0" pn="section-4.2.10-2.5.1">Reached the end of input_string without finding a closing DQUOTE; fail parsing.</t>
            </li>
          </ol>
        </section>
      </section>
    </section>
    <section anchor="iana" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-5-1">IANA has added the following note to the "Hypertext Transfer Protocol (HTTP) Field Name Registry":</t>
      <blockquote pn="section-5-2">
        <t indent="0" pn="section-5-2.1">The "Structured Type" column indicates the type of the field (per RFC 9651), if any, and may be
"Dictionary", "List", or "Item".</t>
        <t indent="0" pn="section-5-2.2">Note that field names beginning with characters other than ALPHA or "*" will not be able to be
represented as a Structured Fields Token and therefore may be incompatible with being mapped into
field values that refer to it.</t>
      </blockquote>
      <t indent="0" pn="section-5-3">A new column, "Structured Type", has been added to the registry.</t>
      <t indent="0" pn="section-5-4">The indicated Structured Type for each existing registry entry listed in <xref target="existing-fields" format="default" sectionFormat="of" derivedContent="Table 1"/> has also been added.</t>
      <table anchor="existing-fields" align="center" pn="table-1">
        <name slugifiedName="name-existing-fields">Existing Fields</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Field Name</th>
            <th align="left" colspan="1" rowspan="1">Structured Type</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">Accept-CH</td>
            <td align="left" colspan="1" rowspan="1">List</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Cache-Status</td>
            <td align="left" colspan="1" rowspan="1">List</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">CDN-Cache-Control</td>
            <td align="left" colspan="1" rowspan="1">Dictionary</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Cross-Origin-Embedder-Policy</td>
            <td align="left" colspan="1" rowspan="1">Item</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Cross-Origin-Embedder-Policy-Report-Only</td>
            <td align="left" colspan="1" rowspan="1">Item</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Cross-Origin-Opener-Policy</td>
            <td align="left" colspan="1" rowspan="1">Item</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Cross-Origin-Opener-Policy-Report-Only</td>
            <td align="left" colspan="1" rowspan="1">Item</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Origin-Agent-Cluster</td>
            <td align="left" colspan="1" rowspan="1">Item</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Priority</td>
            <td align="left" colspan="1" rowspan="1">Dictionary</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Proxy-Status</td>
            <td align="left" colspan="1" rowspan="1">List</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="security" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-6-1">The size of most types defined by Structured Fields is not limited; as a result, extremely large fields could be an attack vector (e.g., for resource consumption). Most HTTP implementations limit the sizes of individual fields as well as the overall header or trailer section size to mitigate such attacks.</t>
      <t indent="0" pn="section-6-2">It is possible for parties with the ability to inject new HTTP fields to change the meaning
of a Structured Field. In some circumstances, this will cause parsing to fail, but it is not possible to reliably fail in all such circumstances.</t>
      <t indent="0" pn="section-6-3">The Display String type can convey any possible Unicode code point without sanitization; for example, they might contain unassigned code points, control points (including NUL), or noncharacters. Therefore, applications consuming Display Strings need to consider strategies such as filtering or escaping untrusted content before displaying it. See <xref target="RFC8264" format="default" sectionFormat="of" derivedContent="PRECIS"/> and <xref target="UNICODE-SECURITY" format="default" sectionFormat="of" derivedContent="UNICODE-SECURITY"/>.</t>
    </section>
  </middle>
  <back>
    <displayreference target="RFC9113" to="HTTP/2"/>
    <displayreference target="RFC9110" to="HTTP"/>
    <displayreference target="RFC7541" to="HPACK"/>
    <displayreference target="RFC8264" to="PRECIS"/>
    <displayreference target="RFC3629" to="UTF8"/>
    <references pn="section-7">
      <name slugifiedName="name-references">References</name>
      <references anchor="sec-normative-references" pn="section-7.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC9110" target="https://www.rfc-editor.org/info/rfc9110" quoteTitle="true" derivedAnchor="HTTP">
          <front>
            <title>HTTP Semantics</title>
            <author fullname="R. Fielding" initials="R." role="editor" surname="Fielding"/>
            <author fullname="M. Nottingham" initials="M." role="editor" surname="Nottingham"/>
            <author fullname="J. Reschke" initials="J." role="editor" surname="Reschke"/>
            <date month="June" year="2022"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document describes the overall architecture of HTTP, establishes common terminology, and defines aspects of the protocol that are shared by all versions. In this definition are core protocol elements, extensibility mechanisms, and the "http" and "https" Uniform Resource Identifier (URI) schemes.</t>
              <t indent="0">This document updates RFC 3864 and obsoletes RFCs 2818, 7231, 7232, 7233, 7235, 7538, 7615, 7694, and portions of 7230.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="97"/>
          <seriesInfo name="RFC" value="9110"/>
          <seriesInfo name="DOI" value="10.17487/RFC9110"/>
        </reference>
        <reference anchor="RFC0020" target="https://www.rfc-editor.org/info/rfc20" quoteTitle="true" derivedAnchor="RFC0020">
          <front>
            <title>ASCII format for network interchange</title>
            <author fullname="V.G. Cerf" initials="V.G." surname="Cerf"/>
            <date month="October" year="1969"/>
          </front>
          <seriesInfo name="STD" value="80"/>
          <seriesInfo name="RFC" value="20"/>
          <seriesInfo name="DOI" value="10.17487/RFC0020"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC4648" target="https://www.rfc-editor.org/info/rfc4648" quoteTitle="true" derivedAnchor="RFC4648">
          <front>
            <title>The Base16, Base32, and Base64 Data Encodings</title>
            <author fullname="S. Josefsson" initials="S." surname="Josefsson"/>
            <date month="October" year="2006"/>
            <abstract>
              <t indent="0">This document describes the commonly used base 64, base 32, and base 16 encoding schemes. It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4648"/>
          <seriesInfo name="DOI" value="10.17487/RFC4648"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC3629" target="https://www.rfc-editor.org/info/rfc3629" quoteTitle="true" derivedAnchor="UTF8">
          <front>
            <title>UTF-8, a transformation format of ISO 10646</title>
            <author fullname="F. Yergeau" initials="F." surname="Yergeau"/>
            <date month="November" year="2003"/>
            <abstract>
              <t indent="0">ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems. The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo. UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values. This memo obsoletes and replaces RFC 2279.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="63"/>
          <seriesInfo name="RFC" value="3629"/>
          <seriesInfo name="DOI" value="10.17487/RFC3629"/>
        </reference>
      </references>
      <references anchor="sec-informative-references" pn="section-7.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541" quoteTitle="true" derivedAnchor="HPACK">
          <front>
            <title>HPACK: Header Compression for HTTP/2</title>
            <author fullname="R. Peon" initials="R." surname="Peon"/>
            <author fullname="H. Ruellan" initials="H." surname="Ruellan"/>
            <date month="May" year="2015"/>
            <abstract>
              <t indent="0">This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7541"/>
          <seriesInfo name="DOI" value="10.17487/RFC7541"/>
        </reference>
        <reference anchor="RFC9113" target="https://www.rfc-editor.org/info/rfc9113" quoteTitle="true" derivedAnchor="HTTP/2">
          <front>
            <title>HTTP/2</title>
            <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson"/>
            <author fullname="C. Benfield" initials="C." role="editor" surname="Benfield"/>
            <date month="June" year="2022"/>
            <abstract>
              <t indent="0">This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.</t>
              <t indent="0">This document obsoletes RFCs 7540 and 8740.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9113"/>
          <seriesInfo name="DOI" value="10.17487/RFC9113"/>
        </reference>
        <reference anchor="IEEE754" target="https://ieeexplore.ieee.org/document/8766229" quoteTitle="true" derivedAnchor="IEEE754">
          <front>
            <title>IEEE Standard for Floating-Point Arithmetic</title>
            <author>
              <organization showOnFrontPage="true">IEEE</organization>
            </author>
            <date year="2019" month="July"/>
          </front>
          <seriesInfo name="IEEE Std" value="754-2019"/>
          <seriesInfo name="DOI" value="10.1109/IEEESTD.2019.8766229"/>
          <seriesInfo name="ISBN" value="978-1-5044-5924-2"/>
        </reference>
        <reference anchor="RFC8264" target="https://www.rfc-editor.org/info/rfc8264" quoteTitle="true" derivedAnchor="PRECIS">
          <front>
            <title>PRECIS Framework: Preparation, Enforcement, and Comparison of Internationalized Strings in Application Protocols</title>
            <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"/>
            <author fullname="M. Blanchet" initials="M." surname="Blanchet"/>
            <date month="October" year="2017"/>
            <abstract>
              <t indent="0">Application protocols using Unicode code points in protocol strings need to properly handle such strings in order to enforce internationalization rules for strings placed in various protocol slots (such as addresses and identifiers) and to perform valid comparison operations (e.g., for purposes of authentication or authorization). This document defines a framework enabling application protocols to perform the preparation, enforcement, and comparison of internationalized strings ("PRECIS") in a way that depends on the properties of Unicode code points and thus is more agile with respect to versions of Unicode. As a result, this framework provides a more sustainable approach to the handling of internationalized strings than the previous framework, known as Stringprep (RFC 3454). This document obsoletes RFC 7564.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8264"/>
          <seriesInfo name="DOI" value="10.17487/RFC8264"/>
        </reference>
        <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234" quoteTitle="true" derivedAnchor="RFC5234">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <author fullname="D. Crocker" initials="D." role="editor" surname="Crocker"/>
            <author fullname="P. Overell" initials="P." surname="Overell"/>
            <date month="January" year="2008"/>
            <abstract>
              <t indent="0">Internet technical specifications often need to define a formal syntax. Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications. The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power. The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges. This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="68"/>
          <seriesInfo name="RFC" value="5234"/>
          <seriesInfo name="DOI" value="10.17487/RFC5234"/>
        </reference>
        <reference anchor="RFC7493" target="https://www.rfc-editor.org/info/rfc7493" quoteTitle="true" derivedAnchor="RFC7493">
          <front>
            <title>The I-JSON Message Format</title>
            <author fullname="T. Bray" initials="T." role="editor" surname="Bray"/>
            <date month="March" year="2015"/>
            <abstract>
              <t indent="0">I-JSON (short for "Internet JSON") is a restricted profile of JSON designed to maximize interoperability and increase confidence that software can process it successfully with predictable results.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7493"/>
          <seriesInfo name="DOI" value="10.17487/RFC7493"/>
        </reference>
        <reference anchor="RFC8259" target="https://www.rfc-editor.org/info/rfc8259" quoteTitle="true" derivedAnchor="RFC8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author fullname="T. Bray" initials="T." role="editor" surname="Bray"/>
            <date month="December" year="2017"/>
            <abstract>
              <t indent="0">JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data.</t>
              <t indent="0">This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
          <seriesInfo name="DOI" value="10.17487/RFC8259"/>
        </reference>
        <reference anchor="UNICODE-SECURITY" target="https://www.unicode.org/reports/tr36/tr36-15.html" quoteTitle="true" derivedAnchor="UNICODE-SECURITY">
          <front>
            <title>Unicode Security Considerations</title>
            <author initials="M." surname="Davis" fullname="Mark Davis">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Suignard" fullname="Michel Suignard">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="September" day="19"/>
          </front>
          <seriesInfo name="Unicode Technical Report" value="#36"/>
          <annotation>Latest version available at <eref target="https://www.unicode.org/reports/tr36/" brackets="angle"/>.</annotation>
        </reference>
      </references>
    </references>
    <section anchor="faq" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-frequently-asked-questions">Frequently Asked Questions</name>
      <section anchor="why-not-json" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a.1">
        <name slugifiedName="name-why-not-json">Why Not JSON?</name>
        <t indent="0" pn="section-appendix.a.1-1">Earlier proposals for Structured Fields were based upon JSON <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/>. However, constraining its use to make it suitable for HTTP fields required senders and recipients to implement specific additional handling.</t>
        <t indent="0" pn="section-appendix.a.1-2">For example, JSON has specification issues around large numbers and objects with duplicate members. Although advice for avoiding these issues is available (e.g., <xref target="RFC7493" format="default" sectionFormat="of" derivedContent="RFC7493"/>), it cannot be relied upon.</t>
        <t indent="0" pn="section-appendix.a.1-3">Likewise, JSON strings are by default Unicode strings, which have a number of potential interoperability issues (e.g., in comparison). Although implementers can be advised to avoid non-ASCII content where unnecessary, this is difficult to enforce.</t>
        <t indent="0" pn="section-appendix.a.1-4">Another example is JSON's ability to nest content to arbitrary depths. Since the resulting memory commitment might be unsuitable (e.g., in embedded and other limited server deployments), it's necessary to limit it in some fashion; however, existing JSON implementations have no such limits, and even if a limit is specified, it's likely that some field definition will find a need to violate it.</t>
        <t indent="0" pn="section-appendix.a.1-5">Because of JSON's broad adoption and implementation, it is difficult to impose such additional constraints across all implementations; some deployments would fail to enforce them, thereby harming interoperability. In short, if it looks like JSON, people will be tempted to use a JSON parser/serializer on field values.</t>
        <t indent="0" pn="section-appendix.a.1-6">Since a major goal for Structured Fields is to improve interoperability and simplify implementation, these concerns led to a format that requires a dedicated parser and serializer.</t>
        <t indent="0" pn="section-appendix.a.1-7">Additionally, there were widely shared feelings that JSON doesn't "look right" in HTTP fields.</t>
      </section>
    </section>
    <section anchor="implementation-notes" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-implementation-notes">Implementation Notes</name>
      <t indent="0" pn="section-appendix.b-1">A generic implementation of this specification should expose the top-level serialize (<xref target="text-serialize" format="default" sectionFormat="of" derivedContent="Section 4.1"/>) and parse (<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/>) functions. They need not be functions; for example, it could be implemented as an object, with methods for each of the different top-level types.</t>
      <t indent="0" pn="section-appendix.b-2">For interoperability, it's important that generic implementations be complete and follow the algorithms closely; see <xref target="strict" format="default" sectionFormat="of" derivedContent="Section 1.1"/>. To aid this, a common test suite is being maintained by the community at &lt;https://github.com/httpwg/structured-field-tests&gt;.</t>
      <t indent="0" pn="section-appendix.b-3">Implementers should note that Dictionaries and Parameters are order-preserving maps. Some fields may not convey meaning in the ordering of these data types, but it should still be exposed so that it will be available to applications that need to use it.</t>
      <t indent="0" pn="section-appendix.b-4">Likewise, implementations should note that it's important to preserve the distinction between Tokens and Strings. While most programming languages have built-in types that map to the other types well, it may be necessary to create a wrapper "token" object or use a parameter on functions to assure that these types remain separate.</t>
      <t indent="0" pn="section-appendix.b-5">The serialization algorithm is defined in a way that it is not strictly limited to the data types defined in <xref target="types" format="default" sectionFormat="of" derivedContent="Section 3"/> in every case. For example, Decimals are designed to take broader input and round to allowed values.</t>
      <t indent="0" pn="section-appendix.b-6">Implementations are allowed to limit the size of different structures, subject to the minimums defined for each type. When a structure exceeds an implementation limit, that structure fails parsing or serialization.</t>
    </section>
    <section anchor="abnf" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-abnf">ABNF</name>
      <t indent="0" pn="section-appendix.c-1">This section uses the Augmented Backus-Naur Form (ABNF) notation <xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/> to illustrate the expected syntax of Structured Fields. However, it cannot be used to validate their syntax because it does not capture all requirements.</t>
      <t indent="0" pn="section-appendix.c-2">This section is non-normative. If there is disagreement between the parsing algorithms and ABNF, the specified algorithms take precedence.</t>
      <sourcecode type="abnf" markers="false" pn="section-appendix.c-3">
sf-list       = list-member *( OWS "," OWS list-member )
list-member   = sf-item / inner-list

inner-list    = "(" *SP [ sf-item *( 1*SP sf-item ) *SP ] ")"
                parameters

parameters    = *( ";" *SP parameter )
parameter     = param-key [ "=" param-value ]
param-key     = key
key           = ( lcalpha / "*" )
                *( lcalpha / DIGIT / "_" / "-" / "." / "*" )
lcalpha       = %x61-7A ; a-z
param-value   = bare-item

sf-dictionary = dict-member *( OWS "," OWS dict-member )
dict-member   = member-key ( parameters / ( "=" member-value ))
member-key    = key
member-value  = sf-item / inner-list

sf-item   = bare-item parameters
bare-item = sf-integer / sf-decimal / sf-string / sf-token
            / sf-binary / sf-boolean / sf-date / sf-displaystring

sf-integer       = ["-"] 1*15DIGIT
sf-decimal       = ["-"] 1*12DIGIT "." 1*3DIGIT
sf-string        = DQUOTE *( unescaped / "%" / bs-escaped ) DQUOTE
sf-token         = ( ALPHA / "*" ) *( tchar / ":" / "/" )
sf-binary        = ":" base64 ":"
sf-boolean       = "?" ( "0" / "1" )
sf-date          = "@" sf-integer
sf-displaystring = "%" DQUOTE *( unescaped / "\" / pct-encoded )
                   DQUOTE

base64       = *( ALPHA / DIGIT / "+" / "/" ) *"="

unescaped    = %x20-21 / %x23-24 / %x26-5B / %x5D-7E
bs-escaped   = "\" ( DQUOTE / "\" )

pct-encoded  = "%" lc-hexdig lc-hexdig
lc-hexdig = DIGIT / %x61-66 ; 0-9, a-f
</sourcecode>
    </section>
    <section anchor="changes" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.d">
      <name slugifiedName="name-changes-from-rfc-8941">Changes from RFC 8941</name>
      <t indent="0" pn="section-appendix.d-1">This revision of the "Structured Field Values for HTTP" specification has made the following changes:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.d-2">
        <li pn="section-appendix.d-2.1">
          <t indent="0" pn="section-appendix.d-2.1.1">Added the Date Structured Type. (<xref target="date" format="default" sectionFormat="of" derivedContent="Section 3.3.7"/>)</t>
        </li>
        <li pn="section-appendix.d-2.2">
          <t indent="0" pn="section-appendix.d-2.2.1">Stopped encouraging use of ABNF in definitions of new Structured Fields. (<xref target="specify" format="default" sectionFormat="of" derivedContent="Section 2"/>)</t>
        </li>
        <li pn="section-appendix.d-2.3">
          <t indent="0" pn="section-appendix.d-2.3.1">Moved ABNF to an informative appendix. (<xref target="abnf" format="default" sectionFormat="of" derivedContent="Appendix C"/>)</t>
        </li>
        <li pn="section-appendix.d-2.4">
          <t indent="0" pn="section-appendix.d-2.4.1">Added a "Structured Type" column to the "Hypertext Transfer Protocol (HTTP) Field Name Registry". (<xref target="iana" format="default" sectionFormat="of" derivedContent="Section 5"/>)</t>
        </li>
        <li pn="section-appendix.d-2.5">
          <t indent="0" pn="section-appendix.d-2.5.1">Refined parse failure handling. (<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/>)</t>
        </li>
        <li pn="section-appendix.d-2.6">
          <t indent="0" pn="section-appendix.d-2.6.1">Added the Display String Structured Type. (<xref target="displaystring" format="default" sectionFormat="of" derivedContent="Section 3.3.8"/>)</t>
        </li>
      </ul>
    </section>
    <section numbered="false" anchor="acknowledgements" removeInRFC="false" toc="include" pn="section-appendix.e">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t indent="0" pn="section-appendix.e-1">Many thanks to <contact fullname="Matthew Kerwin"/> for his detailed feedback and careful consideration during the development of this specification.</t>
      <t indent="0" pn="section-appendix.e-2">Thanks also to <contact fullname="Ian Clelland"/>, <contact fullname="Roy Fielding"/>, <contact fullname="Anne van Kesteren"/>, <contact fullname="Kazuho Oku"/>, <contact fullname="Evert Pot"/>, <contact fullname="Julian Reschke"/>, <contact fullname="Martin Thomson"/>, <contact fullname="Mike West"/>, and <contact fullname="Jeffrey Yasskin"/> for their contributions.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.f">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
        <organization showOnFrontPage="true">Cloudflare</organization>
        <address>
          <postal>
            <city>Prahran</city>
            <region>VIC</region>
            <country>Australia</country>
          </postal>
          <email>mnot@mnot.net</email>
          <uri>https://www.mnot.net/</uri>
        </address>
      </author>
      <author initials="P-H." surname="Kamp" fullname="Poul-Henning Kamp">
        <organization showOnFrontPage="true">The Varnish Cache Project</organization>
        <address>
          <email>phk@varnish-cache.org</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
