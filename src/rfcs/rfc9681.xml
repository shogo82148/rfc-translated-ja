<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="exp" docName="draft-ietf-lsr-isis-fast-flooding-11" number="9681" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="2" consensus="true" symRefs="true" sortRefs="true" prepTime="2024-11-25T14:23:33" indexInclude="true" scripts="Common,Latin">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-lsr-isis-fast-flooding-11" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9681" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="IS-IS Fast Flooding">IS-IS Fast Flooding</title>
    <seriesInfo name="RFC" value="9681" stream="IETF"/>
    <author fullname="Bruno Decraene" initials="B." surname="Decraene">
      <organization showOnFrontPage="true">Orange</organization>
      <address>
        <email>bruno.decraene@orange.com</email>
      </address>
    </author>
    <author fullname="Les Ginsberg" initials="L" surname="Ginsberg">
      <organization showOnFrontPage="true">Cisco Systems</organization>
      <address>
        <postal>
          <street>821 Alder Drive</street>
          <city>Milpitas</city>
          <code>95035</code>
          <region>CA</region>
          <country>United States of America</country>
        </postal>
        <email>ginsberg@cisco.com</email>
      </address>
    </author>
    <author fullname="Tony Li" initials="T." surname="Li">
      <organization showOnFrontPage="true">Juniper Networks, Inc.</organization>
      <address>
        <email>tony.li@tony.li</email>
      </address>
    </author>
    <author fullname="Guillaume Solignac" initials="G." surname="Solignac">
      <address>
        <email>gsoligna@protonmail.com</email>
      </address>
    </author>
    <author fullname="Marek Karasek" initials="M" surname="Karasek">
      <organization showOnFrontPage="true">Cisco Systems</organization>
      <address>
        <postal>
          <street>Pujmanove 1753/10a, Prague 4 - Nusle</street>
          <city>Prague</city>
          <code>10 14000</code>
          <country>Czech Republic</country>
        </postal>
        <email>mkarasek@cisco.com</email>
      </address>
    </author>
    <author initials="G." surname="Van de Velde" fullname="Gunter Van de Velde">
      <organization showOnFrontPage="true">Nokia</organization>
      <address>
        <postal>
          <street>Copernicuslaan 50</street>
          <city>Antwerp</city>
          <code>2018</code>
          <country>Belgium</country>
        </postal>
        <email>gunter.van_de_velde@nokia.com</email>
      </address>
    </author>
    <author fullname="Tony Przygienda" initials="T" surname="Przygienda">
      <organization showOnFrontPage="true">Juniper</organization>
      <address>
        <postal>
          <street>1133 Innovation Way</street>
          <city>Sunnyvale</city>
          <region>CA</region>
          <code>94089</code>
          <country>United States of America</country>
        </postal>
        <email>prz@juniper.net</email>
      </address>
    </author>
    <date month="11" year="2024"/>
    <area>RTG</area>
    <workgroup>lsr</workgroup>
    <keyword>LSP</keyword>
    <keyword>congestion</keyword>
    <keyword>flow control</keyword>
    <keyword>scale</keyword>
    <keyword>performance</keyword>
    <keyword>IS-IS</keyword>
    <keyword>flooding</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">Current Link State PDU flooding rates are much
      slower than what modern networks can support.  The use of IS-IS at 
      larger scale requires faster flooding rates to achieve desired
      convergence goals.  This document discusses the need for faster
      flooding, the issues around faster flooding, and some example approaches
      to achieve faster flooding. It also defines protocol extensions relevant
      to faster flooding.
      </t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for examination, experimental implementation, and
            evaluation.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document defines an Experimental Protocol for the Internet
            community.  This document is a product of the Internet Engineering
            Task Force (IETF).  It represents the consensus of the IETF community.
            It has received public review and has been approved for publication
            by the Internet Engineering Steering Group (IESG).  Not all documents
            approved by the IESG are candidates for any level of Internet
            Standard; see Section 2 of RFC 7841. 
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9681" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-language">Requirements Language</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-historical-behavior">Historical Behavior</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-flooding-parameters-tlv">Flooding Parameters TLV</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-lsp-burst-size-sub-tlv">LSP Burst Size Sub-TLV</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-lsp-transmission-interval-s">LSP Transmission Interval Sub-TLV</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-lsps-per-psnp-sub-tlv">LSPs per PSNP Sub-TLV</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.4">
                <t indent="0" pn="section-toc.1-1.4.2.4.1"><xref derivedContent="4.4" format="counter" sectionFormat="of" target="section-4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-flags-sub-tlv">Flags Sub-TLV</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.5">
                <t indent="0" pn="section-toc.1-1.4.2.5.1"><xref derivedContent="4.5" format="counter" sectionFormat="of" target="section-4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-psnp-interval-sub-tlv">PSNP Interval Sub-TLV</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.6">
                <t indent="0" pn="section-toc.1-1.4.2.6.1"><xref derivedContent="4.6" format="counter" sectionFormat="of" target="section-4.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-receive-window-sub-tlv">Receive Window Sub-TLV</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.7">
                <t indent="0" pn="section-toc.1-1.4.2.7.1"><xref derivedContent="4.7" format="counter" sectionFormat="of" target="section-4.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-operation-on-a-lan-interfac">Operation on a LAN Interface</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-performance-improvement-on-">Performance Improvement on the Receiver</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rate-of-lsp-acknowledgments">Rate of LSP Acknowledgments</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-packet-prioritization-on-re">Packet Prioritization on Receive</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-congestion-and-flow-control">Congestion and Flow Control</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-overview">Overview</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-congestion-and-flow-control-">Congestion and Flow Control Algorithm</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t indent="0" pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-transmitter-based-congestio">Transmitter-Based Congestion Control Approach</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-flooding-parameters-tlv-2">Flooding Parameters TLV</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-registry-is-is-sub-tlv-for-">Registry: IS-IS Sub-TLV for Flooding Parameters TLV</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.3">
                <t indent="0" pn="section-toc.1-1.7.2.3.1"><xref derivedContent="7.3" format="counter" sectionFormat="of" target="section-7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-registry-is-is-bit-values-f">Registry: IS-IS Bit Values for Flooding Parameters Flags Sub-TLV</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-contributors">Contributors</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">Link state IGPs such as Intermediate System to Intermediate System
      (IS-IS) depend upon having consistent Link State Databases (LSDBs) on all
      Intermediate Systems (ISs) in the network in order to provide correct
      forwarding of data packets. When topology changes occur, new/updated
      Link State PDUs (LSPs) are propagated network-wide. The speed of
      propagation is a key contributor to convergence time.</t>
      <t indent="0" pn="section-1-2">IS-IS base specification <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/>
      does not use flow or congestion control but static flooding rates.
      Historically, flooding rates have been conservative -- on the order of
      tens of LSPs per second. This is the result of guidance in the base
      specification and early deployments when the CPU and interface speeds
      were much slower and the area scale was much smaller than they are
      today.</t>
      <t indent="0" pn="section-1-3">As IS-IS is deployed in greater scale both in the number of nodes in
      an area and in the number of neighbors per node, the impact of the
      historic flooding rates becomes more significant. Consider the bring-up
      or failure of a node with 1000 neighbors. This will result in a minimum
      of 1000 LSP updates. At typical LSP flooding rates used today (33
      LSPs per second), it would take more than 30 seconds simply to send the
      updated LSPs to a given neighbor. Depending on the diameter of the
      network, achieving a consistent LSDB on all nodes in the network could
      easily take a minute or more.</t>
      <t indent="0" pn="section-1-4">Therefore, increasing the LSP flooding rate becomes an essential
      element of supporting greater network scale.</t>
      <t indent="0" pn="section-1-5"> Improving the LSP flooding rate is complementary to protocol
      extensions that reduce LSP flooding traffic by reducing the flooding
      topology such as Mesh Groups <xref target="RFC2973" format="default" sectionFormat="of" derivedContent="RFC2973"/>
      or Dynamic Flooding <xref target="RFC9667" format="default" sectionFormat="of" derivedContent="RFC9667"/>. Reduction of the flooding topology does not alter
      the number of LSPs required to be exchanged between two nodes, so
      increasing the overall flooding speed is still beneficial when such
      extensions are in use. It is also possible that the flooding topology
      can be reduced in ways that prefer the use of neighbors that support
      improved flooding performance.</t>
      <t indent="0" pn="section-1-6">With the goal of supporting faster flooding, this document introduces the signaling
	of additional flooding related parameters (<xref target="FloodingTLV" format="default" sectionFormat="of" derivedContent="Section 4"/>), specifies some
	performance improvements on the receiver (<xref target="Receiver" format="default" sectionFormat="of" derivedContent="Section 5"/>)
	and introduces the use of flow and/or congestion control (<xref target="Control" format="default" sectionFormat="of" derivedContent="Section 6"/>).</t>
    </section>
    <section anchor="Language" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-requirements-language">Requirements Language</name>
      <t indent="0" pn="section-2-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>
    <section anchor="HISTORY" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-historical-behavior">Historical Behavior</name>
      <t indent="0" pn="section-3-1">The base specification for IS-IS <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/> was first published in 1992 and updated in 2002. The
      update made no changes in regards to suggested timer values. Convergence
      targets at the time were on the order of seconds, and the specified timer
      values reflect that.  Here are some examples:</t>
      <blockquote pn="section-3-2">
        <dl spacing="normal" newline="false" indent="3" pn="section-3-2.1">
          <dt pn="section-3-2.1.1">minimumLSPGenerationInterval</dt>
          <dd pn="section-3-2.1.2">
            <t indent="0" pn="section-3-2.1.2.1">- This is the minimum time
	interval between generation of Link State PDUs. A source Intermediate
	system shall wait at least this long before regenerating one of its
	own Link State PDUs. [...]</t>
            <t indent="0" pn="section-3-2.1.2.2">A reasonable value is 30 s.</t>
          </dd>
          <dt pn="section-3-2.1.3">minimumLSPTransmissionInterval</dt>
          <dd pn="section-3-2.1.4">
            <t indent="0" pn="section-3-2.1.4.1">- This is the amount of
	time an Intermediate system shall wait before further propagating
	another Link State PDU from the same source system. [...]</t>
            <t indent="0" pn="section-3-2.1.4.2">A reasonable value is 5 s.</t>
          </dd>
          <dt pn="section-3-2.1.5">partialSNPInterval</dt>
          <dd pn="section-3-2.1.6">
            <t indent="0" pn="section-3-2.1.6.1">- This is the amount of time between periodic action for
	transmission of Partial Sequence Number PDUs.  It shall be less than
	minimumLSPTransmissionInterval. [...]</t>
            <t indent="0" pn="section-3-2.1.6.2">A reasonable value is 2 s.</t>
          </dd>
        </dl>
      </blockquote>
      <t indent="0" pn="section-3-3">Most relevant to a discussion of the LSP flooding rate is the
	recommended interval between the transmission of two different LSPs on
	a given interface.</t>
      <t indent="0" pn="section-3-4">For broadcast interfaces, <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/> states:</t>
      <blockquote pn="section-3-5">
        <t indent="0" pn="section-3-5.1">
	    minimumBroadcastLSPTransmissionInterval indicates the minimum
	    interval between PDU arrivals which can be processed by the slowest
	    Intermediate System on the LAN.
        </t>
      </blockquote>
      <t indent="0" pn="section-3-6">
	  The default value was defined as 33 milliseconds.
	  It is permitted to send multiple LSPs back to back
	  as a burst, but this was limited to 10 LSPs in a one-second
	  period.
      </t>
      <t indent="0" pn="section-3-7">
	  Although this value was specific to LAN interfaces, this has
	  commonly been applied by implementations to all interfaces though
	  that was not the original intent of the base specification. In
	  fact, Section 12.1.2.4.3 of <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/> states:</t>
      <blockquote pn="section-3-8">
        <t indent="0" pn="section-3-8.1">On point-to-point links the peak rate of arrival is
      limited only by the speed of the data link and the other traffic flowing
      on that link.</t>
      </blockquote>
      <t indent="0" pn="section-3-9">Although modern implementations have not strictly adhered to the
      33-millisecond interval, it is commonplace for implementations to limit
      the flooding rate to the same order of magnitude: tens of milliseconds,
      and not the single digits or fractions of milliseconds that are needed
      today.</t>
      <t indent="0" pn="section-3-10">In the past 20 years, significant work on achieving faster
      convergence, more specifically sub-second convergence, has resulted in
      implementations modifying a number of the above timers in order to
      support faster signaling of topology changes. For example,
      minimumLSPGenerationInterval has been modified to support millisecond
      intervals, often with a backoff algorithm applied to prevent LSP
      generation storms in the event of rapid successive oscillations.</t>
      <t indent="0" pn="section-3-11">However, the flooding rate has not been fundamentally altered.</t>
    </section>
    <section anchor="FloodingTLV" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-flooding-parameters-tlv">Flooding Parameters TLV</name>
      <t indent="0" pn="section-4-1">This document defines a new Type-Length-Value (TLV) tuple called the
      "Flooding Parameters TLV" that may be included in IS-IS Hellos (IIHs)
      or Partial Sequence Number PDUs (PSNPs). It allows IS-IS implementations
      to advertise flooding-related parameters and capabilities that may be
      used by the peer to support faster flooding.</t>
      <dl newline="false" spacing="compact" indent="9" pn="section-4-2">
        <dt pn="section-4-2.1">Type:</dt>
        <dd pn="section-4-2.2">21</dd>
        <dt pn="section-4-2.3">Length:</dt>
        <dd pn="section-4-2.4">variable; the size in octets of the Value field</dd>
        <dt pn="section-4-2.5">Value:</dt>
        <dd pn="section-4-2.6">one or more sub-TLVs</dd>
      </dl>
      <t indent="0" pn="section-4-3">Several sub-TLVs are defined in this document. The support of any sub-TLV is <bcp14>OPTIONAL</bcp14>.</t>
      <t indent="0" pn="section-4-4"> For a given IS-IS adjacency, the Flooding Parameters TLV does not
      need to be advertised in each IIH or PSNP.  An IS uses the latest
      received value for each parameter until a new value is advertised by the
      peer.  However, as IIHs and PSNPs are not reliably exchanged and may
      never be received, parameters <bcp14>SHOULD</bcp14> be sent even if
      there is no change in value since the last transmission.  For a
      parameter that has never been advertised, an IS uses its local default
      value. That value <bcp14>SHOULD</bcp14> be configurable on a per-node
      basis and <bcp14>MAY</bcp14> be configurable on a per-interface basis.
      </t>
      <section anchor="LSPBurstSize" numbered="true" toc="include" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-lsp-burst-size-sub-tlv">LSP Burst Size Sub-TLV</name>
        <t indent="0" pn="section-4.1-1">The LSP Burst Size sub-TLV advertises the maximum number of LSPs that the node can receive without an intervening delay between LSP transmissions.</t>
        <dl newline="false" spacing="compact" indent="9" pn="section-4.1-2">
          <dt pn="section-4.1-2.1">Type:</dt>
          <dd pn="section-4.1-2.2">1</dd>
          <dt pn="section-4.1-2.3">Length:</dt>
          <dd pn="section-4.1-2.4">4 octets</dd>
          <dt pn="section-4.1-2.5">Value:</dt>
          <dd pn="section-4.1-2.6">number of LSPs that can be received back to back</dd>
        </dl>
      </section>
      <section anchor="InterfaceLSPTransmissionInterval" numbered="true" toc="include" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-lsp-transmission-interval-s">LSP Transmission Interval Sub-TLV</name>
        <t indent="0" pn="section-4.2-1">The LSP Transmission Interval sub-TLV advertises the minimum interval, in microseconds, between LSPs arrivals that can be sustained on this receiving interface.</t>
        <dl newline="false" spacing="compact" indent="9" pn="section-4.2-2">
          <dt pn="section-4.2-2.1">Type:</dt>
          <dd pn="section-4.2-2.2">2</dd>
          <dt pn="section-4.2-2.3">Length:</dt>
          <dd pn="section-4.2-2.4">4 octets</dd>
          <dt pn="section-4.2-2.5">Value:</dt>
          <dd pn="section-4.2-2.6">minimum interval, in microseconds, between two
          consecutive LSPs received after LSP Burst Size LSPs have been
          received</dd>
        </dl>
        <t indent="0" pn="section-4.2-3">The LSP Transmission Interval is an advertisement of the receiver's sustainable LSP reception rate. This rate may be safely used by a sender that does not support the flow control or congestion algorithm. It may also be used as the minimal safe rate by flow control or congestion algorithms in unexpected cases, e.g., when the receiver is not acknowledging LSPs anymore. </t>
      </section>
      <section anchor="LPP" numbered="true" toc="include" removeInRFC="false" pn="section-4.3">
        <name slugifiedName="name-lsps-per-psnp-sub-tlv">LSPs per PSNP Sub-TLV</name>
        <t indent="0" pn="section-4.3-1">The LSP per PSNP (LPP) sub-TLV advertises the number of received LSPs that triggers the immediate sending of a PSNP to acknowledge them.</t>
        <dl newline="false" spacing="compact" indent="9" pn="section-4.3-2">
          <dt pn="section-4.3-2.1">Type:</dt>
          <dd pn="section-4.3-2.2">3</dd>
          <dt pn="section-4.3-2.3">Length:</dt>
          <dd pn="section-4.3-2.4">2 octets</dd>
          <dt pn="section-4.3-2.5">Value:</dt>
          <dd pn="section-4.3-2.6">number of LSPs acknowledged per PSNP</dd>
        </dl>
        <t indent="0" pn="section-4.3-3">A node advertising this sub-TLV with a value for LPP <bcp14>MUST</bcp14> send a PSNP once LPP LSPs have been received and need to be acknowledged.</t>
      </section>
      <section anchor="Flags" numbered="true" toc="include" removeInRFC="false" pn="section-4.4">
        <name slugifiedName="name-flags-sub-tlv">Flags Sub-TLV</name>
        <t indent="0" pn="section-4.4-1">The sub-TLV Flags advertises a set of flags.</t>
        <dl newline="false" spacing="compact" indent="9" pn="section-4.4-2">
          <dt pn="section-4.4-2.1">Type:</dt>
          <dd pn="section-4.4-2.2">4</dd>
          <dt pn="section-4.4-2.3">Length:</dt>
          <dd pn="section-4.4-2.4">Indicates the length in octets (1-8) of the Value field. The length <bcp14>SHOULD</bcp14> be the minimum required to send all bits that are set.</dd>
          <dt pn="section-4.4-2.5">Value:</dt>
          <dd pn="section-4.4-2.6">
            <t indent="0" pn="section-4.4-2.6.1">list of flags</t>
            <artwork align="left" name="" type="" alt="" pn="section-4.4-2.6.2">
 0 1 2 3 4 5 6 7 ...
+-+-+-+-+-+-+-+-+...
|O|              ...
+-+-+-+-+-+-+-+-+...</artwork>
          </dd>
        </dl>
        <t indent="0" pn="section-4.4-3">An LSP receiver sets the O-flag (Ordered        
              acknowledgment) to indicate to the LSP sender that
        it will acknowledge the LSPs in the order as received. A PSNP
        acknowledging N LSPs is acknowledging the N oldest LSPs received. The
        order inside the PSNP is meaningless. If the sender keeps track of the
        order of LSPs sent, this indication allows for fast detection of the
        loss of an LSP. This <bcp14>MUST NOT</bcp14> be used to alter the
        retransmission timer for any LSP. This <bcp14>MAY</bcp14> be used to
        trigger a congestion signal.</t>
      </section>
      <section anchor="partialSNPI" numbered="true" toc="include" removeInRFC="false" pn="section-4.5">
        <name slugifiedName="name-psnp-interval-sub-tlv">PSNP Interval Sub-TLV</name>
        <t indent="0" pn="section-4.5-1">The PSNP Interval sub-TLV advertises the amount of
	time in milliseconds between periodic action for transmission of PSNPs. This time will trigger the sending of a PSNP
        even if the number of unacknowledged LSPs received on a given
        interface does not exceed LPP (<xref target="LPP" format="default" sectionFormat="of" derivedContent="Section 4.3"/>). The time is
	measured from the reception of the first unacknowledged LSP.</t>
        <dl newline="false" spacing="compact" indent="9" pn="section-4.5-2">
          <dt pn="section-4.5-2.1">Type:</dt>
          <dd pn="section-4.5-2.2">5</dd>
          <dt pn="section-4.5-2.3">Length:</dt>
          <dd pn="section-4.5-2.4">2 octets</dd>
          <dt pn="section-4.5-2.5">Value:</dt>
          <dd pn="section-4.5-2.6">partialSNPInterval in milliseconds</dd>
        </dl>
        <t indent="0" pn="section-4.5-3">A node advertising this sub-TLV <bcp14>SHOULD</bcp14> send a PSNP at least once
        per PSNP Interval if one or more unacknowledged LSPs have been
        received on a given interface.</t>
      </section>
      <section anchor="RWIN" numbered="true" toc="include" removeInRFC="false" pn="section-4.6">
        <name slugifiedName="name-receive-window-sub-tlv">Receive Window Sub-TLV</name>
        <t indent="0" pn="section-4.6-1">The Receive Window (RWIN) sub-TLV advertises the maximum number of unacknowledged LSPs that the node can receive for a given adjacency.</t>
        <dl newline="false" spacing="compact" indent="9" pn="section-4.6-2">
          <dt pn="section-4.6-2.1">Type:</dt>
          <dd pn="section-4.6-2.2">6</dd>
          <dt pn="section-4.6-2.3">Length:</dt>
          <dd pn="section-4.6-2.4">2 octets</dd>
          <dt pn="section-4.6-2.5">Value:</dt>
          <dd pn="section-4.6-2.6">maximum number of unacknowledged LSPs</dd>
        </dl>
      </section>
      <section anchor="TLVoperationLAN" numbered="true" toc="include" removeInRFC="false" pn="section-4.7">
        <name slugifiedName="name-operation-on-a-lan-interfac">Operation on a LAN Interface</name>
        <t indent="0" pn="section-4.7-1">On a LAN interface, all LSPs are link-level multicasts. Each LSP sent will be received by all ISs on the LAN, and each IS will receive LSPs from all transmitters. In this section, we clarify how the flooding parameters should be interpreted in the context of a LAN.</t>
        <t indent="0" pn="section-4.7-2">An LSP receiver on a LAN will communicate its desired flooding parameters using a single Flooding Parameters TLV, which will be received by all LSP transmitters. The flooding parameters sent by the LSP receiver <bcp14>MUST</bcp14> be understood as instructions from the LSP receiver to each LSP transmitter about the desired maximum transmit characteristics of each transmitter. The receiver is aware that there are multiple transmitters that can send LSPs to the receiver LAN interface. The receiver might want to take that into account by advertising more conservative values, e.g., a higher LSP Transmission Interval. When the transmitters receive the LSP Transmission Interval value advertised by an LSP receiver, the transmitters should rate-limit LSPs according to the advertised flooding parameters. They should not apply any further interpretation to the flooding parameters advertised by the receiver.</t>
        <t indent="0" pn="section-4.7-3">A given LSP transmitter will receive multiple flooding parameter advertisements from different receivers that may include different flooding parameter values. A given transmitter <bcp14>SHOULD</bcp14> use the most conservative value on a per-parameter basis. For example, if the transmitter receives multiple LSP Burst Size values, it should use the smallest value.</t>
        <t indent="0" pn="section-4.7-4">The Designated Intermediate System (DIS) plays a special role in the operation of flooding on the LAN as it is responsible for responding to PSNPs sent on the LAN circuit that are used to request LSPs that the sender of the PSNP does not have. If the DIS does not support faster flooding, this will impact the maximum flooding speed that could occur on a LAN. Use of LAN priority to prefer a node that supports faster flooding in the DIS election may be useful.</t>
        <t indent="0" pn="section-4.7-5">Note: The focus of work used to develop the example algorithms discussed later in this document focused on operation over point-to-point interfaces. A full discussion of how best to do faster flooding on a LAN interface is therefore out of scope for this document.</t>
      </section>
    </section>
    <section anchor="Receiver" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-performance-improvement-on-">Performance Improvement on the Receiver</name>
      <t indent="0" pn="section-5-1">This section defines two behaviors that <bcp14>SHOULD</bcp14> be implemented on the receiver.</t>
      <section anchor="LSPACKRate" numbered="true" toc="include" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-rate-of-lsp-acknowledgments">Rate of LSP Acknowledgments</name>
        <t indent="0" pn="section-5.1-1">On point-to-point networks, PSNPs provide acknowledgments for
        received LSPs. <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/> suggests
        using some delay when sending PSNPs. This provides some optimization
        as multiple LSPs can be acknowledged by a single PSNP.</t>
        <t indent="0" pn="section-5.1-2">Faster LSP flooding benefits from a faster feedback loop. This
        requires a reduction in the delay in sending PSNPs.
        </t>
        <t indent="0" pn="section-5.1-3">For the generation of PSNPs, the receiver <bcp14>SHOULD</bcp14> use
        a partialSNPInterval smaller than the one defined in <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/>. The choice of this lower value
        is a local choice. It may depend on the available processing power of
        the node, the number of adjacencies, and the requirement to
        synchronize the LSDB more quickly. 200 ms seems to be a reasonable
        value.</t>
        <t indent="0" pn="section-5.1-4">In addition to the timer-based partialSNPInterval, the receiver
        <bcp14>SHOULD</bcp14> keep track of the number of unacknowledged LSPs
        per circuit and level. When this number exceeds a preset threshold of
        LSPs per PSNP (LPP), the receiver <bcp14>SHOULD</bcp14> immediately
        send a PSNP without waiting for the PSNP timer to expire. In the case
        of a burst of LSPs, this allows more frequent PSNPs, giving faster
        feedback to the sender. Outside of the burst case, the usual
        timer-based PSNP approach comes into effect.</t>
        <t indent="0" pn="section-5.1-5">The smaller the LPP is, the faster the feedback to the sender and
        possibly the higher the rate if the rate is limited by the end-to-end
        RTT (link RTT + time to acknowledge). This may result in an increase
        in the number of PSNPs sent, which may increase CPU and IO load on both
        the sender and receiver.  The LPP should be less than or equal to 90
        as this is the maximum number of LSPs that can be acknowledged in a
        PSNP at common MTU sizes; hence, waiting longer would not reduce the
        number of PSNPs sent but would delay the acknowledgments. LPP should
        not be chosen too high as the congestion control starts with a
        congestion window of LPP + 1.  Based on experimental evidence, 15
        unacknowledged LSPs is a good value, assuming that the Receive Window
        is at least 30. More frequent PSNPs give the transmitter more
        feedback on receiver progress, allowing the transmitter to continue
        transmitting while not burdening the receiver with undue overhead.
        </t>
        <t indent="0" pn="section-5.1-6">By deploying both the timer-based and the threshold-based PSNP approaches, the receiver can be adaptive to both LSP bursts and infrequent LSP updates.  </t>
        <t indent="0" pn="section-5.1-7">As PSNPs also consume link bandwidth, packet-queue space, and
        protocol-processing time on receipt, the increased sending of PSNPs
        should be taken into account when considering the rate at which LSPs
        can be sent on an interface.</t>
      </section>
      <section anchor="PKTPRI" numbered="true" toc="include" removeInRFC="false" pn="section-5.2">
        <name slugifiedName="name-packet-prioritization-on-re">Packet Prioritization on Receive</name>
        <t indent="0" pn="section-5.2-1">There are three classes of PDUs sent by IS-IS:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.2-2">
          <li pn="section-5.2-2.1">
            <t indent="0" pn="section-5.2-2.1.1">Hellos</t>
          </li>
          <li pn="section-5.2-2.2">
            <t indent="0" pn="section-5.2-2.2.1">LSPs</t>
          </li>
          <li pn="section-5.2-2.3">
            <t indent="0" pn="section-5.2-2.3.1">SNPs (Complete Sequence Number PDUs (CSNPs) and PSNPs)</t>
          </li>
        </ul>
        <t indent="0" pn="section-5.2-3">Implementations today may prioritize the reception of Hellos
        over LSPs and Sequence Number PDUs (SNPs) in order to prevent a burst of LSP updates from
        triggering an adjacency timeout, which in turn would require additional
        LSPs to be updated.</t>
        <t indent="0" pn="section-5.2-4">CSNPs and PSNPs serve to trigger or acknowledge the transmission of specified
        LSPs. On a point-to-point link, PSNPs acknowledge the receipt of one
        or more LSPs. 
        For this reason, <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/>
 specifies a delay
        (partialSNPInterval) before sending a PSNP so that the number of PSNPs
        required to be sent is reduced. On receipt of a PSNP, the set of LSPs
        acknowledged by that PSNP can be marked so that they do not need to be
        retransmitted.</t>
        <t indent="0" pn="section-5.2-5">If a PSNP is dropped on reception, the set of LSPs advertised in
        the PSNP cannot be marked as acknowledged, and this results in
        needless retransmissions that further delay transmission of
        other LSPs that are yet to be transmitted. It may also make it more
        likely that a receiver becomes overwhelmed by LSP transmissions.</t>
        <t indent="0" pn="section-5.2-6">Therefore, implementations <bcp14>SHOULD</bcp14> prioritize IS-IS
        PDUs on the way from the incoming interface to the IS-IS process. The
        relative priority of packets in decreasing order <bcp14>SHOULD</bcp14>
        be: Hellos, SNPs, and LSPs. Implementations <bcp14>MAY</bcp14> also
        prioritize IS-IS packets over other protocols, which are less critical
        for the router or network, less sensitive to delay, or more bursty
        (e.g., BGP).</t>
      </section>
    </section>
    <section anchor="Control" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-congestion-and-flow-control">Congestion and Flow Control</name>
      <section anchor="Overview" numbered="true" toc="include" removeInRFC="false" pn="section-6.1">
        <name slugifiedName="name-overview">Overview</name>
        <t indent="0" pn="section-6.1-1">Ensuring the goodput between two entities is a Layer 4
        responsibility as per the OSI model. A typical example is the TCP
        protocol defined in <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="RFC9293"/> that
        provides flow control, congestion control, and reliability.
        </t>
        <t indent="0" pn="section-6.1-2">Flow control creates a control loop between a transmitter and a receiver so that the transmitter does not overwhelm the receiver. TCP provides a means for the receiver to govern the amount of data sent by the sender through the use of a sliding window.</t>
        <t indent="0" pn="section-6.1-3"> Congestion control prevents the set of transmitters from overwhelming the path of the packets between two IS-IS implementations. This path typically includes a point-to-point link between two IS-IS neighbors, which is usually oversized compared to the capability of the IS-IS speakers, but potentially also includes some internal elements inside each neighbor such as switching fabric, line card CPU, and forwarding plane buffers that may experience congestion. These resources may be shared across multiple IS-IS adjacencies for the system, and it is the responsibility of congestion control to ensure that these are shared reasonably.</t>
        <t indent="0" pn="section-6.1-4">Reliability provides loss detection and recovery. IS-IS already has mechanisms to ensure the reliable transmission of LSPs. This is not changed by this document.</t>
        <t indent="0" pn="section-6.1-5">Sections <xref target="RWIN-Algo" format="counter" sectionFormat="of" derivedContent="6.2"/> and <xref target="TxSide" format="counter" sectionFormat="of" derivedContent="6.3"/> provide two flow and/or congestion control algorithms that may be implemented by taking advantage of the extensions defined in this document. The signal that these IS-IS extensions (defined in Sections <xref target="FloodingTLV" format="counter" sectionFormat="of" derivedContent="4"/> and  <xref target="Receiver" format="counter" sectionFormat="of" derivedContent="5"/>) provide is generic and is designed to support different sender-side algorithms. A sender can unilaterally choose a different algorithm to use.</t>
      </section>
      <section anchor="RWIN-Algo" numbered="true" toc="include" removeInRFC="false" pn="section-6.2">
        <name slugifiedName="name-congestion-and-flow-control-">Congestion and Flow Control Algorithm</name>
        <section anchor="FlowControl" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.1">
          <name slugifiedName="name-flow-control">Flow Control</name>
          <t indent="0" pn="section-6.2.1-1"> A flow control mechanism creates a control loop between a single
          transmitter and a single receiver. This section uses a
          mechanism similar to the TCP receive window to allow the receiver to
          govern the amount of data sent by the sender. This receive window
          (RWIN) indicates an allowed number of LSPs that the sender may
          transmit before waiting for an acknowledgment. The size of the
          receive window, in units of LSPs, is initialized with the value
          advertised by the receiver in the Receive Window sub-TLV. 

If no
          value is advertised, the transmitter should initialize RWIN with its
          locally configured value for this receiver.
          </t>
          <t indent="0" pn="section-6.2.1-2">
		    When the transmitter sends a set of LSPs to the
		    receiver, it subtracts the number of LSPs sent
		    from RWIN. If the transmitter receives a PSNP,
		    then RWIN is incremented for each acknowledged
		    LSP. The transmitter must ensure that the value of
		    RWIN never goes negative.
          </t>
          <t indent="0" pn="section-6.2.1-3">The RWIN value is of importance when the RTT is the limiting factor for the throughput. In this case, the optimal size is the desired LSP rate multiplied by the RTT. The RTT is the addition of the link RTT plus the time taken by the receiver to acknowledge the first received LSP in its PSNP. The values 50 or 100 may be reasonable default numbers for RWIN.
As an example, an RWIN of 100 requires a control plane input buffer of 150 kbytes per neighbor (assuming an IS-IS MTU of 1500 octets) and limits the throughput to 10000 LSPs per second and per neighbor for a link RTT of 10 ms. With the same RWIN, the throughput limitation is 2000 LSPs per second when the RTT is 50 ms. That's the maximum throughput assuming no other limitations such as CPU limitations.</t>
          <t indent="0" pn="section-6.2.1-4">Equally, RTT is of importance for the performance. That is why the
          performance improvements on the receiver specified in <xref target="Receiver" format="default" sectionFormat="of" derivedContent="Section 5"/> are important to achieve good
          throughput. If the receiver does not support those performance
          improvements, in the worst case (small RWIN and high RTT) the
          throughput will be limited by the LSP Transmission Interval as
          defined in <xref target="InterfaceLSPTransmissionInterval" format="default" sectionFormat="of" derivedContent="Section 4.2"/>.</t>
          <section anchor="TLVoperationP2P" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.1.1">
            <name slugifiedName="name-operation-on-a-point-to-poi">Operation on a Point-to-Point Interface</name>
            <t indent="0" pn="section-6.2.1.1-1">By sending the Receive Window sub-TLV, a node advertises to its neighbor its ability to receive that many unacknowledged LSPs from the neighbor. This is akin to a receive window or sliding window in flow control. In some implementations, this value should reflect the IS-IS socket buffer size. Special care must be taken to leave space for CSNPs, PSNPs, and IIHs if they share the same input queue. In this case, this document suggests advertising an LSP Receive Window corresponding to half the size of the IS-IS input queue. </t>
            <t indent="0" pn="section-6.2.1.1-2">By advertising an LSP Transmission Interval sub-TLV, a node advertises its ability to receive LSPs separated by at least the advertised value, outside of LSP bursts.</t>
            <t indent="0" pn="section-6.2.1.1-3">By advertising an LSP Burst Size sub-TLV, a node advertises its ability to receive that number of LSPs back to back.</t>
            <t indent="0" pn="section-6.2.1.1-4">The LSP transmitter <bcp14>MUST NOT</bcp14> exceed these parameters. After having sent a full burst of LSPs, it <bcp14>MUST</bcp14> send the subsequent LSPs with a minimum of LSP Transmission Interval between LSP transmissions. For CPU scheduling reasons, this rate <bcp14>MAY</bcp14> be averaged over a small period, e.g., 10-30 ms.</t>
            <t indent="0" pn="section-6.2.1.1-5">If either the LSP transmitter or receiver does not adhere to these parameters, for example, because of transient conditions, this doesn't result in a fatal condition for IS-IS operation. In the worst case, an LSP is lost at the receiver, and this situation is already remedied by mechanisms in <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/>.
					After a few seconds, neighbors will exchange PSNPs (for point-to-point interfaces) or CSNPs (for broadcast interfaces) and recover from the lost LSPs. This worst case should be avoided as those additional seconds impact convergence time since the LSDB is not fully synchronized. Hence, it is better to err on the conservative side and to under-run the receiver rather than over-run it.</t>
          </section>
          <section numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.1.2">
            <name slugifiedName="name-operation-on-a-broadcast-la">Operation on a Broadcast LAN Interface</name>
            <t indent="0" pn="section-6.2.1.2-1">Flow and congestion control on a LAN interface is out of scope for this document.</t>
          </section>
        </section>
        <section anchor="CongestionControl" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.2">
          <name slugifiedName="name-congestion-control">Congestion Control</name>
          <t indent="0" pn="section-6.2.2-1">Whereas flow control prevents the sender from overwhelming the
          receiver, congestion control prevents senders from overwhelming the
          network. For an IS-IS adjacency, the network between two IS-IS
          neighbors is relatively limited in scope and includes a single link
          that is typically oversized compared to the capability of the IS-IS
          speakers.  In situations where the probability of LSP drop is low,
          flow control (<xref target="FlowControl" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>) is
          expected to give good results, without the need to implement
          congestion control. Otherwise, adding congestion control will help
          handling congestion of LSPs in the receiver.</t>
          <t indent="0" pn="section-6.2.2-2">This section describes one sender-side congestion control algorithm largely inspired by the TCP congestion control algorithm <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>.</t>
          <t indent="0" pn="section-6.2.2-3">The proposed algorithm uses a variable congestion window 'cwin'. It plays a role similar to the receive window described above. The main difference is that cwin is adjusted dynamically according to various events described below.</t>
          <section anchor="CC1Core" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.2.1">
            <name slugifiedName="name-core-algorithm">Core Algorithm</name>
            <t indent="0" pn="section-6.2.2.1-1">In its simplest form, the congestion control algorithm looks like the following:</t>
            <figure anchor="cc1_core_algo" align="left" suppress-title="false" pn="figure-1">
              <artwork name="" type="" align="left" alt="" pn="section-6.2.2.1-2.1">
+---------------+
|               |
|               v
|   +----------------------+
|   | Congestion avoidance |
|   + ---------------------+
|               |
|               | Congestion signal
----------------+</artwork>
            </figure>
            <t indent="0" pn="section-6.2.2.1-3">The algorithm starts with cwin = cwin0 = LPP + 1. In the congestion avoidance phase, cwin increases as LSPs are acked: for every acked LSP, cwin += 1 / cwin without exceeding RWIN. When LSPs are exchanged, cwin LSPs will be acknowledged in 1 RTT, meaning cwin(t) = t/RTT + cwin0. Since the RTT is low in many IS-IS deployments, the sending rate can reach fast rates in short periods of time.</t>
            <t indent="0" pn="section-6.2.2.1-4">When updating cwin, it must not become higher than the number of LSPs waiting to be sent, otherwise the sending will not be paced by the receiving of acks. Said differently, transmission pressure is needed to maintain and increase cwin.</t>
            <t indent="0" pn="section-6.2.2.1-5">When the congestion signal is triggered, cwin is set back to its initial value, and the congestion avoidance phase starts again.</t>
          </section>
          <section anchor="CC1CongestionSignals" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.2.2">
            <name slugifiedName="name-congestion-signals">Congestion Signals</name>
            <t indent="0" pn="section-6.2.2.2-1">The congestion signal can take various forms. The more reactive the congestion signals, the fewer LSPs will be lost due to congestion. However, overly aggressive congestion signals will cause a sender to keep a very low sending rate even without actual congestion on the path.</t>
            <t indent="0" pn="section-6.2.2.2-2">Two practical signals are given below.</t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-6.2.2.2-3">
              <li pn="section-6.2.2.2-3.1" derivedCounter="1.">
                <t indent="0" pn="section-6.2.2.2-3.1.1">Delay: When receiving acknowledgments, a sender
              estimates the acknowledgment time of the receiver. Based on
              this estimation, it can infer that a packet was lost and 
              that the path is congested.</t>
                <t indent="0" pn="section-6.2.2.2-3.1.2">There can be a timer per LSP, but this can become costly for
              implementations. It is possible to use only a single timer t1
              for all LSPs: during t1, sent LSPs are recorded in a list
              list_1. Once the RTT is over, list_1 is kept and another list,
              list_2, is used to store the next LSPs. LSPs are removed from the
              lists when acked. At the end of the second t1 period, every LSP
              in list_1 should have been acked, so list_1 is checked to be
              empty. list_1 can then be reused for the next RTT.</t>
                <t indent="0" pn="section-6.2.2.2-3.1.3">There are multiple strategies to set the timeout value t1. It
              should be based on measurements of the maximum acknowledgment
              time (MAT) of each PSNP. Using three times the RTT is the simplest strategy; 
               alternatively, an exponential moving average of the MATs,
              as described in <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/>, can be used. A more
              elaborate one is to take a running maximum of the MATs over a
              period of a few seconds. This value should include a margin of
              error to avoid false positives (e.g., estimated MAT measure
              variance), which would have a significant impact on
              performance.</t>
              </li>
              <li pn="section-6.2.2.2-3.2" derivedCounter="2.">
                <t indent="0" pn="section-6.2.2.2-3.2.1">Loss: if the receiver has signaled the O-flag (see <xref target="Flags" format="default" sectionFormat="of" derivedContent="Section 4.4"/>), a
              sender <bcp14>MAY</bcp14> record its sending order and check
              that acknowledgments arrive in the same order. If not, some
              LSPs are missing, and this <bcp14>MAY</bcp14> be used to trigger
              a congestion signal.</t>
              </li>
            </ol>
          </section>
          <section anchor="CC1Refinement" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.2.3">
            <name slugifiedName="name-refinement">Refinement</name>
            <t indent="0" pn="section-6.2.2.3-1">With the algorithm presented above, if congestion is detected, cwin goes back to its initial value and does not use the information gathered in previous congestion avoidance phases.</t>
            <t indent="0" pn="section-6.2.2.3-2">It is possible to use a fast recovery phase once congestion is detected and to avoid going through this linear rate of growth from scratch. When congestion is detected, a fast recovery threshold frthresh is set to frthresh = cwin / 2. In this fast recovery phase, for every acked LSP, cwin += 1. Once cwin reaches frthresh, the algorithm goes back to the congestion avoidance phase.</t>
            <figure anchor="cc1_algo_refinement_1" align="left" suppress-title="false" pn="figure-2">
              <artwork name="" type="" align="left" alt="" pn="section-6.2.2.3-3.1">
+---------------+
|               |
|               v
|   +----------------------+
|   | Congestion avoidance |
|   + ---------------------+
|               |
|               | Congestion signal
|               |
|   +----------------------+
|   |     Fast recovery    |
|   +----------------------+
|               |
|               | frthresh reached
----------------+</artwork>
            </figure>
          </section>
          <section anchor="cc_remarks" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.2.4">
            <name slugifiedName="name-remarks">Remarks</name>
            <t indent="0" pn="section-6.2.2.4-1"> This algorithm's performance is dependent on the LPP
            value. Indeed, the smaller the LPP is, the more information is
            available for the congestion control algorithm to perform
            well. However, it also increases the resources spent on sending
            PSNPs, so a trade-off must be made. This document recommends 
            using an LPP of 15 or less. If a Receive Window is advertised, LPP
            <bcp14>SHOULD</bcp14> be lower, and the best performance is
            achieved when LPP is an integer fraction of the Receive Window.
            </t>
            <t indent="0" pn="section-6.2.2.4-2">Note that this congestion control algorithm benefits from the
            extensions proposed in this document. The advertisement of a
            receive window from the receiver (<xref target="FlowControl" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>) avoids the use of an arbitrary maximum value
            by the sender. The faster acknowledgment of LSPs (<xref target="LSPACKRate" format="default" sectionFormat="of" derivedContent="Section 5.1"/>) allows for a faster
            control loop and hence a faster increase of the congestion
            window in the absence of congestion.
            </t>
          </section>
        </section>
        <section anchor="Pacing" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.3">
          <name slugifiedName="name-pacing">Pacing</name>
          <t indent="0" pn="section-6.2.3-1">As discussed in <xref target="RFC9002" sectionFormat="comma" section="7.7" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9002#section-7.7" derivedContent="RFC9002"/>, a sender <bcp14>SHOULD</bcp14>
          pace sending of all in-flight LSPs based on input from the
          congestion controller.</t>
          <t indent="0" pn="section-6.2.3-2">Sending multiple packets without any delay between them creates a packet burst that might cause short-term congestion and losses. Senders <bcp14>MUST</bcp14> either use pacing or limit such bursts. Senders <bcp14>SHOULD</bcp14> limit bursts to LSP Burst Size.</t>
          <t indent="0" pn="section-6.2.3-3">Senders can implement pacing as they choose. A perfectly paced sender spreads packets evenly over time. For a window-based congestion controller, such as the one in this section, that rate can be computed by averaging the congestion window over the RTT. Expressed as an inter-packet interval in units of time:</t>
          <t indent="3" pn="section-6.2.3-4">interval = (SRTT / cwin) / N</t>
          <t indent="0" pn="section-6.2.3-5">SRTT is the Smoothed Round-Trip Time <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/>.</t>
          <t indent="0" pn="section-6.2.3-6">Using a value for N that is small, but at least 1 (for example, 1.25), ensures that variations in RTT do not result in underutilization of the congestion window.</t>
          <t indent="0" pn="section-6.2.3-7">Practical considerations, such as scheduling delays and computational efficiency, can cause a sender to deviate from this rate over time periods that are much shorter than an RTT.</t>
          <t indent="0" pn="section-6.2.3-8">One possible implementation strategy for pacing uses a leaky bucket algorithm, where the capacity of the "bucket" is limited to the maximum burst size, and the rate that the "bucket" fills is determined by the above function.</t>
        </section>
        <section anchor="sec_determining_values" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.4">
          <name slugifiedName="name-determining-values-to-be-ad">Determining Values to be Advertised in the Flooding Parameters TLV</name>
          <t indent="0" pn="section-6.2.4-1">The values that a receiver advertises do not need to be perfect. If the values are too low, then the transmitter will not use the full bandwidth or available CPU resources. If the values are too high, then the receiver may drop some LSPs during the first RTT, and this loss will reduce the usable receive window, and the protocol mechanisms will allow the adjacency to recover. Flooding slower than both nodes can support will hurt performance as will consistently overloading the receiver.</t>
          <section anchor="sec_determining_values_static" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.4.1">
            <name slugifiedName="name-static-values">Static Values</name>
            <t indent="0" pn="section-6.2.4.1-1">The values advertised need not be dynamic, as feedback is
            provided by the acknowledgment of LSPs in SNP
            messages. Acknowledgments provide a feedback loop on how fast the
            LSPs are processed by the receiver. They also signal that the LSPs
            can be removed from the receive window, explicitly signaling to the
            sender that more LSPs may be sent. By advertising relatively
            static parameters, we expect to produce overall flooding behavior
            similar to what might be achieved by manually configuring
            per-interface LSP rate-limiting on all interfaces in the
            network. The advertised values could be based, for example, on
            offline tests of the overall LSP-processing speed for a particular
            set of hardware and the number of interfaces configured for
            IS-IS. With such a formula, the values advertised in the Flooding
            Parameters TLV would only change when additional IS-IS interfaces
            are configured.</t>
            <t indent="0" pn="section-6.2.4.1-2">Static values are dependent on the CPU generation, class of
            router, and network scaling, typically the number of adjacent
            neighbors.  Examples at the time of publication are provided
            below. 

The LSP Burst Size could be in the range 5 to 20. From a router
            perspective, this value typically depends on the queue(s) size(s)
            on the I/O path from the packet forwarding engine to the control
            plane, which is very platform-dependent.  It also depends upon how
            many IS-IS neighbors share this I/O path, as typically all
            neighbors will send the same LSPs at the same time.  It may also
            depend on other incoming control plane traffic that is sharing that I/O
            path, how bursty they are, and how many incoming IS-IS packets are
            prioritized over other incoming control plane traffic.  As
            indicated in <xref target="HISTORY" format="default" sectionFormat="of" derivedContent="Section 3"/>, the
            historical behavior from <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/> allows a value of 10; hence, 10 seems
            conservative. From a network operation perspective, it would be
            beneficial for the burst size to be equal to or higher than the
            number of LSPs that may be originated by a single failure. For a
            node failure, this is equal to the number of IS-IS neighbors of
            the failed node.  

The LSP Transmission Interval could be in the range
            of 1 ms to 33 ms. As indicated in <xref target="HISTORY" format="default" sectionFormat="of" derivedContent="Section 3"/>, the historical behavior from <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/> is 33 ms; hence, 33 ms is
            conservative. The LSP Transmission Interval is an advertisement of
            the receiver's sustainable LSP reception rate taking into account
            all aspects and particularly the control plane CPU and the I/O
            bandwidth. It's expected to improve (hence, decrease) as hardware
            and software naturally improve over time. It should be chosen
            conservatively, as this rate may be used by the sender in all
            conditions -- including the worst conditions.  It's also not a
            bottleneck as the flow control algorithm may use a higher rate in
            good conditions, particularly when the receiver acknowledges
            quickly, and the receive window is large enough compared to the
            RTT.  

LPP could be in the range of 5 to 90 with a proposed 15. A
            smaller value provides faster feedback at the cost of the small
            overhead of more PSNP messages.  

PartialSNPInterval could be in
            the range 50 to 500 ms with a proposed value of 200 ms.  One may
            distinguish the value used locally from the value signaled to the
            sender. The value used locally benefits from being small but is
            not expected to be the main parameter to improve performance. It
            depends on how fast the IS-IS flooding process may be scheduled by
            the CPU. Even when the receiver CPU is busy, it's safe because it will
            naturally delay its acknowledgments, which provides a negative
            feedback loop. The value advertised to the sender should be
            conservative (high enough) as this value could be used by the
            sender to send some LSPs rather than keep waiting for
            acknowledgments. 

Receive Window could be in the range of 30 to 200 with a
            proposed value of 60. In general, the larger the better the performance on
            links with high RTT. The higher that number and the higher the
            number of IS-IS neighbors, the higher the use of control plane
            memory, so it's mostly dependent on the amount of memory, which may
            be dedicated to IS-IS flooding and the number of IS-IS
            neighbors. From a memory usage perspective (a priori), one could
            use the same value as the TCP receive window, but the value
            advertised should not be higher than the buffer of the "socket"
            used.</t>
          </section>
          <section anchor="sec_determining_values_dynamic" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.4.2">
            <name slugifiedName="name-dynamic-values">Dynamic Values</name>
            <t indent="0" pn="section-6.2.4.2-1">To reflect the relative change of load on the receiver, the
            values may be updated dynamically by improving the values when the
            receiver load is getting lower and by degrading the values when the
            receiver load is getting higher. For example, if LSPs are
            regularly dropped, or if the queue regularly comes close to being
            filled, then the values may be too high. On the other hand, if the
            queue is barely used (by IS-IS), then the values may be too
            low.</t>
            <t indent="0" pn="section-6.2.4.2-2">Alternatively, the values may be computed
            to reflect the relevant average hardware resources, e.g.,
            the amount of buffer space used by incoming
            LSPs. In this case, care must be taken when choosing the
            parameters influencing the values in order to avoid undesirable or
            unstable feedback loops. For example, it would be undesirable to
            use a formula that depends on an active measurement of the
            instantaneous CPU load to modify the values advertised in the
            Flooding Parameters TLV. This could introduce feedback into the
            IGP flooding process that could produce unexpected behavior.</t>
          </section>
        </section>
        <section anchor="OPS_Considerations" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.5">
          <name slugifiedName="name-operational-considerations">Operational Considerations</name>
          <t indent="0" pn="section-6.2.5-1">As discussed in <xref target="TLVoperationLAN" format="default" sectionFormat="of" derivedContent="Section 4.7"/>, the solution is more effective on point-to-point
          adjacencies. Hence, a broadcast interface (e.g., Ethernet) only
          shared by two IS-IS neighbors should be configured as point-to-point
          in order to have more effective flooding.</t>
        </section>
      </section>
      <section anchor="TxSide" numbered="true" toc="include" removeInRFC="false" pn="section-6.3">
        <name slugifiedName="name-transmitter-based-congestio">Transmitter-Based Congestion Control Approach</name>
        <t indent="0" pn="section-6.3-1">This section describes an approach to the congestion control algorithm based on
        performance measured by the transmitter without dependence on
        signaling from the receiver.</t>
        <section anchor="Router-arch" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.3.1">
          <name slugifiedName="name-router-architecture-discuss">Router Architecture Discussion</name>
          <t indent="0" pn="section-6.3.1-1">Note that the following description is an abstraction;
          implementation details vary.</t>
          <t indent="0" pn="section-6.3.1-2">Existing router architectures may utilize multiple input queues.
          On a given line card, IS-IS PDUs from multiple interfaces may be
          placed in a rate-limited input queue. This queue may be dedicated to
          IS-IS PDUs or may be shared with other routing related packets.</t>
          <t indent="0" pn="section-6.3.1-3">The input queue may then pass IS-IS PDUs to a "punt queue", which
          is used to pass PDUs from the data plane to the control plane. The
          punt queue typically also has controls on its size and the rate at
          which packets will be punted.</t>
          <t indent="0" pn="section-6.3.1-4">An input queue in the control plane may then be used to assemble
          PDUs from multiple line cards, separate the IS-IS PDUs from other
          types of packets, and place the IS-IS PDUs in an input queue
          dedicated to the IS-IS protocol.</t>
          <t indent="0" pn="section-6.3.1-5">The IS-IS input queue then separates the IS-IS PDUs and directs
          them to an instance-specific processing queue. The instance-specific
          processing queue may then further separate the IS-IS PDUs by type
          (IIHs, SNPs, and LSPs) so that separate processing threads with
          varying priorities may be employed to process the incoming PDUs.</t>
          <t indent="0" pn="section-6.3.1-6">In such an architecture, it may be difficult for IS-IS in the
          control plane to determine what value should be advertised as a
          receive window.</t>
          <t indent="0" pn="section-6.3.1-7">The following section describes an approach to congestion control
          based on performance measured by the transmitter without dependence
          on signaling from the receiver.</t>
        </section>
        <section anchor="Ex2-tx" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.3.2">
          <name slugifiedName="name-guidelines-for-transmitter-">Guidelines for Transmitter-Side Congestion Controls</name>
          <t indent="0" pn="section-6.3.2-1">The approach described in this section does not depend upon
          direct signaling from the receiver. Instead, it adapts the
          transmission rate based on measurement of the actual rate of
          acknowledgments received.</t>
          <t indent="0" pn="section-6.3.2-2">Flow control is not used by this approach. When congestion
          control is necessary, it can be implemented based on knowledge of
          the current flooding rate and the current acknowledgment rate. The
          algorithm used is a local matter. There is no requirement to
          standardize it, but there are a number of aspects that serve as
          guidelines that can be described. Algorithms based on this approach
          should follow the recommendations described below. </t>
          <t indent="0" pn="section-6.3.2-3">A maximum LSP transmission rate (LSPTxMax) should be
          configurable. This represents the fastest LSP transmission rate
          that will be attempted. This value should be applicable to all
          interfaces and should be consistent network wide.</t>
          <t indent="0" pn="section-6.3.2-4">When the current rate of LSP transmission (LSPTxRate) exceeds the
          capabilities of the receiver, the congestion control algorithm needs to
          quickly and aggressively reduce the LSPTxRate. Slower
          responsiveness is likely to result in a larger number of
          retransmissions, which can introduce much longer delays in
          convergence.</t>
          <t indent="0" pn="section-6.3.2-5">Dynamic increase of the rate of LSP transmission (LSPTxRate),
           i.e., making the rate faster, should be done less aggressively and only be
          done when the neighbor has demonstrated its ability to sustain the
          current LSPTxRate.</t>
          <t indent="0" pn="section-6.3.2-6">The congestion control algorithm should not assume that the receive
          performance of a neighbor is static, i.e., it should handle
          transient conditions that result in a slower or faster receive rate
          on the part of a neighbor.</t>
          <t indent="0" pn="section-6.3.2-7">The congestion control algorithm should consider the expected
          delay time in receiving an acknowledgment. Therefore, it
          incorporates the neighbor partialSNPInterval (<xref target="partialSNPI" format="default" sectionFormat="of" derivedContent="Section 4.5"/>) to help determine whether
          acknowledgments are keeping pace with the rate of LSPs
          transmitted. In the absence of an advertisement of
          partialSNPInterval, a locally configured value can be used.</t>
        </section>
      </section>
    </section>
    <section anchor="IANA_Consideration" numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <section anchor="IANA_Consideration1" numbered="true" toc="include" removeInRFC="false" pn="section-7.1">
        <name slugifiedName="name-flooding-parameters-tlv-2">Flooding Parameters TLV</name>
        <t indent="0" pn="section-7.1-1">IANA has made the following allocation in the "IS-IS Top-Level TLV Codepoints" registry.</t>
        <table align="center" pn="table-1">
          <name/>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="left" colspan="1" rowspan="1">IIH</th>
              <th align="left" colspan="1" rowspan="1">LSP</th>
              <th align="left" colspan="1" rowspan="1">SNP</th>
              <th align="left" colspan="1" rowspan="1">Purge</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center" colspan="1" rowspan="1">21</td>
              <td align="left" colspan="1" rowspan="1">Flooding Parameters TLV</td>
              <td align="left" colspan="1" rowspan="1">y</td>
              <td align="left" colspan="1" rowspan="1">n</td>
              <td align="left" colspan="1" rowspan="1">y</td>
              <td align="left" colspan="1" rowspan="1">n</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="IANA_Consideration2" numbered="true" toc="include" removeInRFC="false" pn="section-7.2">
        <name slugifiedName="name-registry-is-is-sub-tlv-for-">Registry: IS-IS Sub-TLV for Flooding Parameters TLV</name>
        <t indent="0" pn="section-7.2-1">IANA has created the following sub-TLV registry in the "IS-IS TLV Codepoints" registry group.</t>
        <dl newline="false" spacing="compact" indent="3" pn="section-7.2-2">
          <dt pn="section-7.2-2.1">Name:</dt>
          <dd pn="section-7.2-2.2">IS-IS Sub-TLVs for Flooding Parameters TLV</dd>
          <dt pn="section-7.2-2.3">Registration Procedure(s):</dt>
          <dd pn="section-7.2-2.4">Expert Review</dd>
          <dt pn="section-7.2-2.5">Description:</dt>
          <dd pn="section-7.2-2.6">This registry defines sub-TLVs for the Flooding Parameters TLV (21).</dd>
          <dt pn="section-7.2-2.7">Reference:</dt>
          <dd pn="section-7.2-2.8">RFC 9681</dd>
        </dl>
        <table anchor="Registry_Flooding" align="center" pn="table-2">
          <name slugifiedName="name-initial-sub-tlv-allocations">Initial Sub-TLV Allocations for Flooding Parameters TLV</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Type</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center" colspan="1" rowspan="1">0</td>
              <td align="left" colspan="1" rowspan="1">Reserved</td>
            </tr>
            <tr>
              <td align="center" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1">LSP Burst Size</td>
            </tr>
            <tr>
              <td align="center" colspan="1" rowspan="1">2</td>
              <td align="left" colspan="1" rowspan="1">LSP Transmission Interval</td>
            </tr>
            <tr>
              <td align="center" colspan="1" rowspan="1">3</td>
              <td align="left" colspan="1" rowspan="1">LSPs per PSNP</td>
            </tr>
            <tr>
              <td align="center" colspan="1" rowspan="1">4</td>
              <td align="left" colspan="1" rowspan="1">Flags</td>
            </tr>
            <tr>
              <td align="center" colspan="1" rowspan="1">5</td>
              <td align="left" colspan="1" rowspan="1">PSNP Interval</td>
            </tr>
            <tr>
              <td align="center" colspan="1" rowspan="1">6</td>
              <td align="left" colspan="1" rowspan="1">Receive Window</td>
            </tr>
            <tr>
              <td align="center" colspan="1" rowspan="1">7-255</td>
              <td align="left" colspan="1" rowspan="1">Unassigned</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="IANA_Consideration3" numbered="true" toc="include" removeInRFC="false" pn="section-7.3">
        <name slugifiedName="name-registry-is-is-bit-values-f">Registry: IS-IS Bit Values for Flooding Parameters Flags Sub-TLV</name>
        <t indent="0" pn="section-7.3-1">IANA has created a new registry, in the "IS-IS TLV Codepoints" registry group, for assigning Flag bits advertised in the Flags sub-TLV.</t>
        <dl newline="false" spacing="compact" indent="3" pn="section-7.3-2">
          <dt pn="section-7.3-2.1">Name:</dt>
          <dd pn="section-7.3-2.2">IS-IS Bit Values for Flooding Parameters Flags Sub-TLV</dd>
          <dt pn="section-7.3-2.3">Registration Procedure:</dt>
          <dd pn="section-7.3-2.4">Expert Review</dd>
          <dt pn="section-7.3-2.5">Description:</dt>
          <dd pn="section-7.3-2.6">
            <t indent="0" pn="section-7.3-2.6.1">This registry defines bit values for the Flags sub-TLV (4) advertised in the Flooding Parameters TLV (21).</t>
          </dd>
          <dt pn="section-7.3-2.7">Note:</dt>
          <dd pn="section-7.3-2.8">
            <t indent="0" pn="section-7.3-2.8.1">In order to minimize encoding space, a new allocation should pick the smallest available value.</t>
          </dd>
          <dt pn="section-7.3-2.9">Reference:</dt>
          <dd pn="section-7.3-2.10">RFC 9681</dd>
        </dl>
        <table anchor="Registry_Flags" align="center" pn="table-3">
          <name slugifiedName="name-initial-bit-allocations-for">Initial Bit Allocations for Flags Sub-TLV</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Bit #</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">0</td>
              <td align="left" colspan="1" rowspan="1">Ordered acknowledgment (O-flag)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1-63</td>
              <td align="left" colspan="1" rowspan="1">Unassigned</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="Security" toc="include" numbered="true" removeInRFC="false" pn="section-8">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-8-1">Security concerns for IS-IS are addressed in <xref target="ISO10589" format="default" sectionFormat="of" derivedContent="ISO10589"/>, <xref target="RFC5304" format="default" sectionFormat="of" derivedContent="RFC5304"/>, and
      <xref target="RFC5310" format="default" sectionFormat="of" derivedContent="RFC5310"/>.  These documents describe
      mechanisms that provide for the authentication and integrity of IS-IS
      PDUs, including SNPs and IIHs. These authentication mechanisms are not
      altered by this document.</t>
      <t indent="0" pn="section-8-2">With the cryptographic mechanisms described in <xref target="RFC5304" format="default" sectionFormat="of" derivedContent="RFC5304"/> and <xref target="RFC5310" format="default" sectionFormat="of" derivedContent="RFC5310"/>, an attacker wanting to advertise an incorrect
      Flooding Parameters TLV would have to first defeat these mechanisms.</t>
      <t indent="0" pn="section-8-3">In the absence of cryptographic authentication, as IS-IS does not run
      over IP but directly over the link layer, it's considered difficult to
      inject a false SNP or IIH without having access to the link layer.</t>
      <t indent="0" pn="section-8-4">If a false SNP or IIH is sent with a Flooding Parameters TLV set to
      conservative values, the attacker can reduce the flooding speed between
      the two adjacent neighbors, which can result in LSDB inconsistencies and
      transient forwarding loops. However, it is not significantly different
      than filtering or altering LSPs, which would also be possible with access
      to the link layer. In addition, if the downstream flooding neighbor has
      multiple IGP neighbors (which is typically the case for reliability or
      topological reasons), it would receive LSPs at a regular speed from its
      other neighbors and hence would maintain LSDB consistency.</t>
      <t indent="0" pn="section-8-5">If a false SNP or IIH is sent with a Flooding Parameters TLV set to
      aggressive values, the attacker can increase the flooding speed, which
      can either overload a node or more likely cause loss of
      LSPs. However, it is not significantly different than sending many LSPs,
      which would also be possible with access to the link layer, even with
      cryptographic authentication enabled. In addition, IS-IS has procedures
      to detect the loss of LSPs and recover.</t>
      <t indent="0" pn="section-8-6">This TLV advertisement is not flooded across the network but only
      sent between adjacent IS-IS neighbors. This would limit the consequences
      in case of forged messages and also limit the dissemination of such
      information.</t>
    </section>
  </middle>
  <back>
    <references pn="section-9">
      <name slugifiedName="name-references">References</name>
      <references pn="section-9.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="ISO10589" target="https://www.iso.org/standard/30932.html" quoteTitle="true" derivedAnchor="ISO10589">
          <front>
            <title>Information technology - Telecommunications and information exchange between systems - Intermediate system to Intermediate system intra-domain routeing information exchange protocol for use in conjunction with the protocol for providing the connectionless-mode network service (ISO 8473)</title>
            <author>
              <organization abbrev="ISO/IEC" showOnFrontPage="true">International Organization for Standardization/International Electrotechnical Commission</organization>
            </author>
            <date month="Nov" year="2002"/>
          </front>
          <seriesInfo name="ISO/IEC" value="10589:2002"/>
          <refcontent>Second Edition</refcontent>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC5304" target="https://www.rfc-editor.org/info/rfc5304" quoteTitle="true" derivedAnchor="RFC5304">
          <front>
            <title>IS-IS Cryptographic Authentication</title>
            <author fullname="T. Li" initials="T." surname="Li"/>
            <author fullname="R. Atkinson" initials="R." surname="Atkinson"/>
            <date month="October" year="2008"/>
            <abstract>
              <t indent="0">This document describes the authentication of Intermediate System to Intermediate System (IS-IS) Protocol Data Units (PDUs) using the Hashed Message Authentication Codes - Message Digest 5 (HMAC-MD5) algorithm as found in RFC 2104. IS-IS is specified in International Standards Organization (ISO) 10589, with extensions to support Internet Protocol version 4 (IPv4) described in RFC 1195. The base specification includes an authentication mechanism that allows for multiple authentication algorithms. The base specification only specifies the algorithm for cleartext passwords. This document replaces RFC 3567.</t>
              <t indent="0">This document proposes an extension to that specification that allows the use of the HMAC-MD5 authentication algorithm to be used in conjunction with the existing authentication mechanisms. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5304"/>
          <seriesInfo name="DOI" value="10.17487/RFC5304"/>
        </reference>
        <reference anchor="RFC5310" target="https://www.rfc-editor.org/info/rfc5310" quoteTitle="true" derivedAnchor="RFC5310">
          <front>
            <title>IS-IS Generic Cryptographic Authentication</title>
            <author fullname="M. Bhatia" initials="M." surname="Bhatia"/>
            <author fullname="V. Manral" initials="V." surname="Manral"/>
            <author fullname="T. Li" initials="T." surname="Li"/>
            <author fullname="R. Atkinson" initials="R." surname="Atkinson"/>
            <author fullname="R. White" initials="R." surname="White"/>
            <author fullname="M. Fanto" initials="M." surname="Fanto"/>
            <date month="February" year="2009"/>
            <abstract>
              <t indent="0">This document proposes an extension to Intermediate System to Intermediate System (IS-IS) to allow the use of any cryptographic authentication algorithm in addition to the already-documented authentication schemes, described in the base specification and RFC 5304. IS-IS is specified in International Standards Organization (ISO) 10589, with extensions to support Internet Protocol version 4 (IPv4) described in RFC 1195.</t>
              <t indent="0">Although this document has been written specifically for using the Hashed Message Authentication Code (HMAC) construct along with the Secure Hash Algorithm (SHA) family of cryptographic hash functions, the method described in this document is generic and can be used to extend IS-IS to support any cryptographic hash function in the future. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5310"/>
          <seriesInfo name="DOI" value="10.17487/RFC5310"/>
        </reference>
        <reference anchor="RFC6298" target="https://www.rfc-editor.org/info/rfc6298" quoteTitle="true" derivedAnchor="RFC6298">
          <front>
            <title>Computing TCP's Retransmission Timer</title>
            <author fullname="V. Paxson" initials="V." surname="Paxson"/>
            <author fullname="M. Allman" initials="M." surname="Allman"/>
            <author fullname="J. Chu" initials="J." surname="Chu"/>
            <author fullname="M. Sargent" initials="M." surname="Sargent"/>
            <date month="June" year="2011"/>
            <abstract>
              <t indent="0">This document defines the standard algorithm that Transmission Control Protocol (TCP) senders are required to use to compute and manage their retransmission timer. It expands on the discussion in Section 4.2.3.1 of RFC 1122 and upgrades the requirement of supporting the algorithm from a SHOULD to a MUST. This document obsoletes RFC 2988. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6298"/>
          <seriesInfo name="DOI" value="10.17487/RFC6298"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
      </references>
      <references pn="section-9.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="RFC2973" target="https://www.rfc-editor.org/info/rfc2973" quoteTitle="true" derivedAnchor="RFC2973">
          <front>
            <title>IS-IS Mesh Groups</title>
            <author fullname="R. Balay" initials="R." surname="Balay"/>
            <author fullname="D. Katz" initials="D." surname="Katz"/>
            <author fullname="J. Parker" initials="J." surname="Parker"/>
            <date month="October" year="2000"/>
            <abstract>
              <t indent="0">This document describes a mechanism to reduce redundant packet transmissions for the Intermediate System to Intermediate System (IS-IS) Routing protocol, as described in ISO 10589. This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2973"/>
          <seriesInfo name="DOI" value="10.17487/RFC2973"/>
        </reference>
        <reference anchor="RFC5681" target="https://www.rfc-editor.org/info/rfc5681" quoteTitle="true" derivedAnchor="RFC5681">
          <front>
            <title>TCP Congestion Control</title>
            <author fullname="M. Allman" initials="M." surname="Allman"/>
            <author fullname="V. Paxson" initials="V." surname="Paxson"/>
            <author fullname="E. Blanton" initials="E." surname="Blanton"/>
            <date month="September" year="2009"/>
            <abstract>
              <t indent="0">This document defines TCP's four intertwined congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery. In addition, the document specifies how TCP should begin transmission after a relatively long idle period, as well as discussing various acknowledgment generation methods. This document obsoletes RFC 2581. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5681"/>
          <seriesInfo name="DOI" value="10.17487/RFC5681"/>
        </reference>
        <reference anchor="RFC9002" target="https://www.rfc-editor.org/info/rfc9002" quoteTitle="true" derivedAnchor="RFC9002">
          <front>
            <title>QUIC Loss Detection and Congestion Control</title>
            <author fullname="J. Iyengar" initials="J." role="editor" surname="Iyengar"/>
            <author fullname="I. Swett" initials="I." role="editor" surname="Swett"/>
            <date month="May" year="2021"/>
            <abstract>
              <t indent="0">This document describes loss detection and congestion control mechanisms for QUIC.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9002"/>
          <seriesInfo name="DOI" value="10.17487/RFC9002"/>
        </reference>
        <reference anchor="RFC9293" target="https://www.rfc-editor.org/info/rfc9293" quoteTitle="true" derivedAnchor="RFC9293">
          <front>
            <title>Transmission Control Protocol (TCP)</title>
            <author fullname="W. Eddy" initials="W." role="editor" surname="Eddy"/>
            <date month="August" year="2022"/>
            <abstract>
              <t indent="0">This document specifies the Transmission Control Protocol (TCP). TCP is an important transport-layer protocol in the Internet protocol stack, and it has continuously evolved over decades of use and growth of the Internet. Over this time, a number of changes have been made to TCP as it was specified in RFC 793, though these have only been documented in a piecemeal fashion. This document collects and brings those changes together with the protocol specification from RFC 793. This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093, 6429, 6528, and 6691 that updated parts of RFC 793. It updates RFCs 1011 and 1122, and it should be considered as a replacement for the portions of those documents dealing with TCP requirements. It also updates RFC 5961 by adding a small clarification in reset handling while in the SYN-RECEIVED state. The TCP header control bits from RFC 793 have also been updated based on RFC 3168.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="7"/>
          <seriesInfo name="RFC" value="9293"/>
          <seriesInfo name="DOI" value="10.17487/RFC9293"/>
        </reference>
        <reference anchor="RFC9667" target="https://www.rfc-editor.org/info/rfc9667" quoteTitle="true" derivedAnchor="RFC9667">
          <front>
            <title>Dynamic Flooding on Dense Graphs</title>
            <author initials="T." surname="Li" fullname="Tony Li" role="editor">
              <organization showOnFrontPage="true">Juniper Networks</organization>
            </author>
            <author initials="P." surname="Psenak" fullname="Peter Psenak" role="editor">
              <organization showOnFrontPage="true">Cisco Systems, Inc.</organization>
            </author>
            <author initials="H." surname="Chen" fullname="Huaimo Chen">
              <organization showOnFrontPage="true">Futurewei</organization>
            </author>
            <author initials="L." surname="Jalil" fullname="Luay Jalil">
              <organization showOnFrontPage="true">Verizon</organization>
            </author>
            <author initials="S." surname="Dontula" fullname="Srinath Dontula">
              <organization showOnFrontPage="true">ATT</organization>
            </author>
            <date month="October" year="2024"/>
          </front>
          <seriesInfo name="RFC" value="9667"/>
          <seriesInfo name="DOI" value="10.17487/RFC9667"/>
        </reference>
      </references>
    </references>
    <section anchor="Acknowledgments" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">The authors would like to thank <contact fullname="Henk Smit"/>,
      <contact fullname="Sarah Chen"/>, <contact fullname="Xuesong Geng"/>,
      <contact fullname="Pierre Francois"/>, <contact fullname="Hannes       Gredler"/>, <contact fullname="Acee Lindem"/>, <contact fullname="Mirja       Kühlewind"/>, <contact fullname="Zaheduzzaman Sarker"/>, and <contact fullname="John Scudder"/> for their reviews, comments, and
      suggestions.</t>
      <t indent="0" pn="section-appendix.a-2">The authors would like to thank <contact fullname="David Jacquet"/>,
      <contact fullname="Sarah Chen"/>, and <contact fullname="Qiangzhou       Gao"/> for the tests performed on commercial implementations and for
      their identification of some limiting factors.</t>
    </section>
    <section anchor="Contributors" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.b">
      <name slugifiedName="name-contributors">Contributors</name>
      <t indent="0" pn="section-appendix.b-1">The following people gave substantial contributions to the content of this document and should be considered as coauthors:</t>
      <contact fullname="Jayesh J">
        <organization showOnFrontPage="true">Ciena</organization>
        <address>
          <email>jayesh.ietf@gmail.com</email>
        </address>
      </contact>
      <contact fullname="Chris Bowers">
        <organization showOnFrontPage="true">Juniper Networks</organization>
        <address>
          <email>cbowers@juniper.net</email>
        </address>
      </contact>
      <contact fullname="Peter Psenak">
        <organization showOnFrontPage="true">Cisco Systems</organization>
        <address>
          <email>ppsenak@cisco.com</email>
        </address>
      </contact>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Bruno Decraene" initials="B." surname="Decraene">
        <organization showOnFrontPage="true">Orange</organization>
        <address>
          <email>bruno.decraene@orange.com</email>
        </address>
      </author>
      <author fullname="Les Ginsberg" initials="L" surname="Ginsberg">
        <organization showOnFrontPage="true">Cisco Systems</organization>
        <address>
          <postal>
            <street>821 Alder Drive</street>
            <city>Milpitas</city>
            <code>95035</code>
            <region>CA</region>
            <country>United States of America</country>
          </postal>
          <email>ginsberg@cisco.com</email>
        </address>
      </author>
      <author fullname="Tony Li" initials="T." surname="Li">
        <organization showOnFrontPage="true">Juniper Networks, Inc.</organization>
        <address>
          <email>tony.li@tony.li</email>
        </address>
      </author>
      <author fullname="Guillaume Solignac" initials="G." surname="Solignac">
        <address>
          <email>gsoligna@protonmail.com</email>
        </address>
      </author>
      <author fullname="Marek Karasek" initials="M" surname="Karasek">
        <organization showOnFrontPage="true">Cisco Systems</organization>
        <address>
          <postal>
            <street>Pujmanove 1753/10a, Prague 4 - Nusle</street>
            <city>Prague</city>
            <code>10 14000</code>
            <country>Czech Republic</country>
          </postal>
          <email>mkarasek@cisco.com</email>
        </address>
      </author>
      <author initials="G." surname="Van de Velde" fullname="Gunter Van de Velde">
        <organization showOnFrontPage="true">Nokia</organization>
        <address>
          <postal>
            <street>Copernicuslaan 50</street>
            <city>Antwerp</city>
            <code>2018</code>
            <country>Belgium</country>
          </postal>
          <email>gunter.van_de_velde@nokia.com</email>
        </address>
      </author>
      <author fullname="Tony Przygienda" initials="T" surname="Przygienda">
        <organization showOnFrontPage="true">Juniper</organization>
        <address>
          <postal>
            <street>1133 Innovation Way</street>
            <city>Sunnyvale</city>
            <region>CA</region>
            <code>94089</code>
            <country>United States of America</country>
          </postal>
          <email>prz@juniper.net</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
