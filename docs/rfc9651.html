<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0">
<title>RFC 9651: HTTPのための構造化フィールド値（日本語訳）</title>
<style type="text/css">@import url(https://fonts.googleapis.com/css2?family=BIZ+UDPGothic:wght@400;700&family=Noto+Sans+Mono&display=swap);

@viewport {
  zoom: 1;
  width: extend-to-zoom;
}

body {
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: "BIZ UDPGothic", sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}

.row {
  display: flex;
  width: 100%;
}

.col {
  flex: 0 0 50%;
  max-width: 50%;
  width: 50%;
  padding: 0px 5% 0px 5%;
  box-sizing: border-box;
}

/* metadata */
#external-metadata {
  padding: 0.5em;
  font-size: 0.8em;
  line-height: 1em;
  background-color: rgb(238, 238, 238);
}

#external-updates dt {
  width: 8em;
}

#updated-by,
#obsoleted-by {
  font-size: 16px;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th,
td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n + 1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}

@media (max-width: 600px) {
  .row {
    flex-wrap: wrap;
  }
  .col {
    flex: 0 0 100%;
    max-width: 100%;
    width: 100%;
  }
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

.bcp14 {
  font-weight: bold;
}

blockquote {
  background-color: rgb(249, 249, 249);
  color: rgb(17, 17, 17);
  border: 1px solid rgb(221, 221, 221);
  border-radius: 3px;
  margin: 1em 0px;
  padding: 1.2em 2em;
}

dt {
  break-before: auto;
}

dl > dd {
  margin-bottom: 0.8em;
  min-height: 1.3em;
}

dl > dt {
  float: left;
  margin-right: 1em;
}

.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}

.references dd {
  margin-left: 8em;
  overflow: auto;
}

tt,
code,
pre,
code {
  background-color: #f9f9f9;
  font-family: "Roboto Mono", Courier, "Courier New", monospace;
}

pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  padding-top: 42px;
}
h5,
h6 {
  font-size: 14px;
}
</style>
</head>
<body>
<div id="external-metadata"><dl id="external-updates">
<dt>ステータス:</dt>
<dd>PROPOSED STANDARD</dd>
<dt>廃止:</dt>
<dd><span>RFC8941</span></dd>
<dt>原文:</dt>
<dd><a href="https://www.rfc-editor.org/rfc/rfc9651.html">RFC 9651</a></dd>
<dt>その他の情報:</dt>
<dd>
<a href="https://datatracker.ietf.org/doc/rfc9651">Datatracker</a>|<a href="https://www.rfc-editor.org/info/rfc9651">Info page</a>
</dd>
</dl></div>
<div class="row">
<div lang="en" class="col">
<span></span><h1 id="rfcnum">RFC 9651</h1>
<h1 id="title">Structured Field Values for HTTP</h1>
</div>
<div lang="ja" class="col">
<span></span><h1 id="rfcnum">RFC 9651</h1>
<h1 id="title">HTTPのための構造化フィールド値</h1>
</div>
</div>
<div class="row">
<div lang="en" class="col"><h1>Abstract</h1></div>
<div lang="ja" class="col"><h1>概要</h1></div>
</div>
<section><div class="row">
<div lang="en" class="col"><p>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields.</p></div>
<div lang="ja" class="col"><p>この文書は、「構造化フィールド」、「構造化ヘッダー」、または「構造化トレーラー」として知られるHTTPヘッダーおよびトレーラーフィールドを定義および処理することを容易かつ安全にするための一連のデータ型および関連するアルゴリズムについて説明します。これは、新しいHTTPフィールドの仕様で使用することを意図しています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This document obsoletes RFC 8941.</p></div>
<div lang="ja" class="col"><p>この文書はRFC 8941を廃止します。</p></div>
</div></section><section><span id="status-of-memo-en"></span><span id="status-of-memo-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-status-of-this-memo-en" lang="en">
<a href="#name-status-of-this-memo-en" class="section-name selfRef">Status of This Memo</a>
        </h2></div>
<div lang="ja" class="col"><h2 id="name-status-of-this-memo-ja" lang="ja">
<a href="#name-status-of-this-memo-ja" class="section-name selfRef">このメモのステータス</a>
        </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>
            This is an Internet Standards Track document.
        </p></div>
<div lang="ja" class="col"><p>
            これはインターネット標準化団体（Internet Standards Track）の文章です。
        </p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </p></div>
<div lang="ja" class="col"><p>
            この文書は、インターネット技術タスクフォース（IETF）の成果物です。
            この文書は、IETFコミュニティのコンセンサスを代表するものです。
            この文書は公開レビューを受けており、インターネット技術運営グループ（IESG）により発行が承認されています。
            インターネット標準に関する詳しい情報は、RFC 7841のセクション2に記載されています。
        </p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc9651" class="eref">https://www.rfc-editor.org/info/rfc9651</a>.
        </span></p></div>
<div lang="ja" class="col"><p>
            この文書の現在の状態、正誤表、それに対するフィードバックの提供方法に関する情報は、
            <span><a href="https://www.rfc-editor.org/info/rfc9651" class="eref">https://www.rfc-editor.org/info/rfc9651</a> で入手できます。
        </span></p></div>
</div></section><section><span id="copyright-en"></span><span id="copyright-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-copyright-notice-en" lang="en">
<a href="#name-copyright-notice-en" class="section-name selfRef">Copyright Notice</a>
        </h2></div>
<div lang="ja" class="col"><h2 id="name-copyright-notice-ja" lang="ja">
<a href="#name-copyright-notice-ja" class="section-name selfRef">著作権表示</a>
        </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </p></div>
<div lang="ja" class="col"><p>
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info" class="eref">https://trustee.ietf.org/license-info</a>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </span></p></div>
<div lang="ja" class="col"><p>
            この文書は、この文書の発行日に有効なBCP 78およびIETFトラストのIETF文書に関する法的規定
            (<span><a href="https://trustee.ietf.org/license-info" class="eref">https://trustee.ietf.org/license-info</a>)に従うものとします。
            これらの文書は、この文書に関するあなたの権利と制限を記述しているので、注意深く確認してください。
            この文書から抽出されたコードコンポーネントには、信託の法的規定のセクション4.eに記載されているように、
            簡易BSDライセンステキストを含める必要があります。簡易BSDライセンスに記載されているように、保証なしに提供されます。
        </span></p></div>
</div></section><section><span id="toc-en"></span><span id="toc-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-table-of-contents-en" lang="en">
<a href="#name-table-of-contents-en" class="section-name selfRef">Table of Contents</a>
        </h2></div>
<div lang="ja" class="col"><h2 id="name-table-of-contents-ja" lang="ja">
<a href="#name-table-of-contents-ja" class="section-name selfRef">目次</a>
        </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><ul>
<li>
            <p><a href="#section-1-en">1</a>.  <a href="#name-introduction-en">Introduction</a></p>
<ul>
<li>
                <p><a href="#section-1.1-en">1.1</a>.  <a href="#name-intentionally-strict-proces-en">Intentionally Strict Processing</a></p>
</li>
              <li>
                <p><a href="#section-1.2-en">1.2</a>.  <a href="#name-notational-conventions-en">Notational Conventions</a></p>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-2-en">2</a>.  <a href="#name-defining-new-structured-fie-en">Defining New Structured Fields</a></p>
<ul>
<li>
                <p><a href="#section-2.1-en">2.1</a>.  <a href="#name-example-en">Example</a></p>
</li>
              <li>
                <p><a href="#section-2.2-en">2.2</a>.  <a href="#name-error-handling-en">Error Handling</a></p>
</li>
              <li>
                <p><a href="#section-2.3-en">2.3</a>.  <a href="#name-preserving-extensibility-en">Preserving Extensibility</a></p>
</li>
              <li>
                <p><a href="#section-2.4-en">2.4</a>.  <a href="#name-using-new-structured-types--en">Using New Structured Types in Extensions</a></p>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-3-en">3</a>.  <a href="#name-structured-data-types-en">Structured Data Types</a></p>
<ul>
<li>
                <p><a href="#section-3.1-en">3.1</a>.  <a href="#name-lists-en">Lists</a></p>
<ul>
<li>
                    <p><a href="#section-3.1.1-en">3.1.1</a>.  <a href="#name-inner-lists-en">Inner Lists</a></p>
</li>
                  <li>
                    <p><a href="#section-3.1.2-en">3.1.2</a>.  <a href="#name-parameters-en">Parameters</a></p>
</li>
                </ul>
</li>
              <li>
                <p><a href="#section-3.2-en">3.2</a>.  <a href="#name-dictionaries-en">Dictionaries</a></p>
</li>
              <li>
                <p><a href="#section-3.3-en">3.3</a>.  <a href="#name-items-en">Items</a></p>
<ul>
<li>
                    <p><a href="#section-3.3.1-en">3.3.1</a>.  <a href="#name-integers-en">Integers</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.2-en">3.3.2</a>.  <a href="#name-decimals-en">Decimals</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.3-en">3.3.3</a>.  <a href="#name-strings-en">Strings</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.4-en">3.3.4</a>.  <a href="#name-tokens-en">Tokens</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.5-en">3.3.5</a>.  <a href="#name-byte-sequences-en">Byte Sequences</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.6-en">3.3.6</a>.  <a href="#name-booleans-en">Booleans</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.7-en">3.3.7</a>.  <a href="#name-dates-en">Dates</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.8-en">3.3.8</a>.  <a href="#name-display-strings-en">Display Strings</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-4-en">4</a>.  <a href="#name-working-with-structured-fie-en">Working with Structured Fields in HTTP</a></p>
<ul>
<li>
                <p><a href="#section-4.1-en">4.1</a>.  <a href="#name-serializing-structured-fiel-en">Serializing Structured Fields</a></p>
<ul>
<li>
                    <p><a href="#section-4.1.1-en">4.1.1</a>.  <a href="#name-serializing-a-list-en">Serializing a List</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.2-en">4.1.2</a>.  <a href="#name-serializing-a-dictionary-en">Serializing a Dictionary</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.3-en">4.1.3</a>.  <a href="#name-serializing-an-item-en">Serializing an Item</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.4-en">4.1.4</a>.  <a href="#name-serializing-an-integer-en">Serializing an Integer</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.5-en">4.1.5</a>.  <a href="#name-serializing-a-decimal-en">Serializing a Decimal</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.6-en">4.1.6</a>.  <a href="#name-serializing-a-string-en">Serializing a String</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.7-en">4.1.7</a>.  <a href="#name-serializing-a-token-en">Serializing a Token</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.8-en">4.1.8</a>.  <a href="#name-serializing-a-byte-sequence-en">Serializing a Byte Sequence</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.9-en">4.1.9</a>.  <a href="#name-serializing-a-boolean-en">Serializing a Boolean</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.10-en">4.1.10</a>. <a href="#name-serializing-a-date-en">Serializing a Date</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.11-en">4.1.11</a>. <a href="#name-serializing-a-display-strin-en">Serializing a Display String</a></p>
</li>
                </ul>
</li>
              <li>
                <p><a href="#section-4.2-en">4.2</a>.  <a href="#name-parsing-structured-fields-en">Parsing Structured Fields</a></p>
<ul>
<li>
                    <p><a href="#section-4.2.1-en">4.2.1</a>.  <a href="#name-parsing-a-list-en">Parsing a List</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.2-en">4.2.2</a>.  <a href="#name-parsing-a-dictionary-en">Parsing a Dictionary</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.3-en">4.2.3</a>.  <a href="#name-parsing-an-item-en">Parsing an Item</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.4-en">4.2.4</a>.  <a href="#name-parsing-an-integer-or-decim-en">Parsing an Integer or Decimal</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.5-en">4.2.5</a>.  <a href="#name-parsing-a-string-en">Parsing a String</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.6-en">4.2.6</a>.  <a href="#name-parsing-a-token-en">Parsing a Token</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.7-en">4.2.7</a>.  <a href="#name-parsing-a-byte-sequence-en">Parsing a Byte Sequence</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.8-en">4.2.8</a>.  <a href="#name-parsing-a-boolean-en">Parsing a Boolean</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.9-en">4.2.9</a>.  <a href="#name-parsing-a-date-en">Parsing a Date</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.10-en">4.2.10</a>. <a href="#name-parsing-a-display-string-en">Parsing a Display String</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-5-en">5</a>.  <a href="#name-iana-considerations-en">IANA Considerations</a></p>
</li>
          <li>
            <p><a href="#section-6-en">6</a>.  <a href="#name-security-considerations-en">Security Considerations</a></p>
</li>
          <li>
            <p><a href="#section-7-en">7</a>.  <a href="#name-references-en">References</a></p>
<ul>
<li>
                <p><a href="#section-7.1-en">7.1</a>.  <a href="#name-normative-references-en">Normative References</a></p>
</li>
              <li>
                <p><a href="#section-7.2-en">7.2</a>.  <a href="#name-informative-references-en">Informative References</a></p>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-appendix.a-en">Appendix A</a>.  <a href="#name-frequently-asked-questions-en">Frequently Asked Questions</a></p>
<ul>
<li>
                <p><a href="#section-appendix.a.1-en">A.1</a>.  <a href="#name-why-not-json-en">Why Not JSON?</a></p>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-appendix.b-en">Appendix B</a>.  <a href="#name-implementation-notes-en">Implementation Notes</a></p>
</li>
          <li>
            <p><a href="#section-appendix.c-en">Appendix C</a>.  <a href="#name-abnf-en">ABNF</a></p>
</li>
          <li>
            <p><a href="#section-appendix.d-en">Appendix D</a>.  <a href="#name-changes-from-rfc-8941-en">Changes from RFC 8941</a></p>
</li>
          <li>
            <p><a href="#section-appendix.e-en"></a><a href="#name-acknowledgements-en">Acknowledgements</a></p>
</li>
          <li>
            <p><a href="#section-appendix.f-en"></a><a href="#name-authors-addresses-en">Authors' Addresses</a></p>
</li>
        </ul></div>
<div lang="ja" class="col"><ul>
<li>
            <p><a href="#section-1-ja">1</a>.  <a href="#name-introduction-ja">Introduction</a></p>
<ul>
<li>
                <p><a href="#section-1.1-ja">1.1</a>.  <a href="#name-intentionally-strict-proces-ja">Intentionally Strict Processing</a></p>
</li>
              <li>
                <p><a href="#section-1.2-ja">1.2</a>.  <a href="#name-notational-conventions-ja">Notational Conventions</a></p>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-2-ja">2</a>.  <a href="#name-defining-new-structured-fie-ja">Defining New Structured Fields</a></p>
<ul>
<li>
                <p><a href="#section-2.1-ja">2.1</a>.  <a href="#name-example-ja">Example</a></p>
</li>
              <li>
                <p><a href="#section-2.2-ja">2.2</a>.  <a href="#name-error-handling-ja">Error Handling</a></p>
</li>
              <li>
                <p><a href="#section-2.3-ja">2.3</a>.  <a href="#name-preserving-extensibility-ja">Preserving Extensibility</a></p>
</li>
              <li>
                <p><a href="#section-2.4-ja">2.4</a>.  <a href="#name-using-new-structured-types--ja">Using New Structured Types in Extensions</a></p>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-3-ja">3</a>.  <a href="#name-structured-data-types-ja">Structured Data Types</a></p>
<ul>
<li>
                <p><a href="#section-3.1-ja">3.1</a>.  <a href="#name-lists-ja">Lists</a></p>
<ul>
<li>
                    <p><a href="#section-3.1.1-ja">3.1.1</a>.  <a href="#name-inner-lists-ja">Inner Lists</a></p>
</li>
                  <li>
                    <p><a href="#section-3.1.2-ja">3.1.2</a>.  <a href="#name-parameters-ja">Parameters</a></p>
</li>
                </ul>
</li>
              <li>
                <p><a href="#section-3.2-ja">3.2</a>.  <a href="#name-dictionaries-ja">Dictionaries</a></p>
</li>
              <li>
                <p><a href="#section-3.3-ja">3.3</a>.  <a href="#name-items-ja">Items</a></p>
<ul>
<li>
                    <p><a href="#section-3.3.1-ja">3.3.1</a>.  <a href="#name-integers-ja">Integers</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.2-ja">3.3.2</a>.  <a href="#name-decimals-ja">Decimals</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.3-ja">3.3.3</a>.  <a href="#name-strings-ja">Strings</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.4-ja">3.3.4</a>.  <a href="#name-tokens-ja">Tokens</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.5-ja">3.3.5</a>.  <a href="#name-byte-sequences-ja">Byte Sequences</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.6-ja">3.3.6</a>.  <a href="#name-booleans-ja">Booleans</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.7-ja">3.3.7</a>.  <a href="#name-dates-ja">Dates</a></p>
</li>
                  <li>
                    <p><a href="#section-3.3.8-ja">3.3.8</a>.  <a href="#name-display-strings-ja">Display Strings</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-4-ja">4</a>.  <a href="#name-working-with-structured-fie-ja">Working with Structured Fields in HTTP</a></p>
<ul>
<li>
                <p><a href="#section-4.1-ja">4.1</a>.  <a href="#name-serializing-structured-fiel-ja">Serializing Structured Fields</a></p>
<ul>
<li>
                    <p><a href="#section-4.1.1-ja">4.1.1</a>.  <a href="#name-serializing-a-list-ja">Serializing a List</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.2-ja">4.1.2</a>.  <a href="#name-serializing-a-dictionary-ja">Serializing a Dictionary</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.3-ja">4.1.3</a>.  <a href="#name-serializing-an-item-ja">Serializing an Item</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.4-ja">4.1.4</a>.  <a href="#name-serializing-an-integer-ja">Serializing an Integer</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.5-ja">4.1.5</a>.  <a href="#name-serializing-a-decimal-ja">Serializing a Decimal</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.6-ja">4.1.6</a>.  <a href="#name-serializing-a-string-ja">Serializing a String</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.7-ja">4.1.7</a>.  <a href="#name-serializing-a-token-ja">Serializing a Token</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.8-ja">4.1.8</a>.  <a href="#name-serializing-a-byte-sequence-ja">Serializing a Byte Sequence</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.9-ja">4.1.9</a>.  <a href="#name-serializing-a-boolean-ja">Serializing a Boolean</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.10-ja">4.1.10</a>. <a href="#name-serializing-a-date-ja">Serializing a Date</a></p>
</li>
                  <li>
                    <p><a href="#section-4.1.11-ja">4.1.11</a>. <a href="#name-serializing-a-display-strin-ja">Serializing a Display String</a></p>
</li>
                </ul>
</li>
              <li>
                <p><a href="#section-4.2-ja">4.2</a>.  <a href="#name-parsing-structured-fields-ja">Parsing Structured Fields</a></p>
<ul>
<li>
                    <p><a href="#section-4.2.1-ja">4.2.1</a>.  <a href="#name-parsing-a-list-ja">Parsing a List</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.2-ja">4.2.2</a>.  <a href="#name-parsing-a-dictionary-ja">Parsing a Dictionary</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.3-ja">4.2.3</a>.  <a href="#name-parsing-an-item-ja">Parsing an Item</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.4-ja">4.2.4</a>.  <a href="#name-parsing-an-integer-or-decim-ja">Parsing an Integer or Decimal</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.5-ja">4.2.5</a>.  <a href="#name-parsing-a-string-ja">Parsing a String</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.6-ja">4.2.6</a>.  <a href="#name-parsing-a-token-ja">Parsing a Token</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.7-ja">4.2.7</a>.  <a href="#name-parsing-a-byte-sequence-ja">Parsing a Byte Sequence</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.8-ja">4.2.8</a>.  <a href="#name-parsing-a-boolean-ja">Parsing a Boolean</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.9-ja">4.2.9</a>.  <a href="#name-parsing-a-date-ja">Parsing a Date</a></p>
</li>
                  <li>
                    <p><a href="#section-4.2.10-ja">4.2.10</a>. <a href="#name-parsing-a-display-string-ja">Parsing a Display String</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-5-ja">5</a>.  <a href="#name-iana-considerations-ja">IANA Considerations</a></p>
</li>
          <li>
            <p><a href="#section-6-ja">6</a>.  <a href="#name-security-considerations-ja">Security Considerations</a></p>
</li>
          <li>
            <p><a href="#section-7-ja">7</a>.  <a href="#name-references-ja">References</a></p>
<ul>
<li>
                <p><a href="#section-7.1-ja">7.1</a>.  <a href="#name-normative-references-ja">Normative References</a></p>
</li>
              <li>
                <p><a href="#section-7.2-ja">7.2</a>.  <a href="#name-informative-references-ja">Informative References</a></p>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-appendix.a-ja">Appendix A</a>.  <a href="#name-frequently-asked-questions-ja">Frequently Asked Questions</a></p>
<ul>
<li>
                <p><a href="#section-appendix.a.1-ja">A.1</a>.  <a href="#name-why-not-json-ja">Why Not JSON?</a></p>
</li>
            </ul>
</li>
          <li>
            <p><a href="#section-appendix.b-ja">Appendix B</a>.  <a href="#name-implementation-notes-ja">Implementation Notes</a></p>
</li>
          <li>
            <p><a href="#section-appendix.c-ja">Appendix C</a>.  <a href="#name-abnf-ja">ABNF</a></p>
</li>
          <li>
            <p><a href="#section-appendix.d-ja">Appendix D</a>.  <a href="#name-changes-from-rfc-8941-ja">Changes from RFC 8941</a></p>
</li>
          <li>
            <p><a href="#section-appendix.e-ja"></a><a href="#name-acknowledgements-ja">Acknowledgements</a></p>
</li>
          <li>
            <p><a href="#section-appendix.f-ja"></a><a href="#name-authors-addresses-ja">Authors' Addresses</a></p>
</li>
        </ul></div>
</div></section><section><span id="introduction-en"></span><span id="introduction-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-introduction-en" lang="en">
<a id="section-1" href="#section-1" class="section-number selfRef">1.</a> <a href="#name-introduction-en" class="section-name selfRef">Introduction</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-introduction-ja" lang="ja">
<a id="section-1" href="#section-1" class="section-number selfRef">1.</a> <a href="#name-introduction-ja" class="section-name selfRef">はじめに</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Specifying the syntax of new HTTP header (and trailer) fields is an onerous task; even with the guidance in <span><a href="https://rfc-editor.org/rfc/rfc9110#section-16.3.2">Section 16.3.2</a> of [<a href="#RFC9110-en">HTTP</a>]</span>, there are many decisions -- and pitfalls -- for a prospective HTTP field author.</p></div>
<div lang="ja" class="col"><p>新しいHTTPヘッダー（とトレーラー）フィールドの構文を指定するのは大変な作業です。<span>[<a href="#RFC9110-ja">HTTP</a>]の<a href="https://rfc-editor.org/rfc/rfc9110#section-16.3.2">Section 16.3.2</a></span>のガイダンスがあったとしても、 これからHTTPフィールドを作ろうとする人にとっては多くの決定事項や落とし穴があります。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Once a field is defined, bespoke parsers and serializers often need to be written, because each field value has a slightly different handling of what looks like common syntax.</p></div>
<div lang="ja" class="col"><p>フィールドが定義されると、特注のパーサーやシリアライザーを作成することが多くあります。 なぜなら、一般的な構文に見えるものであっても、それぞれのフィールドの値は少しことなった扱いをするからです。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This document introduces a set of common data structures for use in definitions of new HTTP field values to address these problems. In particular, it defines a generic, abstract model for them, along with a concrete serialization for expressing that model in HTTP <span>[<a href="#RFC9110-en">HTTP</a>]</span> header and trailer fields.</p></div>
<div lang="ja" class="col"><p>この文書ではこれらの問題に対処するために、 新しいHTTPフィールド値の定義で使用するための一連の共通データ構造を導入します。とくに、HTTP <span>[<a href="#RFC9110-ja">HTTP</a>]</span> のヘッダーとトレーラーフィールドで、 そのモデルを表現するための具体的なシリアライズとともに、それらのための一般的で抽象的なモデルを定義しています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>An HTTP field that is defined as a "Structured Header" or "Structured Trailer" (if the field can be either, it is a "Structured Field") uses the types defined in this specification to define its syntax and basic handling rules, thereby simplifying both its definition by specification writers and handling by implementations.</p></div>
<div lang="ja" class="col"><p>構造化ヘッダー "または "構造化トレーラー "として定義されるHTTPフィールド(どちらにもなりうる場合、それは "構造化フィールド")は、その構文と基本処理規則を定義するためにこの仕様で定義される型を使用し、それによって仕様作成者による定義と実装による処理の両方を単純化します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Additionally, future versions of HTTP can define alternative serializations of the abstract model of these structures, allowing fields that use that model to be transmitted more efficiently without being redefined.</p></div>
<div lang="ja" class="col"><p>さらに、将来のバージョンのHTTPでは、これらの構造の抽象モデルの代替シリアライゼーションを定義することができ、そのモデルを使用するフィールドを再定義することなく、より効率的に伝送することができます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that it is not a goal of this document to redefine the syntax of existing HTTP fields; the mechanisms described herein are only intended to be used with fields that explicitly opt into them.</p></div>
<div lang="ja" class="col"><p>既存のHTTPフィールドの構文を再定義することは、この文書の目的ではないことに注意してください。ここで説明するメカニズムは、明示的にそれらを選択するフィールドでのみ使用することを意図しています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p><a href="#specify-en">Section 2</a> describes how to specify a Structured Field.</p></div>
<div lang="ja" class="col"><p><a href="#specify-ja">Section 2</a> は、構造化フィールドの指定方法について説明しています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p><a href="#types-en">Section 3</a> defines a number of abstract data types that can be used in Structured Fields.</p></div>
<div lang="ja" class="col"><p><a href="#types-ja">Section 3</a> は、構造化フィールドで使用できる多くの抽象的なデータ型を定義しています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Those abstract types can be serialized into and parsed from HTTP field values using the algorithms described in <a href="#text-en">Section 4</a>.</p></div>
<div lang="ja" class="col"><p>これらの抽象型は、<a href="#text-ja">Section 4</a>で説明されているアルゴリズムを使って、HTTP フィールド値にシリアライズしたり、HTTP フィールド値からパースしたりすることができます。</p></div>
</div>
<section><span id="strict-en"></span><span id="strict-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-intentionally-strict-proces-en" lang="en">
<a id="section-1.1" href="#section-1.1" class="section-number selfRef">1.1.</a> <a href="#name-intentionally-strict-proces-en" class="section-name selfRef">Intentionally Strict Processing</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-intentionally-strict-proces-ja" lang="ja">
<a id="section-1.1" href="#section-1.1" class="section-number selfRef">1.1.</a> <a href="#name-intentionally-strict-proces-ja" class="section-name selfRef">意図的に厳密な処理</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This specification intentionally defines strict parsing and serialization behaviors using step-by-step algorithms; the only error handling defined is to fail the entire operation altogether.</p></div>
<div lang="ja" class="col"><p>この仕様では、段階的なアルゴリズムによる厳密な解析と直列化の動作を意図的に定義しており、 定義された唯一のエラー処理は操作を完全に失敗させることです。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>It is designed to encourage faithful implementation and good interoperability. Therefore, an implementation that tried to be helpful by being more tolerant of input would make interoperability worse, since that would create pressure on other implementations to implement similar (but likely subtly different) workarounds.</p></div>
<div lang="ja" class="col"><p>これは、忠実な実装と良好な相互運用性を奨励するために設計されています。 したがって、入力に対してより寛容になることで役に立とうとする実装は、 他の実装に同様の（しかしおそらく微妙に異なる）回避策を実装するように圧力をかけることになり、 相互運用性を悪化させることになります。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>In other words, strict processing is an intentional feature of this specification; it allows non-conformant input to be discovered and corrected by the producer early and avoids both interoperability and security issues that might otherwise result.</p></div>
<div lang="ja" class="col"><p>つまり、厳密な処理は、この仕様の意図的な機能です。準拠していない入力を生産者が早期に発見して修正し、相互運用性やセキュリティー上の問題を回避できます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that as a result of this strictness, if a field is appended to by multiple parties (e.g., intermediaries or different components in the sender), an error in one party's value is likely to cause the entire field value to fail parsing.</p></div>
<div lang="ja" class="col"><p>この厳格さの結果、あるフィールドが複数の関係者（たとえば、仲介者や送信者内の異なるコンポーネント）によって付加される場合、ある関係者の値にエラーがあると、フィールド値全体のパースに失敗する可能性が高いことに注意する必要があります。</p></div>
</div></section><section><span id="notational-conventions-en"></span><span id="notational-conventions-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-notational-conventions-en" lang="en">
<a id="section-1.2" href="#section-1.2" class="section-number selfRef">1.2.</a> <a href="#name-notational-conventions-en" class="section-name selfRef">Notational Conventions</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-notational-conventions-ja" lang="ja">
<a id="section-1.2" href="#section-1.2" class="section-number selfRef">1.2.</a> <a href="#name-notational-conventions-ja" class="section-name selfRef">表記上の注意事項</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>", "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>", "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>", "<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be interpreted as described in BCP 14 <span>[<a href="#RFC2119-en">RFC2119</a>]</span> <span>[<a href="#RFC8174-en">RFC8174</a>]</span> when, and only when, they appear in all capitals, as shown here.</p></div>
<div lang="ja" class="col"><p>キーワード「<span class="bcp14">しなければなりません（MUST）</span>」、「<span class="bcp14">してはなりません（MUST NOT）</span>」、
「<span class="bcp14">要求されています（REQUIRED）</span>」、
「<span class="bcp14">することになります（SHALL）</span>」、「<span class="bcp14">することはありません（SHALL NOT）</span>」、
「<span class="bcp14">すべきです（SHOULD）</span>」、「<span class="bcp14">すべきではありません（SHOULD NOT）</span>」、
「<span class="bcp14">推奨されます（RECOMMENDED）</span>」、「<span class="bcp14">推奨されません（NOT RECOMMENDED）</span>」、
「<span class="bcp14">してもよいです（MAY）</span>」、「<span class="bcp14">選択できます（OPTIONAL）</span>」は、
BCP 14<span>[<a href="#RFC2119-ja">RFC2119</a>]</span> <span>[<a href="#RFC8174-ja">RFC8174</a>]</span> に記載されているとおりに解釈されるものとします。
ただし、ここに示すようにすべて大文字で表示される場合に限ります。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This document uses the VCHAR, SP, DIGIT, ALPHA, and DQUOTE rules from <span>[<a href="#RFC5234-en">RFC5234</a>]</span> to specify characters and/or their corresponding ASCII bytes, depending on context. It uses the tchar and OWS rules from <span>[<a href="#RFC9110-en">HTTP</a>]</span> for the same purpose.</p></div>
<div lang="ja" class="col"><p>この文書では、<span>[<a href="#RFC5234-ja">RFC5234</a>]</span>からVCHAR、SP、DIGIT、ALPHA、およびDQUOTEルールを使用して、文脈に応じて文字および/またはそれに対応するASCIIバイトを指定します。同じ目的で、<span>[<a href="#RFC9110-ja">HTTP</a>]</span>からtcharおよびOWSルールを使用します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This document uses algorithms to specify parsing and serialization behaviors. When parsing from HTTP fields, implementations <span class="bcp14">MUST</span> have behavior that is indistinguishable from following the algorithms.</p></div>
<div lang="ja" class="col"><p>この文書では、解析およびシリアル化の動作を指定するためにアルゴリズムを使用します。HTTPフィールドから解析する場合、実装はアルゴリズムに従うのと区別がつかない動作を<span class="bcp14">しなければなりません（MUST）</span>。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For serialization to HTTP fields, the algorithms define the recommended way to produce them. Implementations <span class="bcp14">MAY</span> vary from the specified behavior so long as the output is still correctly handled by the parsing algorithm described in <a href="#text-parse-en">Section 4.2</a>.</p></div>
<div lang="ja" class="col"><p>HTTPフィールドへのシリアル化については、アルゴリズムはそれらを生成する推奨方法を定義します。実装は、<a href="#text-parse-ja">Section 4.2</a>で説明されている解析アルゴリズムによって出力が正しく処理される限り、指定された動作から変化<span class="bcp14">してもよいです（MAY）</span>。</p></div>
</div></section></section><section><span id="specify-en"></span><span id="specify-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-defining-new-structured-fie-en" lang="en">
<a id="section-2" href="#section-2" class="section-number selfRef">2.</a> <a href="#name-defining-new-structured-fie-en" class="section-name selfRef">Defining New Structured Fields</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-defining-new-structured-fie-ja" lang="ja">
<a id="section-2" href="#section-2" class="section-number selfRef">2.</a> <a href="#name-defining-new-structured-fie-ja" class="section-name selfRef">新しい構造化フィールドを定義する</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>To specify an HTTP field as a Structured Field, its authors need to:</p></div>
<div lang="ja" class="col"><p>HTTP フィールドを Structured Field として指定するために、その作者は以下のことを行う必要があります。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ul>
<li>
          <p>Normatively reference this specification. Recipients and generators of the field need to know that the requirements of this document are in effect.</p>
</li>
        <li>
          <p>Identify whether the field is a Structured Header (i.e., it can only be used in the header section -- the common case), a Structured Trailer (only in the trailer section), or a Structured Field (both).</p>
</li>
        <li>
          <p>Specify the type of the field value; either List (<a href="#list-en">Section 3.1</a>), Dictionary (<a href="#dictionary-en">Section 3.2</a>), or Item (<a href="#item-en">Section 3.3</a>).</p>
</li>
        <li>
          <p>Define the semantics of the field value.</p>
</li>
        <li>
          <p>Specify any additional constraints upon the field value, as well as the consequences when those constraints are violated.</p>
</li>
      </ul></div>
<div lang="ja" class="col"><ul>
<li>
          <p>本仕様書を規範的に参照する。現場の受信者及び生成者は、この文書の要求事項が有効であることを知る必要があります。</p>
</li>
        <li>
          <p>そのフィールドが Structured Header (すなわち、ヘッダーセクションでのみ使用可能。一般的なケース)、 Structured Trailer (トレーラーセクションのみ)、または Structured Field (両方)のいずれであるかを特定する。</p>
</li>
        <li>
          <p>フィールド値の型を指定する。 リスト(<a href="#list-ja">Section 3.1</a>)、辞書(<a href="#dictionary-ja">Section 3.2</a>)、アイテム(<a href="#item-ja">Section 3.3</a>)のいずれかです。</p>
</li>
        <li>
          <p>フィールド値のセマンティクスを定義する。</p>
</li>
        <li>
          <p>フィールド値に対する追加制約を指定する。同様に制約に違反した場合の結果も指定します。</p>
</li>
      </ul></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Typically, this means that a field definition will specify the top-level type -- List, Dictionary, or Item -- and then define its allowable types and constraints upon them. For example, a header defined as a List might have all Integer members, or a mix of types; a header defined as an Item might allow only Strings, and additionally only strings beginning with the letter "Q", or strings in lowercase. Likewise, Inner Lists (<a href="#inner-list-en">Section 3.1.1</a>) are only valid when a field definition explicitly allows them.</p></div>
<div lang="ja" class="col"><p>一般的に、これはフィールド定義が最上位の型（リスト、辞書、アイテム）を指定し、次に許容される型とそれに対する制約を定義することを意味します。 たとえば、リストとして定義されたヘッダーは、すべての整数のメンバを持つか、またはそれらの型が混在するかもしれません。 アイテムとして定義されたヘッダーは、文字列のみを許可し、さらに文字「Q」で始まる文字列や、小文字の文字列のみを許可するかもしれません。同様に、内部リスト (<a href="#inner-list-ja">Section 3.1.1</a>) は、 フィールド定義で明示的に許可されている場合にのみ有効です。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Fields that use the Display String type are advised to carefully specify their allowable Unicode code points; for example, specifying the use of a profile from <span>[<a href="#RFC8264-en">PRECIS</a>]</span>.</p></div>
<div lang="ja" class="col"><p>表示文字列タイプを使用するフィールドは、許可されるUnicodeコードポイントを慎重に指定することが推奨されます。例えば、<span>[<a href="#RFC8264-ja">PRECIS</a>]</span>のプロファイルの使用を指定することが考えられます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Field definitions can only use this specification for the entire field value, not a portion thereof.</p></div>
<div lang="ja" class="col"><p>フィールド定義は、フィールド値全体に対してのみこの仕様を使用でき、一部に対しては使用できません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Specifications can refer to a field name as a "Structured Header name", "Structured Trailer name", or "Structured Field name" as appropriate. Likewise, they can refer its field value as a "Structured Header value", "Structured Trailer value", or "Structured Field value" as necessary.</p></div>
<div lang="ja" class="col"><p>仕様書では、フィールド名を必要に応じて 「構造化ヘッダー名（structured header name）」、「構造化トレーラー名（structured trailer name）」、 「構造化フィールド名（structured field name）」と表記することができます。 同様に必要に応じて、そのフィールド値を「構造化ヘッダー値（structured header value）」、 「構造化トレーラー値（structured trailer value）」または「構造化フィールド値（structured field value）」として参照することができます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This specification defines minimums for the length or number of various structures supported by implementations. It does not specify maximum sizes in most cases, but authors should be aware that HTTP implementations do impose various limits on the size of individual fields, the total number of fields, and/or the size of the entire header or trailer section.</p></div>
<div lang="ja" class="col"><p>この仕様では、実装によってサポートされる様々な構造体の長さや数の最小値を定義しています。 ほとんどの場合、最大サイズは指定しません。しかしHTTPの実装では個々のフィールドのサイズやフィールドの総数、 ヘッダーやトレーラーセクション全体のサイズに様々な制限があることを、作者は知っておくべきです。</p></div>
</div>
<section><span id="example-en"></span><span id="example-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-example-en" lang="en">
<a id="section-2.1" href="#section-2.1" class="section-number selfRef">2.1.</a> <a href="#name-example-en" class="section-name selfRef">Example</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-example-ja" lang="ja">
<a id="section-2.1" href="#section-2.1" class="section-number selfRef">2.1.</a> <a href="#name-example-ja" class="section-name selfRef">例</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>A fictitious Foo-Example header field might be specified as:</p></div>
<div lang="ja" class="col"><p>架空のFoo-Exampleヘッダーフィールドは次のように指定されるかもしれません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><blockquote>
<p>42. Foo-Example Header Field</p>
<p>The Foo-Example HTTP header field conveys information about how
much Foo the message has.</p>
<p>Foo-Example is an Item Structured Header Field [RFC9651]. Its value
<span class="bcp14">MUST</span> be an Integer (Section 3.3.1 of [RFC9651]).</p>
<p>Its value indicates the amount of Foo in the message, and it <span class="bcp14">MUST</span>
be between 0 and 10, inclusive; other values <span class="bcp14">MUST</span> cause
the entire header field to be ignored.</p>
<p>The following parameter is defined:</p>
<ul>
<li>A parameter whose key is "foourl", and whose value is a String
  (Section 3.3.3 of [RFC9651]), conveying the Foo URL
  for the message. See below for processing requirements.</li>
          </ul>
<p>"foourl" contains a URI-reference (Section 4.1 of [RFC3986]). If
its value is not a valid URI-reference, the entire header field
<span class="bcp14">MUST</span> be ignored. If its value is a relative reference (Section 4.2
of [RFC3986]), it <span class="bcp14">MUST</span> be resolved (Section 5 of [RFC3986]) before
being used.</p>
<p>For example:</p>
<div lang=""><pre>
  Foo-Example: 2; foourl="https://foo.example.com/"
</pre></div>
</blockquote></div>
<div lang="ja" class="col"><blockquote>
<p>42. Foo-Example ヘッダーフィールド</p>
<p>Foo-Example HTTPヘッダーフィールドは、メッセージにどれだけのFooがあるかという情報を伝えます。</p>
<p>Foo-Example は Item Structured Header [RFC9651] である。その値は整数(Integer)である<span class="bcp14">必要があります（MUST）</span> ([RFC9651] の Section 3.3.1 参照)。</p>
<p>その値はメッセージ中のFooの量を表し、0から10の間（両端を含む）である<span class="bcp14">必要があります（MUST）</span>。           他の値は、ヘッダーフィールド全体を無視する<span class="bcp14">必要があります（MUST）</span>。</p>
<p>以下のパラメーターが定義されています。</p>
<ul>
<li>キー「foourl」を持つパラメーターの値は文字列（String）([RFC9651] の Section 3.3.3)です。
            メッセージのFoo URLを伝えるために使用されます。処理の要件は以下を参照してください。</li>
          </ul>
<p>「foourl」はURIリファレンス（[RFC3986]のSection 4.1）。 その値が有効なURIリファレンスでない場合、そのヘッダーフィールド全体は無視される<span class="bcp14">必要があります（MUST）</span>。 その値が相対リファレンス（[RFC3986]のSection 5）の場合、使用される前に解決されなければなりません。</p>
<p>例を以下に示します:</p>
<div lang=""><pre>
  Foo-Example: 2; foourl="https://foo.example.com/"
</pre></div>
</blockquote></div>
</div></section><section><span id="error-handling-en"></span><span id="error-handling-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-error-handling-en" lang="en">
<a id="section-2.2" href="#section-2.2" class="section-number selfRef">2.2.</a> <a href="#name-error-handling-en" class="section-name selfRef">Error Handling</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-error-handling-ja" lang="ja">
<a id="section-2.2" href="#section-2.2" class="section-number selfRef">2.2.</a> <a href="#name-error-handling-ja" class="section-name selfRef">エラーハンドリング</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When parsing fails, the entire field is ignored (see <a href="#text-parse-en">Section 4.2</a>). Field definitions cannot override this because doing so would preclude handling by generic software; they can only add additional constraints (for example, on the numeric range of Integers and Decimals, the format of Strings and Tokens, the types allowed in a Dictionary's values, or the number of Items in a List).</p></div>
<div lang="ja" class="col"><p>パースに失敗すると、フィールド全体が無視されます (<a href="#text-parse-ja">Section 4.2</a>参照)。フィールド定義はこれを上書きすることはできません。なぜなら、それを行うと汎用ソフトウェアによる処理ができなくなるからです。フィールド定義は追加の制約を加えることしかできません（例えば、整数や小数の数値範囲、文字列やトークンの形式、辞書の値に許可される型、リスト内の項目数など）。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When field-specific constraints are violated, the entire field is also ignored, unless the field definition defines other handling requirements. For example, if a header field is defined as an Item and required to be an Integer, but a String is received, it should be ignored unless that field's definition explicitly specifies otherwise.</p></div>
<div lang="ja" class="col"><p>フィールド固有の制約が違反された場合、フィールド定義が他の処理要件を定義していない限り、フィールド全体も無視されます。例えば、ヘッダーフィールドがアイテムとして定義され、整数であることが要求されているが、文字列が受信された場合、そのフィールドの定義が明示的に他の処理を指定していない限り、それは無視されるべきです。</p></div>
</div></section><section><span id="preserving-extensibility-en"></span><span id="preserving-extensibility-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-preserving-extensibility-en" lang="en">
<a id="section-2.3" href="#section-2.3" class="section-number selfRef">2.3.</a> <a href="#name-preserving-extensibility-en" class="section-name selfRef">Preserving Extensibility</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-preserving-extensibility-ja" lang="ja">
<a id="section-2.3" href="#section-2.3" class="section-number selfRef">2.3.</a> <a href="#name-preserving-extensibility-ja" class="section-name selfRef">拡張性の保持</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Structured Fields are designed to be extensible because experience has shown that, even when it is not foreseen, it is often necessary to modify and add to the allowable syntax and semantics of a field in a controlled fashion.</p></div>
<div lang="ja" class="col"><p>構造化フィールドは、経験上、予見されていない場合でも、フィールドの許容される構文と意味を制御された方法で変更および追加する必要があることが多いため、拡張可能に設計されています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Both Items and Inner Lists allow Parameters as an extensibility mechanism; this means that their values can later be extended to accommodate more information, if need be. To preserve forward compatibility, field specifications are discouraged from defining the presence of an unrecognized parameter as an error condition.</p></div>
<div lang="ja" class="col"><p>アイテムと内部リストの両方が拡張メカニズムとしてパラメータを許可します。これは、必要に応じて後でその値を拡張してより多くの情報を収容できることを意味します。将来の互換性を維持するために、フィールド仕様では認識されないパラメータの存在をエラー条件として定義することは推奨されません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Field specifications are required to be either an Item, List, or Dictionary to preserve extensibility. Fields that erroneously defined as another type (e.g., Integer) are assumed to be Items (i.e., they allow Parameters).</p></div>
<div lang="ja" class="col"><p>フィールド仕様は、拡張性を保持するために、アイテム、リスト、または辞書のいずれかである必要があります。誤って他のタイプ（例：整数）として定義されたフィールドは、アイテムと見なされます（つまり、パラメータを許可します）。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>To further assure that this extensibility is available in the future, and to encourage consumers to use a complete parser implementation, a field definition can specify that "grease" parameters be added by senders. A specification could stipulate that all parameters that fit a defined pattern are reserved for this use and then encourage them to be sent on some portion of requests. This helps to discourage recipients from writing a parser that does not account for Parameters.</p></div>
<div lang="ja" class="col"><p>将来にわたってこの拡張性が利用可能であることをさらに保証し、消費者が完全なパーサー実装を使用することを奨励するために、フィールド定義では送信者によって「グリース」パラメータが追加されることを指定できます。仕様では、定義されたパターンに適合するすべてのパラメータがこの使用のために予約されていることを規定し、それらが一部のリクエストで送信されることを奨励することができます。これにより、受信者がパラメータを考慮しないパーサーを作成することを防ぐのに役立ちます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Specifications that use Dictionaries can also allow for forward compatibility by requiring that the presence of -- as well as value and type associated with -- unknown keys be ignored. Subsequent specifications can then add additional keys, specifying constraints on them as appropriate.</p></div>
<div lang="ja" class="col"><p>辞書を使用する仕様は、未知のキーの存在、およびそれに関連する値とタイプを無視することを要求することで、将来の互換性を確保することもできます。その後の仕様で追加のキーを追加し、それに適した制約を指定することができます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>An extension to a Structured Field can then require that an entire field value be ignored by a recipient that understands the extension if constraints on the value it defines are not met.</p></div>
<div lang="ja" class="col"><p>構造化フィールドの拡張は、定義された値の制約が満たされない場合に、そのフィールド値全体を理解する受信者によって無視することを要求できます。</p></div>
</div></section><section><span id="using-new-structured-types-in-extensions-en"></span><span id="using-new-structured-types-in-extensions-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-using-new-structured-types--en" lang="en">
<a id="section-2.4" href="#section-2.4" class="section-number selfRef">2.4.</a> <a href="#name-using-new-structured-types--en" class="section-name selfRef">Using New Structured Types in Extensions</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-using-new-structured-types--ja" lang="ja">
<a id="section-2.4" href="#section-2.4" class="section-number selfRef">2.4.</a> <a href="#name-using-new-structured-types--ja" class="section-name selfRef">新しい構造化タイプの拡張での使用</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Because a field definition needs to reference a specific RFC for Structured Fields, the types available for use in its value are limited to those defined in that RFC. For example, a field whose definition references this document can have a value that uses the Date type (<a href="#date-en">Section 3.3.7</a>), whereas a field whose definition references RFC 8941 cannot because it will be treated as invalid (and therefore discarded) by implementations of that specification.</p></div>
<div lang="ja" class="col"><p>フィールド定義が構造化フィールドの特定のRFCを参照する必要があるため、その値に使用できるタイプはそのRFCで定義されたものに限定されます。例えば、この文書を参照するフィールド定義は、Dateタイプ（<a href="#date-ja">Section 3.3.7</a>）を使用する値を持つことができますが、RFC 8941を参照するフィールド定義は、その仕様の実装によって無効（したがって破棄）と見なされるため、使用できません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This limitation also applies to future extensions to a field; for example, a field that is defined with a reference to RFC 8941 cannot use the Date type because some recipients might still be using a parser based on RFC 8941 to process it.</p></div>
<div lang="ja" class="col"><p>この制限は、フィールドの将来の拡張にも適用されます。例えば、RFC 8941を参照して定義されたフィールドは、Dateタイプを使用できません。なぜなら、一部の受信者は依然としてRFC 8941に基づいたパーサーを使用してそれを処理している可能性があるからです。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>However, this document is designed to be backward compatible with RFC 8941; a parser that implements the requirements here can also parse valid Structured Fields whose definitions reference RFC 8941.</p></div>
<div lang="ja" class="col"><p>ただし、この文書はRFC 8941との後方互換性を持つように設計されています。ここでの要件を実装するパーサーは、RFC 8941を参照する定義の有効な構造化フィールドも解析できます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Upgrading a Structured Fields implementation to support a newer revision of the specification (such as this document) brings the possibility that some field values that were invalid according to the earlier RFC might become valid when processed.</p></div>
<div lang="ja" class="col"><p>構造化フィールドの実装を新しい改訂版の仕様（この文書など）に対応するようにアップグレードすると、以前のRFCでは無効とされていたフィールド値が処理時に有効になる可能性があります。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For example, a field instance might contain a syntactically valid Date (<a href="#date-en">Section 3.3.7</a>), even though that field's definition does not accommodate Dates. An implementation based on RFC 8941 would fail parsing such a field instance because it is not defined in that specification. If that implementation were upgraded to this specification, parsing would now succeed. In some cases, the resulting Date value will be rejected by field-specific logic, but values in fields that are otherwise ignored (such as extension parameters) might not be detected, and the field might subsequently be accepted and processed.</p></div>
<div lang="ja" class="col"><p>例えば、フィールドインスタンスが構文的に有効なDate（<a href="#date-ja">Section 3.3.7</a>）を含む場合、そのフィールドの定義がDateを受け入れないにもかかわらずです。RFC 8941に基づく実装は、その仕様で定義されていないため、そのようなフィールドインスタンスの解析に失敗します。その実装がこの仕様にアップグレードされた場合、解析は成功します。一部のケースでは、結果として得られるDate値はフィールド固有のロジックによって拒否されますが、拡張パラメータなどの他のフィールドで無視される値は検出されず、そのフィールドが受け入れられ処理される可能性があります。</p></div>
</div></section></section><section><span id="types-en"></span><span id="types-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-structured-data-types-en" lang="en">
<a id="section-3" href="#section-3" class="section-number selfRef">3.</a> <a href="#name-structured-data-types-en" class="section-name selfRef">Structured Data Types</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-structured-data-types-ja" lang="ja">
<a id="section-3" href="#section-3" class="section-number selfRef">3.</a> <a href="#name-structured-data-types-ja" class="section-name selfRef">構造化データ型</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This section provides an overview of the abstract types that Structured Fields use and gives a brief description and examples of how each of those types are serialized into textual HTTP fields. <a href="#text-en">Section 4</a> specifies the details of how they are parsed from and serialized into textual HTTP fields.</p></div>
<div lang="ja" class="col"><p>このセクションでは、構造化フィールドが使用する抽象型の概要を示し、それぞれの型がテキストHTTPフィールドにシリアル化される方法の簡単な説明と例を示します。<a href="#text-ja">Section 4</a>では、それらがテキストHTTPフィールドから解析され、シリアル化される方法の詳細を指定しています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>In summary:</p></div>
<div lang="ja" class="col"><p>まとめると</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ul>
<li>
          <p>There are three top-level types that an HTTP field can be defined as: Lists, Dictionaries, and Items.</p>
</li>
        <li>
          <p>Lists and Dictionaries are containers; their members can be Items or Inner Lists (which are themselves arrays of Items).</p>
</li>
        <li>
          <p>Both Items and Inner Lists can be Parameterized with key/value pairs.</p>
</li>
      </ul></div>
<div lang="ja" class="col"><ul>
<li>
          <p>HTTPフィールドが定義できるトップレベルの型は3つあります。リスト、ディクショナリ、そしてアイテムです。</p>
</li>
        <li>
          <p>リストとディクショナリはコンテナであり、そのメンバはアイテムまたはインナーリスト（それ自体がアイテムの配列である）であることができます。</p>
</li>
        <li>
          <p>アイテムもインナーリストも、キーと値のペアでパラメーター化することができます。</p>
</li>
      </ul></div>
</div>
<section><span id="list-en"></span><span id="list-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-lists-en" lang="en">
<a id="section-3.1" href="#section-3.1" class="section-number selfRef">3.1.</a> <a href="#name-lists-en" class="section-name selfRef">Lists</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-lists-ja" lang="ja">
<a id="section-3.1" href="#section-3.1" class="section-number selfRef">3.1.</a> <a href="#name-lists-ja" class="section-name selfRef">リスト（List）</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Lists are arrays of zero or more members, each of which can be an Item (<a href="#item-en">Section 3.3</a>) or an Inner List (<a href="#inner-list-en">Section 3.1.1</a>), both of which can be Parameterized (<a href="#param-en">Section 3.1.2</a>).</p></div>
<div lang="ja" class="col"><p>リスト（List）は0個以上のメンバーからなる配列で、 それぞれがアイテム(<a href="#item-ja">Section 3.3</a>)またはインナーリスト(<a href="#inner-list-ja">Section 3.1.1</a>)になります。 どちらもパラメーター化(<a href="#param-ja">Section 3.1.2</a>)することが可能です。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>An empty List is denoted by not serializing the field at all. This implies that fields defined as Lists have a default empty value.</p></div>
<div lang="ja" class="col"><p>空のリストは、フィールドを全くシリアライズしないことで示されます。 これは、リストとして定義されたフィールドは、デフォルトで空の値を持つことを意味します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When serialized as a textual HTTP field, each member is separated by a comma and optional whitespace. For example, a field whose value is defined as a List of Tokens could look like:</p></div>
<div lang="ja" class="col"><p>テキストHTTPフィールドとしてシリアル化されると、各メンバーはカンマとオプションの空白で区切られます。例えば、値がトークンのリストとして定義されているフィールドは次のようになります:</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: sugar, tea, rum
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: sugar, tea, rum
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that Lists can have their members split across multiple lines of the same header or trailer section, as per <span><a href="https://rfc-editor.org/rfc/rfc9110#section-5.3">Section 5.3</a> of [<a href="#RFC9110-en">HTTP</a>]</span>; for example, the following are equivalent:</p></div>
<div lang="ja" class="col"><p>リストは、<span>[<a href="#RFC9110-ja">HTTP</a>]の<a href="https://rfc-editor.org/rfc/rfc9110#section-5.3">Section 5.3</a></span>のように， そのメンバを同じヘッダーやトレーラーセクション内の複数の行に、分割することができることに注意してください。たとえば、以下は等価です:</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: sugar, tea, rum
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: sugar, tea, rum
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>and</p></div>
<div lang="ja" class="col"><p>と</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: sugar, tea
Example-List: rum
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: sugar, tea
Example-List: rum
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>However, individual members of a List cannot be safely split between lines; see <a href="#text-parse-en">Section 4.2</a> for details.</p></div>
<div lang="ja" class="col"><p>ただし、Listの個々のメンバを安全に行に分割することはできません。 詳しくは、<a href="#text-parse-ja">Section 4.2</a>を参照してください。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parsers <span class="bcp14">MUST</span> support Lists containing at least 1024 members. Field specifications can constrain the types and cardinality of individual List values as they require.</p></div>
<div lang="ja" class="col"><p>パーサーは、少なくとも1024個のメンバーを含むListをサポート<span class="bcp14">しなければなりません（MUST）</span>。 フィールドの仕様は、必要に応じて個々のリスト値の型と要素数を制限することができます。</p></div>
</div>
<section><span id="inner-list-en"></span><span id="inner-list-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-inner-lists-en" lang="en">
<a id="section-3.1.1" href="#section-3.1.1" class="section-number selfRef">3.1.1.</a> <a href="#name-inner-lists-en" class="section-name selfRef">Inner Lists</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-inner-lists-ja" lang="ja">
<a id="section-3.1.1" href="#section-3.1.1" class="section-number selfRef">3.1.1.</a> <a href="#name-inner-lists-ja" class="section-name selfRef">インナーリスト（Inner Lists）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>An Inner List is an array of zero or more Items (<a href="#item-en">Section 3.3</a>). Both the individual Items and the Inner List itself can be Parameterized (<a href="#param-en">Section 3.1.2</a>).</p></div>
<div lang="ja" class="col"><p>インナーリスト（Inner List）は、0個以上のアイテム（<a href="#item-ja">Section 3.3</a>)です。個々のItemもInner List自体もパラメーター化することができます(<a href="#param-ja">Section 3.1.2</a>）からなる配列です。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When serialized in a textual HTTP field, Inner Lists are denoted by surrounding parenthesis, and their values are delimited by one or more spaces. A field whose value is defined as a List of Inner Lists of Strings could look like:</p></div>
<div lang="ja" class="col"><p>テキストHTTPフィールドとしてシリアル化されると、内部リストは括弧で囲まれ、その値は1つ以上のスペースで区切られます。値が文字列の内部リストのリストとして定義されているフィールドは次のようになります:</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: ("foo" "bar"), ("baz"), ("bat" "one"), ()
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: ("foo" "bar"), ("baz"), ("bat" "one"), ()
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that the last member in this example is an empty Inner List.</p></div>
<div lang="ja" class="col"><p>この例で、最後のメンバーは空のインナーリストであることに注意してください。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>A header field whose value is defined as a List of Inner Lists with Parameters at both levels could look like:</p></div>
<div lang="ja" class="col"><p>あるヘッダーフィールドがインナーリストのリストとして定義されるとき、 どのレベルでもパラメーターを持つ可能性があります：</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: ("foo"; a=1;b=2);lvl=5, ("bar" "baz");lvl=1
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: ("foo"; a=1;b=2);lvl=5, ("bar" "baz");lvl=1
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parsers <span class="bcp14">MUST</span> support Inner Lists containing at least 256 members. Field specifications can constrain the types and cardinality of individual Inner List members as they require.</p></div>
<div lang="ja" class="col"><p>パーサーは、少なくとも256のメンバーを含むインナーリストをサポート<span class="bcp14">しなければなりません（MUST）</span>。
フィールド仕様は、個々のインナーリストのメンバー型と要素数を、必要に応じて制限することができます。</p></div>
</div></section><section><span id="param-en"></span><span id="param-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parameters-en" lang="en">
<a id="section-3.1.2" href="#section-3.1.2" class="section-number selfRef">3.1.2.</a> <a href="#name-parameters-en" class="section-name selfRef">Parameters</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parameters-ja" lang="ja">
<a id="section-3.1.2" href="#section-3.1.2" class="section-number selfRef">3.1.2.</a> <a href="#name-parameters-ja" class="section-name selfRef">パラメーター（Parameter）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parameters are an ordered map of key-value pairs that are associated with an Item (<a href="#item-en">Section 3.3</a>) or Inner List (<a href="#inner-list-en">Section 3.1.1</a>). The keys are unique within the scope of the Parameters they occur within, and the values are bare items (i.e., they themselves cannot be parameterized; see <a href="#item-en">Section 3.3</a>).</p></div>
<div lang="ja" class="col"><p>パラメーター（Parameter）は、アイテム（<a href="#item-ja">Section 3.3</a> ）または
インナーリスト（<a href="#inner-list-ja">Section 3.1.1</a> ）と関連付けられた、キーと値のペアの順序付きマップです。
キーはパラメーターの範囲内で一意であり、値は裸のアイテムです（つまり、それ自体をパラメーター化することはできません。<a href="#item-ja">Section 3.3</a> を参照してください）。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Implementations <span class="bcp14">MUST</span> provide access to Parameters both by index and by key. Specifications <span class="bcp14">MAY</span> use either means of accessing them.</p></div>
<div lang="ja" class="col"><p>実装は、パラメーターへのアクセス方法として、インデックスとキーの両方を提供<span class="bcp14">しなければなりません（MUST）</span>。
仕様は、どちらかの方法でアクセス<span class="bcp14">してもよいです（MAY）</span>。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that parameters are ordered, and parameter keys cannot contain uppercase letters.</p></div>
<div lang="ja" class="col"><p>パラメーターはシリアライズされた順番で順序付けされ、 パラメーターのキーに大文字を含めることができないことに注意してください。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When serialized in a textual HTTP field, a Parameter is separated from its Item or Inner List and other Parameters by a semicolon. For example:</p></div>
<div lang="ja" class="col"><p>テキストHTTPフィールドとしてシリアル化されると、パラメータはそのアイテムまたは内部リストおよび他のパラメータとセミコロンで区切られます。例えば:</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: abc;a=1;b=2; cde_456, (ghi;jk=4 l);q="9";r=w
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-List: abc;a=1;b=2; cde_456, (ghi;jk=4 l);q="9";r=w
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parameters whose value is Boolean (see <a href="#boolean-en">Section 3.3.6</a>) true <span class="bcp14">MUST</span> omit that value when serialized. For example, the "a" parameter here is true, while the "b" parameter is false:</p></div>
<div lang="ja" class="col"><p>値が真偽値（<a href="#boolean-ja">Section 3.3.6</a> 参照）であるパラメーターは、
シリアライズ時にその値を省略<span class="bcp14">しなければなりません（MUST）</span>。
たとえば、ここで "a "パラメーターはtrueであり、"b "パラメーターはfalseです。</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Integer: 1; a; b=?0
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Integer: 1; a; b=?0
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that this requirement is only on serialization; parsers are still required to correctly handle the true value when it appears in a parameter.</p></div>
<div lang="ja" class="col"><p>この要件はシリアライズに関するものであることに注意してください。
パーサーは、真の値がパラメーターに現れたときに正しく処理することを依然として要求されます</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parsers <span class="bcp14">MUST</span> support at least 256 parameters on an Item or Inner List, and support parameter keys with at least 64 characters. Field specifications can constrain the order of individual parameters, as well as their values' types as required.</p></div>
<div lang="ja" class="col"><p>パーサはItemまたはInner Listで少なくとも256個のパラメーターをサポートし、
少なくとも64文字のパラメーターキーをサポート<span class="bcp14">しなければなりません（MUST）</span>。
フィールド指定は、必要に応じて個々のパラメーターの順序やその値の型を制約することができます。</p></div>
</div></section></section><section><span id="dictionary-en"></span><span id="dictionary-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-dictionaries-en" lang="en">
<a id="section-3.2" href="#section-3.2" class="section-number selfRef">3.2.</a> <a href="#name-dictionaries-en" class="section-name selfRef">Dictionaries</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-dictionaries-ja" lang="ja">
<a id="section-3.2" href="#section-3.2" class="section-number selfRef">3.2.</a> <a href="#name-dictionaries-ja" class="section-name selfRef">辞書（Dictionary）</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Dictionaries are ordered maps of key-value pairs, where the keys are short textual strings and the values are Items (<a href="#item-en">Section 3.3</a>) or arrays of Items, both of which can be Parameterized (<a href="#param-en">Section 3.1.2</a>). There can be zero or more members, and their keys are unique in the scope of the Dictionary they occur within.</p></div>
<div lang="ja" class="col"><p>辞書（Dictionary）はキーと値のペアの順序付きマップであり、
キーは短いテキスト文字列、値はアイテム (<a href="#item-ja">Section 3.3</a>) またはアイテムの配列で、
どちらもパラメーター化 (<a href="#param-ja">Section 3.1.2</a>) が可能です。
メンバーは0個以上存在でき、そのキーは辞書のスコープ内で一意です。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Implementations <span class="bcp14">MUST</span> provide access to Dictionaries both by index and by key. Specifications <span class="bcp14">MAY</span> use either means of accessing the members.</p></div>
<div lang="ja" class="col"><p>実装は辞書へのアクセス方法として、インデックスとキーの両方を提供<span class="bcp14">しなければなりません（MUST）</span>。
仕様は、メンバーへのアクセスにどちらかの手段を使用<span class="bcp14">してもよいです（MAY）</span>。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>As with Lists, an empty Dictionary is represented by omitting the entire field. This implies that fields defined as Dictionaries have a default empty value.</p></div>
<div lang="ja" class="col"><p>リストと同様に、空の辞書はフィールド全体を省略することで表現されます。 これは、ディクショナリとして定義されたフィールドはデフォルトで空の値を持つことを意味します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Typically, a field specification will define the semantics of Dictionaries by specifying the allowed type(s) for individual members by their keys, as well as whether their presence is required or optional. Recipients <span class="bcp14">MUST</span> ignore members whose keys are undefined or unknown, unless the field's specification specifically disallows them.</p></div>
<div lang="ja" class="col"><p>一般的に、フィールド仕様は、キーによって個々のメンバーに許可される型と、
その存在が必須か任意かを指定することによって、辞書のセマンティクスを定義します。
受信者は、フィールドの仕様でとくに禁止されていない限り、キーが未定義または不明のメンバーを無視<span class="bcp14">しなければなりません（MUST）</span>。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When serialized as a textual HTTP field, members are ordered as serialized and separated by a comma with optional whitespace. Member keys cannot contain uppercase characters. Keys and values are separated by "=" (without whitespace). For example:</p></div>
<div lang="ja" class="col"><p>テキストHTTPフィールドとしてシリアル化されると、メンバーはシリアル化された順序で並べられ、カンマとオプションの空白で区切られます。メンバーキーには大文字を含めることはできません。キーと値は"="（空白なし）で区切られます。例えば:</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: en="Applepie", da=:w4ZibGV0w6ZydGU=:
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: en="Applepie", da=:w4ZibGV0w6ZydGU=:
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that in this example, the final "=" is due to the inclusion of a Byte Sequence; see <a href="#binary-en">Section 3.3.5</a>.</p></div>
<div lang="ja" class="col"><p>この例では、最後の"="はバイト列（<a href="#binary-ja">Section 3.3.5</a> を参照）を含むためであることに注意してください。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Members whose value is Boolean (see <a href="#boolean-en">Section 3.3.6</a>) true <span class="bcp14">MUST</span> omit that value when serialized. For example, here both "b" and "c" are true:</p></div>
<div lang="ja" class="col"><p>値が真偽値（<a href="#boolean-ja">Section 3.3.6</a> を参照）であるメンバーは、
シリアライズ時にその値を省略<span class="bcp14">しなければなりません（MUST）</span>。たとえば、以下の例では「b」と「c」の両方がtrueです。</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: a=?0, b, c; foo=bar
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: a=?0, b, c; foo=bar
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that this requirement is only on serialization; parsers are still required to correctly handle the true Boolean value when it appears in Dictionary values.</p></div>
<div lang="ja" class="col"><p>この要件はシリアライズに関するものであることに注意してください。
パーサは、辞書の値に現れる真の真偽値を正しく処理することが、依然として要求されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>A Dictionary with a member whose value is an Inner List of Tokens:</p></div>
<div lang="ja" class="col"><p>以下は、トークンのインナーリストを値とするメンバーを持つ辞書です：</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: rating=1.5, feelings=(joy sadness)
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: rating=1.5, feelings=(joy sadness)
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>A Dictionary with a mix of Items and Inner Lists, some with parameters:</p></div>
<div lang="ja" class="col"><p>以下は、アイテムとインナーリストが混在する辞書で、一部のメンバーはパラメーターを持ちます：</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that Dictionaries can have their members split across multiple lines of the same header or trailer section; for example, the following are equivalent:</p></div>
<div lang="ja" class="col"><p>なお、辞書は、そのメンバを同じヘッダーやトレーラーセクションの複数の行に分割することができます。
たとえば、次のものは同等です：</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: foo=1, bar=2
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: foo=1, bar=2
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>and</p></div>
<div lang="ja" class="col"><p>と</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: foo=1
Example-Dict: bar=2
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Dict: foo=1
Example-Dict: bar=2
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>However, individual members of a Dictionary cannot be safely split between lines; see <a href="#text-parse-en">Section 4.2</a> for details.</p></div>
<div lang="ja" class="col"><p>ただし、辞書の個々のメンバーを安全に行に分割することはできません。
詳しくは<a href="#text-parse-ja">Section 4.2</a> を参照してください。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parsers <span class="bcp14">MUST</span> support Dictionaries containing at least 1024 key/value pairs and keys with at least 64 characters. Field specifications can constrain the order of individual Dictionary members, as well as their values' types as required.</p></div>
<div lang="ja" class="col"><p>パーサーは、少なくとも1024のキー/値ペアと、
少なくとも64文字のキーを含む辞書をサポート<span class="bcp14">しなければなりません（MUST）</span>。
フィールド指定は、必要に応じて値の型と、個々の辞書メンバーの順序を制限することができます。</p></div>
</div></section><section><span id="item-en"></span><span id="item-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-items-en" lang="en">
<a id="section-3.3" href="#section-3.3" class="section-number selfRef">3.3.</a> <a href="#name-items-en" class="section-name selfRef">Items</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-items-ja" lang="ja">
<a id="section-3.3" href="#section-3.3" class="section-number selfRef">3.3.</a> <a href="#name-items-ja" class="section-name selfRef">アイテム（Item）</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>An Item can be an Integer (<a href="#integer-en">Section 3.3.1</a>), a Decimal (<a href="#decimal-en">Section 3.3.2</a>), a String (<a href="#string-en">Section 3.3.3</a>), a Token (<a href="#token-en">Section 3.3.4</a>), a Byte Sequence (<a href="#binary-en">Section 3.3.5</a>), a Boolean (<a href="#boolean-en">Section 3.3.6</a>), or a Date (<a href="#date-en">Section 3.3.7</a>). It can have associated parameters (<a href="#param-en">Section 3.1.2</a>).</p></div>
<div lang="ja" class="col"><p>アイテム（Item）は、 整数(<a href="#integer-ja">Section 3.3.1</a>)、小数(<a href="#decimal-ja">Section 3.3.2</a>)、文字列(<a href="#string-ja">Section 3.3.3</a>)、トークン(<a href="#token-ja">Section 3.3.4</a>)、バイト列(<a href="#binary-ja">Section 3.3.5</a>)、真偽値(<a href="#boolean-ja">Section 3.3.6</a>)、日付(<a href="#date-ja">Section 3.3.7</a>)のいずれかを表します。また、関連するパラメーター(<a href="#param-ja">Section 3.1.2</a>)を持つことも可能です。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For example, a header field that is defined to be an Item that is an Integer might look like:</p></div>
<div lang="ja" class="col"><p>たとえば、アイテムが整数であると定義されたヘッダーフィールドは、以下のようになります。</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Integer: 5
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Integer: 5
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>or with parameters:</p></div>
<div lang="ja" class="col"><p>また、パラメーターで指定した場合です：</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Integer: 5; foo=bar
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Integer: 5; foo=bar
</pre></div>
        </div>
</div>
<section><span id="integer-en"></span><span id="integer-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-integers-en" lang="en">
<a id="section-3.3.1" href="#section-3.3.1" class="section-number selfRef">3.3.1.</a> <a href="#name-integers-en" class="section-name selfRef">Integers</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-integers-ja" lang="ja">
<a id="section-3.3.1" href="#section-3.3.1" class="section-number selfRef">3.3.1.</a> <a href="#name-integers-ja" class="section-name selfRef">整数（Integer）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Integers have a range of -999,999,999,999,999 to 999,999,999,999,999 inclusive (i.e., up to fifteen digits, signed), for IEEE 754 compatibility <span>[<a href="#IEEE754-en">IEEE754</a>]</span>.</p></div>
<div lang="ja" class="col"><p>整数（Integer）は、IEEE754互換<span>[<a href="#IEEE754-ja">IEEE754</a>]</span>のため、
  -999,999,999,999～999,999,999の範囲（すなわち最大15桁、符号あり）を持ちます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For example:</p></div>
<div lang="ja" class="col"><p>以下に例を示します：</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Integer: 42
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Integer: 42
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Integers larger than 15 digits can be supported in a variety of ways; for example, by using a String (<a href="#string-en">Section 3.3.3</a>), a Byte Sequence (<a href="#binary-en">Section 3.3.5</a>), or a parameter on an Integer that acts as a scaling factor.</p></div>
<div lang="ja" class="col"><p>15桁より大きい整数については、
様々な方法でサポートすることができます。
たとえば、文字列(<a href="#string-ja">Section 3.3.3</a>)、
バイト列(<a href="#binary-ja">Section 3.3.5</a>)、
またはスケーリングファクターとして機能する整数のパラメーターを使用することで対応できます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>While it is possible to serialize Integers with leading zeros (e.g., "0002", "-01") and signed zero ("-0"), these distinctions may not be preserved by implementations.</p></div>
<div lang="ja" class="col"><p>整数を先行ゼロ（「0002」、「-01」など）や符号付きゼロ（「-0」）でシリアライズすることは可能ですが、
実装によってはこれらの区別が保持されない可能性があります。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that commas in Integers are used in this section's prose only for readability; they are not valid in the wire format.</p></div>
<div lang="ja" class="col"><p>整数のカンマは、本セクションの文中では読みやすくするためにのみ使用していることに注意してください。wireフォーマットでは無効です。</p></div>
</div></section><section><span id="decimal-en"></span><span id="decimal-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-decimals-en" lang="en">
<a id="section-3.3.2" href="#section-3.3.2" class="section-number selfRef">3.3.2.</a> <a href="#name-decimals-en" class="section-name selfRef">Decimals</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-decimals-ja" lang="ja">
<a id="section-3.3.2" href="#section-3.3.2" class="section-number selfRef">3.3.2.</a> <a href="#name-decimals-ja" class="section-name selfRef">小数（Decimal）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Decimals are numbers with an integer and a fractional component. The integer component has at most 12 digits; the fractional component has at most three digits.</p></div>
<div lang="ja" class="col"><p>小数（Decimal）は、整数部と小数部を持つ数です。 整数部は最大12桁、小数部は最大3桁です。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For example, a header whose value is defined as a Decimal could look like:</p></div>
<div lang="ja" class="col"><p>たとえば、値が小数として定義されているヘッダーは、以下のようになります。</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Decimal: 4.5
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Decimal: 4.5
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>While it is possible to serialize Decimals with leading zeros (e.g., "0002.5", "-01.334"), trailing zeros (e.g., "5.230", "-0.40"), and signed zero (e.g., "-0.0"), these distinctions may not be preserved by implementations.</p></div>
<div lang="ja" class="col"><p>先行するゼロ（たとえば、「0002.5」、「-01.334」）、後続するゼロ(たとえば、「5.230」「-0.40」) および符号付きゼロ (たとえば「-0.0」) は
小数へシリアライズできる一方で、実装によってこれらの区別が維持されない可能性があります。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that the serialization algorithm (<a href="#ser-decimal-en">Section 4.1.5</a>) rounds input with more than three digits of precision in the fractional component. If an alternative rounding strategy is desired, this should be specified by the field definition to occur before serialization.</p></div>
<div lang="ja" class="col"><p>シリアライズアルゴリズム(<a href="#ser-decimal-ja">Section 4.1.5</a>)は、
小数部の精度が3桁以上の入力を丸めることに注意してください。
もし別の丸め方をしたい場合は、ヘッダー定義でシリアライズの前に指定する必要があります。</p></div>
</div></section><section><span id="string-en"></span><span id="string-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-strings-en" lang="en">
<a id="section-3.3.3" href="#section-3.3.3" class="section-number selfRef">3.3.3.</a> <a href="#name-strings-en" class="section-name selfRef">Strings</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-strings-ja" lang="ja">
<a id="section-3.3.3" href="#section-3.3.3" class="section-number selfRef">3.3.3.</a> <a href="#name-strings-ja" class="section-name selfRef">文字列（String）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Strings are zero or more printable ASCII <span>[<a href="#RFC0020-en">RFC0020</a>]</span> characters (i.e., the range %x20 to %x7E). Note that this excludes tabs, newlines, carriage returns, etc.</p></div>
<div lang="ja" class="col"><p>文字列（String）は、0個以上の印刷可能なASCII<span>[<a href="#RFC0020-ja">RFC0020</a>]</span> 文字（すなわち、%x20 から %x7E の範囲）です。
タブ、改行、キャリッジリターンなどは含まれないことに注意してください。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Non-ASCII characters are not directly supported in Strings because they cause a number of interoperability issues, and -- with few exceptions -- field values do not require them.</p></div>
<div lang="ja" class="col"><p>非ASCII文字は、いくつかの相互運用性の問題を引き起こすため、文字列では直接サポートされていません。そして、いくつかの例外を除いて、フィールド値はそれらを必要としません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When it is necessary for a field value to convey non-ASCII content, a Display String (<a href="#displaystring-en">Section 3.3.8</a>) can be specified.</p></div>
<div lang="ja" class="col"><p>フィールド値が非ASCIIコンテンツを伝える必要がある場合、表示文字列（<a href="#displaystring-ja">Section 3.3.8</a>)を指定できます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When serialized in a textual HTTP field, Strings are delimited with double quotes, using a backslash ("\") to escape double quotes and backslashes. For example:</p></div>
<div lang="ja" class="col"><p>テキストHTTPフィールドとしてシリアル化されると、文字列は二重引用符で区切られ、バックスラッシュ（"\"）を使用して二重引用符とバックスラッシュをエスケープします。例えば:</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-String: "hello world"
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-String: "hello world"
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that Strings only use DQUOTE as a delimiter; single quotes do not delimit Strings. Furthermore, only DQUOTE and "\" can be escaped; other characters after "\" <span class="bcp14">MUST</span> cause parsing to fail.</p></div>
<div lang="ja" class="col"><p>文字列の区切り文字はDQUOTEのみで、シングルクォートでは区切りらないので注意してください。
また、エスケープできるのはDQUOTEと「\」だけで、それ以外の文字はパースに失敗<span class="bcp14">しなければなりません（MUST）</span></p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parsers <span class="bcp14">MUST</span> support Strings (after any decoding) with at least 1024 characters.</p></div>
<div lang="ja" class="col"><p>パーサーは、少なくとも1024文字の文字列（デコード後）をサポート<span class="bcp14">しなければなりません（MUST）</span>。</p></div>
</div></section><section><span id="token-en"></span><span id="token-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-tokens-en" lang="en">
<a id="section-3.3.4" href="#section-3.3.4" class="section-number selfRef">3.3.4.</a> <a href="#name-tokens-en" class="section-name selfRef">Tokens</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-tokens-ja" lang="ja">
<a id="section-3.3.4" href="#section-3.3.4" class="section-number selfRef">3.3.4.</a> <a href="#name-tokens-ja" class="section-name selfRef">トークン（Token）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Tokens are short textual words that begin with an alphabetic character or "*", followed by zero to many token characters, which are the same as those allowed by the "token" ABNF rule defined in <span>[<a href="#RFC9110-en">HTTP</a>]</span> plus the ":" and "/" characters.</p></div>
<div lang="ja" class="col"><p>トークンは、アルファベット文字または"*"で始まり、その後にゼロ個以上のトークン文字が続く短いテキスト単語です。トークン文字は、<span>[<a href="#RFC9110-ja">HTTP</a>]</span>で定義された"token" ABNFルールで許可される文字に加えて、":"および"/"文字も含まれます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For example:</p></div>
<div lang="ja" class="col"><p>例えば:</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Token: foo123/456
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Token: foo123/456
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parsers <span class="bcp14">MUST</span> support Tokens with at least 512 characters.</p></div>
<div lang="ja" class="col"><p>パーサーは少なくとも512文字のトークンをサポート<span class="bcp14">しなければなりません（MUST）</span>。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that Tokens are defined largely for compatibility with the data model of existing HTTP fields and may require additional steps to use in some implementations. As a result, new fields are encouraged to use Strings.</p></div>
<div lang="ja" class="col"><p>トークンは、既存のHTTPフィールドのデータモデルとの互換性のために定義されており、一部の実装では使用するために追加の手順が必要になる場合があります。その結果、新しいフィールドは文字列を使用することが推奨されます。</p></div>
</div></section><section><span id="binary-en"></span><span id="binary-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-byte-sequences-en" lang="en">
<a id="section-3.3.5" href="#section-3.3.5" class="section-number selfRef">3.3.5.</a> <a href="#name-byte-sequences-en" class="section-name selfRef">Byte Sequences</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-byte-sequences-ja" lang="ja">
<a id="section-3.3.5" href="#section-3.3.5" class="section-number selfRef">3.3.5.</a> <a href="#name-byte-sequences-ja" class="section-name selfRef">バイト列（Byte Sequence）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Byte Sequences can be conveyed in Structured Fields.</p></div>
<div lang="ja" class="col"><p>バイト列（Byte Sequence）を、構造化フィールドで伝えることができます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When serialized in a textual HTTP field, a Byte Sequence is delimited with colons and encoded using base64 (<span>[<a href="#RFC4648-en">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-4">Section 4</a></span>). For example:</p></div>
<div lang="ja" class="col"><p>テキストHTTPフィールドとしてシリアル化されると、バイトシーケンスはコロンで区切られ、base64（<span>[<a href="#RFC4648-ja">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-4">Section 4</a></span>）を使用してエンコードされます。例えば:</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-ByteSequence: :cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==:
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-ByteSequence: :cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==:
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parsers <span class="bcp14">MUST</span> support Byte Sequences with at least 16384 octets after decoding.</p></div>
<div lang="ja" class="col"><p>パーサーは、デコード後に少なくとも16384オクテットのバイト列をサポート<span class="bcp14">しなければなりません（MUST）</span>。</p></div>
</div></section><section><span id="boolean-en"></span><span id="boolean-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-booleans-en" lang="en">
<a id="section-3.3.6" href="#section-3.3.6" class="section-number selfRef">3.3.6.</a> <a href="#name-booleans-en" class="section-name selfRef">Booleans</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-booleans-ja" lang="ja">
<a id="section-3.3.6" href="#section-3.3.6" class="section-number selfRef">3.3.6.</a> <a href="#name-booleans-ja" class="section-name selfRef">真偽値（Boolean）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Boolean values can be conveyed in Structured Fields.</p></div>
<div lang="ja" class="col"><p>真偽値（Boolean）を構造化フィールドで伝えることができます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When serialized in a textual HTTP field, a Boolean is indicated with a leading "?" character followed by a "1" for a true value or "0" for false. For example:</p></div>
<div lang="ja" class="col"><p>テキストHTTPフィールドとしてシリアル化されると、ブール値は先頭に"?"文字が付き、trueの場合は"1"、falseの場合は"0"が続きます。例えば:</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Boolean: ?1
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Boolean: ?1
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that in Dictionary (<a href="#dictionary-en">Section 3.2</a>) and Parameter (<a href="#param-en">Section 3.1.2</a>) values, Boolean true is indicated by omitting the value.</p></div>
<div lang="ja" class="col"><p>なお、辞書(<a href="#dictionary-ja">Section 3.2</a>)およびパラメーター(<a href="#param-ja">Section 3.1.2</a>)の値では、
ブール値の真は値を省略することで表されます。</p></div>
</div></section><section><span id="date-en"></span><span id="date-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-dates-en" lang="en">
<a id="section-3.3.7" href="#section-3.3.7" class="section-number selfRef">3.3.7.</a> <a href="#name-dates-en" class="section-name selfRef">Dates</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-dates-ja" lang="ja">
<a id="section-3.3.7" href="#section-3.3.7" class="section-number selfRef">3.3.7.</a> <a href="#name-dates-ja" class="section-name selfRef">日付（Date）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Date values can be conveyed in Structured Fields.</p></div>
<div lang="ja" class="col"><p>日付（Date）を構造化フィールドで伝えることができます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Dates have a data model that is similar to Integers, representing a (possibly negative) delta in seconds from 1970-01-01T00:00:00Z, excluding leap seconds. Accordingly, their serialization in textual HTTP fields is similar to that of Integers, distinguished from them with a leading "@".</p></div>
<div lang="ja" class="col"><p>日付は整数に似たデータモデルを持ち、1970-01-01T00:00:00Zからの秒単位の（場合によっては負の）差分を表し、うるう秒を除きます。したがって、テキストHTTPフィールドでのシリアル化は整数に似ていますが、先頭に"@"が付いていることで区別されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For example:</p></div>
<div lang="ja" class="col"><p>たとえば：</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Date: @1659578233
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-Date: @1659578233
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parsers <span class="bcp14">MUST</span> support Dates whose values include all days in years 1 to 9999 (i.e., -62,135,596,800 to 253,402,214,400 delta seconds from 1970-01-01T00:00:00Z).</p></div>
<div lang="ja" class="col"><p>パーサーは、値が1年から9999年のすべての日を含む日付をサポート<span class="bcp14">しなければなりません（MUST）</span>（つまり、1970-01-01T00:00:00Zからのデルタ秒が-62,135,596,800から253,402,214,400まで）。</p></div>
</div></section><section><span id="displaystring-en"></span><span id="displaystring-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-display-strings-en" lang="en">
<a id="section-3.3.8" href="#section-3.3.8" class="section-number selfRef">3.3.8.</a> <a href="#name-display-strings-en" class="section-name selfRef">Display Strings</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-display-strings-ja" lang="ja">
<a id="section-3.3.8" href="#section-3.3.8" class="section-number selfRef">3.3.8.</a> <a href="#name-display-strings-ja" class="section-name selfRef">表示文字列（Display String）</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Display Strings are similar to Strings, in that they consist of zero or more characters, but they allow Unicode scalar values (i.e., all Unicode code points except for surrogates), unlike Strings.</p></div>
<div lang="ja" class="col"><p>表示文字列は文字列に似ており、ゼロ個以上の文字で構成されますが、文字列とは異なり、Unicodeスカラー値（つまり、サロゲートを除くすべてのUnicodeコードポイント）を許可します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Display Strings are intended for use in cases where a value is displayed to end users and therefore may need to carry non-ASCII content. It is <span class="bcp14">NOT RECOMMENDED</span> that they be used in situations where a String (<a href="#string-en">Section 3.3.3</a>) or Token (<a href="#token-en">Section 3.3.4</a>) would be adequate because Unicode has processing considerations (e.g., normalization) and security considerations (e.g., homograph attacks) that make it more difficult to handle correctly.</p></div>
<div lang="ja" class="col"><p>表示文字列は、値がエンドユーザーに表示される場合に使用されることを意図しており、非ASCIIコンテンツを含む必要がある場合があります。文字列（<a href="#string-ja">Section 3.3.3</a>)やトークン（<a href="#token-ja">Section 3.3.4</a>)で十分な場合には、表示文字列を使用することは<span class="bcp14">推奨されません（NOT RECOMMENDED）</span>。なぜなら、Unicodeには処理上の考慮事項（例：正規化）やセキュリティ上の考慮事項（例：同形異義攻撃）があり、正しく処理するのが難しいからです。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that Display Strings do not indicate the language used in the value; that can be done separately if necessary (e.g., with a parameter).</p></div>
<div lang="ja" class="col"><p>表示文字列は、値に使用されている言語を示すものではないことに注意してください。必要に応じて、別途（例えば、パラメータで）行うことができます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>In textual HTTP fields, Display Strings are represented in a manner similar to Strings, except that non-ASCII characters are percent-encoded; there is a leading "%" to distinguish them from Strings.</p></div>
<div lang="ja" class="col"><p>テキストHTTPフィールドでは、表示文字列は文字列と同様に表現されますが、非ASCII文字はパーセントエンコードされます。文字列と区別するために先頭に"%"が付きます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For example:</p></div>
<div lang="ja" class="col"><p>たとえば：</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-DisplayString: %"This is intended for display to %c3%bcsers."
</pre></div>
          </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-DisplayString: %"This is intended for display to %c3%bcsers."
</pre></div>
          </div>
</div>
<div class="row">
<div lang="en" class="col"><p>See <a href="#security-en">Section 6</a> for additional security considerations when handling Display Strings.</p></div>
<div lang="ja" class="col"><p>表示文字列を扱う際の追加のセキュリティ考慮事項については、<a href="#security-ja">Section 6</a>を参照してください。</p></div>
</div></section></section></section><section><span id="text-en"></span><span id="text-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-working-with-structured-fie-en" lang="en">
<a id="section-4" href="#section-4" class="section-number selfRef">4.</a> <a href="#name-working-with-structured-fie-en" class="section-name selfRef">Working with Structured Fields in HTTP</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-working-with-structured-fie-ja" lang="ja">
<a id="section-4" href="#section-4" class="section-number selfRef">4.</a> <a href="#name-working-with-structured-fie-ja" class="section-name selfRef">HTTPにおける構造化フィールドとの連携</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This section defines how to serialize and parse the abstract types defined by <a href="#types-en">Section 3</a> into textual HTTP field values and other encodings compatible with them (e.g., in HTTP/2 <span>[<a href="#RFC9113-en">HTTP/2</a>]</span> before compression with HPACK <span>[<a href="#RFC7541-en">HPACK</a>]</span>).</p></div>
<div lang="ja" class="col"><p>このセクションでは、<a href="#types-ja">Section 3</a>で定義された抽象型をテキストHTTPフィールド値およびそれらと互換性のある他のエンコーディング（例：HTTP/2 <span>[<a href="#RFC9113-ja">HTTP/2</a>]</span>でのHPACK <span>[<a href="#RFC7541-ja">HPACK</a>]</span>による圧縮前）にシリアライズおよびパースする方法を定義します。</p></div>
</div>
<section><span id="text-serialize-en"></span><span id="text-serialize-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-serializing-structured-fiel-en" lang="en">
<a id="section-4.1" href="#section-4.1" class="section-number selfRef">4.1.</a> <a href="#name-serializing-structured-fiel-en" class="section-name selfRef">Serializing Structured Fields</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-serializing-structured-fiel-ja" lang="ja">
<a id="section-4.1" href="#section-4.1" class="section-number selfRef">4.1.</a> <a href="#name-serializing-structured-fiel-ja" class="section-name selfRef">構造化フィールドのシリアライズ</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given a structure defined in this specification, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>本仕様書で定義された構造体が与えられた場合、HTTPフィールド値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
            <p>If the structure is a Dictionary or List and its value is empty (i.e., it has no members), do not serialize the field at all (i.e., omit both the field-name and field-value).</p>
</li>
          <li>
            <p>If the structure is a List, let output_string be the result of running Serializing a List (<a href="#ser-list-en">Section 4.1.1</a>) with the structure.</p>
</li>
          <li>
            <p>Else, if the structure is a Dictionary, let output_string be the result of running Serializing a Dictionary (<a href="#ser-dictionary-en">Section 4.1.2</a>) with the structure.</p>
</li>
          <li>
            <p>Else, if the structure is an Item, let output_string be the result of running Serializing an Item (<a href="#ser-item-en">Section 4.1.3</a>) with the structure.</p>
</li>
          <li>
            <p>Else, fail serialization.</p>
</li>
          <li>
            <p>Return output_string converted into an array of bytes, using ASCII encoding <span>[<a href="#RFC0020-en">RFC0020</a>]</span>.</p>
</li>
        </ol></div>
<div lang="ja" class="col"><ol>
<li>
            <p>構造体が辞書またはリストであり、その値が空である場合（つまり、メンバーを持たない場合）、 そのフィールドは一切シリアライズしません（つまりfield-nameとfield-valueの両方を省略します）。</p>
</li>
          <li>
            <p>構造体がリストの場合、 その構造体に対して、リストのシリアライズ（<a href="#ser-list-ja">Section 4.1.1</a>）を実行した結果を、output_stringとします。</p>
</li>
          <li>
            <p>構造体が辞書の場合、 その構造体に対して、辞書のシリアライズ（<a href="#ser-dictionary-ja">Section 4.1.2</a>）を実行した結果を、output_stringとします。</p>
</li>
          <li>
            <p>構造体がアイテムの場合、 その構造体に対して、アイテムのシリアライズ（<a href="#ser-item-ja">Section 4.1.3</a>）を実行した結果を、output_stringとします。</p>
</li>
          <li>
            <p>それ以外の場合は失敗します。</p>
</li>
          <li>
            <p>output_stringをASCIIエンコーディング<span>[<a href="#RFC0020-ja">RFC0020</a>]</span>を用いて、 バイト配列に変換した結果を返します。</p>
</li>
        </ol></div>
</div>
<section><span id="ser-list-en"></span><span id="ser-list-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-a-list-en" lang="en">
<a id="section-4.1.1" href="#section-4.1.1" class="section-number selfRef">4.1.1.</a> <a href="#name-serializing-a-list-en" class="section-name selfRef">Serializing a List</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-a-list-ja" lang="ja">
<a id="section-4.1.1" href="#section-4.1.1" class="section-number selfRef">4.1.1.</a> <a href="#name-serializing-a-list-ja" class="section-name selfRef">リストのシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an array of (member_value, parameters) tuples as input_list, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>input_list として (member_value, parameters) タプルの配列が与えられた場合、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Let output be an empty string.</p>
</li>
            <li>
              <p>For each (member_value, parameters) of input_list:
              </p>
<ol>
<li>
                  <p>If member_value is an array, append the result of running Serializing an Inner List (<a href="#ser-innerlist-en">Section 4.1.1.1</a>) with (member_value, parameters) to output.</p>
</li>
                <li>
                  <p>Otherwise, append the result of running Serializing an Item (<a href="#ser-item-en">Section 4.1.3</a>) with (member_value, parameters) to output.</p>
</li>
                <li>
                  <p>If more member_values remain in input_list:
                  </p>
<ol>
<li>
                      <p>Append "," to output.</p>
</li>
                    <li>
                      <p>Append a single SP to output.</p>
</li>
                  </ol>
</li>
              </ol>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>outputに空文字列を代入します。</p>
</li>
            <li>
              <p>input_list の各（member_value, parameters）に対して：
              </p>
<ol>
<li>
                  <p>member_valueが配列の場合、 (member_value, parameters)に対して、インナーリストのシリアライズ（<a href="#ser-innerlist-ja">Section 4.1.1.1</a>） を実行した結果を、outputに追加します。</p>
</li>
                <li>
                  <p>それ以外の場合、 (member_value, parameters)に対して、アイテムのシリアライズ（<a href="#ser-item-ja">Section 4.1.3</a>） を実行した結果を、outputに追加します。</p>
</li>
                <li>
                  <p>input_list にさらに member_value が残っている場合：
                  </p>
<ol>
<li>
                      <p>「,」をoutputに追加します。</p>
</li>
                    <li>
                      <p>ひとつのSPをoutput追加します。</p>
</li>
                  </ol>
</li>
              </ol>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div>
<section><span id="ser-innerlist-en"></span><span id="ser-innerlist-ja"></span><div class="row">
<div lang="en" class="col"><h5 id="name-serializing-an-inner-list-en" lang="en">
<a id="section-4.1.1.1" href="#section-4.1.1.1" class="section-number selfRef">4.1.1.1.</a> <a href="#name-serializing-an-inner-list-en" class="section-name selfRef">Serializing an Inner List</a>
            </h5></div>
<div lang="ja" class="col"><h5 id="name-serializing-an-inner-list-ja" lang="ja">
<a id="section-4.1.1.1" href="#section-4.1.1.1" class="section-number selfRef">4.1.1.1.</a> <a href="#name-serializing-an-inner-list-ja" class="section-name selfRef">インナーリストのシリアライズ</a>
            </h5></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an array of (member_value, parameters) tuples as inner_list, and parameters as list_parameters, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>(member_value, parameters) タプルの配列を inner_list、 パラメーターを list_parameters として与えたとき、HTTP フィールドの値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
                <p>Let output be the string "(".</p>
</li>
              <li>
                <p>For each (member_value, parameters) of inner_list:
                </p>
<ol>
<li>
                    <p>Append the result of running Serializing an Item (<a href="#ser-item-en">Section 4.1.3</a>) with (member_value, parameters) to output.</p>
</li>
                  <li>
                    <p>If more values remain in inner_list, append a single SP to output.</p>
</li>
                </ol>
</li>
              <li>
                <p>Append ")" to output.</p>
</li>
              <li>
                <p>Append the result of running Serializing Parameters (<a href="#ser-params-en">Section 4.1.1.2</a>) with list_parameters to output.</p>
</li>
              <li>
                <p>Return output.</p>
</li>
            </ol></div>
<div lang="ja" class="col"><ol>
<li>
                <p>outputに「(」を代入します。</p>
</li>
              <li>
                <p>inner_listの各(member_value, parameters)に対して：
                </p>
<ol>
<li>
                    <p>(member_value, parameters)に対して、 アイテムのシリアライズ（<a href="#ser-item-ja">Section 4.1.3</a>）を実行した結果を、 outputに追加します。</p>
</li>
                  <li>
                    <p>まだinner_listに要素が残っている場合、outputにSPをひとつ追加します。</p>
</li>
                </ol>
</li>
              <li>
                <p>outputに「)」を追加します。</p>
</li>
              <li>
                <p>list_parametersに対して、 パラメーターのシリアライズ（<a href="#ser-params-ja">Section 4.1.1.2</a>）を実行した結果を、 outputに追加します。</p>
</li>
              <li>
                <p>outputを返します。</p>
</li>
            </ol></div>
</div></section><section><span id="ser-params-en"></span><span id="ser-params-ja"></span><div class="row">
<div lang="en" class="col"><h5 id="name-serializing-parameters-en" lang="en">
<a id="section-4.1.1.2" href="#section-4.1.1.2" class="section-number selfRef">4.1.1.2.</a> <a href="#name-serializing-parameters-en" class="section-name selfRef">Serializing Parameters</a>
            </h5></div>
<div lang="ja" class="col"><h5 id="name-serializing-parameters-ja" lang="ja">
<a id="section-4.1.1.2" href="#section-4.1.1.2" class="section-number selfRef">4.1.1.2.</a> <a href="#name-serializing-parameters-ja" class="section-name selfRef">パラメーターのシリアライズ</a>
            </h5></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ordered Dictionary as input_parameters (each member having a param_key and a param_value), return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>input_parametersとして順序付き辞書（各メンバーはparam_keyとparam_valueを持ちます）を与え、 HTTPフィールドの値として使用するのに適したASCII 文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
                <p>Let output be an empty string.</p>
</li>
              <li>
                <p>For each param_key with a value of param_value in input_parameters:
                </p>
<ol>
<li>
                    <p>Append ";" to output.</p>
</li>
                  <li>
                    <p>Append the result of running Serializing a Key (<a href="#ser-key-en">Section 4.1.1.3</a>) with param_key to output.</p>
</li>
                  <li>
                    <p>If param_value is not Boolean true:
                    </p>
<ol>
<li>
                        <p>Append "=" to output.</p>
</li>
                      <li>
                        <p>Append the result of running Serializing a bare Item (<a href="#ser-bare-item-en">Section 4.1.3.1</a>) with param_value to output.</p>
</li>
                    </ol>
</li>
                </ol>
</li>
              <li>
                <p>Return output.</p>
</li>
            </ol></div>
<div lang="ja" class="col"><ol>
<li>
                <p>outputに空文字列を代入します。</p>
</li>
              <li>
                <p>input_parameters中でparam_keyの値がparam_valueであるものについて：
                </p>
<ol>
<li>
                    <p>「;」をoutputに追加します。</p>
</li>
                  <li>
                    <p>param_keyに対して、 キーのシリアライズ（<a href="#ser-key-ja">Section 4.1.1.3</a>）を実行した結果を、 outputに追加します。</p>
</li>
                  <li>
                    <p>param_valueが真偽値の真でない場合：
                    </p>
<ol>
<li>
                        <p>「=」をoutputに追加します。</p>
</li>
                      <li>
                        <p>param_valueに対して、 裸のアイテムのシリアライズ（<a href="#ser-bare-item-ja">Section 4.1.3.1</a>）を実行した結果を、 outputに追加します。</p>
</li>
                    </ol>
</li>
                </ol>
</li>
              <li>
                <p>outputを返します。</p>
</li>
            </ol></div>
</div></section><section><span id="ser-key-en"></span><span id="ser-key-ja"></span><div class="row">
<div lang="en" class="col"><h5 id="name-serializing-a-key-en" lang="en">
<a id="section-4.1.1.3" href="#section-4.1.1.3" class="section-number selfRef">4.1.1.3.</a> <a href="#name-serializing-a-key-en" class="section-name selfRef">Serializing a Key</a>
            </h5></div>
<div lang="ja" class="col"><h5 id="name-serializing-a-key-ja" lang="ja">
<a id="section-4.1.1.3" href="#section-4.1.1.3" class="section-number selfRef">4.1.1.3.</a> <a href="#name-serializing-a-key-ja" class="section-name selfRef">キーのシリアライズ</a>
            </h5></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given a key as input_key, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>キーをinput_keyとして渡すと、HTTPフィールドの値として適切なASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
                <p>Convert input_key into a sequence of ASCII characters; if conversion fails, fail serialization.</p>
</li>
              <li>
                <p>If input_key contains characters not in lcalpha, DIGIT, "_", "-", ".", or "*", fail serialization.</p>
</li>
              <li>
                <p>If the first character of input_key is not lcalpha or "*", fail serialization.</p>
</li>
              <li>
                <p>Let output be an empty string.</p>
</li>
              <li>
                <p>Append input_key to output.</p>
</li>
              <li>
                <p>Return output.</p>
</li>
            </ol></div>
<div lang="ja" class="col"><ol>
<li>
                <p>input_keyをASCII文字の列に変換します；この変換が失敗した場合、シリアライズも失敗します。</p>
</li>
              <li>
                <p>input_keyがlcalpha、DIGIT、「_」、「-」、「.」、「*」に含まれない文字を含んでいる場合、シリアライズに失敗します。</p>
</li>
              <li>
                <p>input_keyの最初の文字がlcalphaまたは「*」でない場合、シリアライズに失敗します。</p>
</li>
              <li>
                <p>outputに空文字列を代入します。</p>
</li>
              <li>
                <p>input_keyをoutputに代入します。</p>
</li>
              <li>
                <p>outputを返します。</p>
</li>
            </ol></div>
</div></section></section><section><span id="ser-dictionary-en"></span><span id="ser-dictionary-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-a-dictionary-en" lang="en">
<a id="section-4.1.2" href="#section-4.1.2" class="section-number selfRef">4.1.2.</a> <a href="#name-serializing-a-dictionary-en" class="section-name selfRef">Serializing a Dictionary</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-a-dictionary-ja" lang="ja">
<a id="section-4.1.2" href="#section-4.1.2" class="section-number selfRef">4.1.2.</a> <a href="#name-serializing-a-dictionary-ja" class="section-name selfRef">辞書のシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ordered Dictionary as input_dictionary (each member having a member_key and a tuple value of (member_value, parameters)), return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>input_dictionary として順序付き辞書（各メンバーはmember_keyと(member_value, parameters)のタプル値）が与えられたとき、 HTTP フィールド値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Let output be an empty string.</p>
</li>
            <li>
              <p>For each member_key with a value of (member_value, parameters) in input_dictionary:
              </p>
<ol>
<li>
                  <p>Append the result of running Serializing a Key (<a href="#ser-key-en">Section 4.1.1.3</a>) with member's member_key to output.</p>
</li>
                <li>
                  <p>If member_value is Boolean true:
                  </p>
<ol>
<li>
                      <p>Append the result of running Serializing Parameters (<a href="#ser-params-en">Section 4.1.1.2</a>) with parameters to output.</p>
</li>
                  </ol>
</li>
                <li>
                  <p>Otherwise:
                  </p>
<ol>
<li>
                      <p>Append "=" to output.</p>
</li>
                    <li>
                      <p>If member_value is an array, append the result of running Serializing an Inner List (<a href="#ser-innerlist-en">Section 4.1.1.1</a>) with (member_value, parameters) to output.</p>
</li>
                    <li>
                      <p>Otherwise, append the result of running Serializing an Item (<a href="#ser-item-en">Section 4.1.3</a>) with (member_value, parameters) to output.</p>
</li>
                  </ol>
</li>
                <li>
                  <p>If more members remain in input_dictionary:
                  </p>
<ol>
<li>
                      <p>Append "," to output.</p>
</li>
                    <li>
                      <p>Append a single SP to output.</p>
</li>
                  </ol>
</li>
              </ol>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>outputに空文字列を代入します。</p>
</li>
            <li>
              <p>input_dictionary の、値が (member_value, parameters) である member_key について、その値を取得します。 
              </p>
<ol>
<li>
                  <p>メンバーのmember_keyに対して、 キーのシリアライズ（<a href="#ser-key-ja">Section 4.1.1.3</a>）を実行した結果を、 outputに追加します。</p>
</li>
                <li>
                  <p>member_value が真偽値の真の場合：
                  </p>
<ol>
<li>
                      <p>parametersに対して、 パラメーターのシリアライズ（<a href="#ser-params-ja">Section 4.1.1.2</a>）を実行した結果を、 outputに追加します。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>それ以外の場合：
                  </p>
<ol>
<li>
                      <p>outputに「=」を追加します。</p>
</li>
                    <li>
                      <p>もしmember_valueが配列ならば、 (member_value, parameters)に対して、 インナーリストのシリアライズ（<a href="#ser-innerlist-ja">Section 4.1.1.1</a>）を実行した結果を、 outputに追加します。</p>
</li>
                    <li>
                      <p>配列でなければ、 (member_value, parameters)に対して、 アイテムのシリアライズ（<a href="#ser-item-ja">Section 4.1.3</a>）を実行した結果を、 outputに追加します。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>input_dictionary にさらにメンバーが残っている場合：
                  </p>
<ol>
<li>
                      <p>outputに「,」を追加します。</p>
</li>
                    <li>
                      <p>outputにSPをひとつ追加します。</p>
</li>
                  </ol>
</li>
              </ol>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="ser-item-en"></span><span id="ser-item-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-an-item-en" lang="en">
<a id="section-4.1.3" href="#section-4.1.3" class="section-number selfRef">4.1.3.</a> <a href="#name-serializing-an-item-en" class="section-name selfRef">Serializing an Item</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-an-item-ja" lang="ja">
<a id="section-4.1.3" href="#section-4.1.3" class="section-number selfRef">4.1.3.</a> <a href="#name-serializing-an-item-ja" class="section-name selfRef">アイテムのシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an Item as bare_item and Parameters as item_parameters, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>bare_itemとしてアイテムを、item_parameters としてパラメーターを与えられたとき、 HTTP フィールド値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Let output be an empty string.</p>
</li>
            <li>
              <p>Append the result of running Serializing a Bare Item (<a href="#ser-bare-item-en">Section 4.1.3.1</a>) with bare_item to output.</p>
</li>
            <li>
              <p>Append the result of running Serializing Parameters (<a href="#ser-params-en">Section 4.1.1.2</a>) with item_parameters to output.</p>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>outputに空文字列を代入します。</p>
</li>
            <li>
              <p>bare_itemに対して、 裸のアイテムのシリアライズ（<a href="#ser-bare-item-ja">Section 4.1.3.1</a>）を実行した結果を、 outputに追加します。</p>
</li>
            <li>
              <p>item_parametersに対して、 パラメーターのシリアライズ（<a href="#ser-params-ja">Section 4.1.1.2</a>）を実行した結果を、 outputに追加します。</p>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div>
<section><span id="ser-bare-item-en"></span><span id="ser-bare-item-ja"></span><div class="row">
<div lang="en" class="col"><h5 id="name-serializing-a-bare-item-en" lang="en">
<a id="section-4.1.3.1" href="#section-4.1.3.1" class="section-number selfRef">4.1.3.1.</a> <a href="#name-serializing-a-bare-item-en" class="section-name selfRef">Serializing a Bare Item</a>
            </h5></div>
<div lang="ja" class="col"><h5 id="name-serializing-a-bare-item-ja" lang="ja">
<a id="section-4.1.3.1" href="#section-4.1.3.1" class="section-number selfRef">4.1.3.1.</a> <a href="#name-serializing-a-bare-item-ja" class="section-name selfRef">裸のアイテムのシリアライズ</a>
            </h5></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an Item as input_item, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>input_itemとしてアイテムを与えられたとき、 HTTPフィールドの値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
                <p>If input_item is an Integer, return the result of running Serializing an Integer (<a href="#ser-integer-en">Section 4.1.4</a>) with input_item.</p>
</li>
              <li>
                <p>If input_item is a Decimal, return the result of running Serializing a Decimal (<a href="#ser-decimal-en">Section 4.1.5</a>) with input_item.</p>
</li>
              <li>
                <p>If input_item is a String, return the result of running Serializing a String (<a href="#ser-string-en">Section 4.1.6</a>) with input_item.</p>
</li>
              <li>
                <p>If input_item is a Token, return the result of running Serializing a Token (<a href="#ser-token-en">Section 4.1.7</a>) with input_item.</p>
</li>
              <li>
                <p>If input_item is a Byte Sequence, return the result of running Serializing a Byte Sequence (<a href="#ser-binary-en">Section 4.1.8</a>) with input_item.</p>
</li>
              <li>
                <p>If input_item is a Boolean, return the result of running Serializing a Boolean (<a href="#ser-boolean-en">Section 4.1.9</a>) with input_item.</p>
</li>
              <li>
                <p>If input_item is a Date, return the result of running Serializing a Date (<a href="#ser-date-en">Section 4.1.10</a>) with input_item.</p>
</li>
              <li>
                <p>If input_item is a Display String, return the result of running Serializing a Display String (<a href="#ser-display-en">Section 4.1.11</a>) with input_item.</p>
</li>
              <li>
                <p>Otherwise, fail serialization.</p>
</li>
            </ol></div>
<div lang="ja" class="col"><ol>
<li>
                <p>もしinput_itemが整数ならば、input_itemに対して、 整数のシリアライズ（<a href="#ser-integer-ja">Section 4.1.4</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_itemが小数ならば、input_itemに対して、 小数のシリアライズ（<a href="#ser-decimal-ja">Section 4.1.5</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_itemが文字列ならば、input_itemに対して、 文字列のシリアライズ（<a href="#ser-string-ja">Section 4.1.6</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_itemがトークンならば、input_itemに対して、 トークンのシリアライズ（<a href="#ser-token-ja">Section 4.1.7</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_itemがバイト列ならば、input_itemに対して、 バイト列のシリアライズ（<a href="#ser-binary-ja">Section 4.1.8</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_itemが真偽値ならば、input_itemに対して、 真偽値のシリアライズ（<a href="#ser-boolean-ja">Section 4.1.9</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_itemが日付ならば、input_itemに対して、 日付のシリアライズ（<a href="#ser-date-ja">Section 4.1.10</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_itemが表示文字列ならば、input_itemに対して、 表示文字列のシリアライズ（<a href="#ser-display-ja">Section 4.1.11</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>それ以外の場合は、シリアライズに失敗します。</p>
</li>
            </ol></div>
</div></section></section><section><span id="ser-integer-en"></span><span id="ser-integer-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-an-integer-en" lang="en">
<a id="section-4.1.4" href="#section-4.1.4" class="section-number selfRef">4.1.4.</a> <a href="#name-serializing-an-integer-en" class="section-name selfRef">Serializing an Integer</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-an-integer-ja" lang="ja">
<a id="section-4.1.4" href="#section-4.1.4" class="section-number selfRef">4.1.4.</a> <a href="#name-serializing-an-integer-ja" class="section-name selfRef">整数のシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an Integer as input_integer, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>整数をinput_integerとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If input_integer is not an integer in the range of -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail serialization.</p>
</li>
            <li>
              <p>Let output be an empty string.</p>
</li>
            <li>
              <p>If input_integer is less than (but not equal to) 0, append "-" to output.</p>
</li>
            <li>
              <p>Append input_integer's numeric value represented in base 10 using only decimal digits to output.</p>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>もしinput_integerが-999,999,999,999,999から999,999,999,999,999までの両端を含む範囲の整数でなければ、 シリアライズに失敗します。</p>
</li>
            <li>
              <p>outputに空文字を代入します。</p>
</li>
            <li>
              <p>もしinput_integerが0未満（0は除く）の場合、outputに「-」を追加します。</p>
</li>
            <li>
              <p>0から9までの数字だけをもちいて、input_integerを10進数で表現した結果を、outputに追加します。</p>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="ser-decimal-en"></span><span id="ser-decimal-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-a-decimal-en" lang="en">
<a id="section-4.1.5" href="#section-4.1.5" class="section-number selfRef">4.1.5.</a> <a href="#name-serializing-a-decimal-en" class="section-name selfRef">Serializing a Decimal</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-a-decimal-ja" lang="ja">
<a id="section-4.1.5" href="#section-4.1.5" class="section-number selfRef">4.1.5.</a> <a href="#name-serializing-a-decimal-ja" class="section-name selfRef">小数のシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given a decimal number as input_decimal, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>小数をinput_decimalとして与えると、HTTP フィールドの値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If input_decimal is not a decimal number, fail serialization.</p>
</li>
            <li>
              <p>If input_decimal has more than three significant digits to the right of the decimal point, round it to three decimal places, rounding the final digit to the nearest value, or to the even value if it is equidistant.</p>
</li>
            <li>
              <p>If input_decimal has more than 12 significant digits to the left of the decimal point after rounding, fail serialization.</p>
</li>
            <li>
              <p>Let output be an empty string.</p>
</li>
            <li>
              <p>If input_decimal is less than (but not equal to) 0, append "-" to output.</p>
</li>
            <li>
              <p>Append input_decimal's integer component represented in base 10 (using only decimal digits) to output; if it is zero, append "0".</p>
</li>
            <li>
              <p>Append "." to output.</p>
</li>
            <li>
              <p>If input_decimal's fractional component is zero, append "0" to output.</p>
</li>
            <li>
              <p>Otherwise, append the significant digits of input_decimal's fractional component represented in base 10 (using only decimal digits) to output.</p>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>input_decimalが小数でない場合、シリアライズに失敗します。</p>
</li>
            <li>
              <p>input_decimalの小数点以下の桁数が3桁より多い場合、もっとも近い3桁に丸めます。 等距離の場合は偶数へ丸めます。</p>
</li>
            <li>
              <p>丸めを行ったあとに、小数点の右側に12桁より多くの桁がある場合は、シリアライズに失敗します。</p>
</li>
            <li>
              <p>outputに空文字列を代入します。</p>
</li>
            <li>
              <p>もしinput_decimalが0未満（0は除く）の場合、outputに「-」を追加します。</p>
</li>
            <li>
              <p>input_decimalの整数部を10進数で表した結果（0から9までの数字のみを使います）をoutputに追加します； つまり整数部がゼロの場合は「0」を追加します。</p>
</li>
            <li>
              <p>「.」をoutputに追加します。</p>
</li>
            <li>
              <p>input_decimalの小数部がゼロの場合、「0」をoutputに追加します。</p>
</li>
            <li>
              <p>そうでない場合、input_decimalの小数部をoutputに追加します（0から9までの数字のみを使います）。</p>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="ser-string-en"></span><span id="ser-string-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-a-string-en" lang="en">
<a id="section-4.1.6" href="#section-4.1.6" class="section-number selfRef">4.1.6.</a> <a href="#name-serializing-a-string-en" class="section-name selfRef">Serializing a String</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-a-string-ja" lang="ja">
<a id="section-4.1.6" href="#section-4.1.6" class="section-number selfRef">4.1.6.</a> <a href="#name-serializing-a-string-ja" class="section-name selfRef">文字列のシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given a String as input_string, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>文字列をinput_stringとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Convert input_string into a sequence of ASCII characters; if conversion fails, fail serialization.</p>
</li>
            <li>
              <p>If input_string contains characters in the range %x00-1f or %x7f-ff (i.e., not in VCHAR or SP), fail serialization.</p>
</li>
            <li>
              <p>Let output be the string DQUOTE.</p>
</li>
            <li>
              <p>For each character char in input_string:
              </p>
<ol>
<li>
                  <p>If char is "\" or DQUOTE:
                  </p>
<ol>
<li>
                      <p>Append "\" to output.</p>
</li>
                  </ol>
</li>
                <li>
                  <p>Append char to output.</p>
</li>
              </ol>
</li>
            <li>
              <p>Append DQUOTE to output.</p>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>文字列をinput_stringとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</p>
</li>
            <li>
              <p>input_stringが%x00-1fまたは%x7f-ffの範囲の文字を含んでいる場合（つまり、VCHARやSPは含みません）、シリアライズに失敗します。</p>
</li>
            <li>
              <p>outputに文字列DQUOTEを代入します。</p>
</li>
            <li>
              <p>input_stringの各文字charについて：
              </p>
<ol>
<li>
                  <p>charが「\」またはDQUOTEの場合
                  </p>
<ol>
<li>
                      <p>「\」をoutputに追加します。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>charをoutputに追加します。</p>
</li>
              </ol>
</li>
            <li>
              <p>DQUOTEをoutputに追加します。</p>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="ser-token-en"></span><span id="ser-token-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-a-token-en" lang="en">
<a id="section-4.1.7" href="#section-4.1.7" class="section-number selfRef">4.1.7.</a> <a href="#name-serializing-a-token-en" class="section-name selfRef">Serializing a Token</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-a-token-ja" lang="ja">
<a id="section-4.1.7" href="#section-4.1.7" class="section-number selfRef">4.1.7.</a> <a href="#name-serializing-a-token-ja" class="section-name selfRef">トークンのシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given a Token as input_token, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>トークンをinput_tokenとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Convert input_token into a sequence of ASCII characters; if conversion fails, fail serialization.</p>
</li>
            <li>
              <p>If the first character of input_token is not ALPHA or "*", or the remaining portion contains a character not in tchar, ":", or "/", fail serialization.</p>
</li>
            <li>
              <p>Let output be an empty string.</p>
</li>
            <li>
              <p>Append input_token to output.</p>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>input_tokenをASCII文字の列に変換します。変換に失敗した場合、シリアライズに失敗します。</p>
</li>
            <li>
              <p>input_tokenの最初の文字がALPHAまたは「*」でない場合、シリアライズに失敗します。 残りの文字がtchar、「:」「/」でない場合、シリアライズに失敗します。</p>
</li>
            <li>
              <p>outputに空文字列を代入します。</p>
</li>
            <li>
              <p>outputにinput_tokenを追加します。</p>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="ser-binary-en"></span><span id="ser-binary-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-a-byte-sequence-en" lang="en">
<a id="section-4.1.8" href="#section-4.1.8" class="section-number selfRef">4.1.8.</a> <a href="#name-serializing-a-byte-sequence-en" class="section-name selfRef">Serializing a Byte Sequence</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-a-byte-sequence-ja" lang="ja">
<a id="section-4.1.8" href="#section-4.1.8" class="section-number selfRef">4.1.8.</a> <a href="#name-serializing-a-byte-sequence-ja" class="section-name selfRef">バイト列のシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given a Byte Sequence as input_bytes, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>バイト列をinput_bytesとして与え、HTTP のフィールド値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If input_bytes is not a sequence of bytes, fail serialization.</p>
</li>
            <li>
              <p>Let output be an empty string.</p>
</li>
            <li>
              <p>Append ":" to output.</p>
</li>
            <li>
              <p>Append the result of base64-encoding input_bytes as per <span>[<a href="#RFC4648-en">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-4">Section 4</a></span>, taking account of the requirements below.</p>
</li>
            <li>
              <p>Append ":" to output.</p>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>もしinput_bytesがバイト列でない場合、シリアライズに失敗します。</p>
</li>
            <li>
              <p>outputに空文字列を代入します。</p>
</li>
            <li>
              <p>「:」をoutputに追加します。</p>
</li>
            <li>
              <p>input_bytesを<span>[<a href="#RFC4648-ja">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-4">Section 4</a></span>にしたがってbase64エンコードをた結果を追加します。 このとき以下の要件を考慮してください。</p>
</li>
            <li>
              <p>「:」をoutputに追加します。</p>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div>
<div class="row">
<div lang="en" class="col"><p>The encoded data is required to be padded with "=", as per <span>[<a href="#RFC4648-en">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.2">Section 3.2</a></span>.</p></div>
<div lang="ja" class="col"><p>エンコードされたデータは、<span>[<a href="#RFC4648-ja">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.2">Section 3.2</a></span>にしたがって、「=」でパディングすることが要求されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Likewise, encoded data <span class="bcp14">SHOULD</span> have pad bits set to zero, as per <span>[<a href="#RFC4648-en">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.5">Section 3.5</a></span>, unless it is not possible to do so due to implementation constraints.</p></div>
<div lang="ja" class="col"><p>同様に、エンコードされたデータは、実装上の制約から不可能な場合を除き、<span>[<a href="#RFC4648-ja">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.5">Section 3.5</a></span>にしたがってパッドビットをゼロに設定<span class="bcp14">すべきです（SHOULD）</span>。</p></div>
</div></section><section><span id="ser-boolean-en"></span><span id="ser-boolean-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-a-boolean-en" lang="en">
<a id="section-4.1.9" href="#section-4.1.9" class="section-number selfRef">4.1.9.</a> <a href="#name-serializing-a-boolean-en" class="section-name selfRef">Serializing a Boolean</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-a-boolean-ja" lang="ja">
<a id="section-4.1.9" href="#section-4.1.9" class="section-number selfRef">4.1.9.</a> <a href="#name-serializing-a-boolean-ja" class="section-name selfRef">真偽値のシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given a Boolean as input_boolean, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>真偽値をinput_booleanとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If input_boolean is not a boolean, fail serialization.</p>
</li>
            <li>
              <p>Let output be an empty string.</p>
</li>
            <li>
              <p>Append "?" to output.</p>
</li>
            <li>
              <p>If input_boolean is true, append "1" to output.</p>
</li>
            <li>
              <p>If input_boolean is false, append "0" to output.</p>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>input_booleanが真偽値でない場合、シリアライズに失敗します。</p>
</li>
            <li>
              <p>outputに空文字列を代入します。</p>
</li>
            <li>
              <p>「?」をoutputに追加します。</p>
</li>
            <li>
              <p>もしinput_booleanが真であれば、「1」をoutputに追加します。</p>
</li>
            <li>
              <p>もしinput_booleanが偽であれば、「0」をoutputに追加します。</p>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="ser-date-en"></span><span id="ser-date-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-a-date-en" lang="en">
<a id="section-4.1.10" href="#section-4.1.10" class="section-number selfRef">4.1.10.</a> <a href="#name-serializing-a-date-en" class="section-name selfRef">Serializing a Date</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-a-date-ja" lang="ja">
<a id="section-4.1.10" href="#section-4.1.10" class="section-number selfRef">4.1.10.</a> <a href="#name-serializing-a-date-ja" class="section-name selfRef">日付のシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given a Date as input_date, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>日付をinput_dateとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Let output be "@".</p>
</li>
            <li>
              <p>Append to output the result of running Serializing an Integer with input_date (<a href="#ser-integer-en">Section 4.1.4</a>).</p>
</li>
            <li>
              <p>Return output.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>outputに「@」を代入します。</p>
</li>
            <li>
              <p>input_dateを使用して整数のシリアライズ (<a href="#ser-integer-ja">Section 4.1.4</a>)を実行した結果を出力に追加します。</p>
</li>
            <li>
              <p>outputを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="ser-display-en"></span><span id="ser-display-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-serializing-a-display-strin-en" lang="en">
<a id="section-4.1.11" href="#section-4.1.11" class="section-number selfRef">4.1.11.</a> <a href="#name-serializing-a-display-strin-en" class="section-name selfRef">Serializing a Display String</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-serializing-a-display-strin-ja" lang="ja">
<a id="section-4.1.11" href="#section-4.1.11" class="section-number selfRef">4.1.11.</a> <a href="#name-serializing-a-display-strin-ja" class="section-name selfRef">表示文字列のシリアライズ</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given a sequence of Unicode code points as input_sequence, return an ASCII string suitable for use in an HTTP field value.</p></div>
<div lang="ja" class="col"><p>Unicodeコードポイント列をinput_sequenceとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If input_sequence is not a sequence of Unicode code points, fail serialization.</p>
</li>
            <li>
              <p>Let byte_array be the result of applying UTF-8 encoding (<span><a href="https://rfc-editor.org/rfc/rfc3629#section-3">Section 3</a> of [<a href="#RFC3629-en">UTF8</a>]</span>) to input_sequence. If encoding fails, fail serialization.</p>
</li>
            <li>
              <p>Let encoded_string be a string containing "%" followed by DQUOTE.</p>
</li>
            <li>
              <p>For each byte in byte_array:
              </p>
<ol>
<li>
                  <p>If byte is %x25 ("%"), %x22 (DQUOTE), or in the ranges %x00-1f or %x7f-ff:
                  </p>
<ol>
<li>
                      <p>Append "%" to encoded_string.</p>
</li>
                    <li>
                      <p>Let encoded_byte be the result of applying base16 encoding (<span><a href="https://rfc-editor.org/rfc/rfc4648#section-8">Section 8</a> of [<a href="#RFC4648-en">RFC4648</a>]</span>) to byte, with any alphabetic characters converted to lowercase.</p>
</li>
                    <li>
                      <p>Append encoded_byte to encoded_string.</p>
</li>
                  </ol>
</li>
                <li>
                  <p>Otherwise, decode byte as an ASCII character and append the result to encoded_string.</p>
</li>
              </ol>
</li>
            <li>
              <p>Append DQUOTE to encoded_string.</p>
</li>
            <li>
              <p>Return encoded_string.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>input_sequenceがUnicodeコードポイント列でない場合、シリアライズに失敗します。</p>
</li>
            <li>
              <p>byte_arrayに、input_sequenceにUTF-8エンコーディング (<span>[<a href="#RFC3629-ja">UTF8</a>]の<a href="https://rfc-editor.org/rfc/rfc3629#section-3">Section 3</a></span>)を適用した結果を代入します。エンコーディングが失敗した場合、シリアル化は失敗します。</p>
</li>
            <li>
              <p>encoded_stringに、DQUOTEの前に「%」を含む文字列を代入します。</p>
</li>
            <li>
              <p>byte_arrayの各バイトbyteについて：
              </p>
<ol>
<li>
                  <p>byteが%x25（"%"）、%x22（DQUOTE）、または%x00-1fまたは%x7f-ffの範囲内の場合:</p>
<ol>
<li>
                      <p>encoded_stringに「%」を追加します。</p>
</li>
                    <li>
                      <p>byteにbase16エンコーディング(<span>[<a href="#RFC4648-ja">RFC4648</a>]の<a href="https://rfc-editor.org/rfc/rfc4648#section-8">Section 8</a></span>)を適用し、アルファベット文字を小文字に変換した結果を、encoded_byteに代入します。</p>
</li>
                    <li>
                      <p>encoded_byteをencoded_stringに追加します。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>そうでない場合、byteをASCII文字としてデコードし、結果をencoded_stringに追加します。</p>
</li>
              </ol>
</li>
            <li>
              <p>encoded_stringにDQUOTEを追加します。</p>
</li>
            <li>
              <p>encoded_stringを返します。</p>
</li>
          </ol></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that <span>[<a href="#RFC3629-en">UTF8</a>]</span> prohibits the encoding of code points between U+D800 and U+DFFF (surrogates); if they occur in input_sequence, serialization will fail.</p></div>
<div lang="ja" class="col"><p> <span>[<a href="#RFC3629-ja">UTF8</a>]</span>はU+D800からU+DFFF（サロゲート）の間のコードポイントのエンコードを禁止していることに注意してください。これらがinput_sequenceに含まれている場合、シリアル化は失敗します。</p></div>
</div></section></section><section><span id="text-parse-en"></span><span id="text-parse-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-parsing-structured-fields-en" lang="en">
<a id="section-4.2" href="#section-4.2" class="section-number selfRef">4.2.</a> <a href="#name-parsing-structured-fields-en" class="section-name selfRef">Parsing Structured Fields</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-parsing-structured-fields-ja" lang="ja">
<a id="section-4.2" href="#section-4.2" class="section-number selfRef">4.2.</a> <a href="#name-parsing-structured-fields-ja" class="section-name selfRef">Structured Fieldsのパース</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When a receiving implementation parses HTTP fields that are known to be Structured Fields, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.</p></div>
<div lang="ja" class="col"><p>受け取り側の実装が、Structured Fieldsであることが分かっているHTTPフィールドを解析するとき、 相互運用性やセキュリティーの問題を引き起こす可能性のある多くのエッジケースがあるため、注意を払うことが重要です。 このセクションでは、そのためのアルゴリズムを規定します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an array of bytes as input_bytes that represent the chosen field's field-value (which is empty if that field is not present) and field_type (one of "dictionary", "list", or "item"), return the parsed field value.</p></div>
<div lang="ja" class="col"><p>選択されたフィールドのフィールド値（そのフィールドが存在しない場合は空）と field_type（dictionary, list, item のいずれか）を表すバイト列を input_bytes として与え、 解析されたヘッダー値を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
            <p>Convert input_bytes into an ASCII string input_string; if conversion fails, fail parsing.</p>
</li>
          <li>
            <p>Discard any leading SP characters from input_string.</p>
</li>
          <li>
            <p>If field_type is "list", let output be the result of running Parsing a List (<a href="#parse-list-en">Section 4.2.1</a>) with input_string.</p>
</li>
          <li>
            <p>If field_type is "dictionary", let output be the result of running Parsing a Dictionary (<a href="#parse-dictionary-en">Section 4.2.2</a>) with input_string.</p>
</li>
          <li>
            <p>If field_type is "item", let output be the result of running Parsing an Item (<a href="#parse-item-en">Section 4.2.3</a>) with input_string.</p>
</li>
          <li>
            <p>Discard any leading SP characters from input_string.</p>
</li>
          <li>
            <p>If input_string is not empty, fail parsing.</p>
</li>
          <li>
            <p>Otherwise, return output.</p>
</li>
        </ol></div>
<div lang="ja" class="col"><ol>
<li>
            <p>input_bytesをASCII文字列input_stringに変換します。変換に失敗した場合、パースに失敗します。</p>
</li>
          <li>
            <p>input_stringの先頭のSPを無視します。.</p>
</li>
          <li>
            <p>もしfield_typeが「リスト」の場合、input_stringについて、 リストのパース（<a href="#parse-list-ja">Section 4.2.1</a>）を実行した結果を、outputに代入します。</p>
</li>
          <li>
            <p>もしfield_typeが「辞書」の場合、input_stringについて、 辞書のパース（<a href="#parse-dictionary-ja">Section 4.2.2</a>）を実行した結果を、outputに代入します。</p>
</li>
          <li>
            <p>もしfield_typeが「アイテム」の場合、input_stringについて、 アイテムのパース（<a href="#parse-item-ja">Section 4.2.3</a>）を実行した結果を、outputに代入します。</p>
</li>
          <li>
            <p>input_stringの先頭のSPを無視します。.</p>
</li>
          <li>
            <p>もし、input_stringが空文字列でない場合は、パースに失敗します。</p>
</li>
          <li>
            <p>そうでなければ、outputを返します。</p>
</li>
        </ol></div>
</div>
<div class="row">
<div lang="en" class="col"><p>When generating input_bytes, parsers <span class="bcp14">MUST</span> combine all field lines in the same section (header or trailer) that case-insensitively match the field name into one comma-separated field-value, as per <span><a href="https://rfc-editor.org/rfc/rfc9110#section-5.2">Section 5.2</a> of [<a href="#RFC9110-en">HTTP</a>]</span>; this assures that the entire field value is processed correctly.</p></div>
<div lang="ja" class="col"><p>input_bytesを生成するとき、パーサーは、<span>[<a href="#RFC9110-ja">HTTP</a>]の<a href="https://rfc-editor.org/rfc/rfc9110#section-5.2">Section 5.2</a></span>にしたがって、 大文字小文字を区別せずにフィールド名と一致する同じセクション（ヘッダーまたはトレーラー）のすべてのフィールド行を1つのカンマ区切りフィールド値に結合<span class="bcp14">しなければなりません（MUST）</span>。 これは、フィールド値全体が正しく処理されることを確実にするものです。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For Lists and Dictionaries, this has the effect of correctly concatenating all of the field's lines, as long as individual members of the top-level data structure are not split across multiple field instances. The parsing algorithms for both types allow tab characters, since these might
be used to combine field lines by some implementations.</p></div>
<div lang="ja" class="col"><p>リストと辞書の場合、トップレベルのデータ構造の個々のメンバーが複数のヘッダーインスタンスにまたがって分割されていない限り、 これはフィールドのすべての行を正しく連結する効果があります。 両タイプの解析アルゴリズムでは、タブ文字を許容しています。 これは、実装によってはフィールドの行を結合するためにタブ文字が使用される可能性があるためです。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Strings split across multiple field lines will have unpredictable results, because one or more commas (with optional whitespace) will become part of the string output by the parser. Since concatenation might be done by an upstream intermediary, the results are not under the control of the serializer or the parser, even when they are both under the control of the same party.</p></div>
<div lang="ja" class="col"><p>複数のフィールド行にまたがる文字列は、予測できない結果をもたらします。 なぜなら、1つ以上のカンマ(オプションの空白文字)がパーサーによって出力される文字列の一部になってしまうからです。 連結は上流の仲介者によって行われる可能性があるため、シリアライザーとパーサーの両方が同じ制御下にある場合でも、その結果はシリアライザーの制御下にはありません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Tokens, Integers, Decimals, and Byte Sequences cannot be split across multiple field lines because the inserted commas will cause parsing to fail.</p></div>
<div lang="ja" class="col"><p>トークン、整数、小数、バイト列は、挿入されたカンマによってパースに失敗するため、複数のフィールド行に分割することはできません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Parsers <span class="bcp14">MAY</span> fail when processing a field value spread across multiple field lines, when one of those lines does not parse as that field. For example, a parsing handling an Example-String field that's defined as an sf-string is allowed to fail when processing this field section:</p></div>
<div lang="ja" class="col"><p>パーサーは、複数のフィールド行にまたがるフィールド値を処理するときに、それらの行の1つがそのフィールドとしてパースされない場合、失敗<span class="bcp14">してもよいです（MAY）</span>。 たとえば、sf-stringとして定義されたExample-Stringフィールドを処理するパーサーは、このフィールドセクションを処理する際に失敗しても構いません。</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-String: "foo
Example-String: bar"
</pre></div>
        </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
Example-String: "foo
Example-String: bar"
</pre></div>
        </div>
</div>
<div class="row">
<div lang="en" class="col"><p>If parsing fails, either the entire field value <span class="bcp14">MUST</span> be ignored (i.e., treated as if the field were not present in the section), or alternatively the complete HTTP message <span class="bcp14">MUST</span> be treated as malformed. This is intentionally strict to improve interoperability and safety, and field specifications that use Structured Fields are not allowed to loosen this requirement.</p></div>
<div lang="ja" class="col"><p>解析に失敗した場合、フィールド値全体を無視（つまり、セクションにフィールドが存在しないかのように扱う）<span class="bcp14">しなければなりません（MUST）</span>。あるいは、完全なHTTPメッセージを不正な形式として扱う<span class="bcp14">必要があります（MUST）</span>。これは相互運用性と安全性を向上させるために意図的に厳格にしており、構造化フィールドを使用するフィールド仕様はこの要件を緩和することは許可されていません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that this requirement does not apply to an implementation that is not parsing the field; for example, an intermediary is not required to strip a failing field from a message before forwarding it.</p></div>
<div lang="ja" class="col"><p>この要件は、フィールドを解析していない実装には適用されないことに注意してください。 たとえば、仲介者は転送する前に、メッセージから失敗したフィールドを取り除くことを要求されません。</p></div>
</div>
<section><span id="parse-list-en"></span><span id="parse-list-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-a-list-en" lang="en">
<a id="section-4.2.1" href="#section-4.2.1" class="section-number selfRef">4.2.1.</a> <a href="#name-parsing-a-list-en" class="section-name selfRef">Parsing a List</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-a-list-ja" lang="ja">
<a id="section-4.2.1" href="#section-4.2.1" class="section-number selfRef">4.2.1.</a> <a href="#name-parsing-a-list-ja" class="section-name selfRef">リストのパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return an array of (item_or_inner_list, parameters) tuples. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、(item_or_inner_list, parameters) タプルの配列を返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Let members be an empty array.</p>
</li>
            <li>
              <p>While input_string is not empty:
              </p>
<ol>
<li>
                  <p>Append the result of running Parsing an Item or Inner List (<a href="#parse-item-or-list-en">Section 4.2.1.1</a>) with input_string to members.</p>
</li>
                <li>
                  <p>Discard any leading OWS characters from input_string.</p>
</li>
                <li>
                  <p>If input_string is empty, return members.</p>
</li>
                <li>
                  <p>Consume the first character of input_string; if it is not ",", fail parsing.</p>
</li>
                <li>
                  <p>Discard any leading OWS characters from input_string.</p>
</li>
                <li>
                  <p>If input_string is empty, there is a trailing comma; fail parsing.</p>
</li>
              </ol>
</li>
            <li>
              <p>No structured data has been found; return members (which is empty).</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>membersに空の配列を代入します。</p>
</li>
            <li>
              <p>input_stringが空でない間:
              </p>
<ol>
<li>
                  <p>input_stringに対して、アイテムまたはインナーリストのパース（<a href="#parse-item-or-list-ja">Section 4.2.1.1</a>）を実行した結果を、 membersに追加します。</p>
</li>
                <li>
                  <p>input_stringの先頭のOWSを無視します。</p>
</li>
                <li>
                  <p>もしinput_stringが空なら、membersを返します。</p>
</li>
                <li>
                  <p>input_stringの最初の一文字を取り除きます。 取り除いた文字が「,」でない場合、パースに失敗します。</p>
</li>
                <li>
                  <p>input_stringの先頭のOWSを無視します。</p>
</li>
                <li>
                  <p>もしinput_stringが空なら、末尾にカンマがあります。その場合、パースに失敗します。</p>
</li>
              </ol>
</li>
            <li>
              <p>構造化データが見つからない場合、（空の）membersを返します。</p>
</li>
          </ol></div>
</div>
<section><span id="parse-item-or-list-en"></span><span id="parse-item-or-list-ja"></span><div class="row">
<div lang="en" class="col"><h5 id="name-parsing-an-item-or-inner-li-en" lang="en">
<a id="section-4.2.1.1" href="#section-4.2.1.1" class="section-number selfRef">4.2.1.1.</a> <a href="#name-parsing-an-item-or-inner-li-en" class="section-name selfRef">Parsing an Item or Inner List</a>
            </h5></div>
<div lang="ja" class="col"><h5 id="name-parsing-an-item-or-inner-li-ja" lang="ja">
<a id="section-4.2.1.1" href="#section-4.2.1.1" class="section-number selfRef">4.2.1.1.</a> <a href="#name-parsing-an-item-or-inner-li-ja" class="section-name selfRef">アイテムまたはインナーリストのパース</a>
            </h5></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return the tuple (item_or_inner_list, parameters), where item_or_inner_list can be either a single bare item or an array of (bare_item, parameters) tuples. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与えると、タプル (item_or_inner_list, parameters) を返します。 ここで item_or_inner_list は単一の裸のアイテムか、 (bare_item, parameters) タプルの配列のいずれかです。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
                <p>If the first character of input_string is "(", return the result of running Parsing an Inner List (<a href="#parse-innerlist-en">Section 4.2.1.2</a>) with input_string.</p>
</li>
              <li>
                <p>Return the result of running Parsing an Item (<a href="#parse-item-en">Section 4.2.3</a>) with input_string.</p>
</li>
            </ol></div>
<div lang="ja" class="col"><ol>
<li>
                <p>もしinput_stringの先頭一文字が「(」の場合、 input_stringに対して、インナーリストのパース（<a href="#parse-innerlist-ja">Section 4.2.1.2</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>input_stringに対して、 アイテムのパース(<a href="#parse-item-ja">Section 4.2.3</a>）を実行した結果を返します。</p>
</li>
            </ol></div>
</div></section><section><span id="parse-innerlist-en"></span><span id="parse-innerlist-ja"></span><div class="row">
<div lang="en" class="col"><h5 id="name-parsing-an-inner-list-en" lang="en">
<a id="section-4.2.1.2" href="#section-4.2.1.2" class="section-number selfRef">4.2.1.2.</a> <a href="#name-parsing-an-inner-list-en" class="section-name selfRef">Parsing an Inner List</a>
            </h5></div>
<div lang="ja" class="col"><h5 id="name-parsing-an-inner-list-ja" lang="ja">
<a id="section-4.2.1.2" href="#section-4.2.1.2" class="section-number selfRef">4.2.1.2.</a> <a href="#name-parsing-an-inner-list-ja" class="section-name selfRef">インナーリストのパース</a>
            </h5></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return the tuple (inner_list, parameters), where inner_list is an array of (bare_item, parameters) tuples. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、inner_listを(bare_item, parameters)の配列としたタプルを返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
                <p>Consume the first character of input_string; if it is not "(", fail parsing.</p>
</li>
              <li>
                <p>Let inner_list be an empty array.</p>
</li>
              <li>
                <p>While input_string is not empty:
                </p>
<ol>
<li>
                    <p>Discard any leading SP characters from input_string.</p>
</li>
                  <li>
                    <p>If the first character of input_string is ")":
                    </p>
<ol>
<li>
                        <p>Consume the first character of input_string.</p>
</li>
                      <li>
                        <p>Let parameters be the result of running Parsing Parameters (<a href="#parse-param-en">Section 4.2.3.2</a>) with input_string.</p>
</li>
                      <li>
                        <p>Return the tuple (inner_list, parameters).</p>
</li>
                    </ol>
</li>
                  <li>
                    <p>Let item be the result of running Parsing an Item (<a href="#parse-item-en">Section 4.2.3</a>) with input_string.</p>
</li>
                  <li>
                    <p>Append item to inner_list.</p>
</li>
                  <li>
                    <p>If the first character of input_string is not SP or ")", fail parsing.</p>
</li>
                </ol>
</li>
              <li>
                <p>The end of the Inner List was not found; fail parsing.</p>
</li>
            </ol></div>
<div lang="ja" class="col"><ol>
<li>
                <p>input_stringの最初の一文字を取り除きます。 取り除いた文字が「(」でない場合、パースに失敗します。</p>
</li>
              <li>
                <p>inner_listに空配列を代入します。</p>
</li>
              <li>
                <p>input_stringが空でない間:
                </p>
<ol>
<li>
                    <p>input_stringの先頭のSPを無視します。</p>
</li>
                  <li>
                    <p>もしinput_stringの先頭一文字が「)」である場合:
                    </p>
<ol>
<li>
                        <p>input_stringの最初の文字を取り除きます。</p>
</li>
                      <li>
                        <p>input_stringに対して、 パラメーターのパース（<a href="#parse-param-ja">Section 4.2.3.2</a>）を実行した結果を、parametersに代入します。</p>
</li>
                      <li>
                        <p>タプル(inner_list, parameters)を返します。</p>
</li>
                    </ol>
</li>
                  <li>
                    <p>input_stringに対して、 アイテムのパース（<a href="#parse-item-ja">Section 4.2.3</a>）を実行した結果を、 itemに代入します。</p>
</li>
                  <li>
                    <p>itemをinner_listに追加します。</p>
</li>
                  <li>
                    <p>もしinput_stringの先頭一文字がSPまたは「)」でない場合、パースに失敗します。</p>
</li>
                </ol>
</li>
              <li>
                <p>インナーリストの終わりを見つけられなかったため、パースに失敗します。</p>
</li>
            </ol></div>
</div></section></section><section><span id="parse-dictionary-en"></span><span id="parse-dictionary-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-a-dictionary-en" lang="en">
<a id="section-4.2.2" href="#section-4.2.2" class="section-number selfRef">4.2.2.</a> <a href="#name-parsing-a-dictionary-en" class="section-name selfRef">Parsing a Dictionary</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-a-dictionary-ja" lang="ja">
<a id="section-4.2.2" href="#section-4.2.2" class="section-number selfRef">4.2.2.</a> <a href="#name-parsing-a-dictionary-ja" class="section-name selfRef">辞書のパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return an ordered map whose values are (item_or_inner_list, parameters) tuples. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、(item_or_inner_list, parameters)タプルを値とする順序付きマップを返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Let dictionary be an empty, ordered map.</p>
</li>
            <li>
              <p>While input_string is not empty:
              </p>
<ol>
<li>
                  <p>Let this_key be the result of running Parsing a Key (<a href="#parse-key-en">Section 4.2.3.3</a>) with input_string.</p>
</li>
                <li>
                  <p>If the first character of input_string is "=":
                  </p>
<ol>
<li>
                      <p>Consume the first character of input_string.</p>
</li>
                    <li>
                      <p>Let member be the result of running Parsing an Item or Inner List (<a href="#parse-item-or-list-en">Section 4.2.1.1</a>) with input_string.</p>
</li>
                  </ol>
</li>
                <li>
                  <p>Otherwise:
                  </p>
<ol>
<li>
                      <p>Let value be Boolean true.</p>
</li>
                    <li>
                      <p>Let parameters be the result of running Parsing Parameters (<a href="#parse-param-en">Section 4.2.3.2</a>) with input_string.</p>
</li>
                    <li>
                      <p>Let member be the tuple (value, parameters).</p>
</li>
                  </ol>
</li>
                <li>
                  <p>If dictionary already contains a key this_key (comparing character for character), overwrite its value with member.</p>
</li>
                <li>
                  <p>Otherwise, append key this_key with value member to dictionary.</p>
</li>
                <li>
                  <p>Discard any leading OWS characters from input_string.</p>
</li>
                <li>
                  <p>If input_string is empty, return dictionary.</p>
</li>
                <li>
                  <p>Consume the first character of input_string; if it is not ",", fail parsing.</p>
</li>
                <li>
                  <p>Discard any leading OWS characters from input_string.</p>
</li>
                <li>
                  <p>If input_string is empty, there is a trailing comma; fail parsing.</p>
</li>
              </ol>
</li>
            <li>
              <p>No structured data has been found; return dictionary (which is empty).</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>dictionaryに空の順序付きマップを代入します。</p>
</li>
            <li>
              <p>input_stringが空でない間:
              </p>
<ol>
<li>
                  <p>input_stringに対して、 キーのパース（<a href="#parse-key-ja">Section 4.2.3.3</a>）を実行した結果を、this_keyに代入します。</p>
</li>
                <li>
                  <p>input_stringの最初の文字が"="である場合:
                  </p>
<ol>
<li>
                      <p>input_stringの最初の一文字を取り除きます。</p>
</li>
                    <li>
                      <p>input_stringに対して、 アイテムまたはインナーリストのパース（<a href="#parse-item-or-list-ja">Section 4.2.1.1</a>）を実行した結果を、 memberに代入します。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>それ以外の場合:
                  </p>
<ol>
<li>
                      <p>valueに真偽値のtrueを代入します。</p>
</li>
                    <li>
                      <p>input_stringに対して、 パラメーターのパース（<a href="#parse-param-ja">Section 4.2.3.2</a>）を実行した結果を、 parametersに代入します。</p>
</li>
                    <li>
                      <p>タプル(value, parameters)をmemberに代入します。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>dictionaryがすでにキーthis_keyを含んでいる場合（一文字ずつ比較）、その値をmemberで上書きします。</p>
</li>
                <li>
                  <p>そうでなければ、キーthis_key値memberをdictionaryに追加します。</p>
</li>
                <li>
                  <p>input_stringの先頭のOWSを無視します。</p>
</li>
                <li>
                  <p>もしinput_stringが空ならdictionaryを返します。</p>
</li>
                <li>
                  <p>input_stringの最初の一文字を取り除きます。 取り除いた文字が「,」でない場合、パースに失敗します。</p>
</li>
                <li>
                  <p>input_stringの先頭のOWSを無視します。</p>
</li>
                <li>
                  <p>もしinput_stringが空なら、末尾にカンマがあります。その場合、パースに失敗します。</p>
</li>
              </ol>
</li>
            <li>
              <p>構造化データが見つからない場合、（空の）dictionaryを返します。</p>
</li>
          </ol></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that when duplicate Dictionary keys are encountered, all but the last instance are ignored.</p></div>
<div lang="ja" class="col"><p>辞書のキーが重複している場合、最後のインスタンス以外は無視されることに注意してください。</p></div>
</div></section><section><span id="parse-item-en"></span><span id="parse-item-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-an-item-en" lang="en">
<a id="section-4.2.3" href="#section-4.2.3" class="section-number selfRef">4.2.3.</a> <a href="#name-parsing-an-item-en" class="section-name selfRef">Parsing an Item</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-an-item-ja" lang="ja">
<a id="section-4.2.3" href="#section-4.2.3" class="section-number selfRef">4.2.3.</a> <a href="#name-parsing-an-item-ja" class="section-name selfRef">アイテムのパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return a (bare_item, parameters) tuple. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII 文字列を input_string として与え、(bare_item, parameters) タプルを返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Let bare_item be the result of running Parsing a Bare Item (<a href="#parse-bare-item-en">Section 4.2.3.1</a>) with input_string.</p>
</li>
            <li>
              <p>Let parameters be the result of running Parsing Parameters (<a href="#parse-param-en">Section 4.2.3.2</a>) with input_string.</p>
</li>
            <li>
              <p>Return the tuple (bare_item, parameters).</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>input_stringに対して、 裸のアイテムのパース（<a href="#parse-bare-item-ja">Section 4.2.3.1</a>）を実行した結果を、 bare_itemに代入します。</p>
</li>
            <li>
              <p>input_stringに対して、 パラメーターのパース（<a href="#parse-param-ja">Section 4.2.3.2</a>）を実行した結果を、 parametersに代入します。</p>
</li>
            <li>
              <p>タプル(bare_item, parameters)を返します。</p>
</li>
          </ol></div>
</div>
<section><span id="parse-bare-item-en"></span><span id="parse-bare-item-ja"></span><div class="row">
<div lang="en" class="col"><h5 id="name-parsing-a-bare-item-en" lang="en">
<a id="section-4.2.3.1" href="#section-4.2.3.1" class="section-number selfRef">4.2.3.1.</a> <a href="#name-parsing-a-bare-item-en" class="section-name selfRef">Parsing a Bare Item</a>
            </h5></div>
<div lang="ja" class="col"><h5 id="name-parsing-a-bare-item-ja" lang="ja">
<a id="section-4.2.3.1" href="#section-4.2.3.1" class="section-number selfRef">4.2.3.1.</a> <a href="#name-parsing-a-bare-item-ja" class="section-name selfRef">裸のアイテムのパース</a>
            </h5></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return a bare Item. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、裸のアイテムを返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
                <p>If the first character of input_string is a "-" or a DIGIT, return the result of running Parsing an Integer or Decimal (<a href="#parse-number-en">Section 4.2.4</a>) with input_string.</p>
</li>
              <li>
                <p>If the first character of input_string is a DQUOTE, return the result of running Parsing a String (<a href="#parse-string-en">Section 4.2.5</a>) with input_string.</p>
</li>
              <li>
                <p>If the first character of input_string is an ALPHA or "*", return the result of running Parsing a Token (<a href="#parse-token-en">Section 4.2.6</a>) with input_string.</p>
</li>
              <li>
                <p>If the first character of input_string is ":", return the result of running Parsing a Byte Sequence (<a href="#parse-binary-en">Section 4.2.7</a>) with input_string.</p>
</li>
              <li>
                <p>If the first character of input_string is "?", return the result of running Parsing a Boolean (<a href="#parse-boolean-en">Section 4.2.8</a>) with input_string.</p>
</li>
              <li>
                <p>If the first character of input_string is "@", return the result of running Parsing a Date (<a href="#parse-date-en">Section 4.2.9</a>) with input_string.</p>
</li>
              <li>
                <p>If the first character of input_string is "%", return the result of running Parsing a Display String (<a href="#parse-display-en">Section 4.2.10</a>) with input_string.</p>
</li>
              <li>
                <p>Otherwise, the item type is unrecognized; fail parsing.</p>
</li>
            </ol></div>
<div lang="ja" class="col"><ol>
<li>
                <p>もしinput_stringの最初の文字が「-」またはDIGITならば、 input_stringに対して、 整数または小数のパース（<a href="#parse-number-ja">Section 4.2.4</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_stringの最初の文字がDQUOTEならば、 input_stringに対して、 文字列のパース（<a href="#parse-string-ja">Section 4.2.5</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_stringの最初の文字がALPHAまたは「*」ならば、 input_stringに対して、 トークンのパース（<a href="#parse-token-ja">Section 4.2.6</a> ）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_stringの最初の文字が「:」ならば、 input_stringに対して、 バイト列のパース（<a href="#parse-binary-ja">Section 4.2.7</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_stringの最初の文字が「?」ならば、 input_stringに対して、 真偽値のパース（<a href="#parse-boolean-ja">Section 4.2.8</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_stringの最初の文字が「@」ならば、input_stringに対して、日付のパース（<a href="#parse-date-ja">Section 4.2.9</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>もしinput_stringの最初の文字が「%」ならば、input_stringに対して、表示文字列のパース（<a href="#parse-display-ja">Section 4.2.10</a>）を実行した結果を返します。</p>
</li>
              <li>
                <p>れ以外の場合アイテムの型を認識できないため、パースに失敗します。</p>
</li>
            </ol></div>
</div></section><section><span id="parse-param-en"></span><span id="parse-param-ja"></span><div class="row">
<div lang="en" class="col"><h5 id="name-parsing-parameters-en" lang="en">
<a id="section-4.2.3.2" href="#section-4.2.3.2" class="section-number selfRef">4.2.3.2.</a> <a href="#name-parsing-parameters-en" class="section-name selfRef">Parsing Parameters</a>
            </h5></div>
<div lang="ja" class="col"><h5 id="name-parsing-parameters-ja" lang="ja">
<a id="section-4.2.3.2" href="#section-4.2.3.2" class="section-number selfRef">4.2.3.2.</a> <a href="#name-parsing-parameters-ja" class="section-name selfRef">パラメーターのパース</a>
            </h5></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return an ordered map whose values are bare Items. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、裸のアイテムを値とする順序付きマップを返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
                <p>Let parameters be an empty, ordered map.</p>
</li>
              <li>
                <p>While input_string is not empty:
                </p>
<ol>
<li>
                    <p>If the first character of input_string is not ";", exit the loop.</p>
</li>
                  <li>
                    <p>Consume the ";" character from the beginning of input_string.</p>
</li>
                  <li>
                    <p>Discard any leading SP characters from input_string.</p>
</li>
                  <li>
                    <p>Let param_key be the result of running Parsing a Key (<a href="#parse-key-en">Section 4.2.3.3</a>) with input_string.</p>
</li>
                  <li>
                    <p>Let param_value be Boolean true.</p>
</li>
                  <li>
                    <p>If the first character of input_string is "=":
                    </p>
<ol>
<li>
                        <p>Consume the "=" character at the beginning of input_string.</p>
</li>
                      <li>
                        <p>Let param_value be the result of running Parsing a Bare Item (<a href="#parse-bare-item-en">Section 4.2.3.1</a>) with input_string.</p>
</li>
                    </ol>
</li>
                  <li>
                    <p>If parameters already contains a key param_key (comparing character for character), overwrite its value with param_value.</p>
</li>
                  <li>
                    <p>Otherwise, append key param_key with value param_value to parameters.</p>
</li>
                </ol>
</li>
              <li>
                <p>Return parameters.</p>
</li>
            </ol></div>
<div lang="ja" class="col"><ol>
<li>
                <p>parametersに空の順序付きマップを代入します。</p>
</li>
              <li>
                <p>input_stringが空でない間:
                </p>
<ol>
<li>
                    <p>もしinput_stringの最初の文字が「;」でなければ、ループを抜けます。</p>
</li>
                  <li>
                    <p>input_stringの先頭から「;」を取り除きます。</p>
</li>
                  <li>
                    <p>input_stringの先頭のSPを無視します。</p>
</li>
                  <li>
                    <p>input_stringに対して、 キーのパース（<a href="#parse-key-ja">Section 4.2.3.3</a>）を実行した結果を、param_keyに代入します。</p>
</li>
                  <li>
                    <p>param_valueに真偽値のtrueを代入します。</p>
</li>
                  <li>
                    <p>input_stringの最初の文字が"="である場合:
                    </p>
<ol>
<li>
                        <p>input_stringの先頭から「=」を取り除きます。</p>
</li>
                      <li>
                        <p>input_stringに対して、 裸のアイテムのパース（<a href="#parse-bare-item-ja">Section 4.2.3.1</a>）を実行した結果を、param_valueに代入します。</p>
</li>
                    </ol>
</li>
                  <li>
                    <p>parametersがすでにキーparam_keyを含んでいる場合（一文字ずつ比較）、その値をparam_valueで上書きします。</p>
</li>
                  <li>
                    <p>そうでなければ、キーparam_key値param_valueをparametersに追加します。</p>
</li>
                </ol>
</li>
              <li>
                <p>parametersを返します。</p>
</li>
            </ol></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Note that when duplicate parameter keys are encountered, all but the last instance are ignored.</p></div>
<div lang="ja" class="col"><p>パラメーターのキーが重複している場合、最後のインスタンス以外は無視されることに注意してください。</p></div>
</div></section><section><span id="parse-key-en"></span><span id="parse-key-ja"></span><div class="row">
<div lang="en" class="col"><h5 id="name-parsing-a-key-en" lang="en">
<a id="section-4.2.3.3" href="#section-4.2.3.3" class="section-number selfRef">4.2.3.3.</a> <a href="#name-parsing-a-key-en" class="section-name selfRef">Parsing a Key</a>
            </h5></div>
<div lang="ja" class="col"><h5 id="name-parsing-a-key-ja" lang="ja">
<a id="section-4.2.3.3" href="#section-4.2.3.3" class="section-number selfRef">4.2.3.3.</a> <a href="#name-parsing-a-key-ja" class="section-name selfRef">キーのパース</a>
            </h5></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return a key. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、キーを返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
                <p>If the first character of input_string is not lcalpha or "*", fail parsing.</p>
</li>
              <li>
                <p>Let output_string be an empty string.</p>
</li>
              <li>
                <p>While input_string is not empty:
                </p>
<ol>
<li>
                    <p>If the first character of input_string is not one of lcalpha, DIGIT, "_", "-", ".", or "*", return output_string.</p>
</li>
                  <li>
                    <p>Let char be the result of consuming the first character of input_string.</p>
</li>
                  <li>
                    <p>Append char to output_string.</p>
</li>
                </ol>
</li>
              <li>
                <p>Return output_string.</p>
</li>
            </ol></div>
<div lang="ja" class="col"><ol>
<li>
                <p>もしinput_stringの先頭一文字がlcaphaまたは「*」でない場合、パースに失敗します。</p>
</li>
              <li>
                <p>output_stringに空文字列を代入します。</p>
</li>
              <li>
                <p>input_stringが空でない間:
                </p>
<ol>
<li>
                    <p>もしinput_stringの先頭一文字がlcapha、DIGIT、「_」、「-」、「.」、「*」でない場合、output_stringを返します。</p>
</li>
                  <li>
                    <p>input_stringの先頭の文字を取り出した結果を、charに代入します。</p>
</li>
                  <li>
                    <p>charをoutput_stringに追加します。</p>
</li>
                </ol>
</li>
              <li>
                <p>output_stringを返します。</p>
</li>
            </ol></div>
</div></section></section><section><span id="parse-number-en"></span><span id="parse-number-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-an-integer-or-decim-en" lang="en">
<a id="section-4.2.4" href="#section-4.2.4" class="section-number selfRef">4.2.4.</a> <a href="#name-parsing-an-integer-or-decim-en" class="section-name selfRef">Parsing an Integer or Decimal</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-an-integer-or-decim-ja" lang="ja">
<a id="section-4.2.4" href="#section-4.2.4" class="section-number selfRef">4.2.4.</a> <a href="#name-parsing-an-integer-or-decim-ja" class="section-name selfRef">整数または小数のパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return an Integer or Decimal. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、整数または小数を返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>NOTE: This algorithm parses both Integers (<a href="#integer-en">Section 3.3.1</a>) and Decimals (<a href="#decimal-en">Section 3.3.2</a>), and returns the corresponding structure.</p></div>
<div lang="ja" class="col"><p>注：このアルゴリズムは、整数(<a href="#integer-ja">Section 3.3.1</a>)と小数(<a href="#decimal-ja">Section 3.3.2</a>)の両方を解析し、対応する構造を返します。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Let type be "integer".</p>
</li>
            <li>
              <p>Let sign be 1.</p>
</li>
            <li>
              <p>Let input_number be an empty string.</p>
</li>
            <li>
              <p>If the first character of input_string is "-", consume it and set sign to -1.</p>
</li>
            <li>
              <p>If input_string is empty, there is an empty integer; fail parsing.</p>
</li>
            <li>
              <p>If the first character of input_string is not a DIGIT, fail parsing.</p>
</li>
            <li>
              <p>While input_string is not empty:
              </p>
<ol>
<li>
                  <p>Let char be the result of consuming the first character of input_string.</p>
</li>
                <li>
                  <p>If char is a DIGIT, append it to input_number.</p>
</li>
                <li>
                  <p>Else, if type is "integer" and char is ".":
                  </p>
<ol>
<li>
                      <p>If input_number contains more than 12 characters, fail parsing.</p>
</li>
                    <li>
                      <p>Otherwise, append char to input_number and set type to "decimal".</p>
</li>
                  </ol>
</li>
                <li>
                  <p>Otherwise, prepend char to input_string, and exit the loop.</p>
</li>
                <li>
                  <p>If type is "integer" and input_number contains more than 15 characters, fail parsing.</p>
</li>
                <li>
                  <p>If type is "decimal" and input_number contains more than 16 characters, fail parsing.</p>
</li>
              </ol>
</li>
            <li>
              <p>If type is "integer":
              </p>
<ol>
<li>
                  <p>Let output_number be an Integer that is the result of parsing input_number as an integer.</p>
</li>
              </ol>
</li>
            <li>
              <p>Otherwise:
              </p>
<ol>
<li>
                  <p>If the final character of input_number is ".", fail parsing.</p>
</li>
                <li>
                  <p>If the number of characters after "." in input_number is greater than three, fail parsing.</p>
</li>
                <li>
                  <p>Let output_number be a Decimal that is the result of parsing input_number as a decimal number.</p>
</li>
              </ol>
</li>
            <li>
              <p>Let output_number be the product of output_number and sign.</p>
</li>
            <li>
              <p>Return output_number.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>typeに「integer」を代入します。</p>
</li>
            <li>
              <p>signに1を代入します。</p>
</li>
            <li>
              <p>input_numberに空文字列を代入します。</p>
</li>
            <li>
              <p>もしinput_stringの先頭一文字が「-」の場合、「-」を取り除いて、signに-1を代入します。</p>
</li>
            <li>
              <p>もしinput_stringが空の場合、空の整数なので、パースに失敗します。</p>
</li>
            <li>
              <p>もしinput_stringの先頭一文字がDIGITでない場合、パースに失敗します。</p>
</li>
            <li>
              <p>input_stringが空でない間:
              </p>
<ol>
<li>
                  <p>input_stringの最初の一文字を取り除き、charに代入します。</p>
</li>
                <li>
                  <p>もし、charがDIGITの場合、input_numberにcharを追加します。</p>
</li>
                <li>
                  <p>また、typeが「integer」で、charが「.」の場合:
                  </p>
<ol>
<li>
                      <p>もし、input_numberが12文字より長ければ、パースに失敗します。</p>
</li>
                    <li>
                      <p>そうでなければ、input_numberにcharを追加し、typeに「decimal」をセットします。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>そうでない場合、input_stringの先頭にcharを追加し、ループを抜けます。</p>
</li>
                <li>
                  <p>もしtypeが「integer」で、input_numberが15文字より長ければ、パースに失敗します。</p>
</li>
                <li>
                  <p>もしtypeが「decimal」で、input_numberが16文字より長ければ、パースに失敗します。</p>
</li>
              </ol>
</li>
            <li>
              <p>typeが「integer」の場合:
              </p>
<ol>
<li>
                  <p>input_numberを整数としてパースし、output_numberに代入します。</p>
</li>
              </ol>
</li>
            <li>
              <p>Otherwise:
              </p>
<ol>
<li>
                  <p>もしinput_numberの最後の文字が「.」なら、パースに失敗します。</p>
</li>
                <li>
                  <p>input_numberの「.」以降の文字数が3文字より長ければ、パースに失敗します。</p>
</li>
                <li>
                  <p>input_numberを小数としてパースし、output_numberに代入します。</p>
</li>
              </ol>
</li>
            <li>
              <p>output_numberにoutput_numberとsignの積を代入します。</p>
</li>
            <li>
              <p>output_numberを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="parse-string-en"></span><span id="parse-string-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-a-string-en" lang="en">
<a id="section-4.2.5" href="#section-4.2.5" class="section-number selfRef">4.2.5.</a> <a href="#name-parsing-a-string-en" class="section-name selfRef">Parsing a String</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-a-string-ja" lang="ja">
<a id="section-4.2.5" href="#section-4.2.5" class="section-number selfRef">4.2.5.</a> <a href="#name-parsing-a-string-ja" class="section-name selfRef">文字列のパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return an unquoted String. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>input_stringにASCII文字列が与えられた場合、引用符で囲まれていない文字列を返します。input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>Let output_string be an empty string.</p>
</li>
            <li>
              <p>If the first character of input_string is not DQUOTE, fail parsing.</p>
</li>
            <li>
              <p>Discard the first character of input_string.</p>
</li>
            <li>
              <p>While input_string is not empty:
              </p>
<ol>
<li>
                  <p>Let char be the result of consuming the first character of input_string.</p>
</li>
                <li>
                  <p>If char is a backslash ("\"):
                  </p>
<ol>
<li>
                      <p>If input_string is now empty, fail parsing.</p>
</li>
                    <li>
                      <p>Let next_char be the result of consuming the first character of input_string.</p>
</li>
                    <li>
                      <p>If next_char is not DQUOTE or "\", fail parsing.</p>
</li>
                    <li>
                      <p>Append next_char to output_string.</p>
</li>
                  </ol>
</li>
                <li>
                  <p>Else, if char is DQUOTE, return output_string.</p>
</li>
                <li>
                  <p>Else, if char is in the range %x00-1f or %x7f-ff (i.e., it is not in VCHAR or SP), fail parsing.</p>
</li>
                <li>
                  <p>Else, append char to output_string.</p>
</li>
              </ol>
</li>
            <li>
              <p>Reached the end of input_string without finding a closing DQUOTE; fail parsing.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>output_stringに空文字列を代入します。</p>
</li>
            <li>
              <p>もしinput_stringの最初の文字がDQUOTEでなければ、パースに失敗します。</p>
</li>
            <li>
              <p>input_stringの最初の文字を取り除きます。</p>
</li>
            <li>
              <p>input_stringが空でない間:
              </p>
<ol>
<li>
                  <p>input_stringの最初の一文字を取り除き、charに代入します。</p>
</li>
                <li>
                  <p>charがバックスラッシュ（「\」）の場合：
                  </p>
<ol>
<li>
                      <p>もしinput_stringが空なら、パースに失敗します。</p>
</li>
                    <li>
                      <p>input_stringの最初の一文字を取り除き、next_charに代入します。</p>
</li>
                    <li>
                      <p>next_charがDQUOTEとバックスラッシュ（「\」）のどちらでもない場合、パースに失敗します。</p>
</li>
                    <li>
                      <p>output_stringにnext_charを追加します。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>もしcharがDQUOTEなら、output_stringを返します。</p>
</li>
                <li>
                  <p>もしcharが%00-1fまたは%7f-ffの範囲内にある場合（つまり、VCHARまたはSPの範囲外の場合）、パースに失敗します。</p>
</li>
                <li>
                  <p>それ以外の場合、output_stringにcharを追加します。</p>
</li>
              </ol>
</li>
            <li>
              <p>DQUOTEが見つからないままinput_stringが空になった場合、パースに失敗します。</p>
</li>
          </ol></div>
</div></section><section><span id="parse-token-en"></span><span id="parse-token-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-a-token-en" lang="en">
<a id="section-4.2.6" href="#section-4.2.6" class="section-number selfRef">4.2.6.</a> <a href="#name-parsing-a-token-en" class="section-name selfRef">Parsing a Token</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-a-token-ja" lang="ja">
<a id="section-4.2.6" href="#section-4.2.6" class="section-number selfRef">4.2.6.</a> <a href="#name-parsing-a-token-ja" class="section-name selfRef">トークンのパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return a Token. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、Tokenを返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If the first character of input_string is not ALPHA or "*", fail parsing.</p>
</li>
            <li>
              <p>Let output_string be an empty string.</p>
</li>
            <li>
              <p>While input_string is not empty:
              </p>
<ol>
<li>
                  <p>If the first character of input_string is not in tchar, ":", or "/", return output_string.</p>
</li>
                <li>
                  <p>Let char be the result of consuming the first character of input_string.</p>
</li>
                <li>
                  <p>Append char to output_string.</p>
</li>
              </ol>
</li>
            <li>
              <p>Return output_string.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>もしinput_stringの先頭一文字がALPHAまたは"*"でなければ、パースに失敗します。</p>
</li>
            <li>
              <p>output_stringに空文字列を代入します。</p>
</li>
            <li>
              <p>input_stringが空でない間:
              </p>
<ol>
<li>
                  <p>input_stringの先頭一文字がtchar、「:」、または「/」でなければ、output_stringを返します。</p>
</li>
                <li>
                  <p>input_stringの先頭の文字を取り出した結果を、charに代入します。</p>
</li>
                <li>
                  <p>output_stringにcharを追加します。</p>
</li>
              </ol>
</li>
            <li>
              <p>output_stringを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="parse-binary-en"></span><span id="parse-binary-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-a-byte-sequence-en" lang="en">
<a id="section-4.2.7" href="#section-4.2.7" class="section-number selfRef">4.2.7.</a> <a href="#name-parsing-a-byte-sequence-en" class="section-name selfRef">Parsing a Byte Sequence</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-a-byte-sequence-ja" lang="ja">
<a id="section-4.2.7" href="#section-4.2.7" class="section-number selfRef">4.2.7.</a> <a href="#name-parsing-a-byte-sequence-ja" class="section-name selfRef">バイト列のパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return a Byte Sequence. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>input_stringにASCII文字列が与えられた場合、バイト列を返します。input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If the first character of input_string is not ":", fail parsing.</p>
</li>
            <li>
              <p>Discard the first character of input_string.</p>
</li>
            <li>
              <p>If there is not a ":" character before the end of input_string, fail parsing.</p>
</li>
            <li>
              <p>Let b64_content be the result of consuming content of input_string up to but not including the first instance of the character ":".</p>
</li>
            <li>
              <p>Consume the ":" character at the beginning of input_string.</p>
</li>
            <li>
              <p>If b64_content contains a character not included in ALPHA, DIGIT, "+", "/", and "=", fail parsing.</p>
</li>
            <li>
              <p>Let binary_content be the result of base64-decoding <span>[<a href="#RFC4648-en">RFC4648</a>]</span> b64_content, synthesizing padding if necessary (note the requirements about recipient behavior below). If base64 decoding fails, parsing fails.</p>
</li>
            <li>
              <p>Return binary_content.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>もしinput_stringの最初の文字が「:」でない場合、パースに失敗します。</p>
</li>
            <li>
              <p>input_stringの最初の文字を取り除きます。</p>
</li>
            <li>
              <p>input_stringの終わりまでに「:」が見つからない場合、パースに失敗します。</p>
</li>
            <li>
              <p>input_stringの最初の「:」までを取り除き、その結果をb64_contentに代入します。ただし、「:」自体は含みません。</p>
</li>
            <li>
              <p>input_stringの最初の「:」を取り除きます。</p>
</li>
            <li>
              <p>もしb64_contentがALPHA、DIGIT、"+"、"/"、または"="以外の文字を含む場合、パースに失敗します。</p>
</li>
            <li>
              <p>必要に応じてパディングを合成しながら、b64_contentをbase64デコード<span>[<a href="#RFC4648-ja">RFC4648</a>]</span>した結果をbinary_contentに代入します（以下の受信者の動作に関する要件に注意してください）。base64デコードに失敗した場合、解析は失敗します。</p>
</li>
            <li>
              <p>binary_contentを返します。</p>
</li>
          </ol></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Because some implementations of base64 do not allow rejection of encoded data that is not properly "=" padded (see <span>[<a href="#RFC4648-en">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.2">Section 3.2</a></span>), parsers <span class="bcp14">SHOULD NOT</span> fail when "=" padding is not present, unless they cannot be configured to do so.</p></div>
<div lang="ja" class="col"><p>base64の実装によっては、適切に"="パディングされていないエンコードされたデータを拒否することができないため(<span>[<a href="#RFC4648-ja">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.2">Section 3.2</a></span>参照)、パーサーは"="パディングが存在しない場合、そう設定できない場合を除いて、失敗<span class="bcp14">すべきではありません（SHOULD NOT）</span>。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Because some implementations of base64 do not allow rejection of encoded data that has non-zero pad bits (see <span>[<a href="#RFC4648-en">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.5">Section 3.5</a></span>), parsers <span class="bcp14">SHOULD NOT</span> fail when non-zero pad bits are present, unless they cannot be configured to do so.</p></div>
<div lang="ja" class="col"><p>base64の実装によっては、0以外のパッドビットを持つエンコードされたデータを拒否することができないため(<span>[<a href="#RFC4648-ja">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.5">Section 3.5</a></span>参照)、パーサーは0以外のパッドビットが存在する場合、そのように設定できない場合を除いて、失敗<span class="bcp14">すべきではありません（SHOULD NOT）</span>。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This specification does not relax the requirements in Sections <a href="#RFC4648-en">RFC4648</a> and <a href="#RFC4648-en">RFC4648</a> of <span>[<a href="#RFC4648-en">RFC4648</a>]</span>; therefore, parsers <span class="bcp14">MUST</span> fail on characters outside the base64 alphabet and on line feeds in encoded data.</p></div>
<div lang="ja" class="col"><p>この仕様では、セクション<a href="#RFC4648-ja">RFC4648</a>と<span>[<a href="#RFC4648-ja">RFC4648</a>]</span>の<a href="#RFC4648-ja">RFC4648</a>の要件は緩和されていません。したがって、パーサーは、base64アルファベット以外の文字や改行がエンコードされたデータに含まれていた場合、失敗<span class="bcp14">しなければなりません（MUST）</span>。</p></div>
</div></section><section><span id="parse-boolean-en"></span><span id="parse-boolean-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-a-boolean-en" lang="en">
<a id="section-4.2.8" href="#section-4.2.8" class="section-number selfRef">4.2.8.</a> <a href="#name-parsing-a-boolean-en" class="section-name selfRef">Parsing a Boolean</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-a-boolean-ja" lang="ja">
<a id="section-4.2.8" href="#section-4.2.8" class="section-number selfRef">4.2.8.</a> <a href="#name-parsing-a-boolean-ja" class="section-name selfRef">真偽値のパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return a Boolean. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、真偽値を返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If the first character of input_string is not "?", fail parsing.</p>
</li>
            <li>
              <p>Discard the first character of input_string.</p>
</li>
            <li>
              <p>If the first character of input_string matches "1", discard the first character, and return true.</p>
</li>
            <li>
              <p>If the first character of input_string matches "0", discard the first character, and return false.</p>
</li>
            <li>
              <p>No value has matched; fail parsing.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>もしinput_stringの先頭一文字が「?」でない場合、パースに失敗します。</p>
</li>
            <li>
              <p>input_stringの最初の一文字を取り除きます。</p>
</li>
            <li>
              <p>もし、input_stringの先頭一文字が「1」である場合、input_stringの最初の一文字を取り除き、真を返します。</p>
</li>
            <li>
              <p>もし、input_stringの先頭一文字が「0」である場合、input_stringの最初の一文字を取り除き、偽を返します。</p>
</li>
            <li>
              <p>いずれの値にもマッチしない場合、パースに失敗します。</p>
</li>
          </ol></div>
</div></section><section><span id="parse-date-en"></span><span id="parse-date-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-a-date-en" lang="en">
<a id="section-4.2.9" href="#section-4.2.9" class="section-number selfRef">4.2.9.</a> <a href="#name-parsing-a-date-en" class="section-name selfRef">Parsing a Date</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-a-date-ja" lang="ja">
<a id="section-4.2.9" href="#section-4.2.9" class="section-number selfRef">4.2.9.</a> <a href="#name-parsing-a-date-ja" class="section-name selfRef">日付のパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return a Date. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、日付を返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If the first character of input_string is not "@", fail parsing.</p>
</li>
            <li>
              <p>Discard the first character of input_string.</p>
</li>
            <li>
              <p>Let output_date be the result of running Parsing an Integer or Decimal (<a href="#parse-number-en">Section 4.2.4</a>) with input_string.</p>
</li>
            <li>
              <p>If output_date is a Decimal, fail parsing.</p>
</li>
            <li>
              <p>Return output_date.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>もしinput_stringの先頭一文字が「@」でない場合、パースに失敗します。</p>
</li>
            <li>
              <p>input_stringの最初の一文字を取り除きます。</p>
</li>
            <li>
              <p>input_stringに対して、整数または小数のパース（<a href="#parse-number-ja">Section 4.2.4</a>）を実行した結果を、output_dateに代入します。</p>
</li>
            <li>
              <p>output_dateが小数の場合、パースに失敗します。</p>
</li>
            <li>
              <p>output_dateを返します。</p>
</li>
          </ol></div>
</div></section><section><span id="parse-display-en"></span><span id="parse-display-ja"></span><div class="row">
<div lang="en" class="col"><h4 id="name-parsing-a-display-string-en" lang="en">
<a id="section-4.2.10" href="#section-4.2.10" class="section-number selfRef">4.2.10.</a> <a href="#name-parsing-a-display-string-en" class="section-name selfRef">Parsing a Display String</a>
          </h4></div>
<div lang="ja" class="col"><h4 id="name-parsing-a-display-string-ja" lang="ja">
<a id="section-4.2.10" href="#section-4.2.10" class="section-number selfRef">4.2.10.</a> <a href="#name-parsing-a-display-string-ja" class="section-name selfRef">表示文字列のパース</a>
          </h4></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Given an ASCII string as input_string, return a sequence of Unicode code points. input_string is modified to remove the parsed value.</p></div>
<div lang="ja" class="col"><p>ASCII文字列をinput_stringとして与え、Unicodeコードポイントの列を返します。 input_stringは解析済みの値を除去するために変更されます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ol>
<li>
              <p>If the first two characters of input_string are not "%" followed by DQUOTE, fail parsing.</p>
</li>
            <li>
              <p>Discard the first two characters of input_string.</p>
</li>
            <li>
              <p>Let byte_array be an empty byte array.</p>
</li>
            <li>
              <p>While input_string is not empty:
              </p>
<ol>
<li>
                  <p>Let char be the result of consuming the first character of input_string.</p>
</li>
                <li>
                  <p>If char is in the range %x00-1f or %x7f-ff (i.e., it is not in VCHAR or SP), fail parsing.</p>
</li>
                <li>
                  <p>If char is "%":
                  </p>
<ol>
<li>
                      <p>Let octet_hex be the result of consuming two characters from input_string. If there are not two characters, fail parsing.</p>
</li>
                    <li>
                      <p>If octet_hex contains characters outside the range %x30-39 or %x61-66 (i.e., it is not in 0-9 or lowercase a-f), fail parsing.</p>
</li>
                    <li>
                      <p>Let octet be the result of hex decoding octet_hex (<span><a href="https://rfc-editor.org/rfc/rfc4648#section-8">Section 8</a> of [<a href="#RFC4648-en">RFC4648</a>]</span>).</p>
</li>
                    <li>
                      <p>Append octet to byte_array.</p>
</li>
                  </ol>
</li>
                <li>
                  <p>If char is DQUOTE:
                  </p>
<ol>
<li>
                      <p>Let unicode_sequence be the result of decoding byte_array as a UTF-8 string (<span><a href="https://rfc-editor.org/rfc/rfc3629#section-3">Section 3</a> of [<a href="#RFC3629-en">UTF8</a>]</span>). Fail parsing if decoding fails.</p>
</li>
                    <li>
                      <p>Return unicode_sequence.</p>
</li>
                  </ol>
</li>
                <li>
                  <p>Otherwise, if char is not "%" or DQUOTE:
                  </p>
<ol>
<li>
                      <p>Let byte be the result of applying ASCII encoding to char.</p>
</li>
                    <li>
                      <p>Append byte to byte_array.</p>
</li>
                  </ol>
</li>
              </ol>
</li>
            <li>
              <p>Reached the end of input_string without finding a closing DQUOTE; fail parsing.</p>
</li>
          </ol></div>
<div lang="ja" class="col"><ol>
<li>
              <p>input_stringの最初の2文字が"%"とそれに続くDQUOTEでない場合、解析に失敗します。</p>
</li>
            <li>
              <p>input_stringの最初の二文字を取り除きます。</p>
</li>
            <li>
              <p>byte_arrayに空のバイト配列を代入します。</p>
</li>
            <li>
              <p>input_stringが空でない間:
              </p>
<ol>
<li>
                  <p>charをinput_stringの最初の文字を消費した結果とします。</p>
</li>
                <li>
                  <p>charが%x00-1fまたは%x7f-ffの範囲内にある場合（つまり、VCHARまたはSPに含まれていない場合）、パースに失敗します。</p>
</li>
                <li>
                  <p>もしcharが「%」ならば：
                  </p>
<ol>
<li>
                      <p>octet_hexをinput_stringから2文字消費した結果とします。2文字ない場合、解析に失敗します。</p>
</li>
                    <li>
                      <p>octet_hexに%x30-39または%x61-66の範囲外の文字が含まれている場合（つまり、0-9または小文字のa-fでない場合）、解析に失敗します。</p>
</li>
                    <li>
                      <p>octetを、octet_hexを16進デコードした結果とします (<span>[<a href="#RFC4648-ja">RFC4648</a>]の<a href="https://rfc-editor.org/rfc/rfc4648#section-8">Section 8</a></span>)。</p>
</li>
                    <li>
                      <p>octetをbyte_arrayに追加します。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>charがDQUOTEの場合:
                  </p>
<ol>
<li>
                      <p>unicode_sequenceを、byte_arrayをUTF-8文字列としてデコードした結果とします (<span>[<a href="#RFC3629-ja">UTF8</a>]の<a href="https://rfc-editor.org/rfc/rfc3629#section-3">Section 3</a></span>)。デコードに失敗した場合、解析に失敗します。</p>
</li>
                    <li>
                      <p>unicode_sequenceを返します。</p>
</li>
                  </ol>
</li>
                <li>
                  <p>それ以外の場合、charが"%"またはDQUOTEでない場合:
                  </p>
<ol>
<li>
                      <p>byteをcharにASCIIエンコーディングを適用した結果とします。</p>
</li>
                    <li>
                      <p>byteをbyte_arrayに追加します。</p>
</li>
                  </ol>
</li>
              </ol>
</li>
            <li>
              <p>input_stringの終わりに達しても閉じるDQUOTEが見つからなかった場合、解析に失敗します。</p>
</li>
          </ol></div>
</div></section></section></section><section><span id="iana-en"></span><span id="iana-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-iana-considerations-en" lang="en">
<a id="section-5" href="#section-5" class="section-number selfRef">5.</a> <a href="#name-iana-considerations-en" class="section-name selfRef">IANA Considerations</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-iana-considerations-ja" lang="ja">
<a id="section-5" href="#section-5" class="section-number selfRef">5.</a> <a href="#name-iana-considerations-ja" class="section-name selfRef">IANAに関する考慮事項</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>IANA has added the following note to the "Hypertext Transfer Protocol (HTTP) Field Name Registry":</p></div>
<div lang="ja" class="col"><p>IANAは「Hypertext Transfer Protocol (HTTP) Field Name Registry」に次の注記を追加しました:</p></div>
</div>
<div class="row">
<div lang="en" class="col"><blockquote>
<p>The "Structured Type" column indicates the type of the field (per RFC 9651), if any, and may be
"Dictionary", "List", or "Item".</p>
<p>Note that field names beginning with characters other than ALPHA or "*" will not be able to be
represented as a Structured Fields Token and therefore may be incompatible with being mapped into
field values that refer to it.</p>
</blockquote></div>
<div lang="ja" class="col"><blockquote>
<p>「Structured Type」列は、フィールドのタイプ（RFC 9651に準拠）を示し、「Dictionary」、「List」、または「Item」のいずれかです。</p>
<p>ALPHAまたは"*"以外の文字で始まるフィールド名は、構造化フィールドトークンとして表現できないため、それに言及するフィールド値にマッピングすることと互換性がない可能性があることに注意してください。</p>
</blockquote></div>
</div>
<div class="row">
<div lang="en" class="col"><p>A new column, "Structured Type", has been added to the registry.</p></div>
<div lang="ja" class="col"><p>新しい列「Structured Type」がレジストリに追加されました。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>The indicated Structured Type for each existing registry entry listed in <a href="#existing-fields-en">Table 1</a> has also been added.</p></div>
<div lang="ja" class="col"><p>また、<a href="#existing-fields-ja">Table 1</a>に記載されている既存のレジストリエントリごとに示されたStructured Typeも追加されました。</p></div>
</div>
<div class="row">
<div lang="en" class="col">
<span id="name-existing-fields-en"></span><span id="existing-fields-en"></span><table id="table-1-en">
<caption>
<a href="#table-1-en" class="selfRef">Table 1</a>:
<a href="#name-existing-fields-en" class="selfRef">Existing Fields</a>
        </caption>
<thead><tr>
<th class="text-left" colspan="1" rowspan="1">Field Name</th>
            <th class="text-left" colspan="1" rowspan="1">Structured Type</th>
          </tr></thead>
<tbody>
<tr>
<td class="text-left" colspan="1" rowspan="1">Accept-CH</td>
            <td class="text-left" colspan="1" rowspan="1">List</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cache-Status</td>
            <td class="text-left" colspan="1" rowspan="1">List</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">CDN-Cache-Control</td>
            <td class="text-left" colspan="1" rowspan="1">Dictionary</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cross-Origin-Embedder-Policy</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cross-Origin-Embedder-Policy-Report-Only</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cross-Origin-Opener-Policy</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cross-Origin-Opener-Policy-Report-Only</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Origin-Agent-Cluster</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Priority</td>
            <td class="text-left" colspan="1" rowspan="1">Dictionary</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Proxy-Status</td>
            <td class="text-left" colspan="1" rowspan="1">List</td>
          </tr>
</tbody>
</table>
</div>
<div lang="ja" class="col">
<span id="name-existing-fields-ja"></span><span id="existing-fields-ja"></span><table id="table-1-ja">
<caption>
<a href="#table-1-ja" class="selfRef">表 1</a>:
<a href="#name-existing-fields-ja" class="selfRef">既存のフィールド</a>
        </caption>
<thead><tr>
<th class="text-left" colspan="1" rowspan="1">フィールド名</th>
            <th class="text-left" colspan="1" rowspan="1">構造化型</th>
          </tr></thead>
<tbody>
<tr>
<td class="text-left" colspan="1" rowspan="1">Accept-CH</td>
            <td class="text-left" colspan="1" rowspan="1">List</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cache-Status</td>
            <td class="text-left" colspan="1" rowspan="1">List</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">CDN-Cache-Control</td>
            <td class="text-left" colspan="1" rowspan="1">Dictionary</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cross-Origin-Embedder-Policy</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cross-Origin-Embedder-Policy-Report-Only</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cross-Origin-Opener-Policy</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Cross-Origin-Opener-Policy-Report-Only</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Origin-Agent-Cluster</td>
            <td class="text-left" colspan="1" rowspan="1">Item</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Priority</td>
            <td class="text-left" colspan="1" rowspan="1">Dictionary</td>
          </tr>
<tr>
<td class="text-left" colspan="1" rowspan="1">Proxy-Status</td>
            <td class="text-left" colspan="1" rowspan="1">List</td>
          </tr>
</tbody>
</table>
</div>
</div></section><section><span id="security-en"></span><span id="security-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-security-considerations-en" lang="en">
<a id="section-6" href="#section-6" class="section-number selfRef">6.</a> <a href="#name-security-considerations-en" class="section-name selfRef">Security Considerations</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-security-considerations-ja" lang="ja">
<a id="section-6" href="#section-6" class="section-number selfRef">6.</a> <a href="#name-security-considerations-ja" class="section-name selfRef">セキュリティーに関する考察</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>The size of most types defined by Structured Fields is not limited; as a result, extremely large fields could be an attack vector (e.g., for resource consumption). Most HTTP implementations limit the sizes of individual fields as well as the overall header or trailer section size to mitigate such attacks.</p></div>
<div lang="ja" class="col"><p>構造化フィールドで定義されたほとんどの型のサイズは制限されていません。その結果、非常に大きなフィールドが攻撃ベクトル（例えば、リソース消費のため）になる可能性があります。ほとんどのHTTP実装は、このような攻撃を軽減するために、個々のフィールドのサイズや全体のヘッダーまたはトレーラーセクションのサイズを制限しています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>It is possible for parties with the ability to inject new HTTP fields to change the meaning
of a Structured Field. In some circumstances, this will cause parsing to fail, but it is not possible to reliably fail in all such circumstances.</p></div>
<div lang="ja" class="col"><p>新しいHTTPフィールドを挿入する能力を持つ者が、構造化フィールドの意味を変更する可能性があります。場合によっては、これにより解析が失敗しますが、すべての状況で確実に失敗するわけではありません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>The Display String type can convey any possible Unicode code point without sanitization; for example, they might contain unassigned code points, control points (including NUL), or noncharacters. Therefore, applications consuming Display Strings need to consider strategies such as filtering or escaping untrusted content before displaying it. See <span>[<a href="#RFC8264-en">PRECIS</a>]</span> and <span>[<a href="#UNICODE-SECURITY-en">UNICODE-SECURITY</a>]</span>.</p></div>
<div lang="ja" class="col"><p>表示文字列タイプは、未割り当てのコードポイント、制御ポイント（NULを含む）、または非文字を含む可能性があるため、サニタイズなしで任意のUnicodeコードポイントを伝えることができます。したがって、表示文字列を消費するアプリケーションは、表示する前に信頼できないコンテンツをフィルタリングまたはエスケープするなどの戦略を検討する必要があります。<span>[<a href="#RFC8264-ja">PRECIS</a>]</span>および<span>[<a href="#UNICODE-SECURITY-ja">UNICODE-SECURITY</a>]</span>を参照してください。</p></div>
</div></section><div class="row">
<div lang="en" class="col"><section><h2 id="name-references-en" lang="en">
<a href="#name-references-en" class="section-name selfRef">References</a>
      </h2>
<section><h3 id="name-normative-references-en" lang="en">
<a href="#name-normative-references-en" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC9110-en">[HTTP]</dt>
<dd class="break">
<span class="refAuthor">Fielding, R.</span>, <span class="refAuthor">Nottingham, M.</span>, and <span class="refAuthor">J. Reschke</span>, <span></span><span class="refTitle">"HTTP Semantics"</span>, <span class="seriesInfo">STD 97</span>, <span class="seriesInfo">RFC 9110</span>, <span class="seriesInfo">DOI 10.17487/RFC9110</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9110">https://www.rfc-editor.org/info/rfc9110</a>&gt;</span>
</dd>
<dt id="RFC0020-en">[RFC0020]</dt>
<dd class="break">
<span class="refAuthor">Cerf, V.</span>, <span></span><span class="refTitle">"ASCII format for network interchange"</span>, <span class="seriesInfo">STD 80</span>, <span class="seriesInfo">RFC 20</span>, <span class="seriesInfo">DOI 10.17487/RFC0020</span>, <time datetime="1969-10" class="refDate">October 1969</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc20">https://www.rfc-editor.org/info/rfc20</a>&gt;</span>
</dd>
<dt id="RFC2119-en">[RFC2119]</dt>
<dd class="break">
<span class="refAuthor">Bradner, S.</span>, <span></span><span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>
</dd>
<dt id="RFC4648-en">[RFC4648]</dt>
<dd class="break">
<span class="refAuthor">Josefsson, S.</span>, <span></span><span class="refTitle">"The Base16, Base32, and Base64 Data Encodings"</span>, <span class="seriesInfo">RFC 4648</span>, <span class="seriesInfo">DOI 10.17487/RFC4648</span>, <time datetime="2006-10" class="refDate">October 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;</span>
</dd>
<dt id="RFC8174-en">[RFC8174]</dt>
<dd class="break">
<span class="refAuthor">Leiba, B.</span>, <span></span><span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>
</dd>
<dt id="RFC3629-en">[UTF8]</dt>
<dd class="break">
<span class="refAuthor">Yergeau, F.</span>, <span></span><span class="refTitle">"UTF-8, a transformation format of ISO 10646"</span>, <span class="seriesInfo">STD 63</span>, <span class="seriesInfo">RFC 3629</span>, <span class="seriesInfo">DOI 10.17487/RFC3629</span>, <time datetime="2003-11" class="refDate">November 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3629">https://www.rfc-editor.org/info/rfc3629</a>&gt;</span>
</dd>
</dl></section><section><h3 id="name-informative-references-en" lang="en">
<a href="#name-informative-references-en" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="RFC7541-en">[HPACK]</dt>
<dd class="break">
<span class="refAuthor">Peon, R.</span> and <span class="refAuthor">H. Ruellan</span>, <span></span><span class="refTitle">"HPACK: Header Compression for HTTP/2"</span>, <span class="seriesInfo">RFC 7541</span>, <span class="seriesInfo">DOI 10.17487/RFC7541</span>, <time datetime="2015-05" class="refDate">May 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7541">https://www.rfc-editor.org/info/rfc7541</a>&gt;</span>
</dd>
<dt id="RFC9113-en">[HTTP/2]</dt>
<dd class="break">
<span class="refAuthor">Thomson, M.</span> and <span class="refAuthor">C. Benfield</span>, <span></span><span class="refTitle">"HTTP/2"</span>, <span class="seriesInfo">RFC 9113</span>, <span class="seriesInfo">DOI 10.17487/RFC9113</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9113">https://www.rfc-editor.org/info/rfc9113</a>&gt;</span>
</dd>
<dt id="IEEE754-en">[IEEE754]</dt>
<dd class="break">
<span class="refAuthor">IEEE</span>, <span></span><span class="refTitle">"IEEE Standard for Floating-Point Arithmetic"</span>, <span class="seriesInfo">IEEE Std 754-2019</span>, <span class="seriesInfo">DOI 10.1109/IEEESTD.2019.8766229</span>, <span class="seriesInfo">ISBN 978-1-5044-5924-2</span>, <time datetime="2019-07" class="refDate">July 2019</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8766229">https://ieeexplore.ieee.org/document/8766229</a>&gt;</span>
</dd>
<dt id="RFC8264-en">[PRECIS]</dt>
<dd class="break">
<span class="refAuthor">Saint-Andre, P.</span> and <span class="refAuthor">M. Blanchet</span>, <span></span><span class="refTitle">"PRECIS Framework: Preparation, Enforcement, and Comparison of Internationalized Strings in Application Protocols"</span>, <span class="seriesInfo">RFC 8264</span>, <span class="seriesInfo">DOI 10.17487/RFC8264</span>, <time datetime="2017-10" class="refDate">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8264">https://www.rfc-editor.org/info/rfc8264</a>&gt;</span>
</dd>
<dt id="RFC5234-en">[RFC5234]</dt>
<dd class="break">
<span class="refAuthor">Crocker, D.</span> and <span class="refAuthor">P. Overell</span>, <span></span><span class="refTitle">"Augmented BNF for Syntax Specifications: ABNF"</span>, <span class="seriesInfo">STD 68</span>, <span class="seriesInfo">RFC 5234</span>, <span class="seriesInfo">DOI 10.17487/RFC5234</span>, <time datetime="2008-01" class="refDate">January 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;</span>
</dd>
<dt id="RFC7493-en">[RFC7493]</dt>
<dd class="break">
<span class="refAuthor">Bray, T.</span>, <span></span><span class="refTitle">"The I-JSON Message Format"</span>, <span class="seriesInfo">RFC 7493</span>, <span class="seriesInfo">DOI 10.17487/RFC7493</span>, <time datetime="2015-03" class="refDate">March 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7493">https://www.rfc-editor.org/info/rfc7493</a>&gt;</span>
</dd>
<dt id="RFC8259-en">[RFC8259]</dt>
<dd class="break">
<span class="refAuthor">Bray, T.</span>, <span></span><span class="refTitle">"The JavaScript Object Notation (JSON) Data Interchange Format"</span>, <span class="seriesInfo">STD 90</span>, <span class="seriesInfo">RFC 8259</span>, <span class="seriesInfo">DOI 10.17487/RFC8259</span>, <time datetime="2017-12" class="refDate">December 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;</span>
</dd>
<dt id="UNICODE-SECURITY-en">[UNICODE-SECURITY]</dt>
<dd class="break">Latest version available at <span class="refAuthor">Davis, M.</span> and <span class="refAuthor">M. Suignard</span>, <span></span><span class="refTitle">"Unicode Security Considerations"</span>, <span class="seriesInfo">Unicode Technical Report #36</span>, <time datetime="2014-09-19" class="refDate">September 19, 2014</time>, <span>&lt;<a href="https://www.unicode.org/reports/tr36/tr36-15.html">https://www.unicode.org/reports/tr36/tr36-15.html</a>&gt;</span>
</dd>
</dl></section></section></div>
<div lang="ja" class="col"><section><h2 id="name-references-ja" lang="ja">
<a href="#name-references-ja" class="section-name selfRef">参考文献</a>
      </h2>
<section><h3 id="name-normative-references-ja" lang="ja">
<a href="#name-normative-references-ja" class="section-name selfRef">引用規格</a>
        </h3>
<dl class="references">
<dt id="RFC9110-ja">[HTTP]</dt>
<dd class="break">
<span class="refAuthor">Fielding, R.</span>, <span class="refAuthor">Nottingham, M.</span>, and <span class="refAuthor">J. Reschke</span>, <span></span><span class="refTitle">"HTTP Semantics"</span>, <span class="seriesInfo">STD 97</span>, <span class="seriesInfo">RFC 9110</span>, <span class="seriesInfo">DOI 10.17487/RFC9110</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9110">https://www.rfc-editor.org/info/rfc9110</a>&gt;</span>
</dd>
<dt id="RFC0020-ja">[RFC0020]</dt>
<dd class="break">
<span class="refAuthor">Cerf, V.</span>, <span></span><span class="refTitle">"ASCII format for network interchange"</span>, <span class="seriesInfo">STD 80</span>, <span class="seriesInfo">RFC 20</span>, <span class="seriesInfo">DOI 10.17487/RFC0020</span>, <time datetime="1969-10" class="refDate">October 1969</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc20">https://www.rfc-editor.org/info/rfc20</a>&gt;</span>
</dd>
<dt id="RFC2119-ja">[RFC2119]</dt>
<dd class="break">
<span class="refAuthor">Bradner, S.</span>, <span></span><span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>
</dd>
<dt id="RFC4648-ja">[RFC4648]</dt>
<dd class="break">
<span class="refAuthor">Josefsson, S.</span>, <span></span><span class="refTitle">"The Base16, Base32, and Base64 Data Encodings"</span>, <span class="seriesInfo">RFC 4648</span>, <span class="seriesInfo">DOI 10.17487/RFC4648</span>, <time datetime="2006-10" class="refDate">October 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;</span>
</dd>
<dt id="RFC8174-ja">[RFC8174]</dt>
<dd class="break">
<span class="refAuthor">Leiba, B.</span>, <span></span><span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>
</dd>
<dt id="RFC3629-ja">[UTF8]</dt>
<dd class="break">
<span class="refAuthor">Yergeau, F.</span>, <span></span><span class="refTitle">"UTF-8, a transformation format of ISO 10646"</span>, <span class="seriesInfo">STD 63</span>, <span class="seriesInfo">RFC 3629</span>, <span class="seriesInfo">DOI 10.17487/RFC3629</span>, <time datetime="2003-11" class="refDate">November 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3629">https://www.rfc-editor.org/info/rfc3629</a>&gt;</span>
</dd>
</dl></section><section><h3 id="name-informative-references-ja" lang="ja">
<a href="#name-informative-references-ja" class="section-name selfRef">参考文献</a>
        </h3>
<dl class="references">
<dt id="RFC7541-ja">[HPACK]</dt>
<dd class="break">
<span class="refAuthor">Peon, R.</span> and <span class="refAuthor">H. Ruellan</span>, <span></span><span class="refTitle">"HPACK: Header Compression for HTTP/2"</span>, <span class="seriesInfo">RFC 7541</span>, <span class="seriesInfo">DOI 10.17487/RFC7541</span>, <time datetime="2015-05" class="refDate">May 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7541">https://www.rfc-editor.org/info/rfc7541</a>&gt;</span>
</dd>
<dt id="RFC9113-ja">[HTTP/2]</dt>
<dd class="break">
<span class="refAuthor">Thomson, M.</span> and <span class="refAuthor">C. Benfield</span>, <span></span><span class="refTitle">"HTTP/2"</span>, <span class="seriesInfo">RFC 9113</span>, <span class="seriesInfo">DOI 10.17487/RFC9113</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9113">https://www.rfc-editor.org/info/rfc9113</a>&gt;</span>
</dd>
<dt id="IEEE754-ja">[IEEE754]</dt>
<dd class="break">
<span class="refAuthor">IEEE</span>, <span></span><span class="refTitle">"IEEE Standard for Floating-Point Arithmetic"</span>, <span class="seriesInfo">IEEE Std 754-2019</span>, <span class="seriesInfo">DOI 10.1109/IEEESTD.2019.8766229</span>, <span class="seriesInfo">ISBN 978-1-5044-5924-2</span>, <time datetime="2019-07" class="refDate">July 2019</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8766229">https://ieeexplore.ieee.org/document/8766229</a>&gt;</span>
</dd>
<dt id="RFC8264-ja">[PRECIS]</dt>
<dd class="break">
<span class="refAuthor">Saint-Andre, P.</span> and <span class="refAuthor">M. Blanchet</span>, <span></span><span class="refTitle">"PRECIS Framework: Preparation, Enforcement, and Comparison of Internationalized Strings in Application Protocols"</span>, <span class="seriesInfo">RFC 8264</span>, <span class="seriesInfo">DOI 10.17487/RFC8264</span>, <time datetime="2017-10" class="refDate">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8264">https://www.rfc-editor.org/info/rfc8264</a>&gt;</span>
</dd>
<dt id="RFC5234-ja">[RFC5234]</dt>
<dd class="break">
<span class="refAuthor">Crocker, D.</span> and <span class="refAuthor">P. Overell</span>, <span></span><span class="refTitle">"Augmented BNF for Syntax Specifications: ABNF"</span>, <span class="seriesInfo">STD 68</span>, <span class="seriesInfo">RFC 5234</span>, <span class="seriesInfo">DOI 10.17487/RFC5234</span>, <time datetime="2008-01" class="refDate">January 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;</span>
</dd>
<dt id="RFC7493-ja">[RFC7493]</dt>
<dd class="break">
<span class="refAuthor">Bray, T.</span>, <span></span><span class="refTitle">"The I-JSON Message Format"</span>, <span class="seriesInfo">RFC 7493</span>, <span class="seriesInfo">DOI 10.17487/RFC7493</span>, <time datetime="2015-03" class="refDate">March 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7493">https://www.rfc-editor.org/info/rfc7493</a>&gt;</span>
</dd>
<dt id="RFC8259-ja">[RFC8259]</dt>
<dd class="break">
<span class="refAuthor">Bray, T.</span>, <span></span><span class="refTitle">"The JavaScript Object Notation (JSON) Data Interchange Format"</span>, <span class="seriesInfo">STD 90</span>, <span class="seriesInfo">RFC 8259</span>, <span class="seriesInfo">DOI 10.17487/RFC8259</span>, <time datetime="2017-12" class="refDate">December 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;</span>
</dd>
<dt id="UNICODE-SECURITY-ja">[UNICODE-SECURITY]</dt>
<dd class="break">Latest version available at <span class="refAuthor">Davis, M.</span> and <span class="refAuthor">M. Suignard</span>, <span></span><span class="refTitle">"Unicode Security Considerations"</span>, <span class="seriesInfo">Unicode Technical Report #36</span>, <time datetime="2014-09-19" class="refDate">September 19, 2014</time>, <span>&lt;<a href="https://www.unicode.org/reports/tr36/tr36-15.html">https://www.unicode.org/reports/tr36/tr36-15.html</a>&gt;</span>
</dd>
</dl></section></section></div>
</div>
<section><span id="faq-en"></span><span id="faq-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-frequently-asked-questions-en" lang="en">
<a id="appendix-A" href="#appendix-A" class="section-number selfRef">Appendix A.</a> <a href="#name-frequently-asked-questions-en" class="section-name selfRef">Frequently Asked Questions</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-frequently-asked-questions-ja" lang="ja">
<a id="appendix-A" href="#appendix-A" class="section-number selfRef">Appendix A.</a> <a href="#name-frequently-asked-questions-ja" class="section-name selfRef">よくある質問</a>
      </h2></div>
</div>
<section><span id="why-not-json-en"></span><span id="why-not-json-ja"></span><div class="row">
<div lang="en" class="col"><h3 id="name-why-not-json-en" lang="en">
<a id="appendix-A.1" href="#appendix-A.1" class="section-number selfRef">A.1.</a> <a href="#name-why-not-json-en" class="section-name selfRef">Why Not JSON?</a>
        </h3></div>
<div lang="ja" class="col"><h3 id="name-why-not-json-ja" lang="ja">
<a id="appendix-A.1" href="#appendix-A.1" class="section-number selfRef">A.1.</a> <a href="#name-why-not-json-ja" class="section-name selfRef">なぜJSONではないのか？</a>
        </h3></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Earlier proposals for Structured Fields were based upon JSON <span>[<a href="#RFC8259-en">RFC8259</a>]</span>. However, constraining its use to make it suitable for HTTP fields required senders and recipients to implement specific additional handling.</p></div>
<div lang="ja" class="col"><p>構造化フィールドの初期の提案はJSON <span>[<a href="#RFC8259-ja">RFC8259</a>]</span>に基づいていました。しかし、HTTPフィールドに適するようにその使用を制約するためには、送信者と受信者が特定の追加処理を実装する必要がありました。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For example, JSON has specification issues around large numbers and objects with duplicate members. Although advice for avoiding these issues is available (e.g., <span>[<a href="#RFC7493-en">RFC7493</a>]</span>), it cannot be relied upon.</p></div>
<div lang="ja" class="col"><p>例えば、JSONには大きな数値や重複するメンバーを持つオブジェクトに関する仕様上の問題があります。これらの問題を回避するためのアドバイスはありますが（例：<span>[<a href="#RFC7493-ja">RFC7493</a>]</span>）、それに頼ることはできません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Likewise, JSON strings are by default Unicode strings, which have a number of potential interoperability issues (e.g., in comparison). Although implementers can be advised to avoid non-ASCII content where unnecessary, this is difficult to enforce.</p></div>
<div lang="ja" class="col"><p>同様に、JSON文字列はデフォルトでUnicode文字列であり、いくつかの潜在的な相互運用性の問題があります（例：比較時）。実装者に非ASCIIコンテンツを避けるようにアドバイスすることはできますが、これを強制するのは難しいです。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Another example is JSON's ability to nest content to arbitrary depths. Since the resulting memory commitment might be unsuitable (e.g., in embedded and other limited server deployments), it's necessary to limit it in some fashion; however, existing JSON implementations have no such limits, and even if a limit is specified, it's likely that some field definition will find a need to violate it.</p></div>
<div lang="ja" class="col"><p>もう一つの例は、JSONが任意の深さまでコンテンツをネストできることです。結果として生じるメモリのコミットメントが不適切である可能性があるため（例：組み込みサーバーや他の制限されたサーバー展開）、何らかの方法でそれを制限する必要があります。しかし、既存のJSON実装にはそのような制限はなく、たとえ制限が指定されても、いくつかのフィールド定義はそれを違反する必要があると感じるでしょう。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Because of JSON's broad adoption and implementation, it is difficult to impose such additional constraints across all implementations; some deployments would fail to enforce them, thereby harming interoperability. In short, if it looks like JSON, people will be tempted to use a JSON parser/serializer on field values.</p></div>
<div lang="ja" class="col"><p>JSONの広範な採用と実装のため、すべての実装に対してそのような追加の制約を課すことは困難です。一部の展開ではそれを強制できず、相互運用性を損なうことになります。要するに、JSONのように見える場合、人々はフィールド値にJSONパーサー/シリアライザーを使用したくなるでしょう。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Since a major goal for Structured Fields is to improve interoperability and simplify implementation, these concerns led to a format that requires a dedicated parser and serializer.</p></div>
<div lang="ja" class="col"><p>構造化フィールドの主要な目標は相互運用性を向上させ、実装を簡素化することであるため、これらの懸念は専用のパーサーとシリアライザーを必要とするフォーマットにつながりました。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Additionally, there were widely shared feelings that JSON doesn't "look right" in HTTP fields.</p></div>
<div lang="ja" class="col"><p>さらに、JSONはHTTPフィールドに「適していない」という広く共有された感情もありました。</p></div>
</div></section></section><section><span id="implementation-notes-en"></span><span id="implementation-notes-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-implementation-notes-en" lang="en">
<a id="appendix-B" href="#appendix-B" class="section-number selfRef">Appendix B.</a> <a href="#name-implementation-notes-en" class="section-name selfRef">Implementation Notes</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-implementation-notes-ja" lang="ja">
<a id="appendix-B" href="#appendix-B" class="section-number selfRef">Appendix B.</a> <a href="#name-implementation-notes-ja" class="section-name selfRef">実装ノート</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>A generic implementation of this specification should expose the top-level serialize (<a href="#text-serialize-en">Section 4.1</a>) and parse (<a href="#text-parse-en">Section 4.2</a>) functions. They need not be functions; for example, it could be implemented as an object, with methods for each of the different top-level types.</p></div>
<div lang="ja" class="col"><p>この仕様の汎用実装は、トップレベルのシリアル化 (<a href="#text-serialize-ja">Section 4.1</a>) および解析 (<a href="#text-parse-ja">Section 4.2</a>) 関数を公開する必要があります。それらは関数である必要はありません。例えば、異なるトップレベルタイプごとにメソッドを持つオブジェクトとして実装することもできます。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>For interoperability, it's important that generic implementations be complete and follow the algorithms closely; see <a href="#strict-en">Section 1.1</a>. To aid this, a common test suite is being maintained by the community at &lt;https://github.com/httpwg/structured-field-tests&gt;.</p></div>
<div lang="ja" class="col"><p>相互運用性のためには、汎用実装が完全であり、アルゴリズムに厳密に従うことが重要です。詳細は <a href="#strict-ja">Section 1.1</a> を参照してください。これを支援するために、共通のテストスイートがコミュニティによって &lt;https://github.com/httpwg/structured-field-tests&gt; で維持されています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Implementers should note that Dictionaries and Parameters are order-preserving maps. Some fields may not convey meaning in the ordering of these data types, but it should still be exposed so that it will be available to applications that need to use it.</p></div>
<div lang="ja" class="col"><p>実装者は、辞書とパラメータが順序を保持するマップであることに注意する必要があります。一部のフィールドはこれらのデータタイプの順序に意味を持たないかもしれませんが、それを使用する必要があるアプリケーションで利用できるようにするために、順序を公開する必要があります。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Likewise, implementations should note that it's important to preserve the distinction between Tokens and Strings. While most programming languages have built-in types that map to the other types well, it may be necessary to create a wrapper "token" object or use a parameter on functions to assure that these types remain separate.</p></div>
<div lang="ja" class="col"><p>同様に、実装はトークンと文字列の区別を保持することが重要であることに注意する必要があります。ほとんどのプログラミング言語には他のタイプにうまくマップする組み込みタイプがありますが、これらのタイプを別々に保つためにラッパー「トークン」オブジェクトを作成するか、関数にパラメータを使用する必要があるかもしれません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>The serialization algorithm is defined in a way that it is not strictly limited to the data types defined in <a href="#types-en">Section 3</a> in every case. For example, Decimals are designed to take broader input and round to allowed values.</p></div>
<div lang="ja" class="col"><p>シリアル化アルゴリズムは、すべての場合に <a href="#types-ja">Section 3</a> で定義されたデータタイプに厳密に限定されないように定義されています。例えば、10進数はより広範な入力を受け入れ、許可された値に丸めるように設計されています。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Implementations are allowed to limit the size of different structures, subject to the minimums defined for each type. When a structure exceeds an implementation limit, that structure fails parsing or serialization.</p></div>
<div lang="ja" class="col"><p>実装は、各タイプに定義された最小値に従って、異なる構造のサイズを制限することが許可されています。構造が実装の制限を超える場合、その構造の解析またはシリアル化は失敗します。</p></div>
</div></section><section><span id="abnf-en"></span><span id="abnf-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-abnf-en" lang="en">
<a id="appendix-C" href="#appendix-C" class="section-number selfRef">Appendix C.</a> <a href="#name-abnf-en" class="section-name selfRef">ABNF</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-abnf-ja" lang="ja">
<a id="appendix-C" href="#appendix-C" class="section-number selfRef">Appendix C.</a> <a href="#name-abnf-ja" class="section-name selfRef">ABNF</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This section uses the Augmented Backus-Naur Form (ABNF) notation <span>[<a href="#RFC5234-en">RFC5234</a>]</span> to illustrate the expected syntax of Structured Fields. However, it cannot be used to validate their syntax because it does not capture all requirements.</p></div>
<div lang="ja" class="col"><p>このセクションでは、拡張バッカス・ナウア形式（ABNF）表記 <span>[<a href="#RFC5234-ja">RFC5234</a>]</span> を使用して構造化フィールドの期待される構文を示します。ただし、すべての要件を捉えていないため、その構文を検証するために使用することはできません。</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This section is non-normative. If there is disagreement between the parsing algorithms and ABNF, the specified algorithms take precedence.</p></div>
<div lang="ja" class="col"><p>このセクションは規範的ではありません。解析アルゴリズムとABNFの間に不一致がある場合、指定されたアルゴリズムが優先されます。</p></div>
</div>
<div class="row">
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
sf-list       = list-member *( OWS "," OWS list-member )
list-member   = sf-item / inner-list

inner-list    = "(" *SP [ sf-item *( 1*SP sf-item ) *SP ] ")"
                parameters

parameters    = *( ";" *SP parameter )
parameter     = param-key [ "=" param-value ]
param-key     = key
key           = ( lcalpha / "*" )
                *( lcalpha / DIGIT / "_" / "-" / "." / "*" )
lcalpha       = %x61-7A ; a-z
param-value   = bare-item

sf-dictionary = dict-member *( OWS "," OWS dict-member )
dict-member   = member-key ( parameters / ( "=" member-value ))
member-key    = key
member-value  = sf-item / inner-list

sf-item   = bare-item parameters
bare-item = sf-integer / sf-decimal / sf-string / sf-token
            / sf-binary / sf-boolean / sf-date / sf-displaystring

sf-integer       = ["-"] 1*15DIGIT
sf-decimal       = ["-"] 1*12DIGIT "." 1*3DIGIT
sf-string        = DQUOTE *( unescaped / "%" / bs-escaped ) DQUOTE
sf-token         = ( ALPHA / "*" ) *( tchar / ":" / "/" )
sf-binary        = ":" base64 ":"
sf-boolean       = "?" ( "0" / "1" )
sf-date          = "@" sf-integer
sf-displaystring = "%" DQUOTE *( unescaped / "\" / pct-encoded )
                   DQUOTE

base64       = *( ALPHA / DIGIT / "+" / "/" ) *"="

unescaped    = %x20-21 / %x23-24 / %x26-5B / %x5D-7E
bs-escaped   = "\" ( DQUOTE / "\" )

pct-encoded  = "%" lc-hexdig lc-hexdig
lc-hexdig = DIGIT / %x61-66 ; 0-9, a-f
</pre></div>
    </div>
<div class="col">
<div class="sourcecode lang-&lt;class 'type'&gt;"><pre>
sf-list       = list-member *( OWS "," OWS list-member )
list-member   = sf-item / inner-list

inner-list    = "(" *SP [ sf-item *( 1*SP sf-item ) *SP ] ")"
                parameters

parameters    = *( ";" *SP parameter )
parameter     = param-key [ "=" param-value ]
param-key     = key
key           = ( lcalpha / "*" )
                *( lcalpha / DIGIT / "_" / "-" / "." / "*" )
lcalpha       = %x61-7A ; a-z
param-value   = bare-item

sf-dictionary = dict-member *( OWS "," OWS dict-member )
dict-member   = member-key ( parameters / ( "=" member-value ))
member-key    = key
member-value  = sf-item / inner-list

sf-item   = bare-item parameters
bare-item = sf-integer / sf-decimal / sf-string / sf-token
            / sf-binary / sf-boolean / sf-date / sf-displaystring

sf-integer       = ["-"] 1*15DIGIT
sf-decimal       = ["-"] 1*12DIGIT "." 1*3DIGIT
sf-string        = DQUOTE *( unescaped / "%" / bs-escaped ) DQUOTE
sf-token         = ( ALPHA / "*" ) *( tchar / ":" / "/" )
sf-binary        = ":" base64 ":"
sf-boolean       = "?" ( "0" / "1" )
sf-date          = "@" sf-integer
sf-displaystring = "%" DQUOTE *( unescaped / "\" / pct-encoded )
                   DQUOTE

base64       = *( ALPHA / DIGIT / "+" / "/" ) *"="

unescaped    = %x20-21 / %x23-24 / %x26-5B / %x5D-7E
bs-escaped   = "\" ( DQUOTE / "\" )

pct-encoded  = "%" lc-hexdig lc-hexdig
lc-hexdig = DIGIT / %x61-66 ; 0-9, a-f
</pre></div>
    </div>
</div></section><section><span id="changes-en"></span><span id="changes-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-changes-from-rfc-8941-en" lang="en">
<a id="appendix-D" href="#appendix-D" class="section-number selfRef">Appendix D.</a> <a href="#name-changes-from-rfc-8941-en" class="section-name selfRef">Changes from RFC 8941</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-changes-from-rfc-8941-ja" lang="ja">
<a id="appendix-D" href="#appendix-D" class="section-number selfRef">Appendix D.</a> <a href="#name-changes-from-rfc-8941-ja" class="section-name selfRef">Changes from RFC 8941</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>This revision of the "Structured Field Values for HTTP" specification has made the following changes:</p></div>
<div lang="ja" class="col"><p>This revision of the "Structured Field Values for HTTP" specification has made the following changes:</p></div>
</div>
<div class="row">
<div lang="en" class="col"><ul>
<li>
          <p>Added the Date Structured Type. (<a href="#date-en">Section 3.3.7</a>)</p>
</li>
        <li>
          <p>Stopped encouraging use of ABNF in definitions of new Structured Fields. (<a href="#specify-en">Section 2</a>)</p>
</li>
        <li>
          <p>Moved ABNF to an informative appendix. (<a href="#abnf-en">Appendix C</a>)</p>
</li>
        <li>
          <p>Added a "Structured Type" column to the "Hypertext Transfer Protocol (HTTP) Field Name Registry". (<a href="#iana-en">Section 5</a>)</p>
</li>
        <li>
          <p>Refined parse failure handling. (<a href="#text-parse-en">Section 4.2</a>)</p>
</li>
        <li>
          <p>Added the Display String Structured Type. (<a href="#displaystring-en">Section 3.3.8</a>)</p>
</li>
      </ul></div>
<div lang="ja" class="col"><ul>
<li>
          <p>Added the Date Structured Type. (<a href="#date-ja">Section 3.3.7</a>)</p>
</li>
        <li>
          <p>Stopped encouraging use of ABNF in definitions of new Structured Fields. (<a href="#specify-ja">Section 2</a>)</p>
</li>
        <li>
          <p>Moved ABNF to an informative appendix. (<a href="#abnf-ja">Appendix C</a>)</p>
</li>
        <li>
          <p>Added a "Structured Type" column to the "Hypertext Transfer Protocol (HTTP) Field Name Registry". (<a href="#iana-ja">Section 5</a>)</p>
</li>
        <li>
          <p>Refined parse failure handling. (<a href="#text-parse-ja">Section 4.2</a>)</p>
</li>
        <li>
          <p>Added the Display String Structured Type. (<a href="#displaystring-ja">Section 3.3.8</a>)</p>
</li>
      </ul></div>
</div></section><section><span id="acknowledgements-en"></span><span id="acknowledgements-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-acknowledgements-en" lang="en">
<a href="#name-acknowledgements-en" class="section-name selfRef">Acknowledgements</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-acknowledgements-ja" lang="ja">
<a href="#name-acknowledgements-ja" class="section-name selfRef">Acknowledgements</a>
      </h2></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Many thanks to <span class="contact-name">Matthew Kerwin</span> for his detailed feedback and careful consideration during the development of this specification.</p></div>
<div lang="ja" class="col"><p>Many thanks to <span class="contact-name">Matthew Kerwin</span> for his detailed feedback and careful consideration during the development of this specification.</p></div>
</div>
<div class="row">
<div lang="en" class="col"><p>Thanks also to <span class="contact-name">Ian Clelland</span>, <span class="contact-name">Roy Fielding</span>, <span class="contact-name">Anne van Kesteren</span>, <span class="contact-name">Kazuho Oku</span>, <span class="contact-name">Evert Pot</span>, <span class="contact-name">Julian Reschke</span>, <span class="contact-name">Martin Thomson</span>, <span class="contact-name">Mike West</span>, and <span class="contact-name">Jeffrey Yasskin</span> for their contributions.</p></div>
<div lang="ja" class="col"><p>Thanks also to <span class="contact-name">Ian Clelland</span>, <span class="contact-name">Roy Fielding</span>, <span class="contact-name">Anne van Kesteren</span>, <span class="contact-name">Kazuho Oku</span>, <span class="contact-name">Evert Pot</span>, <span class="contact-name">Julian Reschke</span>, <span class="contact-name">Martin Thomson</span>, <span class="contact-name">Mike West</span>, and <span class="contact-name">Jeffrey Yasskin</span> for their contributions.</p></div>
</div></section><section><span id="authors-addresses-en"></span><span id="authors-addresses-ja"></span><div class="row">
<div lang="en" class="col"><h2 id="name-authors-addresses-en" lang="en">
<a href="#name-authors-addresses-en" class="section-name selfRef">Authors' Addresses</a>
      </h2></div>
<div lang="ja" class="col"><h2 id="name-authors-addresses-ja" lang="ja">
<a href="#name-authors-addresses-ja" class="section-name selfRef">Authors' Addresses</a>
      </h2></div>
</div></section>
</body>
</html>
