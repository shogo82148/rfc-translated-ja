<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-httpbis-header-structure-19" indexInclude="true" ipr="trust200902" number="8941" prepTime="2021-02-08T15:01:41" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-header-structure-19" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8941" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title>HTTPのための構造化フィールド値</title>
    <seriesInfo name="RFC" value="8941" stream="IETF"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization showOnFrontPage="true">Fastly</organization>
      <address>
        <postal>
          <city>Prahran</city>
          <region>VIC</region>
          <country>Australia</country>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <author initials="P-H." surname="Kamp" fullname="Poul-Henning Kamp">
      <organization showOnFrontPage="true">The Varnish Cache Project</organization>
      <address>
        <email>phk@varnish-cache.org</email>
      </address>
    </author>
    <date month="02" year="2021"/>
    <area>Applications and Real-Time</area>
    <workgroup>HTTP</workgroup>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">この文書は、HTTPヘッダーおよびトレーラーフィールドの定義と取り扱いを、より容易かつ安全にすることを意図した、
一連のデータ型と関連アルゴリズムについて記述するものです。
HTTPヘッダーおよびトレーラーフィールドは「Structured Fields」「Structured Headers」または「Structured Trailers」として知られています。
新しいHTTPフィールドの仕様として使われることを意図しています。従来のHTTPフィールドの値よりも制限が多く共通の構文を使用したい場合に使用されます。</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">このメモのステータス</name>
        <t indent="0" pn="section-boilerplate.1-1">これはインターネット標準化団体（Internet Standards Track）の文章です。 </t>
        <t indent="0" pn="section-boilerplate.1-2">この文書は、インターネット技術タスクフォース（IETF）の成果物です。
この文書は、IETFコミュニティのコンセンサスを代表するものです。
この文書は公開レビューを受けており、インターネット技術運営グループ（IESG）により発行が承認されています。
インターネット標準に関する詳しい情報は、RFC 7841のセクション2に記載されています。 </t>
        <t indent="0" pn="section-boilerplate.1-3">この文書の現在の状態、正誤表、それに対するフィードバックの提供方法に関する情報は、<eref target="https://www.rfc-editor.org/info/rfc8941" brackets="none"/> で入手できます。 </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">著作権表示</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
この文書は、この文書の発行日に有効なBCP 78およびIETFトラストのIETF文書に関する法的規定（<eref target="https://trustee.ietf.org/license-info" brackets="none"/>）に従うものとします。
これらの文書は、この文書に関するあなたの権利と制限を記述しているので、注意深く確認してください。
この文書から抽出されたコードコンポーネントには、信託の法的規定のセクション4.eに記載されているように、
簡易BSDライセンステキストを含める必要があります。簡易BSDライセンスに記載されているように、保証なしに提供されます。 </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">目次</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-intentionally-strict-proces">Intentionally Strict Processing</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-notational-conventions">Notational Conventions</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-defining-new-structured-fie">Defining New Structured Fields</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-structured-data-types">Structured Data Types</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-lists">Lists</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.1.2">
                  <li pn="section-toc.1-1.3.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.1.2.1.1"><xref derivedContent="3.1.1" format="counter" sectionFormat="of" target="section-3.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-inner-lists">Inner Lists</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.1.2.2.1"><xref derivedContent="3.1.2" format="counter" sectionFormat="of" target="section-3.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parameters">Parameters</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dictionaries">Dictionaries</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-items">Items</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.3.2">
                  <li pn="section-toc.1-1.3.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.1.1"><xref derivedContent="3.3.1" format="counter" sectionFormat="of" target="section-3.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-integers">Integers</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.2.1"><xref derivedContent="3.3.2" format="counter" sectionFormat="of" target="section-3.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-decimals">Decimals</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.3">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.3.1"><xref derivedContent="3.3.3" format="counter" sectionFormat="of" target="section-3.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-strings">Strings</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.4">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.4.1"><xref derivedContent="3.3.4" format="counter" sectionFormat="of" target="section-3.3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tokens">Tokens</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.5">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.5.1"><xref derivedContent="3.3.5" format="counter" sectionFormat="of" target="section-3.3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-byte-sequences">Byte Sequences</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.6">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.6.1"><xref derivedContent="3.3.6" format="counter" sectionFormat="of" target="section-3.3.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-booleans">Booleans</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-working-with-structured-fie">Working with Structured Fields in HTTP</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-structured-fiel">Serializing Structured Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.1.2">
                  <li pn="section-toc.1-1.4.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.1.1"><xref derivedContent="4.1.1" format="counter" sectionFormat="of" target="section-4.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-list">Serializing a List</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.2.1"><xref derivedContent="4.1.2" format="counter" sectionFormat="of" target="section-4.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-dictionary">Serializing a Dictionary</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.3">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.3.1"><xref derivedContent="4.1.3" format="counter" sectionFormat="of" target="section-4.1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-an-item">Serializing an Item</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.4">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.4.1"><xref derivedContent="4.1.4" format="counter" sectionFormat="of" target="section-4.1.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-an-integer">Serializing an Integer</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.5">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.5.1"><xref derivedContent="4.1.5" format="counter" sectionFormat="of" target="section-4.1.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-decimal">Serializing a Decimal</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.6">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.6.1"><xref derivedContent="4.1.6" format="counter" sectionFormat="of" target="section-4.1.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-string">Serializing a String</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.7">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.7.1"><xref derivedContent="4.1.7" format="counter" sectionFormat="of" target="section-4.1.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-token">Serializing a Token</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.8">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.8.1"><xref derivedContent="4.1.8" format="counter" sectionFormat="of" target="section-4.1.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-byte-sequence">Serializing a Byte Sequence</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.9">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.9.1"><xref derivedContent="4.1.9" format="counter" sectionFormat="of" target="section-4.1.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serializing-a-boolean">Serializing a Boolean</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-structured-fields">Parsing Structured Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.2.2">
                  <li pn="section-toc.1-1.4.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.1.1"><xref derivedContent="4.2.1" format="counter" sectionFormat="of" target="section-4.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-list">Parsing a List</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.2.1"><xref derivedContent="4.2.2" format="counter" sectionFormat="of" target="section-4.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-dictionary">Parsing a Dictionary</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.3.1"><xref derivedContent="4.2.3" format="counter" sectionFormat="of" target="section-4.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-an-item">Parsing an Item</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.4">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.4.1"><xref derivedContent="4.2.4" format="counter" sectionFormat="of" target="section-4.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-an-integer-or-decim">Parsing an Integer or Decimal</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.5">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.5.1"><xref derivedContent="4.2.5" format="counter" sectionFormat="of" target="section-4.2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-string">Parsing a String</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.6">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.6.1"><xref derivedContent="4.2.6" format="counter" sectionFormat="of" target="section-4.2.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-token">Parsing a Token</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.7">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.7.1"><xref derivedContent="4.2.7" format="counter" sectionFormat="of" target="section-4.2.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-byte-sequence">Parsing a Byte Sequence</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.8">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.8.1"><xref derivedContent="4.2.8" format="counter" sectionFormat="of" target="section-4.2.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parsing-a-boolean">Parsing a Boolean</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-frequently-asked-questions">Frequently Asked Questions</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="A.1" format="counter" sectionFormat="of" target="section-a.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-why-not-json">Why Not JSON?</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-implementation-notes">Implementation Notes</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.d"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">はじめに</name>
      <t indent="0" pn="section-1-1">新しいHTTPヘッダー（とトレーラー）フィールドの構文を指定するのは大変な作業です。
<xref target="RFC7231" section="8.3.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7231#section-8.3.1" derivedContent="RFC7231"/> のガイダンスがあったとしても、
これからHTTPフィールドを作ろうとする人にとっては多くの決定事項や落とし穴があります。</t>
      <t indent="0" pn="section-1-2">フィールドが定義されると、特注のパーサーやシリアライザーを作成することが多くあります。
なぜなら、一般的な構文に見えるものであっても、それぞれのフィールドの値は少しことなった扱いをするからです。</t>
      <t indent="0" pn="section-1-3">この文書ではこれらの問題に対処するために、
新しいHTTPフィールド値の定義で使用するための一連の共通データ構造を導入します。
とくに、HTTP<xref target="RFC7230" format="default" sectionFormat="of" derivedContent="RFC7230"/> のヘッダーとトレーラーフィールドで、
そのモデルを表現するための具体的なシリアライズとともに、それらのための一般的で抽象的なモデルを定義しています。</t>
      <t indent="0" pn="section-1-4">構造化ヘッダー "または "構造化トレーラー "として定義されるHTTPフィールド(どちらにもなりうる場合、それは "構造化フィールド")は、その構文と基本処理規則を定義するためにこの仕様で定義される型を使用し、それによって仕様作成者による定義と実装による処理の両方を単純化します。</t>
      <t indent="0" pn="section-1-5">さらに、将来のバージョンのHTTPでは、これらの構造の抽象モデルの代替シリアライゼーションを定義することができ、そのモデルを使用するフィールドを再定義することなく、より効率的に伝送することができます。</t>
      <t indent="0" pn="section-1-6">既存のHTTPフィールドの構文を再定義することがこのドキュメントの目的ではないことに注意。</t>
      <t indent="0" pn="section-1-7"><xref target="specify" format="default" sectionFormat="of" derivedContent="Section 2"/> は、構造化フィールドの指定方法について説明しています。</t>
      <t indent="0" pn="section-1-8"><xref target="types" format="default" sectionFormat="of" derivedContent="Section 3"/> は、構造化フィールドで使用できる多くの抽象的なデータ型を定義しています。</t>
      <t indent="0" pn="section-1-9">これらの抽象型は、<xref target="text" format="default" sectionFormat="of" derivedContent="Section 4"/> で説明されているアルゴリズムを使って、HTTP フィールド値にシリアライズしたり、HTTP フィールド値からパースしたりすることができます。</t>
      <section anchor="strict" numbered="true" removeInRFC="false" toc="include" pn="section-1.1">
        <name slugifiedName="name-intentionally-strict-proces">意図的に厳密な処理</name>
        <t indent="0" pn="section-1.1-1">この仕様では、段階的なアルゴリズムによる厳密な解析と直列化の動作を意図的に定義しており、
定義された唯一のエラー処理は操作を完全に失敗させることです。</t>
        <t indent="0" pn="section-1.1-2">これは、忠実な実装と良好な相互運用性を奨励するために設計されています。
したがって、入力に対してより寛容になることで役に立とうとする実装は、
他の実装に同様の（しかしおそらく微妙に異なる）回避策を実装するように圧力をかけることになり、
相互運用性を悪化させることになります。</t>
        <t indent="0" pn="section-1.1-3">つまり、厳密な処理はこの仕様の意図的な特徴であり、
製作者は不適合な入力を早期に発見して修正できます。
そうでなければ、生じるかもしれない相互運用性とセキュリティの両方の問題を回避することができるのです。</t>
        <t indent="0" pn="section-1.1-4">この厳格さの結果、あるフィールドが複数の関係者（例えば、仲介者や送信者内の異なるコンポーネント）によって付加される場合、ある関係者の値にエラーがあると、フィールド値全体のパースに失敗する可能性が高いことに注意する必要があります。</t>
      </section>
      <section anchor="notational-conventions" numbered="true" removeInRFC="false" toc="include" pn="section-1.2">
        <name slugifiedName="name-notational-conventions">表記上の注意事項</name>
        <t indent="0" pn="section-1.2-1">キーワード「<bcp14>しなければなりません（MUST）</bcp14>」、「<bcp14>してはなりません（MUST NOT）</bcp14>」、
「<bcp14>要求されています（REQUIRED）</bcp14>」、
「<bcp14>することになります（SHALL）</bcp14>」、「<bcp14>することはありません（SHALL NOT）</bcp14>」、
「<bcp14>すべきです（SHOULD）</bcp14>」、「<bcp14>すべきではありません（SHOULD NOT）</bcp14>」、
「<bcp14>推奨されます（RECOMMENDED）</bcp14>」、「<bcp14>推奨されません（NOT RECOMMENDED）</bcp14>」、
「<bcp14>してもよいです（MAY）</bcp14>」、「<bcp14>選択できます（OPTIONAL）</bcp14>」は、
BCP 14<xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> に記載されているとおりに解釈されるものとします。
ただし、ここに示すようにすべて大文字で表示される場合に限ります。</t>
        <t indent="0" pn="section-1.2-2">この文章では、パースとシリアライズの動作を指定するアルゴリズムと、
HTTPヘッダーフィールドで期待される構文を例示するために、
<xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/> のABNF(Augmented Backus-Naur Form)表記を使用しています。
その際、<xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/> のVCHAR、SP、DIGIT、ALPHA、DQUOTE規則を使用します。
また、<xref target="RFC7230" format="default" sectionFormat="of" derivedContent="RFC7230"/> のtcharとOWS規則も含みます。</t>
        <t indent="0" pn="section-1.2-3">HTTPフィールドからパースする場合、
実装はアルゴリズムに従ったものと区別できない動作を<bcp14>しなければなりません(MUST)</bcp14>。
解析アルゴリズムとABNFの間に不一致がある場合、指定されたアルゴリズムが優先されます。</t>
        <t indent="0" pn="section-1.2-4">HTTPフィールドへのシリアライズのために、
ABNFはそれらの期待されるワイヤー表現を例示し、アルゴリズムはそれらを生成する推奨方法を定義します。
<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/>
で説明されている解析アルゴリズムによって出力が正しく処理される限り、実装は指定された動作から変化<bcp14>してもよいです（MAY）</bcp14>。</t>
      </section>
    </section>
    <section anchor="specify" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-defining-new-structured-fie">Defining New Structured Fields</name>
      <t indent="0" pn="section-2-1">HTTP フィールドを Structured Field として指定するために、その作者は以下のことを行う必要があります。</t>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2-2">
        <li pn="section-2-2.1">本仕様書を規範的に参照する。現場の受信者及び生成者は、この文書の要求事項が有効であることを知る必要があります。</li>
        <li pn="section-2-2.2">そのフィールドが Structured Header (すなわち、ヘッダーセクションでのみ使用可能。一般的なケース)、
Structured Trailer (トレーラーセクションのみ)、または Structured Field (両方)のいずれであるかを特定する。</li>
        <li pn="section-2-2.3">フィールド値の型を指定する。
リスト（<xref target="list" format="default" sectionFormat="of" derivedContent="Section 3.1"/>）、
辞書（<xref target="dictionary" format="default" sectionFormat="of" derivedContent="Section 3.2"/>）、
アイテム（<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/>）のいずれかです。</li>
        <li pn="section-2-2.4">フィールド値のセマンティクスを定義する。</li>
        <li pn="section-2-2.5">フィールド値に対する追加制約を指定する。同様に制約に違反した場合の結果も指定します。</li>
      </ul>
      <t indent="0" pn="section-2-3">一般的に、これはフィールド定義が最上位の型（リスト、辞書、アイテム）を指定し、次に許容される型とそれに対する制約を定義することを意味します。
例えば、リストとして定義されたヘッダーは、すべての整数のメンバを持つか、またはそれらの型が混在するかもしれません。
アイテムとして定義されたヘッダーは、文字列のみを許可し、さらに文字「Q」で始まる文字列や、小文字の文字列のみを許可するかもしれません。
同様に、内部リスト(<xref target="inner-list" format="default" sectionFormat="of" derivedContent="Section 3.1.1"/>)は、
フィールド定義で明示的に許可されている場合にのみ有効です。</t>
      <t indent="0" pn="section-2-4">パースに失敗すると、フィールド全体が無視されます（<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/> 参照）。
ほとんどの状況で、フィールド固有の制約に違反しても同じ効果があります。
したがって、ヘッダーがアイテムとして定義され、整数（Integer）であることが要求されているにもかかわらず、文字列（String）を受信した場合、
そのフィールドはデフォルトで無視されるでしょう。
フィールドが異なるエラー処理を必要とする場合、これは明示的に指定されなければなりません。</t>
      <t indent="0" pn="section-2-5">アイテムもインナーリストも、拡張メカニズムとしてパラメーターを許容している;
これは、必要であれば、より多くの情報を収容するために値を後で拡張できることを意味します。
前方互換性を維持するために、フィールド仕様は認識できないパラメーターの存在を、エラー条件として定義することは推奨されません。</t>
      <t indent="0" pn="section-2-6">将来的にこの拡張性が利用できることをさらに保証し、
完全なパーサー実装を使用することを消費者に奨励するために、フィールド定義では、「グリース」 パラメーターが送信者によって追加されることを指定することができます。
仕様は、定義されたパターンに適合するすべてのパラメーターがこの用途のために予約されていることを規定し、リクエストの一部でそれらを送信することを奨励することができる。
これは、受信者がパラメーターを考慮しないパーサーを書くのを阻止するのに役立ちます。</t>
      <t indent="0" pn="section-2-7">辞書を使用する仕様では、未知のメンバーの存在（値や型と同様に）を無視することを要求することで、
前方互換性を確保することもできます。その後の仕様では、メンバーを追加し、適宜制約を指定することができます。</t>
      <t indent="0" pn="section-2-8">構造化フィールドの拡張は、それが定義する値に対する制約が満たされない場合、
拡張を理解する受信者がフィールド値全体を無視することを要求することができます。</t>
      <t indent="0" pn="section-2-9">フィールド定義は、本仕様の要件を緩和することはできません。
なぜなら、緩和すると汎用ソフトウェアによる処理ができなくなるからです。
追加できるのは、制約（たとえば、整数と小数の数値範囲、文字列とトークンの形式、辞書の値で許可される型、リスト内の項目数など）のみです。
同様に、フィールド定義では、この仕様をフィールド値全体に対してのみ使用でき、その一部には使用できません。</t>
      <t indent="0" pn="section-2-10">この仕様では、実装によってサポートされる様々な構造体の長さや数の最小値を定義しています。
ほとんどの場合、最大サイズは指定しません。しかしHTTPの実装では個々のフィールドのサイズやフィールドの総数、
ヘッダーやトレーラーセクション全体のサイズに様々な制限があることを、作者は知っておくべきです。</t>
      <t indent="0" pn="section-2-11">仕様書では、フィールド名を必要に応じて
「構造化ヘッダー名（structured header name）」、「構造化トレーラー名（structured trailer name）」、 「構造化フィールド名（structured field name）」と表記することができます。
同様に必要に応じて、そのフィールド値を「構造化ヘッダー値（structured header value）」、
「構造化トレーラー値（structured trailer value）」または「構造化フィールド値（structured field value）」として参照することができます。
フィールド定義は、本仕様で定義された「sf-」で始まるABNF規則を使用することが推奨されます。
本仕様の他の規則は、フィールド定義に使用されることを意図していない。</t>
      <t indent="0" pn="section-2-12">例えば、架空のFoo-Exampleヘッダーフィールドは次のように指定されるかもしれません。</t>
      <blockquote pn="section-2-13">
        <t indent="0" pn="section-2-13.1">42.Foo-Example ヘッダー</t>
        <t indent="0" pn="section-2-13.2">Foo-Example HTTPヘッダーフィールドは、メッセージにどれだけのFooがあるかという情報を伝えます。</t>
        <t indent="0" pn="section-2-13.3">Foo-Example は Item Structured Header [RFC8941]である。その値は整数（Integer）でなければなりません(MUST)
（[RFC8941]のSection 3.3.1参照）。そのABNFは</t>
        <artwork align="left" pn="section-2-13.4">
   Foo-Example = sf-integer
</artwork>
        <t indent="0" pn="section-2-13.5">その値は、メッセージ中のFooの量を示し、0から10の間でなければなりません（MUST）。</t>
        <t indent="0" pn="section-2-13.6">以下のパラメーターが定義されています。</t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2-13.7">
          <li pn="section-2-13.7.1">キー「foourl」を持つパラメーターの値は文字列（String）（[RFC8941のSection 3.3.3]）です。
メッセージのFoo URL伝えるために使用されます。処理の要件は以下を参照してください。</li>
        </ul>
        <t indent="0" pn="section-2-13.8">「foourl」はURIリファレンス（[RFC3986]のSection 4.1)。
その値が有効なURIリファレンスでない場合、そのヘッダーフィールド全体は無視されなければなりません（MUST）。
その値が相対リファレンス（[RFC3986]のSection 5）の場合、使用される前に解決されなければなりません。</t>
        <t indent="0" pn="section-2-13.9">例を以下に示します：</t>
        <artwork align="left" pn="section-2-13.10">
   Foo-Example: 2; foourl="https://foo.example.com/"
</artwork>
      </blockquote>
    </section>
    <section anchor="types" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-structured-data-types">構造化データー型</name>
      <t indent="0" pn="section-3-1">この節では、Structured Fields の抽象的な型を定義する。提供されるABNFは、HTTPフィールド値におけるオンワイヤーフォーマットを表します。</t>
      <t indent="0" pn="section-3-2">まとめると</t>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3-3">
        <li pn="section-3-3.1">HTTPフィールドが定義できるトップレベルの型は3つあります。リスト、ディクショナリ、そしてアイテムです。</li>
        <li pn="section-3-3.2">リストとディクショナリはコンテナであり、そのメンバはアイテムまたはインナーリスト（それ自体がアイテムの配列である）であることができる。</li>
        <li pn="section-3-3.3">アイテムもインナーリストも、キーと値のペアでパラメータ化することができます。</li>
      </ul>
      <section anchor="list" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-lists">リスト（List）</name>
        <t indent="0" pn="section-3.1-1">リスト（List）は0個以上のメンバーからなる配列で、
それぞれがアイテム（<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/>）
またはインナーリスト（<xref target="inner-list" format="default" sectionFormat="of" derivedContent="Section 3.1.1"/>）になります。
どちらもパラメーター化(<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>)することが可能です。</t>
        <t indent="0" pn="section-3.1-2">HTTPフィールドのListのABNFは以下の通りです。</t>
        <sourcecode type="abnf" markers="false" pn="section-3.1-3">
sf-list       = list-member *( OWS "," OWS list-member )
list-member   = sf-item / inner-list
</sourcecode>
        <t indent="0" pn="section-3.1-4">各メンバーはカンマとオプションの空白文字で区切られます。
例えば、値がトークンのリストとして定義されるフィールドは、以下のようになります。</t>
        <sourcecode type="http-message" markers="false" pn="section-3.1-5">
Example-List: sugar, tea, rum
</sourcecode>
        <t indent="0" pn="section-3.1-6">空のリストは、フィールドを全くシリアライズしないことで示されます。
これは、リストとして定義されたフィールドは、デフォルトで空の値を持つことを意味します。</t>
        <t indent="0" pn="section-3.1-7">リストは、<xref target="RFC7230" section="3.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7230#section-3.2.2" derivedContent="RFC7230"/> のように，
そのメンバを同じヘッダーやトレーラーセクション内の複数の行に、分割することができることに注意してください。</t>
        <sourcecode type="http-message" markers="false" pn="section-3.1-8">
Example-List: sugar, tea, rum
</sourcecode>
        <t indent="0" pn="section-3.1-9">と</t>
        <sourcecode type="http-message" markers="false" pn="section-3.1-10">
Example-List: sugar, tea
Example-List: rum
</sourcecode>
        <t indent="0" pn="section-3.1-11">ただし、Listの個々のメンバを安全に行に分割することはできません。
詳しくは、<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/> を参照してください。</t>
        <t indent="0" pn="section-3.1-12">パーサーは、少なくとも1024個のメンバーを含むListをサポート<bcp14>しなければなりません（MUST）</bcp14>。
フィールドの仕様は、必要に応じて個々のリスト値の型と要素数を制限することができます。</t>
        <section anchor="inner-list" numbered="true" removeInRFC="false" toc="include" pn="section-3.1.1">
          <name slugifiedName="name-inner-lists">インナーリスト（Inner Lists）</name>
          <t indent="0" pn="section-3.1.1-1">インナーリスト（Inner List）は、0個以上のアイテム（<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/>)。個々のItemもInner List自体もパラメーター化することができます(<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>）からなる配列です。</t>
          <t indent="0" pn="section-3.1.1-2">インナーリストのABNFは以下の通りです：</t>
          <sourcecode type="abnf" markers="false" pn="section-3.1.1-3">
inner-list    = "(" *SP [ sf-item *( 1*SP sf-item ) *SP ] ")"
                parameters
</sourcecode>
          <t indent="0" pn="section-3.1.1-4">インナーリストは括弧で囲まれ、その値は1つ以上のスペースで区切られます。
値が文字列のインナーリストのリストとして定義されるフィールドは、次のようになります：</t>
          <sourcecode type="http-message" markers="false" pn="section-3.1.1-5">
Example-List: ("foo" "bar"), ("baz"), ("bat" "one"), ()
</sourcecode>
          <t indent="0" pn="section-3.1.1-6">この例で、最後のメンバーは空のインナーリストであることに注意してください。</t>
          <t indent="0" pn="section-3.1.1-7">あるヘッダーフィールドがインナーリストのリストとして定義されるとき、
どのレベルでもパラメーターを持つ可能性があります：</t>
          <sourcecode type="http-message" markers="false" pn="section-3.1.1-8">
Example-List: ("foo"; a=1;b=2);lvl=5, ("bar" "baz");lvl=1
</sourcecode>
          <t indent="0" pn="section-3.1.1-9">パーサーは、少なくとも256のメンバーを含むインナーリストをサポート<bcp14>しなければなりません（MUST）</bcp14>。
フィールド仕様は、個々のインナーリストのメンバー型と要素数を、必要に応じて制限することができます。</t>
        </section>
        <section anchor="param" numbered="true" removeInRFC="false" toc="include" pn="section-3.1.2">
          <name slugifiedName="name-parameters">パラメーター（Parameter）</name>
          <t indent="0" pn="section-3.1.2-1">パラメーター（Parameter）は、アイテム（<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/> ）または
インナーリスト（<xref target="inner-list" format="default" sectionFormat="of" derivedContent="Section 3.1.1"/> ）と関連付けられた、キーと値のペアの順序付きマップです。
キーはパラメーターの範囲内で一意であり、値は裸のアイテムです（つまり、それ自体をパラメーター化することはできません。<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/> を参照してください）。</t>
          <t indent="0" pn="section-3.1.2-2">実装は、パラメーターへのアクセス方法として、インデックスとキーの両方を提供<bcp14>しなければなりません（MUST）</bcp14>。
仕様は、どちらかの方法でアクセス<bcp14>してもよいです（MAY）</bcp14>。</t>
          <t indent="0" pn="section-3.1.2-3">パラメーターのABNFは以下の通りです：</t>
          <sourcecode type="abnf" markers="false" pn="section-3.1.2-4">
parameters    = *( ";" *SP parameter )
parameter     = param-key [ "=" param-value ]
param-key     = key
key           = ( lcalpha / "*" )
                *( lcalpha / DIGIT / "_" / "-" / "." / "*" )
lcalpha       = %x61-7A ; a-z
param-value   = bare-item
</sourcecode>
          <t indent="0" pn="section-3.1.2-5">パラメーターはシリアライズされた順番で順序付けされ、
パラメーターのキーに大文字を含めることができないことに注意してください。
パラメーターは、そのアイテムまたはインナーリスト、および他のパラメーターとセミコロンで区切られます。例えば</t>
          <sourcecode type="http-message" markers="false" pn="section-3.1.2-6">
Example-List: abc;a=1;b=2; cde_456, (ghi;jk=4 l);q="9";r=w
</sourcecode>
          <t indent="0" pn="section-3.1.2-7">値が真偽値（<xref target="boolean" format="default" sectionFormat="of" derivedContent="Section 3.3.6"/> 参照）であるパラメーターは、
シリアライズ時にその値を省略<bcp14>しなければなりません（MUST）</bcp14>。
例えば、ここで "a "パラメーターはtrueであり、"b "パラメーターはfalseです。</t>
          <sourcecode type="http-message" markers="false" pn="section-3.1.2-8">
Example-Integer: 1; a; b=?0
</sourcecode>
          <t indent="0" pn="section-3.1.2-9">この要件はシリアライズに関するものであることに注意してください。
パーサーは、真の値がパラメーターに現れたときに正しく処理することを依然として要求されます。</t>
          <t indent="0" pn="section-3.1.2-10">パーサはItemまたはInner Listで少なくとも256個のパラメーターをサポートし、
少なくとも64文字のパラメーターキーをサポート<bcp14>しなければなりません（MUST）</bcp14>。
フィールド指定は、必要に応じて個々のパラメーターの順序やその値の型を制約することができます。</t>
        </section>
      </section>
      <section anchor="dictionary" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-dictionaries">辞書（Dictionary）</name>
        <t indent="0" pn="section-3.2-1">辞書（Dictionary）はキーと値のペアの順序付きマップであり、
キーは短いテキスト文字列、値はアイテム (<xref target="item" format="default" sectionFormat="of" derivedContent="Section 3.3"/>) またはアイテムの配列で、
どちらもパラメーター化 (<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>) が可能です。
メンバーは0個以上存在でき、そのキーは辞書のスコープ内で一意です。</t>
        <t indent="0" pn="section-3.2-2">実装は辞書へのアクセス方法として、インデックスとキーの両方を提供<bcp14>しなければなりません（MUST）</bcp14>。
仕様は、メンバーへのアクセスにどちらかの手段を使用<bcp14>してもよいです（MAY）</bcp14>。</t>
        <t indent="0" pn="section-3.2-3">辞書のABNFは以下の通りです：</t>
        <sourcecode type="abnf" markers="false" pn="section-3.2-4">
sf-dictionary  = dict-member *( OWS "," OWS dict-member )
dict-member    = member-key ( parameters / ( "=" member-value ))
member-key     = key
member-value   = sf-item / inner-list
</sourcecode>
        <t indent="0" pn="section-3.2-5">メンバーはシリアライズされた順番で順序付けされ、
カンマで区切られ、オプションで空白を入れることができます。
メンバーのキーに大文字を含めることはできません。
キーと値は、"=" (ホワイトスペースなし) で区切られます。
以下に例を示します：</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-6">
Example-Dict: en="Applepie", da=:w4ZibGV0w6ZydGU=:
</sourcecode>
        <t indent="0" pn="section-3.2-7">この例では、最後の"="はバイト列（<xref target="binary" format="default" sectionFormat="of" derivedContent="Section 3.3.5"/> を参照）を含むためであることに注意してください。</t>
        <t indent="0" pn="section-3.2-8">値が真偽値（<xref target="boolean" format="default" sectionFormat="of" derivedContent="Section 3.3.6"/> を参照）であるメンバーは、
シリアライズ時にその値を省略<bcp14>しなければなりません（MUST）</bcp14>。例えば、以下の例では「b」と「c」の両方がtrueです。</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-9">
Example-Dict: a=?0, b, c; foo=bar
</sourcecode>
        <t indent="0" pn="section-3.2-10">この要件はシリアライズに関するものであることに注意してください。
パーサは、辞書の値に現れる真の真偽値を正しく処理することが、依然として要求されます。</t>
        <t indent="0" pn="section-3.2-11">以下は、トークンのインナーリストを値とするメンバーを持つ辞書です：</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-12">
Example-Dict: rating=1.5, feelings=(joy sadness)
</sourcecode>
        <t indent="0" pn="section-3.2-13">以下は、アイテムとインナーリストが混在する辞書で、一部のメンバーはパラメーターを持ちます：</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-14">
Example-Dict: a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid
</sourcecode>
        <t indent="0" pn="section-3.2-15">リストと同様に、空の辞書はフィールド全体を省略することで表現されます。
これは、ディクショナリとして定義されたフィールドはデフォルトで空の値を持つことを意味します。</t>
        <t indent="0" pn="section-3.2-16">一般的に、フィールド仕様は、キーによって個々のメンバーに許可される型と、
その存在が必須か任意かを指定することによって、辞書のセマンティクスを定義します。
受信者は、フィールドの仕様でとくに禁止されていない限り、キーが未定義または不明のメンバーを無視<bcp14>しなければなりません（MUST）</bcp14>。</t>
        <t indent="0" pn="section-3.2-17">なお、辞書は、そのメンバを同じヘッダーやトレーラーセクションの複数の行に分割することができます。
例えば、次のものは同等です：</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-18">
Example-Dict: foo=1, bar=2
</sourcecode>
        <t indent="0" pn="section-3.2-19">と</t>
        <sourcecode type="http-message" markers="false" pn="section-3.2-20">
Example-Dict: foo=1
Example-Dict: bar=2
</sourcecode>
        <t indent="0" pn="section-3.2-21">ただし、辞書の個々のメンバーを安全に行に分割することはできません。
詳しくは<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/> を参照してください。</t>
        <t indent="0" pn="section-3.2-22">パーサーは、少なくとも1024のキー/値ペアと、
少なくとも64文字のキーを含む辞書をサポート<bcp14>しなければなりません（MUST）</bcp14>。
フィールド指定は、必要に応じて値の型と、個々の辞書メンバーの順序を制限することができます。</t>
      </section>
      <section anchor="item" numbered="true" removeInRFC="false" toc="include" pn="section-3.3">
        <name slugifiedName="name-items">アイテム（Item）</name>
        <t indent="0" pn="section-3.3-1">アイテム（Item）は、
整数(<xref target="integer" format="default" sectionFormat="of" derivedContent="Section 3.3.1"/>)、
小数(<xref target="decimal" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>)、
文字列(<xref target="string" format="default" sectionFormat="of" derivedContent="Section 3.3.3"/>)、
トークン(<xref target="token" format="default" sectionFormat="of" derivedContent="Section 3.3.4"/>)、
バイト列(<xref target="binary" format="default" sectionFormat="of" derivedContent="Section 3.3.5"/>)、
真偽値(<xref target="boolean" format="default" sectionFormat="of" derivedContent="Section 3.3.6"/>)
のいずれかを表します。
また、関連するパラメーター(<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>)を持つことも可能です。</t>
        <t indent="0" pn="section-3.3-2">ItemのABNFは以下のとおりです：</t>
        <sourcecode type="abnf" markers="false" pn="section-3.3-3">
sf-item   = bare-item parameters
bare-item = sf-integer / sf-decimal / sf-string / sf-token
            / sf-binary / sf-boolean
</sourcecode>
        <t indent="0" pn="section-3.3-4">例えば、アイテムが整数であると定義されたヘッダーフィールドは、以下のようになります。</t>
        <sourcecode type="http-message" markers="false" pn="section-3.3-5">
Example-Integer: 5
</sourcecode>
        <t indent="0" pn="section-3.3-6">また、パラメーターで指定した場合です：</t>
        <sourcecode type="http-message" markers="false" pn="section-3.3-7">
Example-Integer: 5; foo=bar
</sourcecode>
        <section anchor="integer" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.1">
          <name slugifiedName="name-integers">整数（Integer）</name>
          <t indent="0" pn="section-3.3.1-1">整数（Integer）は、IEEE754互換<xref target="IEEE754" format="default" sectionFormat="of" derivedContent="IEEE754"/>のため、
  -999,999,999,999～999,999,999の範囲（すなわち最大15桁、符号あり）を持ちます。</t>
          <t indent="0" pn="section-3.3.1-2">整数のABNFは以下の通りです：</t>
          <sourcecode type="abnf" markers="false" pn="section-3.3.1-3">
sf-integer = ["-"] 1*15DIGIT
</sourcecode>
          <t indent="0" pn="section-3.3.1-4">以下に例を示します：</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.1-5">
Example-Integer: 42
</sourcecode>
          <t indent="0" pn="section-3.3.1-6">15桁より大きい整数については、
様々な方法でサポートすることができます。
例えば、文字列(<xref target="string" format="default" sectionFormat="of" derivedContent="Section 3.3.3"/>)、
バイト列(<xref target="binary" format="default" sectionFormat="of" derivedContent="Section 3.3.5"/>)、
またはスケーリングファクターとして機能する整数のパラメーターを使用することで対応できます。</t>
          <t indent="0" pn="section-3.3.1-7">整数を先行ゼロ（「0002」、「-01」など）や符号付きゼロ（「-0」）でシリアライズすることは可能ですが、
実装によってはこれらの区別が保持されない可能性があります。</t>
          <t indent="0" pn="section-3.3.1-8">整数のカンマは、本セクションの文中では読みやすくするためにのみ使用していることに注意してください。wireフォーマットでは無効です。</t>
        </section>
        <section anchor="decimal" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.2">
          <name slugifiedName="name-decimals">小数（Decimal）</name>
          <t indent="0" pn="section-3.3.2-1">小数（Decimal）は、整数部と小数部を持つ数です。
整数部は最大12桁、小数部は最大3桁です。</t>
          <t indent="0" pn="section-3.3.2-2">小数のABNFは以下の通りです。</t>
          <sourcecode type="abnf" markers="false" pn="section-3.3.2-3">
sf-decimal  = ["-"] 1*12DIGIT "." 1*3DIGIT
</sourcecode>
          <t indent="0" pn="section-3.3.2-4">例えば、値が小数として定義されているヘッダーは、以下のようになります。</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.2-5">
Example-Decimal: 4.5
</sourcecode>
          <t indent="0" pn="section-3.3.2-6">先行するゼロ（例えば、「0002.5」、「-01.334」）、後続するゼロ(例えば、「5.230」「-0.40」) および符号付きゼロ (例えば「-0.0」) は
小数へシリアライズできる一方で、実装によってこれらの区別が維持されない可能性があります。</t>
          <t indent="0" pn="section-3.3.2-7">シリアライズアルゴリズム(<xref target="ser-decimal" format="default" sectionFormat="of" derivedContent="Section 4.1.5"/>)は、
小数部の精度が3桁以上の入力を丸めることに注意してください。
もし別の丸め方をしたい場合は、ヘッダー定義でシリアライズの前に指定する必要があります。</t>
        </section>
        <section anchor="string" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.3">
          <name slugifiedName="name-strings">文字列（String）</name>
          <t indent="0" pn="section-3.3.3-1">文字列（String）は、0個以上の印刷可能なASCII<xref target="RFC0020" format="default" sectionFormat="of" derivedContent="RFC0020"/> 文字（すなわち、%x20 から %x7E の範囲）です。
タブ、改行、キャリッジリターンなどは含まれないことに注意してください。</t>
          <t indent="0" pn="section-3.3.3-2">文字列のABNFは次のとおりです。</t>
          <sourcecode type="abnf" markers="false" pn="section-3.3.3-3">
sf-string = DQUOTE *chr DQUOTE
chr       = unescaped / escaped
unescaped = %x20-21 / %x23-5B / %x5D-7E
escaped   = "\" ( DQUOTE / "\" )
</sourcecode>
          <t indent="0" pn="section-3.3.3-4">文字列は二重引用符で区切られ、二重引用符とバックスラッシュをエスケープするためにバックスラッシュ(" \")を使用します。以下に例を示します：</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.3-5">
Example-String: "hello world"
</sourcecode>
          <t indent="0" pn="section-3.3.3-6">文字列の区切り文字はDQUOTEのみで、シングルクォートでは区切りらないので注意してください。
また、エスケープできるのはDQUOTEと「\」だけで、それ以外の文字はパースに失敗<bcp14>しなければなりません（MUST）</bcp14></t>
          <t indent="0" pn="section-3.3.3-7">Unicodeは、多くの相互運用性の問題を引き起こすため、文字列では直接サポートされていません。
また、いくつかの例外を除いて、フィールド値にUnicodeは必要ありません。</t>
          <t indent="0" pn="section-3.3.3-8">フィールド値が非ASCIIの内容を伝える必要がある場合、
文字エンコーディング（望ましくは UTF-8<xref target="STD63" format="default" sectionFormat="of" derivedContent="STD63"/>）とともにバイト列（<xref target="binary" format="default" sectionFormat="of" derivedContent="Section 3.3.5"/>) を指定することができます。</t>
          <t indent="0" pn="section-3.3.3-9">パーサーは、少なくとも1024文字の文字列（デコード後）をサポート<bcp14>しなければなりません（MUST）</bcp14>。</t>
        </section>
        <section anchor="token" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.4">
          <name slugifiedName="name-tokens">トークン（Token）</name>
          <t indent="0" pn="section-3.3.4-1">トークン（Token）は短いテキストの単語であり、
その抽象的なモデルはHTTPフィールド値シリアライゼーションにおける表現と同じである。</t>
          <t indent="0" pn="section-3.3.4-2">トークンのABNFは以下の通りです。</t>
          <sourcecode type="abnf" markers="false" pn="section-3.3.4-3">
sf-token = ( ALPHA / "*" ) *( tchar / ":" / "/" )
</sourcecode>
          <t indent="0" pn="section-3.3.4-4">以下に例を示します：</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.4-5">
Example-Token: foo123/456
</sourcecode>
          <t indent="0" pn="section-3.3.4-6">パーサーは少なくとも512文字のTokenをサポート<bcp14>しなければなりません（MUST）</bcp14>。</t>
          <t indent="0" pn="section-3.3.4-7">トークンは<xref target="RFC7230" format="default" sectionFormat="of" derivedContent="RFC7230"/>で定義されている「token」ABNFルールと同じ文字が使えます。
ただし、最初の文字はALPHAか「*」でなければならず、「:」と「/」はそれ以降の文字でも許容されるという違いがあります。</t>
        </section>
        <section anchor="binary" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.5">
          <name slugifiedName="name-byte-sequences">バイト列（Byte Sequence）</name>
          <t indent="0" pn="section-3.3.5-1">バイト列（Byte Sequence）を、構造化フィールドで伝えることができます。</t>
          <t indent="0" pn="section-3.3.5-2">バイト列のABNFは以下の通りです：</t>
          <sourcecode type="abnf" markers="false" pn="section-3.3.5-3">
sf-binary = ":" *(base64) ":"
base64    = ALPHA / DIGIT / "+" / "/" / "="
</sourcecode>
          <t indent="0" pn="section-3.3.5-4">バイト列はコロンで区切られ、base64(<xref target="RFC4648" sectionFormat="comma" section="4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-4" derivedContent="RFC4648"/>)でエンコードされます。
以下に例を示します：</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.5-5">
Example-ByteSequence: :cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==:
</sourcecode>
          <t indent="0" pn="section-3.3.5-6">パーサーは、デコード後に少なくとも16384オクテットのByte Sequenceをサポート<bcp14>しなければなりません（MUST）</bcp14>。</t>
        </section>
        <section anchor="boolean" numbered="true" removeInRFC="false" toc="include" pn="section-3.3.6">
          <name slugifiedName="name-booleans">真偽値（Boolean）</name>
          <t indent="0" pn="section-3.3.6-1">真偽値（Boolean）を構造化フィールドで伝えることができます。</t>
          <t indent="0" pn="section-3.3.6-2">真偽値のABNFは以下の通りです。</t>
          <sourcecode type="abnf" markers="false" pn="section-3.3.6-3">
sf-boolean = "?" boolean
boolean    = "0" / "1"
</sourcecode>
          <t indent="0" pn="section-3.3.6-4">真偽値は、先頭の「?」文字の後に、真の場合は「1」、偽の場合は「0」で表されます。以下に例を示します：</t>
          <sourcecode type="http-message" markers="false" pn="section-3.3.6-5">
Example-Boolean: ?1
</sourcecode>
          <t indent="0" pn="section-3.3.6-6">なお、辞書(<xref target="dictionary" format="default" sectionFormat="of" derivedContent="Section 3.2"/>)およびパラメーター(<xref target="param" format="default" sectionFormat="of" derivedContent="Section 3.1.2"/>)の値では、
ブール値の真は値を省略することで表されます。</t>
        </section>
      </section>
    </section>
    <section anchor="text" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-working-with-structured-fie">HTTPにおける構造化フィールドとの連携</name>
      <t indent="0" pn="section-4-1">このセクションでは、構造化フィールドをテキスト形式のHTTPフィールド値
およびそれと互換性のある他のエンコーディングでシリアライズおよびパースする方法を定義します
(例えば、HPACK<xref target="RFC7541" format="default" sectionFormat="of" derivedContent="RFC7541"/>で圧縮する前の
HTTP/2<xref target="RFC7540" format="default" sectionFormat="of" derivedContent="RFC7540"/>)。</t>
      <section anchor="text-serialize" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-serializing-structured-fiel">構造化フィールドのシリアライズ</name>
        <t indent="0" pn="section-4.1-1">本仕様書で定義された構造体が与えられた場合、HTTPフィールド値として使用するのに適したASCII文字列を返します。</t>
        <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1-2">
          <li pn="section-4.1-2.1" derivedCounter="1.">構造体が辞書またはリストであり、その値が空である場合（つまり、メンバーを持たない場合）、
そのフィールドは一切シリアライズしません（つまりfield-nameとfield-valueの両方を省略します）。</li>
          <li pn="section-4.1-2.2" derivedCounter="2.">構造体がリストの場合、
その構造体に対して、リストのシリアライズ（<xref target="ser-list" format="default" sectionFormat="of" derivedContent="Section 4.1.1"/>）を実行した結果を、output_stringとします。</li>
          <li pn="section-4.1-2.3" derivedCounter="3.">構造体が辞書の場合、
その構造体に対して、辞書のシリアライズ（<xref target="ser-dictionary" format="default" sectionFormat="of" derivedContent="Section 4.1.2"/>）を実行した結果を、output_stringとします。</li>
          <li pn="section-4.1-2.4" derivedCounter="4.">構造体がアイテムの場合、
その構造体に対して、アイテムのシリアライズ（<xref target="ser-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3"/>）を実行した結果を、output_stringとします。</li>
          <li pn="section-4.1-2.5" derivedCounter="5.">それ以外の場合は失敗します。</li>
          <li pn="section-4.1-2.6" derivedCounter="6.">output_stringをASCIIエンコーディング<xref target="RFC0020" format="default" sectionFormat="of" derivedContent="RFC0020"/>を用いて、
バイト配列に変換した結果を返します。</li>
        </ol>
        <section anchor="ser-list" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.1">
          <name slugifiedName="name-serializing-a-list">リストのシリアライズ</name>
          <t indent="0" pn="section-4.1.1-1">input_list として (member_value, parameters) タプルの配列が与えられた場合、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.1-2">
            <li pn="section-4.1.1-2.1" derivedCounter="1.">outputに空文字列を代入します。</li>
            <li pn="section-4.1.1-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.1-2.2.1">input_list の各（member_value, parameters）に対して：</t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.1-2.2.2">
                <li pn="section-4.1.1-2.2.2.1" derivedCounter="1.">member_valueが配列の場合、
(member_value, parameters)に対して、インナーリストのシリアライズ（<xref target="ser-innerlist" format="default" sectionFormat="of" derivedContent="Section 4.1.1.1"/>）
を実行した結果を、outputに追加します。</li>
                <li pn="section-4.1.1-2.2.2.2" derivedCounter="2.">それ以外の場合、
(member_value, parameters)に対して、アイテムのシリアライズ（<xref target="ser-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3"/>）
を実行した結果を、outputに追加します。</li>
                <li pn="section-4.1.1-2.2.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.1.1-2.2.2.3.1">input_list にさらに member_value が残っている場合：</t>
                  <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.1-2.2.2.3.2">
                    <li pn="section-4.1.1-2.2.2.3.2.1" derivedCounter="1.">「,」をoutputに追加します。</li>
                    <li pn="section-4.1.1-2.2.2.3.2.2" derivedCounter="2.">ひとつのSPをoutput追加します.</li>
                  </ol>
                </li>
              </ol>
            </li>
            <li pn="section-4.1.1-2.3" derivedCounter="3.">outputを返します。</li>
          </ol>
          <section anchor="ser-innerlist" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.1.1.1">
            <name slugifiedName="name-serializing-an-inner-list">インナーリストのシリアライズ</name>
            <t indent="0" pn="section-4.1.1.1-1">(member_value, parameters) タプルの配列を inner_list、
パラメーターを list_parameters として与えたとき、HTTP フィールドの値として使用するのに適したASCII文字列を返します。</t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.1.1-2">
              <li pn="section-4.1.1.1-2.1" derivedCounter="1.">outputに「(」を代入します。</li>
              <li pn="section-4.1.1.1-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.1.1.1-2.2.1">inner_listの各(member_value, parameters)に対して：</t>
                <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.1.1-2.2.2">
                  <li pn="section-4.1.1.1-2.2.2.1" derivedCounter="1.">(member_value, parameters)に対して、
アイテムのシリアライズ（<xref target="ser-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3"/>）を実行した結果を、
outputに追加します</li>
                  <li pn="section-4.1.1.1-2.2.2.2" derivedCounter="2.">まだinner_listに要素が残っている場合、outputにSPをひとつ追加します。</li>
                </ol>
              </li>
              <li pn="section-4.1.1.1-2.3" derivedCounter="3.">outputに「)」を追加します。</li>
              <li pn="section-4.1.1.1-2.4" derivedCounter="4.">list_parametersに対して、
パラメーターのシリアライズ（<xref target="ser-params" format="default" sectionFormat="of" derivedContent="Section 4.1.1.2"/>）を実行した結果を、
outputに追加します。</li>
              <li pn="section-4.1.1.1-2.5" derivedCounter="5.">outputを返します。</li>
            </ol>
          </section>
          <section anchor="ser-params" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.1.1.2">
            <name slugifiedName="name-serializing-parameters">パラメーターのシリアライズ</name>
            <t indent="0" pn="section-4.1.1.2-1">input_parametersとして順序付き辞書（各メンバーはparam_keyとparam_valueを持ちます）を与え、
HTTPフィールドの値として使用するのに適したASCII 文字列を返します。</t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.1.2-2">
              <li pn="section-4.1.1.2-2.1" derivedCounter="1.">outputに空文字列を代入します。</li>
              <li pn="section-4.1.1.2-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.1.1.2-2.2.1">input_parameters中でparam_keyの値がparam_valueであるものについて：</t>
                <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.1.2-2.2.2">
                  <li pn="section-4.1.1.2-2.2.2.1" derivedCounter="1.">「;」をoutputに追加します。</li>
                  <li pn="section-4.1.1.2-2.2.2.2" derivedCounter="2.">param_keyに対して、
キーのシリアライズ（<xref target="ser-key" format="default" sectionFormat="of" derivedContent="Section 4.1.1.3"/>）を実行した結果を、
outputに追加します。</li>
                  <li pn="section-4.1.1.2-2.2.2.3" derivedCounter="3.">
                    <t indent="0" pn="section-4.1.1.2-2.2.2.3.1">param_valueが真偽値の真でない場合：</t>
                    <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.1.2-2.2.2.3.2">
                      <li pn="section-4.1.1.2-2.2.2.3.2.1" derivedCounter="1.">「=」をoutputに追加します。</li>
                      <li pn="section-4.1.1.2-2.2.2.3.2.2" derivedCounter="2.">param_valueに対して、
裸のアイテムのシリアライズ（<xref target="ser-bare-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3.1"/>）を実行した結果を、
outputに追加します。</li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li pn="section-4.1.1.2-2.3" derivedCounter="3.">outputを返します。</li>
            </ol>
          </section>
          <section anchor="ser-key" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.1.1.3">
            <name slugifiedName="name-serializing-a-key">キーのシリアライズ</name>
            <t indent="0" pn="section-4.1.1.3-1">キーをinput_keyとして渡すと、HTTPフィールドの値として適切なASCII文字列を返します。</t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.1.3-2">
              <li pn="section-4.1.1.3-2.1" derivedCounter="1.">input_keyをASCII文字の列に変換します；この変換が失敗した場合、シリアライズも失敗します。</li>
              <li pn="section-4.1.1.3-2.2" derivedCounter="2.">input_keyがlcalpha、DIGIT、「_」、「-」、「.」、「*」に含まれない文字を含んでいる場合、シリアライズに失敗します。</li>
              <li pn="section-4.1.1.3-2.3" derivedCounter="3.">input_keyの最初の文字がlcalphaまたは「*」でない場合、シリアライズに失敗します。</li>
              <li pn="section-4.1.1.3-2.4" derivedCounter="4.">outputに空文字列を代入します。</li>
              <li pn="section-4.1.1.3-2.5" derivedCounter="5.">input_keyをoutputに代入します。</li>
              <li pn="section-4.1.1.3-2.6" derivedCounter="6.">outputを返します。</li>
            </ol>
          </section>
        </section>
        <section anchor="ser-dictionary" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.2">
          <name slugifiedName="name-serializing-a-dictionary">辞書のシリアライズ</name>
          <t indent="0" pn="section-4.1.2-1">input_dictionary として順序付き辞書（各メンバーはmember_keyと(member_value, parameters)のタプル値）が与えられたとき、
HTTP フィールド値として使用するのに適したASCII文字列を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.2-2">
            <li pn="section-4.1.2-2.1" derivedCounter="1.">outputに空文字列を代入します。</li>
            <li pn="section-4.1.2-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.1.2-2.2.1">input_dictionary の、値が (member_value, parameters) である member_key について、その値を取得します。 </t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.2-2.2.2">
                <li pn="section-4.1.2-2.2.2.1" derivedCounter="1.">メンバーのmember_keyに対して、
キーのシリアライズ（<xref target="ser-key" format="default" sectionFormat="of" derivedContent="Section 4.1.1.3"/>）を実行した結果を、
outputに追加します。</li>
                <li pn="section-4.1.2-2.2.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.1.2-2.2.2.2.1">member_value が真偽値の真の場合：</t>
                  <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.2-2.2.2.2.2">
                    <li pn="section-4.1.2-2.2.2.2.2.1" derivedCounter="1.">parametersに対して、
パラメーターのシリアライズ（<xref target="ser-params" format="default" sectionFormat="of" derivedContent="Section 4.1.1.2"/>）を実行した結果を、
outputに追加します。</li>
                  </ol>
                </li>
                <li pn="section-4.1.2-2.2.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.1.2-2.2.2.3.1">それ以外の場合：</t>
                  <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.2-2.2.2.3.2">
                    <li pn="section-4.1.2-2.2.2.3.2.1" derivedCounter="1.">outputに「=」を追加します。</li>
                    <li pn="section-4.1.2-2.2.2.3.2.2" derivedCounter="2.">もしmember_valueが配列ならば、
(member_value, parameters)に対して、
インナーリストのシリアライズ (<xref target="ser-innerlist" format="default" sectionFormat="of" derivedContent="Section 4.1.1.1"/>）を実行した結果を、
outputに追加します。</li>
                    <li pn="section-4.1.2-2.2.2.3.2.3" derivedCounter="3.">配列でなければ、
(member_value, parameters)に対して、
アイテムのシリアライズ（<xref target="ser-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3"/>）を実行した結果を、
outputに追加します。</li>
                  </ol>
                </li>
                <li pn="section-4.1.2-2.2.2.4" derivedCounter="4.">
                  <t indent="0" pn="section-4.1.2-2.2.2.4.1">input_dictionary にさらにメンバーが残っている場合：</t>
                  <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.2-2.2.2.4.2">
                    <li pn="section-4.1.2-2.2.2.4.2.1" derivedCounter="1.">outputに「,」を追加します。</li>
                    <li pn="section-4.1.2-2.2.2.4.2.2" derivedCounter="2.">outputにSPをひとつ追加します。</li>
                  </ol>
                </li>
              </ol>
            </li>
            <li pn="section-4.1.2-2.3" derivedCounter="3.">outputを返します。</li>
          </ol>
        </section>
        <section anchor="ser-item" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.3">
          <name slugifiedName="name-serializing-an-item">アイテムのシリアライズ</name>
          <t indent="0" pn="section-4.1.3-1">bare_itemとしてアイテムを、item_parameters としてパラメーターを与えられたとき、
HTTP フィールド値として使用するのに適したASCII文字列を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.3-2">
            <li pn="section-4.1.3-2.1" derivedCounter="1.">outputに空文字列を代入します。</li>
            <li pn="section-4.1.3-2.2" derivedCounter="2.">bare_itemに対して、
裸のアイテムのシリアライズ（<xref target="ser-bare-item" format="default" sectionFormat="of" derivedContent="Section 4.1.3.1"/>）を実行した結果を、
outputに追加します。</li>
            <li pn="section-4.1.3-2.3" derivedCounter="3.">item_parametersに対して、
パラメーターのシリアライズ（<xref target="ser-params" format="default" sectionFormat="of" derivedContent="Section 4.1.1.2"/>）を実行した結果を、
outputに追加します。</li>
            <li pn="section-4.1.3-2.4" derivedCounter="4.">outputを返します。</li>
          </ol>
          <section anchor="ser-bare-item" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.1.3.1">
            <name slugifiedName="name-serializing-a-bare-item">裸のアイテムのシリアライズ</name>
            <t indent="0" pn="section-4.1.3.1-1">input_itemとしてアイテムを与えられたとき、
HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.3.1-2">
              <li pn="section-4.1.3.1-2.1" derivedCounter="1.">もしinput_itemが整数ならば、input_itemに対して、
整数のシリアライズ（<xref target="ser-integer" format="default" sectionFormat="of" derivedContent="Section 4.1.4"/>）を実行した結果を返します。</li>
              <li pn="section-4.1.3.1-2.2" derivedCounter="2.">もしinput_itemが小数ならば、input_itemに対して、
小数のシリアライズ（<xref target="ser-decimal" format="default" sectionFormat="of" derivedContent="Section 4.1.5"/>）を実行した結果を返します。</li>
              <li pn="section-4.1.3.1-2.3" derivedCounter="3.">もしinput_itemが文字列ならば、input_itemに対して、
文字列のシリアライズ（<xref target="ser-string" format="default" sectionFormat="of" derivedContent="Section 4.1.6"/>）を実行した結果を返します。</li>
              <li pn="section-4.1.3.1-2.4" derivedCounter="4.">もしinput_itemがトークンならば、input_itemに対して、
トークンのシリアライズ（<xref target="ser-token" format="default" sectionFormat="of" derivedContent="Section 4.1.7"/>）を実行した結果を返します。</li>
              <li pn="section-4.1.3.1-2.5" derivedCounter="5.">もしinput_itemがバイト列ならば、input_itemに対して、
バイト列のシリアライズ（<xref target="ser-binary" format="default" sectionFormat="of" derivedContent="Section 4.1.8"/>）を実行した結果を返します。</li>
              <li pn="section-4.1.3.1-2.6" derivedCounter="6.">もしinput_itemが真偽値ならば、input_itemに対して、
真偽値のシリアライズ（<xref target="ser-boolean" format="default" sectionFormat="of" derivedContent="Section 4.1.9"/>）を実行した結果を返します。</li>
              <li pn="section-4.1.3.1-2.7" derivedCounter="7.">それ以外の場合は、シリアライズに失敗します。</li>
            </ol>
          </section>
        </section>
        <section anchor="ser-integer" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.4">
          <name slugifiedName="name-serializing-an-integer">整数のシリアライズ</name>
          <t indent="0" pn="section-4.1.4-1">整数をinput_integerとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.4-2">
            <li pn="section-4.1.4-2.1" derivedCounter="1.">もしinput_integerが-999,999,999,999,999から999,999,999,999,999までの両端を含む範囲の整数でなければ、
シリアライズに失敗します。</li>
            <li pn="section-4.1.4-2.2" derivedCounter="2.">outputに空文字を代入します。</li>
            <li pn="section-4.1.4-2.3" derivedCounter="3.">もしinput_integerが0未満（0は除く）の場合、outputに「-」を追加します。</li>
            <li pn="section-4.1.4-2.4" derivedCounter="4.">0から9までの数字だけをもちいて、input_integerを10進数で表現した結果を、outputに追加します。</li>
            <li pn="section-4.1.4-2.5" derivedCounter="5.">outputを返します。</li>
          </ol>
        </section>
        <section anchor="ser-decimal" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.5">
          <name slugifiedName="name-serializing-a-decimal">小数のシリアライズ</name>
          <t indent="0" pn="section-4.1.5-1">小数をinput_decimalとして与えると、HTTP フィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.5-2">
            <li pn="section-4.1.5-2.1" derivedCounter="1.">input_decimalが小数でない場合、シリアライズに失敗します</li>
            <li pn="section-4.1.5-2.2" derivedCounter="2.">input_decimalの小数点以下の桁数が3桁より多い場合、もっとも近い3桁に丸めます。
等距離の場合は偶数へ丸めます。</li>
            <li pn="section-4.1.5-2.3" derivedCounter="3.">丸めを行ったあとに、小数点の右側に12桁より多くの桁がある場合は、シリアライズに失敗します。</li>
            <li pn="section-4.1.5-2.4" derivedCounter="4.">outputに空文字列を代入します。</li>
            <li pn="section-4.1.5-2.5" derivedCounter="5.">もしinput_decimalが0未満（0は除く）の場合、outputに「-」を追加します。</li>
            <li pn="section-4.1.5-2.6" derivedCounter="6.">input_decimalの整数部を10進数で表した結果（0から9までの数字のみを使います）をoutputに追加します；
つまり整数部がゼロの場合は「0」を追加します。</li>
            <li pn="section-4.1.5-2.7" derivedCounter="7.">「.」をoutputに追加します。</li>
            <li pn="section-4.1.5-2.8" derivedCounter="8.">input_decimalの小数部がゼロの場合、「0」をoutputに追加します。</li>
            <li pn="section-4.1.5-2.9" derivedCounter="9.">そうでない場合、input_decimalの小数部をoutputに追加します（0から9までの数字のみを使います）。</li>
            <li pn="section-4.1.5-2.10" derivedCounter="10.">outputを返します。</li>
          </ol>
        </section>
        <section anchor="ser-string" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.6">
          <name slugifiedName="name-serializing-a-string">文字列のシリアライズ</name>
          <t indent="0" pn="section-4.1.6-1">文字列をinput_stringとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.6-2">
            <li pn="section-4.1.6-2.1" derivedCounter="1.">input_stringをASCII文字の列に変換します。変換に失敗した場合、シリアライズに失敗します。</li>
            <li pn="section-4.1.6-2.2" derivedCounter="2.">input_stringが%x00-1fまたは%x7f-ffの範囲の文字を含んでいる場合（つまり、VCHARやSPは含みません）、シリアライズに失敗します。</li>
            <li pn="section-4.1.6-2.3" derivedCounter="3.">outputに文字列DQUOTEを代入します。</li>
            <li pn="section-4.1.6-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.1.6-2.4.1">input_stringの各文字charについて：</t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.6-2.4.2">
                <li pn="section-4.1.6-2.4.2.1" derivedCounter="1.">
                  <t indent="0" pn="section-4.1.6-2.4.2.1.1">charが「\」またはDQUOTEの場合</t>
                  <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.6-2.4.2.1.2">
                    <li pn="section-4.1.6-2.4.2.1.2.1" derivedCounter="1.">「\」をoutputに追加します。</li>
                  </ol>
                </li>
                <li pn="section-4.1.6-2.4.2.2" derivedCounter="2.">charをoutputに追加します。</li>
              </ol>
            </li>
            <li pn="section-4.1.6-2.5" derivedCounter="5.">DQUOTEをoutputに追加します。</li>
            <li pn="section-4.1.6-2.6" derivedCounter="6.">outputを返します。</li>
          </ol>
        </section>
        <section anchor="ser-token" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.7">
          <name slugifiedName="name-serializing-a-token">トークンのシリアライズ</name>
          <t indent="0" pn="section-4.1.7-1">トークンをinput_tokenとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.7-2">
            <li pn="section-4.1.7-2.1" derivedCounter="1.">input_tokenをASCII文字の列に変換します。変換に失敗した場合、シリアライズに失敗します。</li>
            <li pn="section-4.1.7-2.2" derivedCounter="2.">input_tokenの最初の文字がALPHAまたは「*」でない場合、シリアライズに失敗します。
残りの文字がtchar、「:」「/」でない場合、シリアライズに失敗します。</li>
            <li pn="section-4.1.7-2.3" derivedCounter="3.">outputに空文字列を代入します。</li>
            <li pn="section-4.1.7-2.4" derivedCounter="4.">outputにinput_tokenを追加します。</li>
            <li pn="section-4.1.7-2.5" derivedCounter="5.">outputを返します。</li>
          </ol>
        </section>
        <section anchor="ser-binary" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.8">
          <name slugifiedName="name-serializing-a-byte-sequence">バイト列のシリアライズ</name>
          <t indent="0" pn="section-4.1.8-1">バイト列をinput_bytesとして与え、HTTP のフィールド値として使用するのに適したASCII文字列を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.8-2">
            <li pn="section-4.1.8-2.1" derivedCounter="1.">もしinput_bytesがバイト列でない場合、シリアライズに失敗します。</li>
            <li pn="section-4.1.8-2.2" derivedCounter="2.">outputに空文字列を代入します。</li>
            <li pn="section-4.1.8-2.3" derivedCounter="3.">「:」をoutputに追加します。</li>
            <li pn="section-4.1.8-2.4" derivedCounter="4.">input_bytesを<xref target="RFC4648" sectionFormat="comma" section="4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-4" derivedContent="RFC4648"/>にしたがってbase64エンコードをた結果を追加します。
このとき以下の要件を考慮してください。</li>
            <li pn="section-4.1.8-2.5" derivedCounter="5.">「:」をoutputに追加します。</li>
            <li pn="section-4.1.8-2.6" derivedCounter="6.">outputを返します。</li>
          </ol>
          <t indent="0" pn="section-4.1.8-3">エンコードされたデータは、<xref target="RFC4648" sectionFormat="comma" section="3.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.2" derivedContent="RFC4648"/> にしたがって、「=」でパディングすることが要求されます。</t>
          <t indent="0" pn="section-4.1.8-4">同様に、エンコードされたデータは、実装上の制約から不可能な場合を除き、<xref target="RFC4648" sectionFormat="comma" section="3.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.5" derivedContent="RFC4648"/> にしたがってパッドビットをゼロに設定<bcp14>すべきです（SHOULD）</bcp14>。</t>
        </section>
        <section anchor="ser-boolean" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.9">
          <name slugifiedName="name-serializing-a-boolean">真偽値のシリアライズ</name>
          <t indent="0" pn="section-4.1.9-1">真偽値をinput_booleanとして与えると、HTTPフィールドの値として使用するのに適したASCII文字列を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.1.9-2">
            <li pn="section-4.1.9-2.1" derivedCounter="1.">input_booleanが真偽値でない場合、シリアライズに失敗します。</li>
            <li pn="section-4.1.9-2.2" derivedCounter="2.">outputに空文字列を代入します。</li>
            <li pn="section-4.1.9-2.3" derivedCounter="3.">「?」をoutputに追加します。</li>
            <li pn="section-4.1.9-2.4" derivedCounter="4.">もしinput_booleanが真であれば、「1」をoutputに追加します。</li>
            <li pn="section-4.1.9-2.5" derivedCounter="5.">もしinput_booleanが偽であれば、「0」をoutputに追加します。</li>
            <li pn="section-4.1.9-2.6" derivedCounter="6.">outputを返します。</li>
          </ol>
        </section>
      </section>
      <section anchor="text-parse" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-parsing-structured-fields">Parsing Structured Fields</name>
        <t indent="0" pn="section-4.2-1">受信側の実装が Structured Fields であることが知られている HTTP フィールドを解析するとき、相互運用性やセキュリティの問題を引き起こす可能性のある多くのエッジケースがあるため、注意を払うことが重要である。この節では、そのためのアルゴリズムを規定する。</t>
        <t indent="0" pn="section-4.2-2">選択されたフィールドのフィールド値（そのフィールドが存在しない場合は空）と field_type（dictionary, list, item のいずれか）を表すバイトの配列を input_bytes として与え、解析されたヘッダー値を返す。</t>
        <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2-3">
          <li pn="section-4.2-3.1" derivedCounter="1.">Convert input_bytes into an ASCII string input_string; if
	  conversion fails, fail parsing.</li>
          <li pn="section-4.2-3.2" derivedCounter="2.">Discard any leading SP characters from input_string.</li>
          <li pn="section-4.2-3.3" derivedCounter="3.">If field_type is "list", let output be the result of running
	  Parsing a List (<xref target="parse-list" format="default" sectionFormat="of" derivedContent="Section 4.2.1"/>) with
	  input_string.</li>
          <li pn="section-4.2-3.4" derivedCounter="4.">If field_type is "dictionary", let output be the result of
	  running Parsing a Dictionary (<xref target="parse-dictionary" format="default" sectionFormat="of" derivedContent="Section 4.2.2"/>) with input_string.</li>
          <li pn="section-4.2-3.5" derivedCounter="5.">If field_type is "item", let output be the result of running
	  Parsing an Item (<xref target="parse-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3"/>) with
	  input_string.</li>
          <li pn="section-4.2-3.6" derivedCounter="6.">Discard any leading SP characters from input_string.</li>
          <li pn="section-4.2-3.7" derivedCounter="7.">If input_string is not empty, fail parsing.</li>
          <li pn="section-4.2-3.8" derivedCounter="8.">Otherwise, return output.</li>
        </ol>
        <t indent="0" pn="section-4.2-4">input_bytesを生成するとき、パーサーは、<xref target="RFC7230" sectionFormat="comma" section="3.2.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7230#section-3.2.2" derivedContent="RFC7230"/> に従って、大文字小文字を区別せずにフィールド名と一致する同じセクション（ヘッダーまたはトレーラー）のすべてのフィールド行を1つのカンマ区切りフィールド値に結合しなければならない（MUSTMUST）。これは、フィールド値全体が正しく処理されることを確実にするものです。</t>
        <t indent="0" pn="section-4.2-5">リストと辞書の場合、トップレベルのデータ構造の個々のメンバーが複数のヘッダーインスタンスにまたがって分割されていない限り、これはフィールドのすべての行を正しく連結する効果があります。両タイプの解析アルゴリズムでは、タブ文字を許容しています。これは、実装によってはフィールドの行を結合するためにタブ文字が使用される可能性があるためです。</t>
        <t indent="0" pn="section-4.2-6">複数のフィールド行にまたがる文字列は、予測できない結果をもたらします。なぜなら、1つ以上のカンマ(オプションの空白文字)がパーサーによって出力される文字列の一部になってしまうからです。連結は上流の仲介者によって行われる可能性があるため、シリアライザーとパーサーの両方が同じ制御下にある場合でも、その結果はシリアライザーの制御下にはない。</t>
        <t indent="0" pn="section-4.2-7">トークン、整数、小数、バイト列は、挿入されたカンマによってパースに失敗するため、複数のフィールド行に分割することはできません。</t>
        <t indent="0" pn="section-4.2-8">パーサーは、複数のフィールド行にまたがるフィールド値を処理するときに、それらの行の1つがそのフィールドとしてパースされない場合、失敗してもよい(MAYMAY)。例えば、sf-stringとして定義されたExample-Stringフィールドを処理するパーサーは、このフィールドセクションを処理する際に失敗しても構わない。</t>
        <sourcecode type="http-message" markers="false" pn="section-4.2-9">
Example-String: "foo
Example-String: bar"
</sourcecode>
        <t indent="0" pn="section-4.2-10">パースに失敗した場合(別のアルゴリズムを呼び出す場合も含む)、フィールド値全体を無視しなければならない(MUST)(すなわち、そのセクションにフィールドが存在しないかのように扱う)。これは相互運用性と安全性を高めるために意図的に厳しくしており、この文書を参照する仕様では、この要件を緩めることは許されない。</t>
        <t indent="0" pn="section-4.2-11">この要件は、フィールドを解析していない実装には適用されないことに注意。例えば、仲介者は転送する前にメッセージから失敗したフィールドを取り除くことを要求されない。</t>
        <section anchor="parse-list" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.1">
          <name slugifiedName="name-parsing-a-list">Parsing a List</name>
          <t indent="0" pn="section-4.2.1-1">ASCII文字列をinput_stringとして与え、(item_or_inner_list, parameters) タプルの配列を返す。 input_stringは解析された値を除去するために修正される。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.1-2">
            <li pn="section-4.2.1-2.1" derivedCounter="1.">Let members be an empty array.</li>
            <li pn="section-4.2.1-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.1-2.2.1">input_stringが空でない間。 </t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.1-2.2.2">
                <li pn="section-4.2.1-2.2.2.1" derivedCounter="1.">Append the result of running Parsing an Item or Inner List
		(<xref target="parse-item-or-list" format="default" sectionFormat="of" derivedContent="Section 4.2.1.1"/>) with
		input_string to members.</li>
                <li pn="section-4.2.1-2.2.2.2" derivedCounter="2.">Discard any leading OWS characters from input_string.</li>
                <li pn="section-4.2.1-2.2.2.3" derivedCounter="3.">If input_string is empty, return members.</li>
                <li pn="section-4.2.1-2.2.2.4" derivedCounter="4.">Consume the first character of input_string; if it is not
		",", fail parsing.</li>
                <li pn="section-4.2.1-2.2.2.5" derivedCounter="5.">Discard any leading OWS characters from input_string.</li>
                <li pn="section-4.2.1-2.2.2.6" derivedCounter="6.">If input_string is empty, there is a trailing comma; fail parsing.</li>
              </ol>
            </li>
            <li pn="section-4.2.1-2.3" derivedCounter="3.">No structured data has been found; return members (which is empty).</li>
          </ol>
          <section anchor="parse-item-or-list" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.1.1">
            <name slugifiedName="name-parsing-an-item-or-inner-li">Parsing an Item or Inner List</name>
            <t indent="0" pn="section-4.2.1.1-1">ASCII 文字列を input_string とすると、タプル (item_or_inner_list, parameters) を返す。ここで item_or_inner_list は単一の裸項目か、 (bare_item, parameters) タプルの配列のいずれかである。</t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.1.1-2">
              <li pn="section-4.2.1.1-2.1" derivedCounter="1.">If the first character of input_string is "(", return the
	      result of running Parsing an Inner List (<xref target="parse-innerlist" format="default" sectionFormat="of" derivedContent="Section 4.2.1.2"/>) with
	      input_string.</li>
              <li pn="section-4.2.1.1-2.2" derivedCounter="2.">Return the result of running Parsing an Item (<xref target="parse-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3"/>) with input_string.</li>
            </ol>
          </section>
          <section anchor="parse-innerlist" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.1.2">
            <name slugifiedName="name-parsing-an-inner-list">Parsing an Inner List</name>
            <t indent="0" pn="section-4.2.1.2-1">ASCII文字列をinput_stringとして与え、inner_listを(bare_item, parameters)の配列としたタプルを返す。 input_stringは解析された値を除去するために修正される。</t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.1.2-2">
              <li pn="section-4.2.1.2-2.1" derivedCounter="1.">Consume the first character of input_string; if it is not
	      "(", fail parsing.</li>
              <li pn="section-4.2.1.2-2.2" derivedCounter="2.">Let inner_list be an empty array.</li>
              <li pn="section-4.2.1.2-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.2.1.2-2.3.1">input_stringが空でない間。 </t>
                <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.1.2-2.3.2">
                  <li pn="section-4.2.1.2-2.3.2.1" derivedCounter="1.">Discard any leading SP characters from input_string.</li>
                  <li pn="section-4.2.1.2-2.3.2.2" derivedCounter="2.">
                    <t indent="0" pn="section-4.2.1.2-2.3.2.2.1">input_stringの最初の文字が") "である場合。 </t>
                    <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.1.2-2.3.2.2.2">
                      <li pn="section-4.2.1.2-2.3.2.2.2.1" derivedCounter="1.">Consume the first character of input_string.</li>
                      <li pn="section-4.2.1.2-2.3.2.2.2.2" derivedCounter="2.">Let parameters be the result of running Parsing
		      Parameters (<xref target="parse-param" format="default" sectionFormat="of" derivedContent="Section 4.2.3.2"/>) with input_string.</li>
                      <li pn="section-4.2.1.2-2.3.2.2.2.3" derivedCounter="3.">Return the tuple (inner_list, parameters).</li>
                    </ol>
                  </li>
                  <li pn="section-4.2.1.2-2.3.2.3" derivedCounter="3.">Let item be the result of running Parsing an Item (<xref target="parse-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3"/>) with
		  input_string.</li>
                  <li pn="section-4.2.1.2-2.3.2.4" derivedCounter="4.">Append item to inner_list.</li>
                  <li pn="section-4.2.1.2-2.3.2.5" derivedCounter="5.">If the first character of input_string is not SP or ")",
		  fail parsing.</li>
                </ol>
              </li>
              <li pn="section-4.2.1.2-2.4" derivedCounter="4.">The end of the Inner List was not found; fail parsing.</li>
            </ol>
          </section>
        </section>
        <section anchor="parse-dictionary" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.2">
          <name slugifiedName="name-parsing-a-dictionary">Parsing a Dictionary</name>
          <t indent="0" pn="section-4.2.2-1">ASCII文字列をinput_stringとして与え、その値を(item_or_inner_list, parameters)タプルとする順序付きマップを返す。 input_stringは解析された値を除去するために修正される。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.2-2">
            <li pn="section-4.2.2-2.1" derivedCounter="1.">Let dictionary be an empty, ordered map.</li>
            <li pn="section-4.2.2-2.2" derivedCounter="2.">
              <t indent="0" pn="section-4.2.2-2.2.1">input_stringが空でない間。 </t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.2-2.2.2">
                <li pn="section-4.2.2-2.2.2.1" derivedCounter="1.">Let this_key be the result of running Parsing a Key (<xref target="parse-key" format="default" sectionFormat="of" derivedContent="Section 4.2.3.3"/>) with input_string.</li>
                <li pn="section-4.2.2-2.2.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.2.2-2.2.2.2.1">input_stringの最初の文字が"="である場合。 </t>
                  <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.2-2.2.2.2.2">
                    <li pn="section-4.2.2-2.2.2.2.2.1" derivedCounter="1.">Consume the first character of input_string.</li>
                    <li pn="section-4.2.2-2.2.2.2.2.2" derivedCounter="2.">Let member be the result of running Parsing an Item or
		    Inner List (<xref target="parse-item-or-list" format="default" sectionFormat="of" derivedContent="Section 4.2.1.1"/>) with input_string.</li>
                  </ol>
                </li>
                <li pn="section-4.2.2-2.2.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.2.2-2.2.2.3.1">それ以外は。 </t>
                  <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.2-2.2.2.3.2">
                    <li pn="section-4.2.2-2.2.2.3.2.1" derivedCounter="1.">Let value be Boolean true.</li>
                    <li pn="section-4.2.2-2.2.2.3.2.2" derivedCounter="2.">Let parameters be the result of running Parsing
		    Parameters (<xref target="parse-param" format="default" sectionFormat="of" derivedContent="Section 4.2.3.2"/>)
		    with input_string.</li>
                    <li pn="section-4.2.2-2.2.2.3.2.3" derivedCounter="3.">Let member be the tuple (value, parameters).</li>
                  </ol>
                </li>
                <li pn="section-4.2.2-2.2.2.4" derivedCounter="4.">If dictionary already contains a key this_key (comparing character for character),  overwrite its value with member.</li>
                <li pn="section-4.2.2-2.2.2.5" derivedCounter="5.">Otherwise, append key this_key with value member to dictionary.</li>
                <li pn="section-4.2.2-2.2.2.6" derivedCounter="6.">Discard any leading OWS characters from input_string.</li>
                <li pn="section-4.2.2-2.2.2.7" derivedCounter="7.">If input_string is empty, return dictionary.</li>
                <li pn="section-4.2.2-2.2.2.8" derivedCounter="8.">Consume the first character of input_string; if it is not
		",", fail parsing.</li>
                <li pn="section-4.2.2-2.2.2.9" derivedCounter="9.">Discard any leading OWS characters from input_string.</li>
                <li pn="section-4.2.2-2.2.2.10" derivedCounter="10.">If input_string is empty, there is a trailing comma; fail parsing.</li>
              </ol>
            </li>
            <li pn="section-4.2.2-2.3" derivedCounter="3.">No structured data has been found; return dictionary (which is empty).</li>
          </ol>
          <t indent="0" pn="section-4.2.2-3">辞書のキーが重複している場合、最後のインスタンス以外は無視されることに注意してください。</t>
        </section>
        <section anchor="parse-item" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.3">
          <name slugifiedName="name-parsing-an-item">Parsing an Item</name>
          <t indent="0" pn="section-4.2.3-1">ASCII 文字列を input_string として与え、(bare_item, parameters) タプルを返す。 input_string はパースされた値を削除するように変更される。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.3-2">
            <li pn="section-4.2.3-2.1" derivedCounter="1.">Let bare_item be the result of running Parsing a Bare Item
	    (<xref target="parse-bare-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3.1"/>) with
	    input_string.</li>
            <li pn="section-4.2.3-2.2" derivedCounter="2.">Let parameters be the result of running Parsing Parameters
	    (<xref target="parse-param" format="default" sectionFormat="of" derivedContent="Section 4.2.3.2"/>) with
	    input_string.</li>
            <li pn="section-4.2.3-2.3" derivedCounter="3.">Return the tuple (bare_item, parameters).</li>
          </ol>
          <section anchor="parse-bare-item" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.3.1">
            <name slugifiedName="name-parsing-a-bare-item">Parsing a Bare Item</name>
            <t indent="0" pn="section-4.2.3.1-1">ASCII文字列をinput_stringとして与え、素のItemを返す。 input_stringは解析された値を取り除くために修正される。</t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.3.1-2">
              <li pn="section-4.2.3.1-2.1" derivedCounter="1.">If the first character of input_string is a "-" or a DIGIT,
	      return the result of running Parsing an Integer or Decimal
	      (<xref target="parse-number" format="default" sectionFormat="of" derivedContent="Section 4.2.4"/>) with
	      input_string.</li>
              <li pn="section-4.2.3.1-2.2" derivedCounter="2.">If the first character of input_string is a DQUOTE, return
	      the result of running Parsing a String (<xref target="parse-string" format="default" sectionFormat="of" derivedContent="Section 4.2.5"/>) with
	      input_string.</li>
              <li pn="section-4.2.3.1-2.3" derivedCounter="3.">If the first character of input_string is an ALPHA or "*",
	      return the result of running Parsing a Token (<xref target="parse-token" format="default" sectionFormat="of" derivedContent="Section 4.2.6"/>) with input_string.</li>
              <li pn="section-4.2.3.1-2.4" derivedCounter="4.">If the first character of input_string is ":", return the
	      result of running Parsing a Byte Sequence (<xref target="parse-binary" format="default" sectionFormat="of" derivedContent="Section 4.2.7"/>) with
	      input_string.</li>
              <li pn="section-4.2.3.1-2.5" derivedCounter="5.">If the first character of input_string is "?", return the
	      result of running Parsing a Boolean (<xref target="parse-boolean" format="default" sectionFormat="of" derivedContent="Section 4.2.8"/>) with
	      input_string.</li>
              <li pn="section-4.2.3.1-2.6" derivedCounter="6.">Otherwise, the item type is unrecognized; fail parsing.</li>
            </ol>
          </section>
          <section anchor="parse-param" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.3.2">
            <name slugifiedName="name-parsing-parameters">Parsing Parameters</name>
            <t indent="0" pn="section-4.2.3.2-1">ASCII文字列をinput_stringとして与え、その値をbare Itemsとする順序付きマップを返す。 input_stringはパースされた値を削除するために変更される。</t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.3.2-2">
              <li pn="section-4.2.3.2-2.1" derivedCounter="1.">Let parameters be an empty, ordered map.</li>
              <li pn="section-4.2.3.2-2.2" derivedCounter="2.">
                <t indent="0" pn="section-4.2.3.2-2.2.1">input_stringが空でない間。 </t>
                <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.3.2-2.2.2">
                  <li pn="section-4.2.3.2-2.2.2.1" derivedCounter="1.">If the first character of input_string is not ";", exit the loop.</li>
                  <li pn="section-4.2.3.2-2.2.2.2" derivedCounter="2.">Consume the ";" character from the beginning of input_string.</li>
                  <li pn="section-4.2.3.2-2.2.2.3" derivedCounter="3.">Discard any leading SP characters from input_string.</li>
                  <li pn="section-4.2.3.2-2.2.2.4" derivedCounter="4.">Let param_key be the result of running Parsing a Key
		  (<xref target="parse-key" format="default" sectionFormat="of" derivedContent="Section 4.2.3.3"/>) with
		  input_string.</li>
                  <li pn="section-4.2.3.2-2.2.2.5" derivedCounter="5.">Let param_value be Boolean true.</li>
                  <li pn="section-4.2.3.2-2.2.2.6" derivedCounter="6.">
                    <t indent="0" pn="section-4.2.3.2-2.2.2.6.1">input_stringの最初の文字が"="である場合。 </t>
                    <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.3.2-2.2.2.6.2">
                      <li pn="section-4.2.3.2-2.2.2.6.2.1" derivedCounter="1.">Consume the "=" character at the beginning of input_string.</li>
                      <li pn="section-4.2.3.2-2.2.2.6.2.2" derivedCounter="2.">Let param_value be the result of running Parsing a
		      Bare Item (<xref target="parse-bare-item" format="default" sectionFormat="of" derivedContent="Section 4.2.3.1"/>) with input_string.</li>
                    </ol>
                  </li>
                  <li pn="section-4.2.3.2-2.2.2.7" derivedCounter="7.">If parameters already contains a key param_key (comparing character for character), overwrite its value with param_value.</li>
                  <li pn="section-4.2.3.2-2.2.2.8" derivedCounter="8.">Otherwise, append key param_key with value param_value to parameters.</li>
                </ol>
              </li>
              <li pn="section-4.2.3.2-2.3" derivedCounter="3.">Return parameters.</li>
            </ol>
            <t indent="0" pn="section-4.2.3.2-3">パラメーターのキーが重複している場合、最後のインスタンス以外は無視されることに注意。</t>
          </section>
          <section anchor="parse-key" numbered="true" removeInRFC="false" toc="exclude" pn="section-4.2.3.3">
            <name slugifiedName="name-parsing-a-key">Parsing a Key</name>
            <t indent="0" pn="section-4.2.3.3-1">ASCII文字列をinput_stringとして与え、キーを返す。 input_stringは解析された値を取り除くために修正される。</t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.3.3-2">
              <li pn="section-4.2.3.3-2.1" derivedCounter="1.">If the first character of input_string is not lcalpha or
	      "*", fail parsing.</li>
              <li pn="section-4.2.3.3-2.2" derivedCounter="2.">Let output_string be an empty string.</li>
              <li pn="section-4.2.3.3-2.3" derivedCounter="3.">
                <t indent="0" pn="section-4.2.3.3-2.3.1">input_stringが空でない間。 </t>
                <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.3.3-2.3.2">
                  <li pn="section-4.2.3.3-2.3.2.1" derivedCounter="1.">If the first character of input_string is not one of
		  lcalpha, DIGIT, "_", "-", ".", or "*", return
		  output_string.</li>
                  <li pn="section-4.2.3.3-2.3.2.2" derivedCounter="2.">Let char be the result of consuming the first character of input_string.</li>
                  <li pn="section-4.2.3.3-2.3.2.3" derivedCounter="3.">Append char to output_string.</li>
                </ol>
              </li>
              <li pn="section-4.2.3.3-2.4" derivedCounter="4.">Return output_string.</li>
            </ol>
          </section>
        </section>
        <section anchor="parse-number" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.4">
          <name slugifiedName="name-parsing-an-integer-or-decim">Parsing an Integer or Decimal</name>
          <t indent="0" pn="section-4.2.4-1">ASCII文字列をinput_stringとして与え、整数または10進数を返す。 input_stringは解析された値を取り除くために修正される。</t>
          <t indent="0" pn="section-4.2.4-2">注：このアルゴリズムは、整数(<xref target="integer" format="default" sectionFormat="of" derivedContent="Section 3.3.1"/>)と小数(<xref target="decimal" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>)の両方を解析し、対応する構造を返します。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.4-3">
            <li pn="section-4.2.4-3.1" derivedCounter="1.">Let type be "integer".</li>
            <li pn="section-4.2.4-3.2" derivedCounter="2.">Let sign be 1.</li>
            <li pn="section-4.2.4-3.3" derivedCounter="3.">Let input_number be an empty string.</li>
            <li pn="section-4.2.4-3.4" derivedCounter="4.">If the first character of input_string is "-", consume it and
	    set sign to -1.</li>
            <li pn="section-4.2.4-3.5" derivedCounter="5.">If input_string is empty, there is an empty integer; fail
	    parsing.</li>
            <li pn="section-4.2.4-3.6" derivedCounter="6.">If the first character of input_string is not a DIGIT, fail
	    parsing.</li>
            <li pn="section-4.2.4-3.7" derivedCounter="7.">
              <t indent="0" pn="section-4.2.4-3.7.1">input_stringが空でない間。 </t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.4-3.7.2">
                <li pn="section-4.2.4-3.7.2.1" derivedCounter="1.">Let char be the result of consuming the first character of
		input_string.</li>
                <li pn="section-4.2.4-3.7.2.2" derivedCounter="2.">If char is a DIGIT, append it to input_number.</li>
                <li pn="section-4.2.4-3.7.2.3" derivedCounter="3.">
                  <t indent="0" pn="section-4.2.4-3.7.2.3.1">また、typeが "integer "でcharが". "の場合。 </t>
                  <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.4-3.7.2.3.2">
                    <li pn="section-4.2.4-3.7.2.3.2.1" derivedCounter="1.">If input_number contains more than 12 characters, fail parsing.</li>
                    <li pn="section-4.2.4-3.7.2.3.2.2" derivedCounter="2.">Otherwise, append char to input_number and set type to "decimal".</li>
                  </ol>
                </li>
                <li pn="section-4.2.4-3.7.2.4" derivedCounter="4.">Otherwise, prepend char to input_string, and exit the loop.</li>
                <li pn="section-4.2.4-3.7.2.5" derivedCounter="5.">If type is "integer" and input_number contains more than
		15 characters, fail parsing.</li>
                <li pn="section-4.2.4-3.7.2.6" derivedCounter="6.">If type is "decimal" and input_number contains more than
		16 characters, fail parsing.</li>
              </ol>
            </li>
            <li pn="section-4.2.4-3.8" derivedCounter="8.">
              <t indent="0" pn="section-4.2.4-3.8.1">typeが "integer "の場合。 </t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.4-3.8.2">
                <li pn="section-4.2.4-3.8.2.1" derivedCounter="1.">Parse input_number as an integer and let output_number be
		the product of the result and sign.</li>
              </ol>
            </li>
            <li pn="section-4.2.4-3.9" derivedCounter="9.">
              <t indent="0" pn="section-4.2.4-3.9.1">それ以外は。 </t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.4-3.9.2">
                <li pn="section-4.2.4-3.9.2.1" derivedCounter="1.">If the final character of input_number is ".", fail parsing.</li>
                <li pn="section-4.2.4-3.9.2.2" derivedCounter="2.">If the number of characters after "." in input_number is
		greater than three, fail parsing.</li>
                <li pn="section-4.2.4-3.9.2.3" derivedCounter="3.">Parse input_number as a decimal number and let
		output_number be the product of the result and sign.</li>
              </ol>
            </li>
            <li pn="section-4.2.4-3.10" derivedCounter="10.">Return output_number.</li>
          </ol>
        </section>
        <section anchor="parse-string" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.5">
          <name slugifiedName="name-parsing-a-string">Parsing a String</name>
          <t indent="0" pn="section-4.2.5-1">input_stringにASCII文字列が与えられた場合、引用符で囲まれていないStringを返す。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.5-2">
            <li pn="section-4.2.5-2.1" derivedCounter="1.">Let output_string be an empty string.</li>
            <li pn="section-4.2.5-2.2" derivedCounter="2.">If the first character of input_string is not DQUOTE, fail parsing.</li>
            <li pn="section-4.2.5-2.3" derivedCounter="3.">Discard the first character of input_string.</li>
            <li pn="section-4.2.5-2.4" derivedCounter="4.">
              <t indent="0" pn="section-4.2.5-2.4.1">input_stringが空でない間。 </t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.5-2.4.2">
                <li pn="section-4.2.5-2.4.2.1" derivedCounter="1.">Let char be the result of consuming the first character of input_string.</li>
                <li pn="section-4.2.5-2.4.2.2" derivedCounter="2.">
                  <t indent="0" pn="section-4.2.5-2.4.2.2.1">charがバックスラッシュ（"Ⓐ"）の場合。 </t>
                  <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.5-2.4.2.2.2">
                    <li pn="section-4.2.5-2.4.2.2.2.1" derivedCounter="1.">If input_string is now empty, fail parsing.</li>
                    <li pn="section-4.2.5-2.4.2.2.2.2" derivedCounter="2.">Let next_char be the result of consuming the first
		    character of input_string.</li>
                    <li pn="section-4.2.5-2.4.2.2.2.3" derivedCounter="3.">If next_char is not DQUOTE or "\", fail parsing.</li>
                    <li pn="section-4.2.5-2.4.2.2.2.4" derivedCounter="4.">Append next_char to output_string.</li>
                  </ol>
                </li>
                <li pn="section-4.2.5-2.4.2.3" derivedCounter="3.">Else, if char is DQUOTE, return output_string.</li>
                <li pn="section-4.2.5-2.4.2.4" derivedCounter="4.">Else, if char is in the range %x00-1f or %x7f-ff (i.e., it is
		not in VCHAR or SP), fail parsing.</li>
                <li pn="section-4.2.5-2.4.2.5" derivedCounter="5.">Else, append char to output_string.</li>
              </ol>
            </li>
            <li pn="section-4.2.5-2.5" derivedCounter="5.">Reached the end of input_string without finding a closing
	    DQUOTE; fail parsing.</li>
          </ol>
        </section>
        <section anchor="parse-token" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.6">
          <name slugifiedName="name-parsing-a-token">Parsing a Token</name>
          <t indent="0" pn="section-4.2.6-1">ASCII文字列をinput_stringとして与え、Tokenを返す。 input_stringは解析された値を取り除くために修正される。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.6-2">
            <li pn="section-4.2.6-2.1" derivedCounter="1.">If the first character of input_string is not ALPHA or "*",
	    fail parsing.</li>
            <li pn="section-4.2.6-2.2" derivedCounter="2.">Let output_string be an empty string.</li>
            <li pn="section-4.2.6-2.3" derivedCounter="3.">
              <t indent="0" pn="section-4.2.6-2.3.1">input_stringが空でない間。 </t>
              <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.6-2.3.2">
                <li pn="section-4.2.6-2.3.2.1" derivedCounter="1.">If the first character of input_string is not in tchar,
		":", or "/", return output_string.</li>
                <li pn="section-4.2.6-2.3.2.2" derivedCounter="2.">Let char be the result of consuming the first character of
		input_string.</li>
                <li pn="section-4.2.6-2.3.2.3" derivedCounter="3.">Append char to output_string.</li>
              </ol>
            </li>
            <li pn="section-4.2.6-2.4" derivedCounter="4.">Return output_string.</li>
          </ol>
        </section>
        <section anchor="parse-binary" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.7">
          <name slugifiedName="name-parsing-a-byte-sequence">Parsing a Byte Sequence</name>
          <t indent="0" pn="section-4.2.7-1">input_stringにASCII文字列が与えられた場合、Byte Sequenceを返す。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.7-2">
            <li pn="section-4.2.7-2.1" derivedCounter="1.">If the first character of input_string is not ":", fail parsing.</li>
            <li pn="section-4.2.7-2.2" derivedCounter="2.">Discard the first character of input_string.</li>
            <li pn="section-4.2.7-2.3" derivedCounter="3.">If there is not a ":" character before the end of input_string, fail parsing.</li>
            <li pn="section-4.2.7-2.4" derivedCounter="4.">Let b64_content be the result of consuming content of
	    input_string up to but not including the first instance of the
	    character ":".</li>
            <li pn="section-4.2.7-2.5" derivedCounter="5.">Consume the ":" character at the beginning of input_string.</li>
            <li pn="section-4.2.7-2.6" derivedCounter="6.">If b64_content contains a character not included in ALPHA,
	    DIGIT, "+", "/", and "=", fail parsing.</li>
            <li pn="section-4.2.7-2.7" derivedCounter="7.">Let binary_content be the result of base64-decoding <xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/> b64_content, synthesizing
	    padding if necessary (note the requirements about recipient
	    behavior below). If base64 decoding fails, parsing fails.</li>
            <li pn="section-4.2.7-2.8" derivedCounter="8.">Return binary_content.</li>
          </ol>
          <t indent="0" pn="section-4.2.7-3">base64の実装によっては、適切に"="パディングされていないエンコードされたデータを拒否することができないため(<xref target="RFC4648" sectionFormat="comma" section="3.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.2" derivedContent="RFC4648"/> 参照)、パーサーは"="パディングが存在しない場合、そう設定できない場合を除いて失敗するべきではない(SHOULD NOTSHOULD<bcp14>NOT</bcp14>)。</t>
          <t indent="0" pn="section-4.2.7-4">base64の実装によっては、0以外のパッドビットを持つエンコードされたデータを拒否することができないため(<xref target="RFC4648" sectionFormat="comma" section="3.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.5" derivedContent="RFC4648"/> 参照)、パーサーは0以外のパッドビットが存在する場合、そのように設定できない場合を除き、失敗するべきではない(SHOULD NOTSHOULD<bcp14>NOT</bcp14>)。</t>
          <t indent="0" pn="section-4.2.7-5">この仕様では、<xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/> 、セクション<xref target="RFC4648" sectionFormat="bare" section="3.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.1" derivedContent="RFC4648"/> 、<xref target="RFC4648" sectionFormat="bare" section="3.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4648#section-3.3" derivedContent="RFC4648"/> の要件は緩和されていません。したがって、パーサーは、base64アルファベット以外の文字とエンコードされたデータの改行で失敗しなければなりません(MUSTMUST)。</t>
        </section>
        <section anchor="parse-boolean" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.8">
          <name slugifiedName="name-parsing-a-boolean">Parsing a Boolean</name>
          <t indent="0" pn="section-4.2.8-1">ASCII文字列をinput_stringとして与え、論理値を返す。 input_stringは解析された値を取り除くために修正される。</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-4.2.8-2">
            <li pn="section-4.2.8-2.1" derivedCounter="1.">If the first character of input_string is not "?", fail parsing.</li>
            <li pn="section-4.2.8-2.2" derivedCounter="2.">Discard the first character of input_string.</li>
            <li pn="section-4.2.8-2.3" derivedCounter="3.">If the first character of input_string matches "1", discard
	    the first character, and return true.</li>
            <li pn="section-4.2.8-2.4" derivedCounter="4.">If the first character of input_string matches "0", discard
	    the first character, and return false.</li>
            <li pn="section-4.2.8-2.5" derivedCounter="5.">No value has matched; fail parsing.</li>
          </ol>
        </section>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-5-1">この文書にはIANAアクションはない。</t>
    </section>
    <section anchor="security-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-6-1">Structured Fields で定義されるほとんどの型のサイズは制限されていません。その結果、極端に大きなフィールドは攻撃のベクトル (リソースの消費など) となる可能性があります。ほとんどの HTTP 実装では、このような攻撃を緩和するために、ヘッダーやトレーラーセクション全体のサイズだけでなく、個々のフィールドのサイズも制限しています。</t>
      <t indent="0" pn="section-6-2">新しいHTTPフィールドを注入する能力を持つ当事者が、構造化フィールドの意味を変更することは可能である。状況によってはパースに失敗しますが、そのような状況すべてにおいて確実に失敗することは不可能です。</t>
    </section>
  </middle>
  <back>
    <references pn="section-7">
      <name slugifiedName="name-references">References</name>
      <references pn="section-7.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC0020" target="https://www.rfc-editor.org/info/rfc20" quoteTitle="true" derivedAnchor="RFC0020">
          <front>
            <title>ASCII format for network interchange</title>
            <author initials="V.G." surname="Cerf" fullname="V.G. Cerf">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1969" month="October"/>
          </front>
          <seriesInfo name="STD" value="80"/>
          <seriesInfo name="RFC" value="20"/>
          <seriesInfo name="DOI" value="10.17487/RFC0020"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">多くの標準追跡文書では、仕様の要件を示すためにいくつかの単語が使用されています。これらの単語はしばしば大文字で表記される。この文書では、IETFの文書で解釈されるべきこれらの単語を定義する。この文書は、インターネットコミュニティのためのインターネットベストカレントプラクティスを規定し、改善のための議論と提案を要請するものである。</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC4648" target="https://www.rfc-editor.org/info/rfc4648" quoteTitle="true" derivedAnchor="RFC4648">
          <front>
            <title>The Base16, Base32, and Base64 Data Encodings</title>
            <author initials="S." surname="Josefsson" fullname="S. Josefsson">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="October"/>
            <abstract>
              <t indent="0">本書では、一般的に使用されているbase64、base32、base16の各エンコーディングスキームについて説明します。また、符号化データにおける改行の使用、符号化データにおけるパディングの使用、符号化データにおける非アルファベット文字の使用、異なる符号化アルファベットの使用、および正準符号化についても説明します。[標準トラック] (standards-track)</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4648"/>
          <seriesInfo name="DOI" value="10.17487/RFC4648"/>
        </reference>
        <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234" quoteTitle="true" derivedAnchor="RFC5234">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <author initials="D." surname="Crocker" fullname="D. Crocker" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Overell" fullname="P. Overell">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="January"/>
            <abstract>
              <t indent="0">インターネットの技術仕様では、しばしば正式な構文を定義する必要がある。長年にわたり、Backus-Naur Form (BNF) の改良版である Augmented BNF (ABNF) が、多くのインターネット仕様の間で人気を博してきた。現在の仕様は、ABNFを文書化したものである。ABNFは、コンパクトでシンプルでありながら、合理的な表現力のバランスがとれている。標準BNFとABNFの違いは、命名規則、繰り返し、選択肢、順序非依存性、値域などである。また、この仕様では、いくつかのインターネット仕様に共通するタイプのコア語彙解析器のために、追加のルール定義とエンコーディングを提供している。[標準トラック] (standards-track)</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="68"/>
          <seriesInfo name="RFC" value="5234"/>
          <seriesInfo name="DOI" value="10.17487/RFC5234"/>
        </reference>
        <reference anchor="RFC7230" target="https://www.rfc-editor.org/info/rfc7230" quoteTitle="true" derivedAnchor="RFC7230">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">ハイパーテキスト転送プロトコル (HTTP) は，分散，協調，ハイパーテキスト情報システム用のステートレスなアプリケーションレベルプロトコルである。この文書は，HTTP のアーキテクチャとそれに関連する用語の概要を提供し，"http" と "https" Uniform Resource Identifier (URI) スキームを定義し，HTTP/1.1 メッセージ構文と解析要件を定義し，実装のための関連セキュリティ事項を記述する。</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7230"/>
          <seriesInfo name="DOI" value="10.17487/RFC7230"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC2119は、プロトコル仕様で使用される可能性のある一般的なキーワードを規定 している。この文書は、キーワードのUPPERCASE使用のみが定義された特別な意味を持つことを明確にすることで、曖昧さを減らすことを目的としています。</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
      </references>
      <references pn="section-7.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="IEEE754" target="https://ieeexplore.ieee.org/document/8766229" quoteTitle="true" derivedAnchor="IEEE754">
          <front>
            <title>IEEE Standard for Floating-Point Arithmetic</title>
            <seriesInfo name="DOI" value="10.1109/IEEESTD.2019.8766229"/>
            <seriesInfo name="IEEE" value="754-2019"/>
            <author>
              <organization showOnFrontPage="true">IEEE</organization>
            </author>
            <date year="2019" month="July"/>
          </front>
        </reference>
        <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231" quoteTitle="true" derivedAnchor="RFC7231">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">HTTP（Hypertext Transfer Protocol）は、分散型、協調型、ハイパーテキスト情報システムのためのステートレスな ⾰新的プロトコルです。この文書では、リクエストメソッド、リクエストヘッダーフィールド、レスポンスステータスコード、レスポンスヘッダーフィールドで表される HTTP/1.1 メッセージのセマンティクスと、メッセージのペイロード（メタデータとボディコンテンツ）、コンテンツネゴシエーションのメカニズムを定義しています。</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7231"/>
          <seriesInfo name="DOI" value="10.17487/RFC7231"/>
        </reference>
        <reference anchor="RFC7493" target="https://www.rfc-editor.org/info/rfc7493" quoteTitle="true" derivedAnchor="RFC7493">
          <front>
            <title>The I-JSON Message Format</title>
            <author initials="T." surname="Bray" fullname="T. Bray" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="March"/>
            <abstract>
              <t indent="0">I-JSON（Internet JSONの略）は、JSONの制限付きプロファイルで、相互運用性を最大化し、ソフトウェアが正常に処理でき、予測可能な結果を得られるように設計されています。</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7493"/>
          <seriesInfo name="DOI" value="10.17487/RFC7493"/>
        </reference>
        <reference anchor="RFC7540" target="https://www.rfc-editor.org/info/rfc7540" quoteTitle="true" derivedAnchor="RFC7540">
          <front>
            <title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
            <author initials="M." surname="Belshe" fullname="M. Belshe">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Peon" fullname="R. Peon">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Thomson" fullname="M. Thomson" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">この仕様は，HTTP バージョン 2 (HTTP/2) と呼ばれるハイパーテキスト転送プロトコル (HTTP) のセマンティクスの最適化された表現について記述している。HTTP/2 は，ヘッダーフィールドの圧縮を導入し，同一コネクション上で複数の同時交換を可能にすることで，ネットワークリソースをより効率的に使用し，遅延の知覚を低減することを可能にする。また、サーバーからクライアントへの表現の非承諾的なプッシュを導入しています。</t>
              <t indent="0">この仕様は，HTTP/1.1 メッセージ構文の代替となるものであるが，廃止されるものではない。HTTP の既存のセマンティクスは変更されません。</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7540"/>
          <seriesInfo name="DOI" value="10.17487/RFC7540"/>
        </reference>
        <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541" quoteTitle="true" derivedAnchor="RFC7541">
          <front>
            <title>HPACK: Header Compression for HTTP/2</title>
            <author initials="R." surname="Peon" fullname="R. Peon">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Ruellan" fullname="H. Ruellan">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">本仕様は、HTTP/2 で使用される HTTP ヘッダーフィールドを効率的に表現する圧縮形式である HPACK を定義する。</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7541"/>
          <seriesInfo name="DOI" value="10.17487/RFC7541"/>
        </reference>
        <reference anchor="RFC8259" target="https://www.rfc-editor.org/info/rfc8259" quoteTitle="true" derivedAnchor="RFC8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author initials="T." surname="Bray" fullname="T. Bray" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="December"/>
            <abstract>
              <t indent="0">JavaScript Object Notation (JSON) は、軽量でテキストベースの、言語に依存しないデータ交換フォーマットです。これは ECMAScript Programming Language Standard から派生したものです。JSONは、構造化されたデータを移植可能に表現するための小さなフォーマット規則のセットを定義しています。</t>
              <t indent="0">この文書は、JSONの他の仕様との不整合を取り除き、仕様の誤りを修復し、経験に基づく相互運用性のガイダンスを提供するものである。</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
          <seriesInfo name="DOI" value="10.17487/RFC8259"/>
        </reference>
        <reference anchor="STD63" target="https://www.rfc-editor.org/info/std63" quoteTitle="true" derivedAnchor="STD63">
          <front>
            <title>UTF-8, a transformation format of ISO 10646</title>
            <author initials="F." surname="Yergeau" fullname="F. Yergeau">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2003" month="November"/>
          </front>
          <seriesInfo name="STD" value="63"/>
          <seriesInfo name="RFC" value="3629"/>
        </reference>
      </references>
    </references>
    <section anchor="faq" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-frequently-asked-questions">Frequently Asked Questions</name>
      <section anchor="why-not-json" numbered="true" removeInRFC="false" toc="include" pn="section-a.1">
        <name slugifiedName="name-why-not-json">Why Not JSON?</name>
        <t indent="0" pn="section-a.1-1">構造化フィールドの初期の提案は、JSON<xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/> に基づいていた。しかし、HTTPヘッダーフィールドに適するようにその使用を制限する ことは、送信者と受信者が特定の追加処理を実装することを必要とした。</t>
        <t indent="0" pn="section-a.1-2">例えば、JSONには、大きな数値や重複するメンバを持つオブジェクトに関する仕様上の問題があります。これらの問題を回避するためのアドバイスがありますが（例：<xref target="RFC7493" format="default" sectionFormat="of" derivedContent="RFC7493"/> ）、それに依存することはできません。</t>
        <t indent="0" pn="section-a.1-3">同様に、JSON文字列はデフォルトでUnicode文字列であり、多くの潜在的な相互運用性の問題がある（例えば、比較において）。実装者は、不必要な場合には非ASCIIコンテンツを避けるように助言することができますが、これを強制することは困難です。</t>
        <t indent="0" pn="section-a.1-4">また、JSONは任意の深さまでコンテンツを入れ子にすることができます。しかし、既存のJSONの実装にはそのような制限がなく、仮に制限を設けたとしても、フィールド定義によっては違反する必要性が出てくる可能性があります。</t>
        <t indent="0" pn="section-a.1-5">JSONは広く採用され、実装されているため、すべての実装にそのような追加制約を課すことは困難である。要するに、もしそれがJSONのように見えるなら、人々はフィールド値に対してJSONパーサー/シリアライザーを使いたくなるのである。</t>
        <t indent="0" pn="section-a.1-6">Structured Fieldsの主な目的は、相互運用性の向上と実装の簡素化であるため、これらの懸念から、専用のパーサーとシリアライザーを必要とする形式となった。</t>
        <t indent="0" pn="section-a.1-7">また、JSONはHTTPのフィールドでは「見栄えが悪い」という意見も多く聞かれました。</t>
      </section>
    </section>
    <section anchor="implementation-notes" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-implementation-notes">Implementation Notes</name>
      <t indent="0" pn="section-appendix.b-1">この仕様の汎用実装は、トップレベルのシリアライズ(<xref target="text-serialize" format="default" sectionFormat="of" derivedContent="Section 4.1"/>)とパース(<xref target="text-parse" format="default" sectionFormat="of" derivedContent="Section 4.2"/>)関数を公開する必要があります。これらは関数である必要はありません。例えば、異なるトップレベルの型のそれぞれに対するメソッドを持つオブジェクトとして実装することができます。</t>
      <t indent="0" pn="section-appendix.b-2"><xref target="strict" format="default" sectionFormat="of" derivedContent="Section 1.1"/>相互運用のためには、汎用的な実装が完全であり、アルゴリズムに忠実であることが重要である。これを支援するために、コミュニティによって共通のテストスイートが<eref brackets="angle" target="https://github.com/httpwg/structured-field-tests"/> でメンテナンスされています。</t>
      <t indent="0" pn="section-appendix.b-3">実装者は、DictionariesとParameterが順序を保持するマップであることに注意する必要がある。いくつかのフィールドは、これらのデータ型の順序で意味を伝えないかもしれませんが、それを使用する必要があるアプリケーションが利用できるように、まだ公開されるべきです。</t>
      <t indent="0" pn="section-appendix.b-4">同様に、トークンと文字列の区別を維持することが重要であることに、実装者は注意すべきです。ほとんどのプログラミング言語は、他の型にうまく対応するネイティブな型を持っていますが、これらの型が分離したままであることを保証するために、ラッパー「トークン」オブジェクトを作成するか、関数のパラメーターを使用することが必要な場合があります。</t>
      <t indent="0" pn="section-appendix.b-5">シリアライズアルゴリズムは、あらゆる場合に<xref target="types" format="default" sectionFormat="of" derivedContent="Section 3"/> で定義されたデータ型に厳密には限定されないように定義されている。例えば、Decimalsはより広い入力を取り、許容される値に丸めるように設計されている。</t>
      <t indent="0" pn="section-appendix.b-6">実装は、各タイプに定義された最小値に従って、さまざまな構造体のサイズを制限することが許されている。構造体が実装上の制限を超えた場合、その構造体はパースやシリアライズに失敗する。</t>
    </section>
    <section numbered="false" anchor="acknowledgements" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t indent="0" pn="section-appendix.c-1">本仕様書の作成にあたり、詳細なフィードバックと慎重な検討をいただいた<contact fullname="Matthew Kerwin"/> 様に深く感謝いたします。</t>
      <t indent="0" pn="section-appendix.c-2">また、<contact fullname="Ian Clelland"/>,<contact fullname="Roy Fielding"/>,<contact fullname="Anne van Kesteren"/>,<contact fullname="Kazuho Oku"/>,<contact fullname="Evert Pot"/>,<contact fullname="Julian Reschke"/>,<contact fullname="Martin       Thomson"/>,<contact fullname="Mike West"/>, および<contact fullname="Jeffrey Yasskin"/> の方々にもご協力をいただきました。</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.d">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
        <organization showOnFrontPage="true">Fastly</organization>
        <address>
          <postal>
            <city>Prahran</city>
            <region>VIC</region>
            <country>Australia</country>
          </postal>
          <email>mnot@mnot.net</email>
          <uri>https://www.mnot.net/</uri>
        </address>
      </author>
      <author initials="P-H." surname="Kamp" fullname="Poul-Henning Kamp">
        <organization showOnFrontPage="true">The Varnish Cache Project</organization>
        <address>
          <email>phk@varnish-cache.org</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
